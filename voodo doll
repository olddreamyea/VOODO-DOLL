game.StarterGui:SetCore("SendNotification",  {
 Title = "ro-ware v2";
 Text = "welcome, "..game.Players.LocalPlayer.DisplayName;
 Icon = game.Players:GetUserThumbnailAsync(game.Players.LocalPlayer.UserId, "HeadShot", Enum.ThumbnailSize.Size100x100);
 Duration = 10;
})

if _G.typicalcool ~= true then
    _G.typicalcool = true
    game:GetService("RunService").Stepped:Connect(function()
       workspace.FallenPartsDestroyHeight = 0/0
       settings().Physics.AllowSleep = false
       game:GetService("Players").LocalPlayer.ReplicationFocus = workspace
       settings().Physics.ThrottleAdjustTime = 6 - math.huge
        game.Players.LocalPlayer.MaximumSimulationRadius = 1000
        sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
        setsimulationradius(1000,1000)
    end)
end

local Config = {
WindowName = "RO-WARE V2 | Best FE Hub (in my opinion l0l)",
Color = Color3.fromRGB(91,142,187),
Keybind = Enum.KeyCode.RightShift
}

local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/TypicallyAUser/random-stuff/main/RowareUILIB.lua"))()-- https://raw.githubusercontent.com/AlexR32/Roblox/main/BracketV3.lua
local Window = Library:CreateWindow(Config, game:GetService("CoreGui"))

local Tab1 = Window:CreateTab("Main")
local Tab2 = Window:CreateTab("Settings")

local Section1 = Tab1:CreateSection("Free Scripts")
local Section2 = Tab1:CreateSection("Hat Scripts")
local Section3 = Tab1:CreateSection("R15 Scripts")
local SettingsMenu2 = Tab2:CreateSection("Reanimation Options")
local SettingsMenu = Tab2:CreateSection("Settings")

function PlayR15Anim(funnyr, sound, soundspeed)
	local playanother = false
local playing = false
local rtrnv;
local c;
local tbl3;
local v;
local anim;
local count;
local hhhh;
local asdf;
local s;
local animid;
local plr;
local char;
local cframe;
local torso;
local rs;
local ls;
local rh;
local lh;
local n;
local rj;
local rsc0;
local lsc0;
local rhc0;
local lhc0;
local rjc0;
local nc0;
local gc0;
local orsc0;
local olsc0;
local orhc0;
local olhc0;
local orjc0;
local onc0;
local count2;
local maxcount2;

local function getnext(tbl,number)
	c=100
	rtrnv=0
	for i,v in pairs(tbl) do
		if i>number and i-number<c then
			c=i-number
			rtrnv=i
		end
	end
	return(rtrnv)
end
local function wait2(tim)
	if tim<0.1 then
		game:GetService("RunService").Heartbeat:Wait()
	else
		for i=1,tim*40 do
			game:GetService("RunService").Heartbeat:Wait()
		end
	end
end
local function kftotbl(kf) -- Below this is literal pain..
	tbl3 = {}
	for i,v in pairs(kf:GetDescendants()) do
		if v:IsA("Pose") then
			tbl3[v.Name] = v.CFrame
		end
	end
	return(tbl3)
end

        if playing == true then
			s:Destroy()
			playing = false
			playanother = true
		end
		wait()
		spawn(function()
			if playanother == true then
				playanother = false
			end
			playing = true
			s = Instance.new("Sound", workspace.Camera.CameraSubject.Parent.UpperTorso)
animid="rbxassetid://"..funnyr
				s.SoundId = "rbxassetid://"..sound
				s.PlaybackSpeed = soundspeed or 1

			s.Looped = true
			s.Playing = true
			wait(.1) -- Do not change because changing it will break.
			
			plr = game.Players.LocalPlayer
			char = workspace.Camera.CameraSubject.Parent
			cframe = char.HumanoidRootPart.CFrame
			utorso = workspace.Camera.CameraSubject.Parent.UpperTorso
			ltorso = workspace.Camera.CameraSubject.Parent.LowerTorso
			-----------------------------------------------------------
			rus = char["RightUpperArm"]["RightShoulder"]
			lus = char["LeftUpperArm"]["LeftShoulder"]
			rls = char["RightLowerArm"]["RightElbow"]
			lls = char["LeftLowerArm"]["LeftElbow"]
			rw = char["RightHand"]["RightWrist"]
			lw = char["LeftHand"]["LeftWrist"]
			ruh = char["RightUpperLeg"]["RightHip"]
			luh = char["LeftUpperLeg"]["LeftHip"]
			rlh = char["RightLowerLeg"]["RightKnee"]
			llh = char["LeftLowerLeg"]["LeftKnee"]
			rf = char["RightFoot"]["RightAnkle"]
			lf = char["LeftFoot"]["LeftAnkle"]
			n = char.Head["Neck"]
            ut = char.UpperTorso.Waist
            lt = char.LowerTorso.Root
			rusc0 = rus.C0
			lusc0 = lus.C0
			rlsc0 = rls.C0
			llsc0 = lls.C0
			rwc0 = rw.C0
			lwc0 = lw.C0
			ruhc0 = ruh.C0
			luhc0 = luh.C0
			rlhc0 = rlh.C0
			llhc0 = llh.C0
			rfc0 = rf.C0
			lfc0 = lf.C0
			nc0 = n.C0
            utc0 = ut.C0
            ltc0 = lt.c0
			gc0 = CFrame.new()
			orrusc0 = rus.C0
			orlusc0 = lus.C0
			orrlsc0 = rls.C0
			orllsc0 = lls.C0
			orrwc0 = rw.C0
			orlwc0 = lw.C0
			orruhc0 = ruh.C0
			orluhc0 = luh.C0
			orrlhc0 = rlh.C0
			orllhc0 = llh.C0
			orrfc0 = rf.C0
			orlfc0 = lf.C0
			ornc0 = n.C0
            orutc0 = ut.C0
            orltc0 = lt.c0
			count2 = 100
			maxcount2=100
			-----------------------------------------------------------
			game:GetService("RunService").Heartbeat:Connect(function() -- Speed.
				if playanother == true then
					return nil
				else
					count2 = count2+1
					if count2<=maxcount2 then
						rus.Transform=rus.Transform:Lerp(rusc0,count2/maxcount2)
						lus.Transform=lus.Transform:Lerp(lusc0,count2/maxcount2)
						rls.Transform=rls.Transform:Lerp(rlsc0,count2/maxcount2)
						lls.Transform=lls.Transform:Lerp(llsc0,count2/maxcount2)
						rw.Transform=rw.Transform:Lerp(rwc0,count2/maxcount2)
						lw.Transform=lw.Transform:Lerp(lwc0,count2/maxcount2)
						ruh.Transform=ruh.Transform:Lerp(ruhc0,count2/maxcount2)
						luh.Transform=luh.Transform:Lerp(luhc0,count2/maxcount2)
						rlh.Transform=rlh.Transform:Lerp(rlhc0,count2/maxcount2)
						llh.Transform=llh.Transform:Lerp(llhc0,count2/maxcount2)
						rf.Transform=rf.Transform:Lerp(rfc0,count2/maxcount2)
						lf.Transform=lf.Transform:Lerp(lfc0,count2/maxcount2)
						n.Transform=n.Transform:Lerp(nc0,count2/maxcount2)
						ut.Transform=ut.Transform:Lerp(utc0,count2/maxcount2)
						lt.Transform=lt.Transform:Lerp(ltc0,count2/maxcount2)
					end
				end
			end)
			-----------------------------------------------------------
			animid=game:GetObjects(animid)[1]
			anim={}
			for i,v in pairs(animid:GetChildren()) do
				if v:IsA("Keyframe") then
					anim[v.Time]=kftotbl(v)
				end
			end

			count = 0
			char=workspace.Camera.CameraSubject.Parent
			hhhh=workspace.Camera.CameraSubject.Parent.Humanoid.Animator
			hhhh.Parent = nil
			for _,v in pairs(char.Humanoid:GetPlayingAnimationTracks()) do
				v:Stop()
			end
			
			hhhh:Destroy()
			char.Animate:Destroy()

			plr.CharacterRemoving:Connect(function()
				if playing == true then
					playing = false
				end
			end)

			while wait() do
				if playanother == true then
					break
				else
					for i,oasjdadlasdkadkldjkl in pairs(anim) do
						asdf=getnext(anim,count)
						v=anim[asdf]
						if v["LeftUpperArm"] then
							lusc0 = v["LeftUpperArm"]
						end
						if v["RightUpperArm"] then
							rusc0 = v["RightUpperArm"]
						end
						if v["LeftLowerArm"] then
							llsc0 = v["LeftLowerArm"]
						end
						if v["RightUpperArm"] then
							rlsc0 = v["RightLowerArm"]
						end
						if v["LeftHand"] then
							lwc0 = v["LeftHand"]
						end
						if v["RightHand"] then
							rwc0 = v["RightHand"]
						end
						if v["LeftUpperALeg"] then
							luhc0 = v["LeftUpperLeg"]
						end
						if v["RightUpperLeg"] then
							ruhc0 = v["RightUpperLeg"]
						end
						if v["LeftLowerLeg"] then
							llhc0 = v["LeftLowerLeg"]
						end
						if v["RightUpperLeg"] then
							rlhc0 = v["RightLowerLeg"]
						end
						if v["LeftFoot"] then
							lfc0 = v["LeftFoot"]
						end
						if v["RightFoot"] then
							rfc0 = v["RightFoot"]
						end
						if v["UpperTorso"] then
							utc0 = v["UpperTorso"]
						end
						if v["LowerTorso"] then
							ltc0 = v["LowerTorso"]
						end
						if v["Head"] then
							nc0 = v["Head"]
						end
						count2=0
						maxcount2=asdf-count
						count=asdf
						wait(asdf-count)
						count2=maxcount2
						if v["LeftUpperArm"] then
							char["LeftUpperArm"]["LeftShoulder"].Transform = v["LeftUpperArm"]
						end
						if v["RightUpperArm"] then
							char["RightUpperArm"]["RightShoulder"].Transform = v["RightUpperArm"]
						end
						if v["LeftLowerArm"] then
							char["LeftLowerArm"]["LeftElbow"].Transform = v["LeftLowerArm"]
						end
						if v["RightUpperArm"] then
							char["RightLowerArm"]["RightElbow"].Transform = v["RightLowerArm"]
						end
						if v["LeftHand"] then
							char["LeftHand"]["LeftWrist"].Transform = v["LeftHand"]
						end
						if v["RightHand"] then
							char["RightHand"]["RightWrist"].Transform = v["RightHand"]
						end
--
						if v["LeftUpperLeg"] then
							char["LeftUpperLeg"]["LeftHip"].Transform = v["LeftUpperLeg"]
						end
						if v["RightUpperLeg"] then
							char["RightUpperLeg"]["RightHip"].Transform = v["RightUpperLeg"]
						end
						if v["LeftLowerLeg"] then
							char["LeftLowerLeg"]["LeftKnee"].Transform = v["LeftLowerLeg"]
						end
						if v["RightUpperLeg"] then
							char["RightLowerLeg"]["RightKnee"].Transform = v["RightLowerLeg"]
						end
						if v["LeftFoot"] then
							char["LeftFoot"]["LeftAnkle"].Transform = v["LeftFoot"]
						end
						if v["RightFoot"] then
							char["RightFoot"]["RightAnkle"].Transform = v["RightFoot"]
						end
						if v["UpperTorso"] then
							char.UpperTorso["Waist"].Transform = v["UpperTorso"]
						end
						if v["LowerTorso"] then
							char.LowerTorso["Root"].Transform = v["LowerTorso"]
						end
						if v["Head"] then
							char.Head["Neck"].Transform = v["Head"]
						end
					end
				end
			end
		end)
	--end
end

function PlayR6Anim(funny, sound)
	
	local playanother = false
local playing = false
local rtrnv;
local c;
local tbl3;
local v;
local anim;
local count;
local hhhh;
local asdf;
local s;
local animid;
local plr;
local char;
local cframe;
local torso;
local rs;
local ls;
local rh;
local lh;
local n;
local rj;
local rsc0;
local lsc0;
local rhc0;
local lhc0;
local rjc0;
local nc0;
local gc0;
local orsc0;
local olsc0;
local orhc0;
local olhc0;
local orjc0;
local onc0;
local count2;
local maxcount2;

local function getnext(tbl,number)
	c=100
	rtrnv=0
	for i,v in pairs(tbl) do
		if i>number and i-number<c then
			c=i-number
			rtrnv=i
		end
	end
	return(rtrnv)
end
local function wait2(tim)
	if tim<0.1 then
		game:GetService("RunService").Heartbeat:Wait()
	else
		for i=1,tim*40 do
			game:GetService("RunService").Heartbeat:Wait()
		end
	end
end
local function kftotbl(kf) -- Below this is literal pain..
	tbl3 = {}
	for i,v in pairs(kf:GetDescendants()) do
		if v:IsA("Pose") then
			tbl3[string.sub(v.Name,1,1)..string.sub(v.Name,#v.Name,#v.Name)] = v.CFrame
		end
	end
	return(tbl3)
end
        if playanother == true then
				playanother = false
			end
			playing = true
			if workspace.Camera.CameraSubject.Parent:FindFirstChild("Sound") then
				workspace.Camera.CameraSubject.Parent:FindFirstChild("Sound"):Remove()
		end
		if sound ~= nil then
			s = Instance.new("Sound", workspace.Camera.CameraSubject.Parent)

				s.SoundId = "rbxassetid://"..sound

			s.Looped = true
			s.Playing = true
		end
			wait(.1) -- Do not change because changing it will break.
			animid="rbxassetid://"..funny
			plr = game.Players.LocalPlayer
			char = workspace.Camera.CameraSubject.Parent
			cframe = char.HumanoidRootPart.CFrame
			torso = char.Torso
			-----------------------------------------------------------
			rs = torso["Right Shoulder"] -- Just took this from another script(Faster).
			ls = torso["Left Shoulder"]
			rh = torso["Right Hip"]
			lh = torso["Left Hip"]
			n = torso["Neck"]
			rj = char.HumanoidRootPart["RootJoint"]
			rsc0 = rs.C0
			lsc0 = ls.C0
			rhc0 = rh.C0
			lhc0 = lh.C0
			rjc0 = rj.C0
			nc0 = n.C0
			gc0 = CFrame.new()
			orsc0 = rs.C0
			olsc0 = ls.C0
			orhc0 = rh.C0
			olhc0 = lh.C0
			orjc0 = rj.C0
			onc0 = n.C0
			count2 = 100
			maxcount2=100
			-----------------------------------------------------------
			game:GetService("RunService").Heartbeat:Connect(function() -- Speed.
				if playanother == true then
					return nil
				else
					count2 = count2+1
					if count2<=maxcount2 then
						rs.Transform=rs.Transform:Lerp(rsc0,count2/maxcount2)
						ls.Transform=ls.Transform:Lerp(lsc0,count2/maxcount2)
						rh.Transform=rh.Transform:Lerp(rhc0,count2/maxcount2)
						lh.Transform=lh.Transform:Lerp(lhc0,count2/maxcount2)
						n.Transform=n.Transform:Lerp(nc0,count2/maxcount2)
						rj.Transform=rj.Transform:Lerp(rjc0,count2/maxcount2)
					end
				end
			end)
			-----------------------------------------------------------
			animid=game:GetObjects(animid)[1]
			anim={}
			for i,v in pairs(animid:GetChildren()) do
				if v:IsA("Keyframe") then
					anim[v.Time]=kftotbl(v)
				end
			end

			count = 0
			char=workspace.Camera.CameraSubject.Parent
			hhhh=char.Humanoid.Animator
			hhhh.Parent = nil
			for _,v in pairs(char.Humanoid:GetPlayingAnimationTracks()) do
				v:Stop()
			end

			plr.CharacterRemoving:Connect(function()
				if playing == true then
					playing = false
				end
			end)

			while wait() do
				if playanother == true then
					break
				else
					for i,oasjdadlasdkadkldjkl in pairs(anim) do
						asdf=getnext(anim,count)
						v=anim[asdf]
						if v["Lg"] then
							lhc0 = v["Lg"]
						end
						if v["Rg"] then
							rhc0 = v["Rg"]
						end
						if v["Lm"] then
							lsc0 = v["Lm"]
						end
						if v["Rm"] then
							rsc0 = v["Rm"]
						end
						if v["To"] then
							rjc0 = v["To"]
						end
						if v["Hd"] then
							nc0 = v["Hd"]
						end
						count2=0
						maxcount2=asdf-count
						count=asdf
						wait(asdf-count)
						count2=maxcount2
						if v["Lg"] then
							char.Torso["Left Hip"].Transform = v["Lg"]
						end
						if v["Rg"] then
							char.Torso["Right Hip"].Transform = v["Rg"]
						end
						if v["Lm"] then
							char.Torso["Left Shoulder"].Transform = v["Lm"]
						end
						if v["Rm"] then
							char.Torso["Right Shoulder"].Transform = v["Rm"]
						end
						if v["To"] then
							char.HumanoidRootPart["RootJoint"].Transform = v["To"]
						end
						if v["Hd"] then
							char.Torso["Neck"].Transform = v["Hd"]
						end
					end
				end
			end
		--end)
end
--_G.BotReanim = false
SettingsMenu2:CreateButton("Bot Reanimation (r6 only)", function()
	print(_G.BotReanim)
	_G.BotReanim = not _G.BotReanim
end)

Section1:CreateButton("Re-Animate", function()
if game.Players.LocalPlayer.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and _G.BotReanim ~= true then
function Align(Part0, Part1, Position, Angle)
    local AlignPosition = Instance.new("AlignPosition",Part0)
    local AlignOrientation = Instance.new("AlignOrientation",Part0)
    
    local Attachment1 = Instance.new("Attachment", Part0)
    local Attachment2 = Instance.new("Attachment", Part1)

    AlignPosition.Attachment0 = Attachment1
    AlignPosition.Attachment1 = Attachment2
    
    AlignOrientation.Attachment0 = Attachment1
    AlignOrientation.Attachment1 = Attachment2
	

    
    Attachment2.Position = Position or Vector3.new(0,0,0)
    Attachment2.Orientation = Angle or Vector3.new(0,0,0)
    
    AlignOrientation.MaxTorque = math.huge
    AlignOrientation.MaxAngularVelocity = math.huge
    AlignOrientation.PrimaryAxisOnly = false 
    AlignOrientation.Responsiveness = 200
    AlignOrientation.RigidityEnabled = false
    AlignOrientation.ReactionTorqueEnabled = false
   AlignPosition.MaxForce = 2626668
    AlignPosition.MaxVelocity = math.huge
    AlignPosition.ReactionForceEnabled = false
    AlignPosition.Responsiveness = 200
    AlignPosition.ApplyAtCenterOfMass = true
    AlignPosition.RigidityEnabled = false
    

                local BodyForce = Instance.new("BodyForce", Part0)
    
    game:GetService("RunService").Heartbeat:Connect(function()
    	if Part0.Name ~= "Torso" then
        Part0.Velocity = Vector3.new(0,-30,0)
		end
		if Part0.Name == "Torso" and _G.Fling == true then
			Part0.Velocity = Vector3.new(1039,460,80)
			Part0.CFrame = Part1.CFrame
			else
			Part0.Velocity = Vector3.new(0,-30,0)
		end
        BodyForce.Force = Vector3.new(10000,10000,10000)
    end)
end

local Players = game:GetService("Players")
local Player = Players.LocalPlayer
Player.Character.Archivable = true
local Character = Player.Character
local fakerig = Character:Clone()
fakerig.Head.face.Transparency = 1
fakerig.Name = "fakerig"
fakerig.Parent = Character
Character.Animate:Remove()
Character.Humanoid:ClearAllChildren()

--[[Rigging]]

Character.Torso["Right Shoulder"]:Remove()
Character.Torso["Left Shoulder"]:Remove()
Character.Torso["Right Hip"]:Remove()
Character.Torso["Left Hip"]:Remove()

--[[Fake Rig Mods]]

for i,v in pairs(fakerig:GetDescendants()) do
    if v:IsA("BasePart") or v:IsA("Part") then
        v.Transparency = 1
        v.CanCollide = false
    end
end

--[[Alignment]]

Align(Character["Right Arm"],fakerig["Right Arm"], Vector3.new(0,0,0), Vector3.new(0,0,0))
Align(Character["Right Leg"],fakerig["Right Leg"], Vector3.new(0,0,0), Vector3.new(0,0,0))
Align(Character["Left Arm"],fakerig["Left Arm"], Vector3.new(0,0,0), Vector3.new(0,0,0))
Align(Character["Left Leg"],fakerig["Left Leg"], Vector3.new(0,0,0), Vector3.new(0,0,0))
Align(Character.Torso, fakerig.Torso,Vector3.new(0,0.5,0))

--[[Wrap it up]]
Character.HumanoidRootPart:Remove()

local movecharacter = game:GetService("RunService").Stepped:Connect(function()
    fakerig:FindFirstChildOfClass("Humanoid"):Move(Character.Humanoid.MoveDirection)
end)

local jump = game:GetService("RunService").Stepped:Connect(function()
    if Character.Humanoid.Jump == true then
        fakerig:FindFirstChildOfClass("Humanoid").Jump = true
    end
end)

local stepped = game:GetService("RunService").Stepped:Connect(function()
    for i,v in pairs(Character:GetDescendants()) do
        if v:IsA("BasePart") or v:IsA("Part") then
            v.CanCollide = false
        end
    end
end)

Character.Humanoid.Died:Connect(function()
	     stepped:Disconnect()
     movecharacter:Disconnect()
     jump:Disconnect()
    Character:BreakJoints()
    Character.Humanoid:Remove()
        for i,v in pairs(Character:GetDescendants()) do
        if v:IsA("BasePart") or v:IsA("Part") then
            v.Anchored = true
        end
    end
    fakerig:Remove()

end)

workspace.Camera.CameraSubject = fakerig.Humanoid
elseif game.Players.LocalPlayer.Character.Humanoid.RigType == Enum.HumanoidRigType.R15 then

function Align(Part0, Part1, Position, Angle)
    local AlignPosition = Instance.new("AlignPosition",Part0)
    local AlignOrientation = Instance.new("AlignOrientation",Part0)
    
    local Attachment1 = Instance.new("Attachment", Part0)
    local Attachment2 = Instance.new("Attachment", Part1)

    AlignPosition.Attachment0 = Attachment1
    AlignPosition.Attachment1 = Attachment2
    
    AlignOrientation.Attachment0 = Attachment1
    AlignOrientation.Attachment1 = Attachment2
    
    Attachment2.Position = Position or Vector3.new(0,0,0)
    Attachment2.Orientation = Angle or Vector3.new(0,0,0)
    
    AlignOrientation.MaxTorque = math.huge
    --AlignOrientation.MaxAngularVelocity = math.huge
    --AlignOrientation.PrimaryAxisOnly = false 
    AlignOrientation.Responsiveness = 200
    AlignOrientation.RigidityEnabled = false
    AlignOrientation.ReactionTorqueEnabled = false
   AlignPosition.MaxForce = 2626668
    AlignPosition.MaxVelocity = math.huge
    AlignPosition.ReactionForceEnabled = false
    AlignPosition.Responsiveness = 200
    AlignPosition.ApplyAtCenterOfMass = true
    AlignPosition.RigidityEnabled = false
    local BodyForce = Instance.new("BodyForce", Part0)
    game:GetService("RunService").Heartbeat:Connect(function()
        Part0.Velocity = Vector3.new(0,-30,0)
        BodyForce.Force = Vector3.new(80,80,80)
    end)
end

local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local Character = Player.Character
local fakerig = game:GetObjects("rbxassetid://6356060731")[1]
fakerig.Head.face.Transparency = 1
fakerig.Name = "fakerig"
fakerig.HumanoidRootPart.CFrame = Character.HumanoidRootPart.CFrame
fakerig.Parent = Character
fakerig.HumanoidRootPart.Anchored = false
Character.Animate:Remove()
Character.Humanoid:ClearAllChildren()
--[[Rigging]]

Character.RightUpperArm["RightShoulder"]:Destroy()
Character.RightLowerArm["RightElbow"]:Destroy()
Character.RightHand["RightWrist"]:Destroy()

Character.LeftUpperArm["LeftShoulder"]:Destroy()
Character.LeftLowerArm["LeftElbow"]:Destroy()
Character.LeftHand["LeftWrist"]:Destroy()

Character.LeftUpperLeg["LeftHip"]:Destroy()
Character.LeftLowerLeg["LeftKnee"]:Destroy()
Character.LeftFoot["LeftAnkle"]:Destroy()

Character.RightUpperLeg["RightHip"]:Destroy()
Character.RightLowerLeg["RightKnee"]:Destroy()
Character.RightFoot["RightAnkle"]:Destroy()

Character.UpperTorso.Waist:Remove()
Character.LowerTorso.Root:Remove()

--[[Fake Rig Mods]]

for i,v in pairs(fakerig:GetDescendants()) do
    if v:IsA("BasePart") or v:IsA("Part") then
        v.Transparency = 1
        v.CanCollide = false
    end
end

--[[Alignment]]

Align(Character.LeftUpperArm, fakerig["Left Arm"], Vector3.new(0, 0.4, 0), Vector3.new(0,0,0))
Align(Character.LeftLowerArm, fakerig["Left Arm"], Vector3.new(0, -0.19, 0), Vector3.new(0,0,0))
Align(Character.LeftHand, fakerig["Left Arm"], Vector3.new(0, -0.82, 0), Vector3.new(0,0,0))
Align(Character.LeftLowerLeg, fakerig["Left Leg"], Vector3.new(0, -0.18, 0), Vector3.new(0,0,0))
Align(Character.LeftUpperLeg, fakerig["Left Leg"], Vector3.new(0, 0.6, 0), Vector3.new(0,0,0))
Align(Character.LeftFoot, fakerig["Left Leg"], Vector3.new(0, -0.825, 0), Vector3.new(0,0,0))
Align(Character.RightUpperArm, fakerig["Right Arm"], Vector3.new(0, 0.4, 0), Vector3.new(0,0,0))
Align(Character.RightLowerArm, fakerig["Right Arm"], Vector3.new(0, -0.19, 0), Vector3.new(0,0,0))
Align(Character.RightHand, fakerig["Right Arm"], Vector3.new(0, -0.82, 0), Vector3.new(0,0,0))
Align(Character.RightLowerLeg, fakerig["Right Leg"], Vector3.new(0, -0.18, 0), Vector3.new(0,0,0))
Align(Character.RightUpperLeg, fakerig["Right Leg"], Vector3.new(0, 0.6, 0), Vector3.new(0,0,0))
Align(Character.RightFoot, fakerig["Right Leg"], Vector3.new(0, -0.825, 0), Vector3.new(0,0,0))
Align(Character.LowerTorso,fakerig["Torso"], Vector3.new(0, -0.78, 0), Vector3.new(0,0,0))
Align(Character.UpperTorso,fakerig["Torso"], Vector3.new(0, 0.65, 0), Vector3.new(0,0,0))

--[[Wrap it up]]

local movecharacter = game:GetService("RunService").Stepped:Connect(function()
    fakerig:FindFirstChildOfClass("Humanoid"):Move(Character.Humanoid.MoveDirection)
end)

local jump = game:GetService("RunService").Stepped:Connect(function()
    if Character.Humanoid.Jump == true then
        fakerig:FindFirstChildOfClass("Humanoid").Jump = true
    end
end)



local stepped = game:GetService("RunService").Stepped:Connect(function()
    for i,v in pairs(Character:GetDescendants()) do
        if v:IsA("BasePart") or v:IsA("Part") then
            v.CanCollide = false
        end
    end
end)
local hrpmove

if _G.Fling == true then
local plrs = game:GetService("Players")
local plr = plrs.LocalPlayer
local char = plr.Character
local hrp = char.HumanoidRootPart

hrp.Name = "HumanoidRootPart"
hrp.Transparency = 0.5
hrp.Anchored = false
local bp = Instance.new("BodyPosition", hrp)
bp.Position = hrp.Position
bp.D = 9999999
bp.P = 999999999999999
bp.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
local flinger = Instance.new("BodyAngularVelocity",hrp)
flinger.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
flinger.P = 1000000000000000000000000000
flinger.AngularVelocity = Vector3.new(10000,10000,10000)

spawn(function()
	while game:GetService("RunService").Heartbeat:Wait() do
		bp.Position = game:GetService("Players").LocalPlayer.Character["fakerig"].HumanoidRootPart.Position
	end
end)
else
hrpmove = game:GetService("RunService").Stepped:Connect(function()
	Character.HumanoidRootPart.CFrame = fakerig.HumanoidRootPart.CFrame
end)
end

Character.Humanoid.Died:Connect(function()
     movecharacter:Disconnect()
     jump:Disconnect()
     if _G.Fling ~= true then
     	
     hrpmove:Disconnect()
 end
    Character:BreakJoints()
    Character:FindFirstChildOfClass("Humanoid"):Remove()
        for i,v in pairs(Character:GetDescendants()) do
        if v:IsA("BasePart") or v:IsA("Part") then
            v.Anchored = true
        end
    end
    fakerig:Remove()
	wait(game.Players.RespawnTime + 0.5)
		     stepped:Disconnect()
	
end)

workspace.Camera.CameraSubject = fakerig.Humanoid

function RunAnimations(folder)
    local Figure = folder.Parent
    local Torso = Figure:WaitForChild("Torso")
    local RightShoulder = Torso:WaitForChild("Right Shoulder")
    local LeftShoulder = Torso:WaitForChild("Left Shoulder")
    local RightHip = Torso:WaitForChild("Right Hip")
    local LeftHip = Torso:WaitForChild("Left Hip")
    local Neck = Torso:WaitForChild("Neck")
    local Humanoid = Figure:WaitForChild("Humanoid")
    local pose = "Standing"
    
    local currentAnim = ""
    local currentAnimInstance = nil
    local currentAnimTrack = nil
    local currentAnimKeyframeHandler = nil
    local currentAnimSpeed = 1.0
    local animTable = {}
    local animNames = { 
        idle = 	{	
                    { id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
                    { id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
                },
        walk = 	{ 	
                    { id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
                }, 
        run = 	{
                    { id = "run.xml", weight = 10 } 
                }, 
        jump = 	{
                    { id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
                }, 
        fall = 	{
                    { id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
                }, 
        climb = {
                    { id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
                }, 
        sit = 	{
                    { id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
                },	
        toolnone = {
                    { id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
                },
        toolslash = {
                    { id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
    --				{ id = "slash.xml", weight = 10 } 
                },
        toollunge = {
                    { id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
                },
        wave = {
                    { id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
                },
        point = {
                    { id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
                },
        dance1 = {
                    { id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
                    { id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
                    { id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
                },
        dance2 = {
                    { id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
                    { id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
                    { id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
                },
        dance3 = {
                    { id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
                    { id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
                    { id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
                },
        laugh = {
                    { id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
                },
        cheer = {
                    { id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
                },
    }
    local dances = {"dance1", "dance2", "dance3"}
    
    -- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
    local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}
    
    function configureAnimationSet(name, fileList)
        if (animTable[name] ~= nil) then
            for _, connection in pairs(animTable[name].connections) do
                connection:disconnect()
            end
        end
        animTable[name] = {}
        animTable[name].count = 0
        animTable[name].totalWeight = 0	
        animTable[name].connections = {}
    
        -- check for config values
        local config = script:FindFirstChild(name)
        if (config ~= nil) then
    --		print("Loading anims " .. name)
            table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
            table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
            local idx = 1
            for _, childPart in pairs(config:GetChildren()) do
                if (childPart:IsA("Animation")) then
                    table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
                    animTable[name][idx] = {}
                    animTable[name][idx].anim = childPart
                    local weightObject = childPart:FindFirstChild("Weight")
                    if (weightObject == nil) then
                        animTable[name][idx].weight = 1
                    else
                        animTable[name][idx].weight = weightObject.Value
                    end
                    animTable[name].count = animTable[name].count + 1
                    animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
        --			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
                    idx = idx + 1
                end
            end
        end
    
        -- fallback to defaults
        if (animTable[name].count <= 0) then
            for idx, anim in pairs(fileList) do
                animTable[name][idx] = {}
                animTable[name][idx].anim = Instance.new("Animation")
                animTable[name][idx].anim.Name = name
                animTable[name][idx].anim.AnimationId = anim.id
                animTable[name][idx].weight = anim.weight
                animTable[name].count = animTable[name].count + 1
                animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
    --			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
            end
        end
    end
    
    -- Setup animation objects
    function scriptChildModified(child)
        local fileList = animNames[child.Name]
        if (fileList ~= nil) then
            configureAnimationSet(child.Name, fileList)
        end	
    end
    
    script.ChildAdded:connect(scriptChildModified)
    script.ChildRemoved:connect(scriptChildModified)
    
    
    for name, fileList in pairs(animNames) do 
        configureAnimationSet(name, fileList)
    end	
    
    -- ANIMATION
    
    -- declarations
    local toolAnim = "None"
    local toolAnimTime = 0
    
    local jumpAnimTime = 0
    local jumpAnimDuration = 0.3
    
    local toolTransitionTime = 0.1
    local fallTransitionTime = 0.3
    local jumpMaxLimbVelocity = 0.75
    
    -- functions
    
    function stopAllAnimations()
        local oldAnim = currentAnim
    
        -- return to idle if finishing an emote
        if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
            oldAnim = "idle"
        end
    
        currentAnim = ""
        currentAnimInstance = nil
        if (currentAnimKeyframeHandler ~= nil) then
            currentAnimKeyframeHandler:disconnect()
        end
    
        if (currentAnimTrack ~= nil) then
            currentAnimTrack:Stop()
            currentAnimTrack:Destroy()
            currentAnimTrack = nil
        end
        return oldAnim
    end
    
    function setAnimationSpeed(speed)
        if speed ~= currentAnimSpeed then
            currentAnimSpeed = speed
            currentAnimTrack:AdjustSpeed(currentAnimSpeed)
        end
    end
    
    function keyFrameReachedFunc(frameName)
        if (frameName == "End") then
    
            local repeatAnim = currentAnim
            -- return to idle if finishing an emote
            if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
                repeatAnim = "idle"
            end
            
            local animSpeed = currentAnimSpeed
            playAnimation(repeatAnim, 0.0, Humanoid)
            setAnimationSpeed(animSpeed)
        end
    end
    
    -- Preload animations
    function playAnimation(animName, transitionTime, humanoid) 
            
        local roll = math.random(1, animTable[animName].totalWeight) 
        local origRoll = roll
        local idx = 1
        while (roll > animTable[animName][idx].weight) do
            roll = roll - animTable[animName][idx].weight
            idx = idx + 1
        end
    --		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
        local anim = animTable[animName][idx].anim
    
        -- switch animation		
        if (anim ~= currentAnimInstance) then
            
            if (currentAnimTrack ~= nil) then
                currentAnimTrack:Stop(transitionTime)
                currentAnimTrack:Destroy()
            end
    
            currentAnimSpeed = 1.0
        
            -- load it to the humanoid; get AnimationTrack
            currentAnimTrack = humanoid:LoadAnimation(anim)
            currentAnimTrack.Priority = Enum.AnimationPriority.Core
             
            -- play the animation
            currentAnimTrack:Play(transitionTime)
            currentAnim = animName
            currentAnimInstance = anim
    
            -- set up keyframe name triggers
            if (currentAnimKeyframeHandler ~= nil) then
                currentAnimKeyframeHandler:disconnect()
            end
            currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
            
        end
    
    end
    
    -------------------------------------------------------------------------------------------
    -------------------------------------------------------------------------------------------
    
    local toolAnimName = ""
    local toolAnimTrack = nil
    local toolAnimInstance = nil
    local currentToolAnimKeyframeHandler = nil
    
    function toolKeyFrameReachedFunc(frameName)
        if (frameName == "End") then
    --		print("Keyframe : ".. frameName)	
            playToolAnimation(toolAnimName, 0.0, Humanoid)
        end
    end
    
    
    function playToolAnimation(animName, transitionTime, humanoid, priority)	 
            
            local roll = math.random(1, animTable[animName].totalWeight) 
            local origRoll = roll
            local idx = 1
            while (roll > animTable[animName][idx].weight) do
                roll = roll - animTable[animName][idx].weight
                idx = idx + 1
            end
    --		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
            local anim = animTable[animName][idx].anim
    
            if (toolAnimInstance ~= anim) then
                
                if (toolAnimTrack ~= nil) then
                    toolAnimTrack:Stop()
                    toolAnimTrack:Destroy()
                    transitionTime = 0
                end
                        
                -- load it to the humanoid; get AnimationTrack
                toolAnimTrack = humanoid:LoadAnimation(anim)
                if priority then
                    toolAnimTrack.Priority = priority
                end
                 
                -- play the animation
                toolAnimTrack:Play(transitionTime)
                toolAnimName = animName
                toolAnimInstance = anim
    
                currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
            end
    end
    
    function stopToolAnimations()
        local oldAnim = toolAnimName
    
        if (currentToolAnimKeyframeHandler ~= nil) then
            currentToolAnimKeyframeHandler:disconnect()
        end
    
        toolAnimName = ""
        toolAnimInstance = nil
        if (toolAnimTrack ~= nil) then
            toolAnimTrack:Stop()
            toolAnimTrack:Destroy()
            toolAnimTrack = nil
        end
    
    
        return oldAnim
    end
    
    -------------------------------------------------------------------------------------------
    -------------------------------------------------------------------------------------------
    
    
    function onRunning(speed)
        if speed > 0.01 then
            playAnimation("walk", 0.1, Humanoid)
            if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
                setAnimationSpeed(speed / 14.5)
            end
            pose = "Running"
        else
            if emoteNames[currentAnim] == nil then
                playAnimation("idle", 0.1, Humanoid)
                pose = "Standing"
            end
        end
    end
    
    function onDied()
        pose = "Dead"
    end
    
    function onJumping()
        playAnimation("jump", 0.1, Humanoid)
        jumpAnimTime = jumpAnimDuration
        pose = "Jumping"
    end
    
    function onClimbing(speed)
        playAnimation("climb", 0.1, Humanoid)
        setAnimationSpeed(speed / 12.0)
        pose = "Climbing"
    end
    
    function onGettingUp()
        pose = "GettingUp"
    end
    
    function onFreeFall()
        if (jumpAnimTime <= 0) then
            playAnimation("fall", fallTransitionTime, Humanoid)
        end
        pose = "FreeFall"
    end
    
    function onFallingDown()
        pose = "FallingDown"
    end
    
    function onSeated()
        pose = "Seated"
    end
    
    function onPlatformStanding()
        pose = "PlatformStanding"
    end
    
    function onSwimming(speed)
        if speed > 0 then
            pose = "Running"
        else
            pose = "Standing"
        end
    end
    
    function getTool()	
        for _, kid in ipairs(Figure:GetChildren()) do
            if kid.className == "Tool" then return kid end
        end
        return nil
    end
    
    function getToolAnim(tool)
        for _, c in ipairs(tool:GetChildren()) do
            if c.Name == "toolanim" and c.className == "StringValue" then
                return c
            end
        end
        return nil
    end
    
    function animateTool()
        
        if (toolAnim == "None") then
            playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
            return
        end
    
        if (toolAnim == "Slash") then
            playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
            return
        end
    
        if (toolAnim == "Lunge") then
            playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
            return
        end
    end
    
    function moveSit()
        RightShoulder.MaxVelocity = 0.15
        LeftShoulder.MaxVelocity = 0.15
        RightShoulder:SetDesiredAngle(3.14 /2)
        LeftShoulder:SetDesiredAngle(-3.14 /2)
        RightHip:SetDesiredAngle(3.14 /2)
        LeftHip:SetDesiredAngle(-3.14 /2)
    end
    
    local lastTick = 0
    
    function move(time)
        local amplitude = 1
        local frequency = 1
          local deltaTime = time - lastTick
          lastTick = time
    
        local climbFudge = 0
        local setAngles = false
    
          if (jumpAnimTime > 0) then
              jumpAnimTime = jumpAnimTime - deltaTime
          end
    
        if (pose == "FreeFall" and jumpAnimTime <= 0) then
            playAnimation("fall", fallTransitionTime, Humanoid)
        elseif (pose == "Seated") then
            playAnimation("sit", 0.5, Humanoid)
            return
        elseif (pose == "Running") then
            playAnimation("walk", 0.1, Humanoid)
        elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
    --		print("Wha " .. pose)
            stopAllAnimations()
            amplitude = 0.1
            frequency = 1
            setAngles = true
        end
    
        if (setAngles) then
            local desiredAngle = amplitude * math.sin(time * frequency)
    
            RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
            LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
            RightHip:SetDesiredAngle(-desiredAngle)
            LeftHip:SetDesiredAngle(-desiredAngle)
        end
    
        -- Tool Animation handling
        local tool = getTool()
        if tool and tool:FindFirstChild("Handle") then
        
            local animStringValueObject = getToolAnim(tool)
    
            if animStringValueObject then
                toolAnim = animStringValueObject.Value
                -- message recieved, delete StringValue
                animStringValueObject.Parent = nil
                toolAnimTime = time + .3
            end
    
            if time > toolAnimTime then
                toolAnimTime = 0
                toolAnim = "None"
            end
    
            animateTool()		
        else
            stopToolAnimations()
            toolAnim = "None"
            toolAnimInstance = nil
            toolAnimTime = 0
        end
    end
    
    -- connect events
    Humanoid.Died:connect(onDied)
    Humanoid.Running:connect(onRunning)
    Humanoid.Jumping:connect(onJumping)
    Humanoid.Climbing:connect(onClimbing)
    Humanoid.GettingUp:connect(onGettingUp)
    Humanoid.FreeFalling:connect(onFreeFall)
    Humanoid.FallingDown:connect(onFallingDown)
    Humanoid.Seated:connect(onSeated)
    Humanoid.PlatformStanding:connect(onPlatformStanding)
    Humanoid.Swimming:connect(onSwimming)
    
    -- setup emote chat hook
    game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
        local emote = ""
        if msg == "/e dance" then
            emote = dances[math.random(1, #dances)]
        elseif (string.sub(msg, 1, 3) == "/e ") then
            emote = string.sub(msg, 4)
        elseif (string.sub(msg, 1, 7) == "/emote ") then
            emote = string.sub(msg, 8)
        end
        
        if (pose == "Standing" and emoteNames[emote] ~= nil) then
            playAnimation(emote, 0.1, Humanoid)
        end
    
    end)
    
    
    -- main program
    
    -- initialize to idle
    playAnimation("idle", 0.1, Humanoid)
    pose = "Standing"
    
    while Figure.Parent ~= nil do
        local _, time = wait(0.1)
        move(time)
    end
end
    
RunAnimations(fakerig.Animate)

elseif game.Players.LocalPlayer.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and _G.BotReanim == true then
function Align(Part0, Part1, Position, Angle)
    local AlignPosition = Instance.new("AlignPosition",Part0)
    local AlignOrientation = Instance.new("AlignOrientation",Part0)
    
    local Attachment1 = Instance.new("Attachment", Part0)
    local Attachment2 = Instance.new("Attachment", Part1)

    AlignPosition.Attachment0 = Attachment1
    AlignPosition.Attachment1 = Attachment2
    
    AlignOrientation.Attachment0 = Attachment1
    AlignOrientation.Attachment1 = Attachment2
	

    
    Attachment2.Position = Position or Vector3.new(0,0,0)
    Attachment2.Orientation = Angle or Vector3.new(0,0,0)
    
    AlignOrientation.MaxTorque = math.huge
    AlignOrientation.MaxAngularVelocity = math.huge
    AlignOrientation.PrimaryAxisOnly = false 
    AlignOrientation.Responsiveness = 200
    AlignOrientation.RigidityEnabled = false
    AlignOrientation.ReactionTorqueEnabled = false
   AlignPosition.MaxForce = 2626668
    AlignPosition.MaxVelocity = math.huge
    AlignPosition.ReactionForceEnabled = false
    AlignPosition.Responsiveness = 200
    AlignPosition.ApplyAtCenterOfMass = true
    AlignPosition.RigidityEnabled = false
    

                local BodyForce = Instance.new("BodyForce", Part0)
    
    game:GetService("RunService").Heartbeat:Connect(function()
        Part0.Velocity = Vector3.new(0,-50,0)
        --BodyForce.Force = Vector3.new(10000,10000,10000)
    end)
end

local Players = game:GetService("Players")
local Player = Players.LocalPlayer
Player.Character.Archivable = true
local Character = Player.Character
local fakerig = Character:Clone()
fakerig.Head.face.Transparency = 1
fakerig.Name = "fakerig"
fakerig.Parent = Character
Character.Animate:Remove()
Character.Humanoid:ClearAllChildren()

--[[Rigging]]

local A = Instance.new("Folder", game) A.Name = "AlignFolder"
local B = Instance.new("Part", A) B.Name = "SPart"
local Num = 1
for _,Hats in next, Character:GetChildren() do
if Hats:IsA("Accessory") then
	Hats.Handle:BreakJoints()
Align(Hats.Handle, fakerig.Humanoid:GetAccessories()[Num].Handle)
Num = Num + 1
end 
end

for _,Aligns in next, A:GetChildren() do
if Aligns:IsA("AlignOrientation") or Aligns:IsA("AlignPosition") then
Aligns.Parent = fakerig 
end 
end

Character["LavanderHair"].Handle:ClearAllChildren()
Character["Hat1"].Handle:ClearAllChildren()
Character["Kate Hair"].Handle:ClearAllChildren()
Character["Pink Hair"].Handle:ClearAllChildren()
Character["SeeMonkey"].Handle:ClearAllChildren()
--Character["Robloxclassicred"].Handle:BreakJoints()

--[[Fake Rig Mods]]

for i,v in pairs(fakerig:GetDescendants()) do
    if v:IsA("BasePart") or v:IsA("Part") then
        v.Transparency = 1
        v.CanCollide = false
    end
end

--[[Alignment]]

Align(Character["SeeMonkey"].Handle, fakerig.Torso, Vector3.new(0,0,0), Vector3.new(90,-0,0))
Align(Character["LavanderHair"].Handle, fakerig["Right Arm"], Vector3.new(0,0,0), Vector3.new(90,-0,0))
Align(Character["Kate Hair"].Handle, fakerig["Right Leg"], Vector3.new(0,0,0), Vector3.new(90,-0,0))
Align(Character["Pink Hair"].Handle, fakerig["Left Arm"], Vector3.new(0,0,0), Vector3.new(90,-0,0))
Align(Character["Hat1"].Handle, fakerig["Left Leg"], Vector3.new(0,0,0), Vector3.new(90,-0,0))
--Character.HumanoidRootPart.RootJoint:Remove()
--Align(Character.Torso, fakerig.Head, Vector3.new(0,20,0))
--Align(Character.HumanoidRootPart, fakerig.HumanoidRootPart, Vector3.new(0,0,0))

--[[Wrap it up]]--

local movecharacter = game:GetService("RunService").Stepped:Connect(function()
    fakerig:FindFirstChildOfClass("Humanoid"):Move(Character.Humanoid.MoveDirection)
    --Character.HumanoidRootPart.CFrame = fakerig.HumanoidRootPart.CFrame
end)

local jump = game:GetService("RunService").Stepped:Connect(function()
    if Character.Humanoid.Jump == true then
        fakerig:FindFirstChildOfClass("Humanoid").Jump = true
    end
end)

Character.HumanoidRootPart.Anchored = true

workspace.Camera.CameraSubject = fakerig.Humanoid
end
end)

--Section2:CreateButton("Hat Rig (R6 ONLY)", function()

--end)

Section2:CreateButton("Elio Blasio", function()
	-----------//Elio Blasio\\-----------
--[[Movelist
E = Equip/Unequip, click to shoot, hold to spray
T = Taunt
---------]]
--Credits to Shackluster for the refit/anti-breakjoints function, he's a cool guy/great scripter.--
--Ayy i'm not dead yet, take that haters, if i even had any to begin with.--
--Keeping this script small since big ones will cause major lag & exceed script limits--
--Using a FE converter because i'm way too lazy to create remotes for it--

Player=game.Players.LocalPlayer
Character=workspace.Camera.CameraSubject.Parent
hum = Character.Humanoid
LeftArm=Character["Left Arm"]
LeftLeg=Character["Left Leg"]
RightArm=Character["Right Arm"]
RightLeg=Character["Right Leg"]
Root=Character["HumanoidRootPart"]
Head=Character["Head"]
Torso=Character["Torso"]
Neck=Torso["Neck"]
mouse = Player:GetMouse()
walking = false
jumping = false
attacking = false
firsttime = false
tauntdebounce = false
position = nil
MseGuide = true
running = false
settime = 0
sine = 0
t = 0
ws = 18
change = 1
combo1 = true
equip = false
dgs = 75
combo2 = false
switch1 = true
switch2 = false
firsttime2 = false
combo3 = false
gunallowance = false
shooting = false
RunSrv = game:GetService("RunService")
RenderStepped = game:GetService("RunService").RenderStepped
removeuseless = game:GetService("Debris")

screenGui = Instance.new("ScreenGui")
screenGui.Parent = script.Parent

local HEADLERP = Instance.new("ManualWeld")
HEADLERP.Parent = Head
HEADLERP.Part0 = Head
HEADLERP.Part1 = Head
HEADLERP.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local TORSOLERP = Instance.new("ManualWeld")
TORSOLERP.Parent = Root
TORSOLERP.Part0 = Torso
TORSOLERP.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local ROOTLERP = Instance.new("ManualWeld")
ROOTLERP.Parent = Root
ROOTLERP.Part0 = Root
ROOTLERP.Part1 = Torso
ROOTLERP.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local RIGHTARMLERP = Instance.new("ManualWeld")
RIGHTARMLERP.Parent = RightArm
RIGHTARMLERP.Part0 = RightArm
RIGHTARMLERP.Part1 = Torso
RIGHTARMLERP.C0 = CFrame.new(-1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local LEFTARMLERP = Instance.new("ManualWeld")
LEFTARMLERP.Parent = LeftArm
LEFTARMLERP.Part0 = LeftArm
LEFTARMLERP.Part1 = Torso
LEFTARMLERP.C0 = CFrame.new(1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local RIGHTLEGLERP = Instance.new("ManualWeld")
RIGHTLEGLERP.Parent = RightLeg
RIGHTLEGLERP.Part0 = RightLeg
RIGHTLEGLERP.Part1 = Torso
RIGHTLEGLERP.C0 = CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local LEFTLEGLERP = Instance.new("ManualWeld")
LEFTLEGLERP.Parent = LeftLeg
LEFTLEGLERP.Part0 = LeftLeg
LEFTLEGLERP.Part1 = Torso
LEFTLEGLERP.C0 = CFrame.new(0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local function weldBetween(a, b)
    local weld = Instance.new("ManualWeld", a)
    weld.Part0 = a
    weld.Part1 = b
    weld.C0 = a.CFrame:inverse() * b.CFrame
    return weld
end

function MAKETRAIL(PARENT,POSITION1,POSITION2,LIFETIME,COLOR)
A = Instance.new("Attachment", PARENT)
A.Position = POSITION1
A.Name = "A"
B = Instance.new("Attachment", PARENT)
B.Position = POSITION2
B.Name = "B"
tr1 = Instance.new("Trail", PARENT)
tr1.Attachment0 = A
tr1.Attachment1 = B
tr1.Enabled = true
tr1.Lifetime = LIFETIME
tr1.TextureMode = "Static"
tr1.LightInfluence = 0
tr1.Color = COLOR
tr1.Transparency = NumberSequence.new(0, 1)
end

function Align(Part0, Part1, Position, Angle)
	if Part0:FindFirstChild("Attachment") then
		Part0:FindFirstChild("Attachment"):Remove()
	end
    local AlignPosition = Instance.new("AlignPosition",Part0)
    local AlignOrientation = Instance.new("AlignOrientation",Part0)
    
    local Attachment1 = Instance.new("Attachment", Part0)
    local Attachment2 = Instance.new("Attachment", Part1)

    AlignPosition.Attachment0 = Attachment1
    AlignPosition.Attachment1 = Attachment2
    
    AlignOrientation.Attachment0 = Attachment1
    AlignOrientation.Attachment1 = Attachment2
    
    Attachment2.Position = Position or Vector3.new(0,0,0)
    Attachment2.Orientation = Angle or Vector3.new(0,0,0)
    
    AlignOrientation.MaxTorque = math.huge
    AlignOrientation.MaxAngularVelocity = math.huge
    AlignOrientation.PrimaryAxisOnly = false 
    AlignOrientation.Responsiveness = 200
    AlignOrientation.RigidityEnabled = false
    AlignOrientation.ReactionTorqueEnabled = false
    AlignPosition.MaxForce = math.huge
    AlignPosition.MaxVelocity = math.huge
    AlignPosition.ReactionForceEnabled = false
    AlignPosition.Responsiveness = 200
    AlignPosition.ApplyAtCenterOfMass = true
    AlignPosition.RigidityEnabled = true
    game:GetService("RunService").Heartbeat:Connect(function()
        Part0.Velocity = Vector3.new(-29.99,0,0)
    end)
    if Part0.Parent:IsA("Accessory") then
    	Part0:BreakJoints()
    end
end

tommygun = Instance.new("Part",Character)
Align(game.Players.LocalPlayer.Character["Type-49 Abomindation Back Accessory"].Handle, tommygun, Vector3.new(-0.3, 0.05, 0), Vector3.new(-0, -90, -51))
tommygun.Size = Vector3.new(2,2,2)
tommygun.CFrame = RightArm.CFrame
tommygun.CanCollide = false
tommygunweld = Instance.new("Weld",tommygun)
tommygunweld.Part0 = tommygun
tommygunweld.Part1 = RightArm
tommygunweld.C0 = tommygun.CFrame:inverse() * RightArm.CFrame * CFrame.new(0,-.80,1.25) * CFrame.Angles(math.rad(98),math.rad(0),0)
mtommygun = Instance.new("SpecialMesh", tommygun)
mtommygun.MeshType = "FileMesh"
mtommygun.Scale = Vector3.new(1, 1, 1)
mtommygun.MeshId,mtommygun.TextureId = 'http://www.roblox.com/asset/?id=116679805','http://www.roblox.com/asset/?id=116679995'
shootbox = Instance.new("Part",Character)
shootbox.Size = Vector3.new(.2,.2,.2)
shootbox.CanCollide = false
shootbox.Transparency = 1
shootbox.CFrame = tommygun.CFrame
shootboxweld = weldBetween(shootbox,tommygun)
shootboxweld.C0 = CFrame.new(0,-.05,2.62)
light = Instance.new("PointLight", shootbox)
light.Color = BrickColor.new("Bright yellow").Color
light.Range = 5
light.Brightness = 11
light.Enabled = false
particlemiter1 = Instance.new("ParticleEmitter", shootbox)
particlemiter1.Enabled = false
particlemiter1.Texture = "rbxassetid://461242617"
particlemiter1.Lifetime = NumberRange.new(.1)
particlemiter1.Size = NumberSequence.new(1,0)
particlemiter1.Rate = 20
particlemiter1.RotSpeed = NumberRange.new(0)
particlemiter1.Speed = NumberRange.new(0)
tommygunammo = Instance.new("Part",Character)
tommygunammo.Size = Vector3.new(2,2,2)
tommygunammo.CFrame = tommygun.CFrame
tommygunammo.Transparency = 1
tommygun.Transparency = 1
tommygunammo.CanCollide = false
tommygunammoweld = Instance.new("Weld",tommygunammo)
tommygunammoweld.Part0 = tommygunammo
tommygunammoweld.Part1 = tommygun
tommygunammoweld.C0 = tommygun.CFrame:inverse() * tommygun.CFrame * CFrame.new(0,.4,.25) * CFrame.Angles(math.rad(0),math.rad(0),0)
mtommygunammo = Instance.new("SpecialMesh", tommygunammo)
mtommygunammo.MeshType = "FileMesh"
mtommygunammo.Scale = Vector3.new(1, 1, 1)
mtommygunammo.MeshId,mtommygunammo.TextureId = 'http://www.roblox.com/asset/?id=116740155','http://www.roblox.com/asset/?id=116679995'


coroutine.wrap(function()
while wait() do
hum.WalkSpeed = ws
LeftArm.BrickColor = BrickColor.new("Really black")
RightArm.BrickColor = BrickColor.new("Really black")
Head.BrickColor = BrickColor.new("Really black")
end
end)()
godmode = coroutine.wrap(function()
for i,v in pairs(Character:GetChildren()) do
if v:IsA("BasePart") and v ~= Root then
v.Anchored = false
end
end
while true do
hum.MaxHealth = math.huge
wait(0.0000001)
hum.Health = math.huge
wait()
end
end)
godmode()
ff = Instance.new("ForceField", Character)
ff.Visible = false

coroutine.wrap(function()
for i,v in pairs(Character:GetChildren()) do
if v.Name == "Animate" then v:Remove()
end
end
end)()

function damagealll(Radius,Position)		
	
	return		
end

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end

doomtheme = Instance.new("Sound", Torso)
doomtheme.Volume = 1
doomtheme.Name = "doomtheme"
doomtheme.Looped = true
doomtheme.SoundId = "rbxassetid://318812395"
doomtheme:Play()

Torso.ChildRemoved:connect(function(removed)
if removed.Name == "doomtheme" then

doomtheme = Instance.new("Sound", Torso)
doomtheme.Volume = 1
doomtheme.Name = "doomtheme"
doomtheme.Looped = true
doomtheme.SoundId = "rbxassetid://318812395"
doomtheme:Play()
end
end)

for _,n in pairs(Character:GetChildren()) do
if n:IsA("Accessory") then n:Remove() end
end
for _,x in pairs(Character:GetChildren()) do
if x:IsA("Decal") then x:Remove() end
end

function SOUND(PARENT,ID,VOL,LOOP,REMOVE)
so = Instance.new("Sound")
so.Parent = PARENT
so.SoundId = "rbxassetid://"..ID
so.Volume = VOL
so.Looped = LOOP
so:Play()
removeuseless:AddItem(so,REMOVE)
end

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='t' then
if tauntdebounce then return end
tauntdebounce = true
local b1 = Instance.new("BillboardGui",Head)
b1.Size = UDim2.new(0,4,0,1.6)
b1.StudsOffset = Vector3.new(0,0,0)
b1.Name = "laff"
b1.AlwaysOnTop = true
b1.StudsOffset = Vector3.new(0,2,0)
b1.Adornee = Head
removeuseless:AddItem(b1,3)
local b2 = Instance.new("TextLabel",b1)
b2.BackgroundTransparency = 1
b2.Text = "HeHeHeHeHeHeHe..."
b2.Font = "Garamond"
b2.TextSize = 30
b2.Name = "lafftext"
b2.TextStrokeTransparency = 0
b2.TextColor3 = BrickColor.new("Grey").Color
b2.TextStrokeColor3 = Color3.new(0,0,0)
b2.Size = UDim2.new(1,0,.5,0)
laff = Instance.new("Sound",Head)
laff.SoundId = "rbxassetid://2126502539"
laff.Volume = 5
laff:Play()
wait(5)
laff:Remove()
tauntdebounce = false
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='e' then
if debounce then return end
if equip then
g1:Remove()
light.Enabled = false
pcall(function()
temmy:Remove()
end)
for i,v in pairs(tommygun:GetDescendants()) do
if v.Name == "temmy" then v:Remove()
end
end
light.Enabled = false
particlemiter1.Enabled = false
hum.CameraOffset = Vector3.new(0,0,0)
attacking = false
equip = false
shooting = false
gunallowance = false
ws = 18
else
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
g1.CFrame = CFrame.new(Root.Position,mouse.Hit.p)
attacking = true
debounce = true
equip = true
coroutine.wrap(function()
while equip do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.1)
ws = 10
swait()
if Root.Velocity.y > 1 then
position = "Jump3"
elseif Root.Velocity.y < -1 then
position = "Falling3"
elseif Root.Velocity.Magnitude > 2 and running == false and attacking == true then
position = "Walk3"
elseif Root.Velocity.Magnitude < 2 and running == false and attacking == true then
position = "Idle4"
end
end
end)()
coroutine.wrap(function()
while equip do
swait()
settime = 0.05
sine = sine + change
if position == "Jump3" and attacking and not running then
change = .65
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.4)
elseif position == "Falling3" and attacking and not running then
change = .65
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(14), math.rad(-4), math.rad(0)), 0.4)
elseif position == "Walk3" and attacking == true and running == false then
change = .65
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0.05*math.sin(sine/4), 0) * CFrame.Angles(math.rad(0), math.rad(-50), math.rad(0)),.2)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.cos(sine/8)/2.8, 0.2 - math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) + -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0), math.cos(25 * math.cos(sine/8))), 0.1)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.cos(sine/8)/2.8, 0.2 + math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) - -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0) , math.cos(25 * math.cos(sine/8))), 0.1)
elseif position == "Idle4" and attacking == true and running == false then
change = .65
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/25), 0) * CFrame.Angles(math.rad(0), math.rad(-50), math.rad(0)),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 - .1 * math.sin(sine/25), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.1)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0 - .1 * math.sin(sine/25), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.1)
end
end
end)()
SOUND(RightArm,898163129,6,false,2)
for i = 1, 30 do
tommygunweld.C0 = tommygunweld.C0:lerp(CFrame.new(0,-.68,1.25) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-12)),.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1, 0.1, 0.4) * CFrame.Angles(math.rad(-90), math.rad(-60), math.rad(0)), 0.25)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-90), math.rad(0), math.rad(0)), 0.25)
swait()
end
gunallowance = true
mouse.Button1Down:connect(function()
if gunallowance then
particlemiter1.Enabled = true
temmy = Instance.new("Sound",tommygun)
temmy.SoundId = "rbxassetid://2204318084"
temmy.Volume = 6
temmy.Name = "temmy"
temmy.Looped = true
temmy:Play()
shooting = true
end
end)
mouse.Button1Up:connect(function()
if gunallowance then
hum.CameraOffset = Vector3.new(0,0,0)
light.Enabled = false
particlemiter1.Enabled = false
pcall(function()
temmy:Remove()
end)
for i,v in pairs(tommygun:GetDescendants()) do
if v.Name == "temmy" then v:Remove()
end
end
shooting = false
end
end)
coroutine.wrap(function()
if firsttime2 then return end
firsttime2 = true
while true do
swait(3)
if shooting then
if switch1 then
switch1 = false
switch2 = true
light.Enabled = true
elseif switch2 then
switch1 = true
switch2 = false
light.Enabled = false
end
pcall(function()
if mouse.Target.Parent:FindFirstChildOfClass("Humanoid") then
end
end)
end
end
end)()
coroutine.wrap(function()
if firsttime then return end
firsttime = true
while true do
if shooting then
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-90), math.rad(0 - 10 * math.sin(sine)), math.rad(0)), 0.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1, 0.1 + .4 * math.sin(sine), 0.4) * CFrame.Angles(math.rad(-90), math.rad(-60), math.rad(0)), 0.25)
pcall(function()
if mouse.Target.Parent:FindFirstChildOfClass("Humanoid") then
end
end)
elseif not shooting then
end
swait()
end
end)()
debounce = false
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='z' then
print("Music switched to 1")
id = 2199374985
doomtheme.SoundId = "rbxassetid://"..id
doomtheme:Play()
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='v' then
print("Music switched to 4")
id = 2111948183
doomtheme.SoundId = "rbxassetid://"..id
doomtheme:Play()
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='x' then
print("Music switched to 2")
id = 318812395
doomtheme.SoundId = "rbxassetid://"..id
doomtheme:Play()
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='c' then
print("Music switched to 3")
id = 180337897
doomtheme.SoundId = "rbxassetid://"..id
doomtheme:Play()
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='b' then
print("Music switched to 5")
id = 649148458
doomtheme.SoundId = "rbxassetid://"..id
doomtheme:Play()
end
end)


checks1 = coroutine.wrap(function() -------Checks
while true do
if Root.Velocity.y > 1 then
position = "Jump"
elseif Root.Velocity.y < -1 then
position = "Falling"
elseif Root.Velocity.Magnitude < 2 then
position = "Idle"
elseif Root.Velocity.Magnitude < 20 then
position = "Walking"
elseif Root.Velocity.Magnitude > 20 then
position = "Running"
else
end
wait()
end
end)
checks1()

function ray(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function ray2(StartPos, EndPos, Distance, Ignore)
local DIRECTION = CFrame.new(StartPos,EndPos).lookVector
return ray(StartPos, DIRECTION, Distance, Ignore)
end

OrgnC0 = Neck.C0
local movelimbs = coroutine.wrap(function()
while RunSrv.RenderStepped:wait() do
TrsoLV = Torso.CFrame.lookVector
Dist = nil
Diff = nil
if not MseGuide then
print("Failed to recognize")
else
local _, Point = Workspace:FindPartOnRay(Ray.new(Head.CFrame.p, mouse.Hit.lookVector), Workspace, false, true)
Dist = (Head.CFrame.p-Point).magnitude
Diff = Head.CFrame.Y-Point.Y
local _, Point2 = Workspace:FindPartOnRay(Ray.new(LeftArm.CFrame.p, mouse.Hit.lookVector), Workspace, false, true)
Dist2 = (LeftArm.CFrame.p-Point).magnitude
Diff2 = LeftArm.CFrame.Y-Point.Y
HEADLERP.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
Neck.C0 = Neck.C0:lerp(OrgnC0*CFrame.Angles((math.tan(Diff/Dist)*1), 0, (((Head.CFrame.p-Point).Unit):Cross(Torso.CFrame.lookVector)).Y*1), .1)
end
end
end)
movelimbs()
immortal = {}
for i,v in pairs(Character:GetDescendants()) do
	if v:IsA("BasePart") and v.Name ~= "lmagic" and v.Name ~= "rmagic" then
		if v ~= Root and v ~= Torso and v ~= Head and v ~= RightArm and v ~= LeftArm and v ~= RightLeg and v.Name ~= "lmagic" and v.Name ~= "rmagic" and v ~= LeftLeg then
			v.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		end
		table.insert(immortal,{v,v.Parent,v.Material,v.Color,v.Transparency})
	elseif v:IsA("JointInstance") then
		table.insert(immortal,{v,v.Parent,nil,nil,nil})
	end
end
for e = 1, #immortal do
	if immortal[e] ~= nil then
		local STUFF = immortal[e]
		local PART = STUFF[1]
		local PARENT = STUFF[2]
		local MATERIAL = STUFF[3]
		local COLOR = STUFF[4]
		local TRANSPARENCY = STUFF[5]
if levitate then
		if PART.ClassName == "Part" and PART ~= Root and PART.Name ~= eyo1 and PART.Name ~= eyo2 and PART.Name ~= "lmagic" and PART.Name ~= "rmagic" then
			PART.Material = MATERIAL
			PART.Color = COLOR
			PART.Transparency = TRANSPARENCY
		end
		PART.AncestryChanged:connect(function()
			PART.Parent = PARENT
		end)
else
		if PART.ClassName == "Part" and PART ~= Root and PART.Name ~= "lmagic" and PART.Name ~= "rmagic" then
			PART.Material = MATERIAL
			PART.Color = COLOR
			PART.Transparency = TRANSPARENCY
		end
		PART.AncestryChanged:connect(function()
			PART.Parent = PARENT
		end)
end
	end
end
function immortality()
	return
end
coroutine.wrap(function()
while true do
if hum.Health < .1 then
deadsound = Instance.new("Sound", Torso)
deadsound.Volume = 6
deadsound.SoundId = "rbxassetid://1411352723"
deadsound:Play()
immortality()
end
wait()
end
end)()

local anims = coroutine.wrap(function()
while true do
settime = 0.05
sine = sine + change
if position == "Jump" and attacking == false then
change = 1
tommygunweld.C0 = tommygunweld.C0:lerp(CFrame.new(0,-.80,1.25) * CFrame.Angles(math.rad(98),math.rad(0),0),.25)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(-3),math.rad(-4)), 0.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.4)
elseif position == "Jump2" and attacking == false then
change = 1
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-20 - 1 * math.sin(sine/9)), math.rad(0 + 0 * math.cos(sine/8)), math.rad(0) + Root.RotVelocity.Y / 30, math.cos(10 * math.cos(sine/10))), 0.3)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.3)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - .1 * math.sin(sine/12)),math.rad(40 - .5 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + .1 * math.sin(sine/12)),math.rad(-40 + .5 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 2.0 + .02 * math.sin(sine/9), 0.2 + .1 * math.sin(sine/9)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/9)), math.rad(20), math.rad(0)), 0.3)
elseif position == "Falling" and attacking == false then
change = 1
tommygunweld.C0 = tommygunweld.C0:lerp(CFrame.new(0,-.80,1.25) * CFrame.Angles(math.rad(98),math.rad(0),0),.25)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(14), math.rad(-4), math.rad(0)), 0.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.6, 0.5, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(20)), 0.2)
elseif position == "Falling2" and attacking == false then
change = 1
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-20 - 1 * math.sin(sine/9)), math.rad(0 + 0 * math.cos(sine/8)), math.rad(0) + Root.RotVelocity.Y / 30, math.cos(10 * math.cos(sine/10))), 0.3)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.3)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - .1 * math.sin(sine/12)),math.rad(40 - .5 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + .1 * math.sin(sine/12)),math.rad(-40 + .5 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 2.0 + .02 * math.sin(sine/9), 0.2 + .1 * math.sin(sine/9)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/9)), math.rad(20), math.rad(0)), 0.3)
elseif position == "Walking" and attacking == false and running == false then
change = 1.2
walking = true
tommygunweld.C0 = tommygunweld.C0:lerp(CFrame.new(0,-.80,1.25) * CFrame.Angles(math.rad(98),math.rad(0),0),.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3,1,0) * CFrame.Angles(math.rad(180),math.rad(1),math.rad(10)), 0.1)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5 + Root.RotVelocity.Y / 85,.35,.5*math.sin(sine/8)) * CFrame.Angles(math.rad(-35*math.sin(sine/8)),math.rad(0*math.sin(sine/8)),math.rad(10 + Root.RotVelocity.Y / 10, math.sin(20 * math.sin(sine/4)))),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0.05*math.sin(sine/4), 0) * CFrame.Angles(math.rad(-10), math.rad(5 * math.cos(sine/7)), math.rad(0) + Root.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/10))), 0.1)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.cos(sine/8)/2.8, 0.2 - math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) + -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0), math.cos(25 * math.cos(sine/8))), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.cos(sine/8)/2.8, 0.2 + math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) - -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0) , math.cos(25 * math.cos(sine/8))), 0.3)
elseif position == "Idle" and attacking == false and running == false then
change = .5
tommygunweld.C0 = tommygunweld.C0:lerp(CFrame.new(0,-.80,1.25) * CFrame.Angles(math.rad(98),math.rad(0),0),.25)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0),math.rad(25),math.rad(0)),.1)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3 + .1 * math.sin(sine/12),1 + .1 * math.sin(sine/12),0) * CFrame.Angles(math.rad(180),math.rad(1),math.rad(8 + 5 * math.sin(sine/12))), 0.1)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.59 - .05 * math.sin(sine/12), 0.1 -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(-2), math.rad(2), math.rad(8  - 6 * math.sin(sine/12))), .2)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.1)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.1)
elseif position == "Idle2" and attacking == false and running == false then
change = .75
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0 - 3 * math.sin(sine/9)),0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(-.2,.2,0) * CFrame.Angles(0,0,0),.1)
LEFTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.6, 0.8 - .1 * math.sin(sine/9), 0) * CFrame.Angles(math.rad(0), math.rad(0 + 3 * math.sin(sine/9)), math.rad(35 - 5 * math.sin(sine/9))), 0.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.6, 0.8 - .1 * math.sin(sine/9), 0) * CFrame.Angles(math.rad(0), math.rad(0 - 3 * math.sin(sine/9)), math.rad(-35 + 5 * math.sin(sine/9))), 0.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 2.0,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10 + 2 * math.sin(sine/9))), 0.4)
elseif position == "Walking2" and attacking == false and running == false then
ws = 50
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-20 - 1 * math.sin(sine/9)), math.rad(0 + 0 * math.cos(sine/8)), math.rad(0) + Root.RotVelocity.Y / 30, math.cos(10 * math.cos(sine/10))), 0.3)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.3)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - .1 * math.sin(sine/12)),math.rad(40 - .5 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + .1 * math.sin(sine/12)),math.rad(-40 + .5 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 2.0 + .02 * math.sin(sine/9), 0.2 + .1 * math.sin(sine/9)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/9)), math.rad(20), math.rad(0)), 0.3)
elseif position == "Running" and attacking == false then
change = 1
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(0, .5, 0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(-1.24+.6*math.sin(sine/4)/1.4, 0.54, 0-0.8*math.sin(sine/4))*CFrame.Angles(math.rad(6+140*math.sin(sine/4)/1.2), math.rad(0), math.rad(20+70*math.sin(sine/4))), 0.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(0,.5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(-20 - 0 * math.sin(sine/4)), math.rad(0 + 6 * math.sin(sine/4)), math.rad(0) + Root.RotVelocity.Y / 30, math.sin(10 * math.sin(sine/4))), 0.3)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,-.2 + .5*-math.sin(sine/4)),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.6+0.1*math.sin(sine/4),.7*-math.sin(sine/4)) * CFrame.Angles(math.rad(15+ -50 * math.sin(sine/4)),0,0),.3)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,-.2 + .5*math.sin(sine/4)),.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.6-0.1*math.sin(sine/4),.7*math.sin(sine/4)) * CFrame.Angles(math.rad(15 + 50 * math.sin(sine/4)),0,0),.3)
end
swait()
end
end)
anims()
warn("Risen from hell, ready to prove his reputation. Made by Supr14")
	
end)

Section2:CreateButton("Minigun", function()
	local script = game:GetObjects("rbxassetid://7683352533")[1]
--this  is  not  heavy  in  tf2
wait(0.2)
Player = game.Players.LocalPlayer

PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = workspace.Camera.CameraSubject.Parent
Humanoid = Character.Humanoid
RootPart = Character["HumanoidRootPart"]
Torso = Character["Torso"]
Head = Character["Head"]
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart["RootJoint"]
Neck = Torso["Neck"]
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
local sick = Instance.new("Sound",Torso)
sick:Play()

local muting=false
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor

local function weldBetween(a, b)
	local weldd = Instance.new("ManualWeld")
	weldd.Part0 = a
	weldd.Part1 = b
	weldd.C0 = CFrame.new()
	weldd.C1 = b.CFrame:inverse() * a.CFrame
	weldd.Parent = a
	return weldd
end

--//=================================\\
--|| 	      USEFUL VALUES
--\\=================================//

local Animation_Speed = 3
local Frame_Speed = 1 / 80 -- (1 / 30) OR (1 / 60)
local Speed = 13
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local ANIM = "Idle"
local ATTACK = false
local COMBO = 1
local Rooted = false
local SINE = 0
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed

local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
--ROBLOXIDLEANIMATION.Parent = Humanoid
local Effects = IT("Folder", Character)
Effects.Name = "Effects"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character.Animate
local SIZE = 1
local TRANSITIONS = false
local FULL = false
local MODE = "Malediction"
local PITCH = 0.9
local VOLUME = 1
local FACE = 2801767831
local MAINRUINCOLOR = BrickColor.new("Fossil")
local SECONDRUINCOLOR  = BrickColor.new("Fossil")
--//=================================\\
--\\=================================//


--//=================================\\
--\\=================================//

--//=================================\\
--|| SAZERENOS' ARTIFICIAL HEARTBEAT
--\\=================================//

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end
--//=================================\\
--//          WINGY STUFF
--\\=================================//

function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end

local Create = function(ty) return function(data) local obj = Instance.new(ty) for k , v in pairs(data) do if type(k) == 'number' then v.Parent = obj else obj[k] = v end end return obj end end

CFuncs = {	
	["Part"] = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part"){
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material,
			}
			RemoveOutlines(Part)
			return Part
		end;
	};

	["Mesh"] = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end;
	};

	["Mesh"] = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end;
	};

	["Weld"] = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld"){
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1,
			}
			return Weld
		end;
	};

	["Sound"] = {
		Create = function(id, par, vol, pit) 
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound"){
					Volume = vol,
					Name = "EffectSoundo",
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 10)
			end))
		end;
	};

	["TimeSound"] = {
		Create = function(id, par, vol, pit, timepos) 
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound"){
					Volume = vol,
					Name = "EffectSoundo",
					Pitch = pit or 1,
					SoundId = id,
					TimePosition = timepos,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 10)
			end))
		end;
	};
	["EchoSound"] = {
		Create = function(id, par, vol, pit, timepos,delays,echodelay,fedb,dryl) 
			coroutine.resume(coroutine.create(function()
				local Sas = Create("Sound"){
					Volume = vol,
					Name = "EffectSoundo",
					Pitch = pit or 1,
					SoundId = id,
					TimePosition = timepos,
					Parent = par or workspace,
				}
				local E = Create("EchoSoundEffect"){
					Delay = echodelay,
					Name = "Echo",
					Feedback = fedb,
					DryLevel = dryl,
					Parent = Sas,
				}
				wait() 
				Sas:play() 
				game:GetService("Debris"):AddItem(Sas, delays)
			end))
		end;
	};

	["LongSound"] = {
		Create = function(id, par, vol, pit) 
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound"){
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 60)
			end))
		end;
	};

	["ParticleEmitter"] = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter"){
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread,
			}
			return fp
		end;
	};

	CreateTemplate = {

	};
}



New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end

function CreateParta(parent,transparency,reflectance,material,brickcolor)
	local p = Instance.new("Part")
	p.TopSurface = 0
	p.BottomSurface = 0
	p.Parent = parent
	p.Size = Vector3.new(0.1,0.1,0.1)
	p.Transparency = transparency
	p.Reflectance = reflectance
	p.CanCollide = false
	p.Locked = true
	p.BrickColor = brickcolor
	p.Material = material
	return p
end

function sphere2(bonuspeed,type,pos,scale,value,value2,value3,color)
	local type = type
	local rng = Instance.new("Part", Character)
	rng.Anchored = true
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = scale
	local scaler2 = 1
	local scaler2b = 1
	local scaler2c = 1
	if type == "Add" then
		scaler2 = 1*value
		scaler2b = 1*value2
		scaler2c = 1*value3
	elseif type == "Divide" then
		scaler2 = 1/value
		scaler2b = 1/value2
		scaler2c = 1/value3
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
				scaler2b = scaler2b - 0.01*value/bonuspeed
				scaler2c = scaler2c - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
				scaler2b = scaler2b - 0.01/value*bonuspeed
				scaler2c = scaler2c - 0.01/value*bonuspeed
			end
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
		end
		rng:Destroy()
	end))
end

function sphereMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	--rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = vt(x1,y1,z1)
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			speeder = speeder - 0.01*FastSpeed*bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
		end
		rng:Destroy()
	end))
end

function slash(bonuspeed,rotspeed,rotatingop,typeofshape,type,typeoftrans,pos,scale,value,color)
	local type = type
	local rotenable = rotatingop
	local rng = Instance.new("Part", Character)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	if typeoftrans == "In" then
		rng.Transparency = 1
	end
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "FileMesh"
	if typeofshape == "Normal" then
		rngm.MeshId = "rbxassetid://662586858"
	elseif typeofshape == "Round" then
		rngm.MeshId = "rbxassetid://662585058"
	end
	rngm.Scale = scale
	local scaler2 = 1/10
	if type == "Add" then
		scaler2 = 1*value/10
	elseif type == "Divide" then
		scaler2 = 1/value/10
	end
	local randomrot = math.random(1,2)
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed/10
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed/10
			end
			if rotenable == true then
				if randomrot == 1 then
					rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(rotspeed*bonuspeed/2),0)
				elseif randomrot == 2 then
					rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(-rotspeed*bonuspeed/2),0)
				end
			end
			if typeoftrans == "Out" then
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
			elseif typeoftrans == "In" then
				rng.Transparency = rng.Transparency - 0.01*bonuspeed
			end
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed/10, 0, scaler2*bonuspeed/10)
		end
		rng:Destroy()
	end))
end

function block(bonuspeed,type,pos,scale,value,value2,value3,color,color3)
	local type = type
	local rng = Instance.new("Part", Character)
	rng.Anchored = true
	rng.BrickColor = color
	rng.Color = color3
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Brick"
	rngm.Scale = scale
	local scaler2 = 1
	local scaler2b = 1
	local scaler2c = 1
	if type == "Add" then
		scaler2 = 1*value
		scaler2b = 1*value2
		scaler2c = 1*value3
	elseif type == "Divide" then
		scaler2 = 1/value
		scaler2b = 1/value2
		scaler2c = 1/value3
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
				scaler2b = scaler2b - 0.01*value/bonuspeed
				scaler2c = scaler2c - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
				scaler2b = scaler2b - 0.01/value*bonuspeed
				scaler2c = scaler2c - 0.01/value*bonuspeed
			end
			rng.CFrame = rng.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
		end
		rng:Destroy()
	end))
end

function Damagefunc(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	if hit.Parent == nil then
		return
	end
	local h = hit.Parent:FindFirstChildOfClass("Humanoid")
	for _, v in pairs(hit.Parent:children()) do
		if v:IsA("Humanoid") then
			h = v
		end
	end
	if h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("Head") ~= nil then
		if hit.Parent:findFirstChild("DebounceHit") ~= nil and hit.Parent.DebounceHit.Value == true then
			return
		end
		local c = Create("ObjectValue")({
			Name = "creator",
			Value = game:GetService("Players").LocalPlayer,
			Parent = h
		})
		game:GetService("Debris"):AddItem(c, 0.5)
		if HitSound ~= nil and HitPitch ~= nil then
			CFuncs.Sound.Create(HitSound, hit, 1, HitPitch)
		end
		local Damage = math.random(minim, maxim)
		local blocked = false
		local block = hit.Parent:findFirstChild("Block")
		if block ~= nil and block.className == "IntValue" and block.Value > 0 then
			blocked = true
			block.Value = block.Value - 1
			print(block.Value)
		end
		if blocked == false then
			local HitHealth = h.Health
			--h.MaxHealth = 100   let it

			h.Health = h.Health - Damage
     --[[if HitHealth ~= h.Health and HitHealth ~= 0 and 0 >= h.Health and h.Parent.Name ~= "Hologram" then
        --print("gained kill")
        --dmg(h.Parent)
      end
      --ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), Damage, .03, Part.BrickColor.Color)
    else
      h.Health = h.Health - Damage / 2
      --ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), Damage, .03, Part.BrickColor.Color)
    end]]
			if Type == "Knockdown" then
				local hum = hit.Parent.Humanoid
				hum.PlatformStand = true
				coroutine.resume(coroutine.create(function(HHumanoid)
					swait(1)
					HHumanoid.PlatformStand = false
				end), hum)
				local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
				local bodvol = Create("BodyVelocity")({
					velocity = angle * knockback,
					P = 5000,
					maxForce = Vector3.new(8000, 8000, 8000),
					Parent = hit
				})
				local rl = Create("BodyAngularVelocity")({
					P = 3000,
					maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
					angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
					Parent = hit
				})
				game:GetService("Debris"):AddItem(bodvol, 0.5)
				game:GetService("Debris"):AddItem(rl, 0.5)
			elseif Type == "Normal" then
				local vp = Create("BodyVelocity")({
					P = 500,
					maxForce = Vector3.new(math.huge, 0, math.huge),
					velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05
				})
				if knockback > 0 then
					vp.Parent = hit.Parent.Head
				end
				game:GetService("Debris"):AddItem(vp, 0.5)
			elseif Type == "Up" then
				local bodyVelocity = Create("BodyVelocity")({
					velocity = Vector3.new(0, 20, 0),
					P = 5000,
					maxForce = Vector3.new(8000, 8000, 8000),
					Parent = hit
				})
				game:GetService("Debris"):AddItem(bodyVelocity, 0.5)
				local bodyVelocity = Create("BodyVelocity")({
					velocity = Vector3.new(0, 20, 0),
					P = 5000,
					maxForce = Vector3.new(8000, 8000, 8000),
					Parent = hit
				})
				game:GetService("Debris"):AddItem(bodyVelocity, 1)
			elseif Type == "Leech" then
				local hum = hit.Parent.Humanoid
				if hum ~= nil then
					for i = 0, 2 do
						Effects.Sphere.Create(BrickColor.new("Bright red"), hit.Parent.Torso.CFrame * cn(0, 0, 0) * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 15, 1, 0, 5, 0, 0.02)
					end
					Humanoid.Health = Humanoid.Health + 10
				end
			elseif Type == "UpKnock" then
				local hum = hit.Parent.Humanoid
				hum.PlatformStand = true
				if hum ~= nil then
					hitr = true
				end
				coroutine.resume(coroutine.create(function(HHumanoid)
					swait(5)
					HHumanoid.PlatformStand = false
					hitr = false
				end), hum)
				local bodyVelocity = Create("BodyVelocity")({
					velocity = Vector3.new(0, 20, 0),
					P = 5000,
					maxForce = Vector3.new(8000, 8000, 8000),
					Parent = hit
				})
				game:GetService("Debris"):AddItem(bodyVelocity, 0.5)
				local bodyVelocity = Create("BodyVelocity")({
					velocity = Vector3.new(0, 20, 0),
					P = 5000,
					maxForce = Vector3.new(8000, 8000, 8000),
					Parent = hit
				})
				game:GetService("Debris"):AddItem(bodyVelocity, 1)
			elseif Type == "Snare" then
				local bp = Create("BodyPosition")({
					P = 2000,
					D = 100,
					maxForce = Vector3.new(math.huge, math.huge, math.huge),
					position = hit.Parent.Torso.Position,
					Parent = hit.Parent.Torso
				})
				game:GetService("Debris"):AddItem(bp, 1)
			elseif Type == "Slashnare" then
				Effects.Block.Create(BrickColor.new("Pastel Blue"), hit.Parent.Torso.CFrame * cn(0, 0, 0), 15*4, 15*4, 15*4, 3*4, 3*4, 3*4, 0.07)
				for i = 1, math.random(4, 5) do
					Effects.Sphere.Create(BrickColor.new("Teal"), hit.Parent.Torso.CFrame * cn(math.random(-5, 5), math.random(-5, 5), math.random(-5, 5)) * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 15, 1, 0, 5, 0, 0.02)
				end
				local bp = Create("BodyPosition")({
					P = 2000,
					D = 100,
					maxForce = Vector3.new(math.huge, math.huge, math.huge),
					position = hit.Parent.Torso.Position,
					Parent = hit.Parent.Torso
				})
				game:GetService("Debris"):AddItem(bp, 1)
			elseif Type == "Burn" then

				local humss = hit.Parent:findFirstChildOfClass("Humanoid")
      --[[humss.PlatformStand = true
      coroutine.resume(coroutine.create(function(HHumanoid)
        swait(60)
        HHumanoid.PlatformStand = false
      end), humss)
      local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
      local bodvol = Create("BodyVelocity")({
        velocity = angle * knockback/25,
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      local rl = Create("BodyAngularVelocity")({
        P = 3000,
        maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
        angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodvol, 0.5)
      game:GetService("Debris"):AddItem(rl, 0.5)
]]
				coroutine.resume(coroutine.create(function()
					if hit.Parent:findFirstChild("Torso")then
						local hitoor=hit.Parent:findFirstChild("Torso")
						local da = script.Firey2:Clone()
						da.Parent = hitoor
						da.Enabled = true
						local BURNBABYBURN = Create("Sound"){
							Volume = 1,
							Name = "asdawdwadadw",
							Pitch = 1.2,
							Looped = true,
							SoundId = "rbxassetid://1601946639",
							Parent = hitoor,
						}
						BURNBABYBURN:play()
						for i=1, 2*knockback do
							swait(5)
							humss.Health = humss.Health - .4
						end
						da.Enabled = false
						BURNBABYBURN:Remove()
						game:GetService("Debris"):AddItem(da, 2)
					end
				end))

			elseif Type == "Spike" then
				-- CreateBigIceSword(hit.Parent.Torso.CFrame)
				local bp = Create("BodyPosition")({
					P = 2000,
					D = 100,
					maxForce = Vector3.new(math.huge, math.huge, math.huge),
					position = hit.Parent.Torso.Position,
					Parent = hit.Parent.Torso
				})
				game:GetService("Debris"):AddItem(bp, 1)
			elseif Type == "Freeze" then
				local BodPos = Create("BodyPosition")({
					P = 50000,
					D = 1000,
					maxForce = Vector3.new(math.huge, math.huge, math.huge),
					position = hit.Parent.Torso.Position,
					Parent = hit.Parent.Torso
				})
				local BodGy = Create("BodyGyro")({
					maxTorque = Vector3.new(400000, 400000, 400000) * math.huge,
					P = 20000,
					Parent = hit.Parent.Torso,
					cframe = hit.Parent.Torso.CFrame
				})
				hit.Parent.Torso.Anchored = true
				coroutine.resume(coroutine.create(function(Part)
					swait(1.5)
					Part.Anchored = false
				end), hit.Parent.Torso)
				game:GetService("Debris"):AddItem(BodPos, 3)
				game:GetService("Debris"):AddItem(BodGy, 3)
			end
			local debounce = Create("BoolValue")({
				Name = "DebounceHit",
				Parent = hit.Parent,
				Value = true
			})
			game:GetService("Debris"):AddItem(debounce, Delay)
			c = Instance.new("ObjectValue")
			c.Name = "creator"
			c.Value = Player
			c.Parent = h
			game:GetService("Debris"):AddItem(c, 0.5)
		end
	end
end

function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
	for _, c in pairs(workspace:children()) do
		local hum = c:findFirstChildOfClass("Humanoid")
		if hum ~= nil then
			local head = c:findFirstChild("Head")
			if head ~= nil then
				local targ = head.Position - Part.Position
				local mag = targ.magnitude
				if magni >= mag and c.Name ~= Player.Name then
					Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://231917784", 1)
				end
			end
		end
	end
end

function CreateMesh(parent,meshtype,x1,y1,z1)
	local mesh = Instance.new("SpecialMesh",parent)
	mesh.MeshType = meshtype
	mesh.Scale = Vector3.new(x1*10,y1*10,z1*10)
	return mesh
end

function CreateSpecialMesh(parent,meshid,x1,y1,z1)
	local mesh = Instance.new("SpecialMesh",parent)
	mesh.MeshType = "FileMesh"
	mesh.MeshId = meshid
	mesh.Scale = Vector3.new(x1,y1,z1)
	return mesh
end


function CreateSpecialGlowMesh(parent,meshid,x1,y1,z1)
	local mesh = Instance.new("SpecialMesh",parent)
	mesh.MeshType = "FileMesh"
	mesh.MeshId = meshid
	mesh.TextureId = "http://www.roblox.com/asset/?id=269748808"
	mesh.Scale = Vector3.new(x1,y1,z1)
	mesh.VertexColor = Vector3.new(parent.BrickColor.r, parent.BrickColor.g, parent.BrickColor.b)
	return mesh
end

function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
	local weld = Instance.new("Weld")
	weld.Parent = parent
	weld.Part0 = part0
	weld.Part1 = part1
	weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
	weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
	return weld
end


local m = Instance.new("Model",Character)
--------------
local sorb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
CreateWeld(sorb,RightArm,sorb,0,1,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local sorb2 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
CreateWeld(sorb2,LeftArm,sorb2,0,1,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

--//=================================\\
--|| 	      SOME FUNCTIONS
--\\=================================//



function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end


function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

local function weldBetween(a, b)
	local weldd = Instance.new("ManualWeld")
	weldd.Part0 = a
	weldd.Part1 = b
	weldd.C0 = CFrame.new()
	weldd.C1 = b.CFrame:inverse() * a.CFrame
	weldd.Parent = a
	return weldd
end


function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end

function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end

function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end

function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
	local frame = IT("Frame")
	frame.BackgroundTransparency = TRANSPARENCY
	frame.BorderSizePixel = BORDERSIZEPIXEL
	frame.Position = POSITION
	frame.Size = SIZE
	frame.BackgroundColor3 = COLOR
	frame.BorderColor3 = BORDERCOLOR
	frame.Name = NAME
	frame.Parent = PARENT
	return frame
end

function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
	local label = IT("TextLabel")
	label.BackgroundTransparency = 1
	label.Size = UD2(1, 0, 1, 0)
	label.Position = UD2(0, 0, 0, 0)
	label.TextColor3 = TEXTCOLOR
	label.TextStrokeTransparency = STROKETRANSPARENCY
	label.TextTransparency = TRANSPARENCY
	label.FontSize = TEXTFONTSIZE
	label.Font = TEXTFONT
	label.BorderSizePixel = BORDERSIZEPIXEL
	label.TextScaled = false
	label.Text = TEXT
	label.Name = NAME
	label.Parent = PARENT
	return label
end

function NoOutlines(PART)
	PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
end

function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end

local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function CreateSoundWithEmitter(ID, PARENT, VOLUME, PITCH, EMITTERSIZE, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		if EMITTERSIZE then
			NEWSOUND.EmitterSize = EMITTERSIZE
		else
			NEWSOUND.EmitterSize = 5
		end
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function CFrameFromTopBack(at, top, back)
	local right = top:Cross(back)
	return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end

function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local WAITTOTWEEN = (Table.WaitToTween or 0)
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
	local BOOMERANG = (Table.Boomerang or 0)
	local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Cylinder" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Cylinder", "", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Swirl2" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		elseif TYPE == "Star" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "2546401234", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local BOOMR1 = 1+BOOMERANG/50
			local BOOMR2 = 1+SIZEBOOMERANG/50
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				if USEBOOMERANGMATH == true then
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
				else
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
				end
			end
			local GROWTH = nil
			if USEBOOMERANGMATH == true then
				GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
			else
				GROWTH = (SIZE - ENDSIZE)
			end
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			if USEBOOMERANGMATH == true then
				for LOOP = 1, TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - (VT((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
						EFFECT.Orientation = ORI
					end
				end
			else
				for LOOP = 1, TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
						EFFECT.Orientation = ORI
					end
				end
			end
			EFFECT.Transparency = 1
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		end
	end))
end

function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

Debris = game:GetService("Debris")

function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end

local Beams = New("Model",Effects,"Beams",{})
local fail = false
BeamRing = New("Model",nil,"BeamRing",{})
local Quantumn = New("Model",nil,"Quantumn",{})
local EffectHolder = New("Part",Quantumn,"EffectHolder",{Transparency = 1,Transparency = 1,Size = Vector3.new(0.05, 0.05, 0.05),CFrame = CFrame.new(0, 5.5000329, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,})
EffectHolder.CanCollide = false
Attachment01 = New("Attachment",EffectHolder,"Attachment01",{CFrame = CFrame.new(1.80000019, -1.34110451e-07, -1.80000019, 1, 0, 0, 0, -5.96046377e-08, -1, 0, 1, -5.96046377e-08),})
Attachment02 = New("Attachment",EffectHolder,"Attachment02",{CFrame = CFrame.new(-1.7999866, 4.47034836e-08, 1.80000019, 1, 0, 0, 0, -5.96046377e-08, -1, 0, 1, -5.96046377e-08),})
Attachment03 = New("Attachment",EffectHolder,"Attachment03",{CFrame = CFrame.new(-1.80000007, -1.34110451e-07, -1.80000019, 1, 0, 0, 0, -5.96046377e-08, -1, 0, 1, -5.96046377e-08),})
Attachment04 = New("Attachment",EffectHolder,"Attachment04",{CFrame = CFrame.new(1.80001354, 4.47034836e-08, 1.80000019, 1, 0, 0, 0, -5.96046377e-08, -1, 0, 1, -5.96046377e-08),})
Attachment05 = New("Attachment",EffectHolder,"Attachment05",{CFrame = CFrame.new(2.60000038, -1.34110451e-07, -2.98023224e-08, 1, 0, 0, 0, -5.96046377e-08, -1, 0, 1, -5.96046377e-08),})
Attachment06 = New("Attachment",EffectHolder,"Attachment06",{CFrame = CFrame.new(-2.59998679, 4.47034836e-08, 1.49011612e-08, 1, 0, 0, 0, -5.96046377e-08, -1, 0, 1, -5.96046377e-08),})
Attachment07 = New("Attachment",EffectHolder,"Attachment07",{CFrame = CFrame.new(1.49011612e-08, -1.34110451e-07, -2.60000038, 1, 0, 0, 0, -5.96046377e-08, -1, 0, 1, -5.96046377e-08),})
Attachment08 = New("Attachment",EffectHolder,"Attachment08",{CFrame = CFrame.new(1.34855509e-05, 4.47034836e-08, 2.60000038, 1, 0, 0, 0, -5.96046377e-08, -1, 0, 1, -5.96046377e-08),})
local Beams = New("Model",EffectHolder,"Beams",{})
Beaamstart2 = New("Part",BeamRing,"BeamHolder",{Transparency = 1,Transparency = 1,Size = Vector3.new(0.200000003, 0.200000003, 0.200000003),CFrame = CFrame.new(77.3999939, 5.40723991, 119.900009, 0, 0, -1, 0, -1, 0, -1, 0, 0),Anchored = true,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
Attachment0 = New("Attachment",Beaamstart2,"Attachment0",{CFrame = CFrame.new(0, 0, .75, 1, 0, 0, 0, -1, 0, 0, 0, -1),})
Attachment1 = New("Attachment",Beaamstart2,"Attachment1",{CFrame = CFrame.new(0, 0, -.75, 1, 0, 0, 0, -1, 0, 0, 0, -1),})
Beaamstart2.CanCollide = false
local Beam2 = New("Beam",Beams,"Beam",{Texture = "rbxassetid://457102813",})
Beam2.Parent = BeamRing
Beam2.Width0 = 1.5
Beam2.Width1 = 1.5
Beam2.FaceCamera = false	

Beam2.Transparency = NumberSequence.new(0,0)
Beam2.TextureLength = .05
Beam2.LightEmission = 1
Beam2.CurveSize0 = 1
Beam2.CurveSize1 = -1
Beam2.Attachment0 = Beaamstart2.Attachment0
Beam2.Attachment1 = Beaamstart2.Attachment1
local Beam2 = New("Beam",Beams,"Beam",{Texture = "rbxassetid://457102813",})
Beam2.Parent = BeamRing
Beam2.Width0 = 1.5
Beam2.Width1 = 1.5
Beam2.FaceCamera = false	

Beam2.Transparency = NumberSequence.new(0,0)
Beam2.TextureLength = .05
Beam2.LightEmission = 1
Beam2.CurveSize0 = -1
Beam2.CurveSize1 = 1
Beam2.Attachment0 = Beaamstart2.Attachment0
Beam2.Attachment1 = Beaamstart2.Attachment1
Beam2.TextureSpeed = -1
local badcombo = {{1,7}, {1,5}, {2,8}, {2,6}, {3,7}, {3,6}, {4,5}, {4,8}}
function scan(scannum1,scannum2)
	for i = 1,#badcombo do	
		local comb = badcombo[i]
		if scannum1 == comb[1] and scannum2 == comb[2]then
			fail = true
		end
		if scannum1 == comb[2] and scannum2 == comb[1]then
			fail = true
		end
		--swait()
	end
end

function GatherAllInstances(Parent,ig)
	local Instances = {}
	local Ignore=nil
	if	ig ~= nil then
		Ignore = ig	
	end

	local function GatherInstances(Parent,Ignore)
		for i, v in pairs(Parent:GetChildren()) do

			if v ~= Ignore then
				GatherInstances(v,Ignore)
				table.insert(Instances, v) end
		end
	end
	GatherInstances(Parent,Ignore)
	return Instances
end
coroutine.resume(coroutine.create(function()
	wait(1)
	for i, v2 in pairs(GatherAllInstances(Character)) do
		if v2:IsA("BasePart") then
			v2.Locked = true
		end end
end))

local AttachmentSelect = function(BeamSelect,Value1,Value2)
	local Select1 = 0
	local Select2 = 0
	scan(Value1,Value2)
	if fail == false then 
		if Value1 == 1 then
			Select1=Attachment01
		elseif Value1 == 2 then
			Select1=Attachment02
		elseif Value1 == 3 then
			Select1=Attachment03
		elseif Value1 == 4 then
			Select1=Attachment04
		elseif Value1 == 5 then
			Select1=Attachment05
		elseif Value1 == 6 then
			Select1=Attachment06
		elseif Value1 == 7 then
			Select1=Attachment07
		elseif Value1 == 8 then	
			Select1=Attachment08	
		elseif Value1 == 0 or 9 then
			Select1=nil			
		end
		if Value2 == 1 then
			Select2=Attachment01
		elseif Value2 == 2 then
			Select2=Attachment02
		elseif Value2 == 3 then
			Select2=Attachment03
		elseif Value2 == 4 then
			Select2=Attachment04
		elseif Value2 == 5 then
			Select2=Attachment05
		elseif Value2 == 6 then
			Select2=Attachment06
		elseif Value2 == 7 then
			Select2=Attachment07
		elseif Value2 == 8 then	
			Select2=Attachment08
		elseif Value2 == 0 or 9 then
			Select2=nil			
		end
		BeamSelect.Attachment0 = Select1
		BeamSelect.Attachment1 = Select2
	else
		fail = false	
		BeamSelect:Destroy()
	end
end

local Glow1 = Color3.new(255/255, 184/255, 56/255)
local Glow2 = Color3.new(1,0,0)
for i = 1,8 do
	swait()
	for v = 1,8 do
		--swait()
		if i ~= v then	
			swait()
			local Beam = New("Beam",Beams,"Beam",{Texture = "rbxassetid://1191605952",})
			Beam.Parent = Beams
			Beam.Width0 = .1
			Beam.Width1 = .1
			Beam.FaceCamera = true	
			Beam.Color = ColorSequence.new(Glow1,Glow2)
			Beam.Transparency = NumberSequence.new(0,0)
			Beam.TextureLength = 1
			Beam.LightEmission = 1
			AttachmentSelect(Beam,i,v)	
		end
	end
end

function MakeBeamWaveEffect(QPlayer,BeamColor,CFPos,QLifeTime,NumberV1,NumberV2,Scale1,T1,BSize,MoveCF)
	QStart = 1.6
	coroutine.resume(coroutine.create(function()
		local CQuan = BeamRing:Clone()
		CQuan.Parent = QPlayer
		game:GetService("Debris"):AddItem(CQuan, 20)
		CQuan.BeamHolder.CFrame = CFrame.new(CFPos)

		for i, v in pairs(GatherAllInstances(CQuan)) do
			coroutine.resume(coroutine.create(function()


				coroutine.resume(coroutine.create(function()		
					if v:isA("Beam") then


						v.Color = ColorSequence.new(BeamColor,BeamColor)				



						coroutine.resume(coroutine.create(function()
							local CS0S=v.CurveSize0*Scale1
							local CS1S=v.CurveSize1*Scale1			
							for i = QStart + NumberV1,QStart + (QStart*QLifeTime),NumberV2 do swait()
								v.CurveSize0=CS0S* COS(i)
								v.CurveSize1=CS1S* COS(i)
							end				
						end))			


						for i = 0,QStart*QLifeTime,NumberV2/(1+T1) do swait()


							v.Transparency = NumberSequence.new(i/(QStart*QLifeTime),i/(QStart*QLifeTime))	




							v.Width0 = (1 - i/(QStart*QLifeTime))*BSize
							v.Width1 = (1 - i/(QStart*QLifeTime))*BSize


						end	
						v.Transparency = NumberSequence.new(1,1)
						wait()			
						CQuan:Destroy()			
					end			
				end))		

				coroutine.resume(coroutine.create(function()
					if v:isA("Attachment") then
						local QX = v.CFrame.X*Scale1
						local QY = v.CFrame.Y*Scale1
						local QZ = v.CFrame.Z*Scale1
						v.CFrame = CFrame.new(QX*0 ,QY* 0,QZ*0)		

						for i = QStart + NumberV1,QStart + (QStart*QLifeTime),NumberV2 do swait()
							v.CFrame = CFrame.new(QX* COS(i) ,QY* COS(i),QZ* COS(i))	


						end


					end

				end))

			end))
		end
		local CFPos2 = CFrame.new(CFPos)
		local endloop=false
		while endloop==false do 


			CQuan.BeamHolder.CFrame = Clerp(CQuan.BeamHolder.CFrame,CFPos2*MoveCF	,.1)	



			CFPos2=	CQuan.BeamHolder.CFrame

			swait() 		if CQuan == nil or CQuan.Parent == nil then
				endloop=true
			end		end	end))
end

function createBGCircle(size,parent,color)
	local bgui = Instance.new("BillboardGui",parent)
	bgui.Size = UDim2.new(size, 0, size, 0)
	local imgc = Instance.new("ImageLabel",bgui)
	imgc.BackgroundTransparency = 1
	imgc.ImageTransparency = 0
	imgc.Size = UDim2.new(1,0,1,0)
	imgc.Image = "rbxassetid://997291547" --997291547,521073910
	imgc.ImageColor3 = color
	return bgui,imgc
end

function symbolizeBlink(guipar,size,img,color,bonussize,vol,pit,soundid,spar,rotationenabled,rotsp,delay)
	local bgui,imgc = createBGCircle(size,guipar,color)
	bgui.AlwaysOnTop = true
	imgc.Image = "rbxassetid://" ..img
	local rrot = math.random(1,2)
	CFuncs["Sound"].Create("rbxassetid://" ..soundid, spar, vol,pit)
	coroutine.resume(coroutine.create(function()
		for i = 0, 24*delay do
			Swait()
			if rotationenabled == true then
				if rrot == 1 then
					imgc.Rotation = imgc.Rotation + rotsp
				elseif rrot == 2 then
					imgc.Rotation = imgc.Rotation - rotsp
				end
			end
			bgui.Size = bgui.Size + UDim2.new(1*bonussize/delay,0,1*bonussize/delay,0)
			imgc.ImageTransparency = imgc.ImageTransparency + 0.04/delay
		end
		bgui:Destroy()
	end))
end


function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end

local EyeSizes={
	NumberSequenceKeypoint.new(0,1,0),
	NumberSequenceKeypoint.new(1,0,0)
}
local EyeTrans={
	NumberSequenceKeypoint.new(0,0.8,0),
	NumberSequenceKeypoint.new(1,1,0)
}
local PE=Instance.new("ParticleEmitter",nil)
PE.LightEmission=.8
PE.Color = ColorSequence.new(BRICKC("Really red").Color)
PE.Size=NumberSequence.new(EyeSizes)
PE.Transparency=NumberSequence.new(EyeTrans)
PE.Lifetime=NumberRange.new(0.35,1.5)
PE.Rotation=NumberRange.new(0,360)
PE.Rate=999
PE.VelocitySpread = 10000
PE.Acceleration = Vector3.new(0,0,0)
PE.Drag = 5
PE.Speed = NumberRange.new(0,0,0)
PE.Texture="http://www.roblox.com/asset/?id=1351966707"
PE.ZOffset = -0
PE.Name = "PE"
PE.Enabled = false

function particles(art)
	local PARTICLES = PE:Clone()
	PARTICLES.Parent = art
end

function turnto(position)
	RootPart.CFrame=CFrame.new(RootPart.CFrame.p,VT(position.X,RootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
end

function turnto2(position)
	RootPart.CFrame=CFrame.new(RootPart.CFrame.p,VT(position.X,position.Y,position.Z)) * CFrame.new(0, 0, 0)
end

function CharacterFade(COLOR,TIMER)
	coroutine.resume(coroutine.create(function()
		local FADE = IT("Model",Effects)
		FADE.Name = "FadingEffect"
		for _, c in pairs(Character:GetChildren()) do
			if c.ClassName == "Part" and c ~= RootPart then
				local FADER = c:Clone()
				FADER.Color = COLOR
				FADER.CFrame = c.CFrame
				FADER.Parent = FADE
				FADER.Anchored = true
				FADER.Transparency = 0.25+c.Transparency
				FADER:BreakJoints()
				FADER.Material = "ForceField"
				if FADER.Name == "Head" then
					FADER:ClearAllChildren()
					FADER.Size = VT(1,1,1)
				end
				FADER.CanCollide = false
			end
		end
		local TRANS = 0.75/TIMER
		for i = 1, TIMER do
			Swait()
			for _, c in pairs(FADE:GetChildren()) do
				if c.ClassName == "Part" then
					c.Transparency = c.Transparency + TRANS
				end
			end
		end
		FADE:remove()
	end))
end

function Chunks(PART)
	for i = 1, MRANDOM(3,5) do
		coroutine.resume(coroutine.create(function()
			local CHUNK = CreatePart(3, workspace, PART.Material, 0, PART.Transparency, PART.BrickColor, "Chunk", VT(0.3,0.3,0.3)*MRANDOM(7,13)/10, false)
			CHUNK.CFrame = PART.CFrame*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			local CFRAME = PART.CFrame*CF(MRANDOM(-4,4)/2,MRANDOM(-4,4)/2,-6)
			CHUNK.Velocity = CF(PART.Position,CFRAME.p).lookVector*MRANDOM(15,65)
			wait(0.1)
			CHUNK.CanCollide = true
			wait(MRANDOM(15,25)/5)
			for i = 1, 25 do
				Swait()
				CHUNK.Transparency = CHUNK.Transparency + 1/25
			end
			CHUNK:remove()
		end))
	end
end

function CreateDebreeRing(FLOOR,POSITION,SIZE,BLOCKSIZE,SWAIT)
	if FLOOR ~= nil then
		coroutine.resume(coroutine.create(function()
			local PART = CreatePart(3, Effects, "Plastic", 0, 1, "Pearl", "DebreeCenter", VT(0,0,0))
			PART.CFrame = CF(POSITION)
			for i = 1, 45 do
				local RingPiece = CreatePart(3, Effects, "Plastic", 0, 1, "Pearl", "DebreePart", BLOCKSIZE)
				RingPiece.Material = FLOOR.Material
				RingPiece.Color = FLOOR.Color
				RingPiece.CFrame = PART.CFrame * ANGLES(RAD(0), RAD(i*8), RAD(0)) * CF(SIZE, 0, 0) * ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)))
				coroutine.resume(coroutine.create(function()
					repeat
						RingPiece.Transparency = RingPiece.Transparency - 0.05
						swait()
					until RingPiece.Transparency==1 or RingPiece.Transparency<0.01
					swait(SWAIT)
					repeat
						RingPiece.Transparency = RingPiece.Transparency + 0.01
						swait()
					until RingPiece.Transparency==0 or RingPiece.Transparency>0.99
					Debris:AddItem(RingPiece,1)
				end))
			end
			PART:remove()
		end))
	end
end

function CreateFlyingDebree(FLOOR,POSITION,AMOUNT,BLOCKSIZE,SWAIT,STRENGTH)
	if FLOOR ~= nil then
		for i = 1, AMOUNT do
			local DEBREE = CreatePart(3, Effects, "Neon", FLOOR.Reflectance, FLOOR.Transparency, "Peal", "Debree", BLOCKSIZE, false)
			DEBREE.Material = FLOOR.Material
			DEBREE.Color = FLOOR.Color
			DEBREE.CFrame = POSITION * ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)))
			DEBREE.Velocity = VT(MRANDOM(-STRENGTH,STRENGTH),MRANDOM(-STRENGTH,STRENGTH),MRANDOM(-STRENGTH,STRENGTH))
			coroutine.resume(coroutine.create(function()
				Swait(15)
				DEBREE.Parent = workspace
				DEBREE.CanCollide = true
				Debris:AddItem(DEBREE,SWAIT)
			end))
		end
	end
end

function MagicSphere(SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
	local mesh = IT("SpecialMesh",wave)
	mesh.MeshType = "Sphere"
	mesh.Scale = SIZE
	mesh.Offset = VT(0,0,0)
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.Transparency = wave.Transparency + (1/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end
function LobbingObject(Part,ToLocation,AmountOfTime,Height,DoesCourontine)
	if DoesCourontine == false then
		local Direction = CF(Part.Position,ToLocation)
		local Distance = (Part.Position - ToLocation).magnitude
		for i = 1, AmountOfTime do
			Swait()
			Part.CFrame = Direction*CF(0,(AmountOfTime/200)+((AmountOfTime/Height)-((i*2)/Height)),-Distance/AmountOfTime)
			Direction = Part.CFrame
		end
	elseif DoesCourontine == true then
		coroutine.resume(coroutine.create(function()
			local Direction = CF(Part.Position,ToLocation)
			local Distance = (Part.Position - ToLocation).magnitude
			for i = 1, AmountOfTime do
				Swait()
				Part.CFrame = Direction*CF(0,(AmountOfTime/200)+((AmountOfTime/Height)-((i*2)/Height)),-Distance/AmountOfTime)
				Direction = Part.CFrame
			end
		end))
	end
end

function chatfunc(text)
	local chat = coroutine.wrap(function()
		if Character:FindFirstChild("TalkingBillBoard")~= nil then
			Character:FindFirstChild("TalkingBillBoard"):destroy()
		end
		local Bill = Instance.new("BillboardGui",Character)
		Bill.Size = UDim2.new(0,100,0,40)
		Bill.StudsOffset = Vector3.new(0,3,0)
		Bill.Adornee = Character.Head
		Bill.Name = "TalkingBillBoard"
		local Hehe = Instance.new("TextLabel",Bill)
		Hehe.BackgroundTransparency = 1
		Hehe.BorderSizePixel = 0
		Hehe.Text = ""
		Hehe.Font = "Fantasy"
		Hehe.TextSize = 40
		Hehe.TextStrokeTransparency = 0
		Hehe.Size = UDim2.new(1,0,0.5,0)
		coroutine.resume(coroutine.create(function()
			while Hehe ~= nil do
				swait()	
				Hehe.Position = UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))	
				--Hehe.Rotation = math.random(-5,5)
				Hehe.TextColor3 = Color3.new(27/255,42/255,53/255)
				Hehe.TextStrokeColor3 = Color3.new(0,0,0)
			end
		end))
		for i = 1,string.len(text),1 do
			swait()
			Hehe.Text = string.sub(text,1,i)
		end
		wait(1)--Re[math.random(1, 93)]
		for i = 0, 1, .025 do
			swait()
			Bill.ExtentsOffset = Vector3.new(math.random(-i, i), math.random(-i, i), math.random(-i, i))
			Hehe.TextStrokeTransparency = i
			Hehe.TextTransparency = i
		end
		Bill:Destroy()
	end)
	chat()
end

function onChatted(msg)
	chatfunc(msg)
end

function Tween(object,property,time,easingstyle,easingdirection,repet,reverse,deelay)
	local infos=TweenInfo.new(time,Enum.EasingStyle[easingstyle],Enum.EasingDirection[easingdirection],repet,reverse,deelay)
	local tween=game:GetService('TweenService'):Create(object,infos,property)
	tween:Play()
	return tween
end

--//=================================\\
--||	     WEAPON CREATION
--\\=================================//

MINIGUN = script.Things.Minigun
MINIGUN.Parent = Character
BODY = MINIGUN.Body
hello = BODY.hello
BARREL = MINIGUN.Barrel
SPINJOINT = BODY.Holder.SpinJoint
BODYWELD = CreateWeldOrSnapOrMotor("Weld", RightArm, BODY.Handle, RightArm, CF(0, 0, 0), CF(0, 0, 0))

for i,v in pairs(MINIGUN:GetDescendants()) do
	if v:IsA("BasePart") then
		v.Transparency = 1
	end
end
-- 5154115297

function Align(Part0, Part1, Position, Angle)
	if Part0:FindFirstChild("Attachment") then
		Part0:FindFirstChild("Attachment"):Remove()
	end
    local AlignPosition = Instance.new("AlignPosition",Part0)
    local AlignOrientation = Instance.new("AlignOrientation",Part0)
    
    local Attachment1 = Instance.new("Attachment", Part0)
    local Attachment2 = Instance.new("Attachment", Part1)

    AlignPosition.Attachment0 = Attachment1
    AlignPosition.Attachment1 = Attachment2
    
    AlignOrientation.Attachment0 = Attachment1
    AlignOrientation.Attachment1 = Attachment2
    
    Attachment2.Position = Position or Vector3.new(0,0,0)
    Attachment2.Orientation = Angle or Vector3.new(0,0,0)
    
    AlignOrientation.MaxTorque = math.huge
    AlignOrientation.MaxAngularVelocity = math.huge
    AlignOrientation.PrimaryAxisOnly = false 
    AlignOrientation.Responsiveness = 200
    AlignOrientation.RigidityEnabled = false
    AlignOrientation.ReactionTorqueEnabled = false
    AlignPosition.MaxForce = math.huge
    AlignPosition.MaxVelocity = math.huge
    AlignPosition.ReactionForceEnabled = false
    AlignPosition.Responsiveness = 200
    AlignPosition.ApplyAtCenterOfMass = true
    AlignPosition.RigidityEnabled = true
    game:GetService("RunService").Heartbeat:Connect(function()
        Part0.Velocity = Vector3.new(-29.99,0,0)
    end)
    if Part0.Parent:IsA("Accessory") then
    	Part0:BreakJoints()
    end
end

Align(game.Players.LocalPlayer.Character["Juggernaut's Chaingun"].Handle, BODY.Handle, Vector3.new(-2.35, -0.55, 0), Vector3.new(-0, 90, 0))

BRO=BARREL.MiniBarrel
Fire=BRO.Barrel1.ParticleEmitter 
Fire2=BRO.Barrel2.ParticleEmitter
Fire3=BRO.Barrel3.ParticleEmitter
Fire4=BRO.Barrel4.ParticleEmitter
Fire5=BRO.Barrel5.ParticleEmitter
Fire6=BRO.Barrel6.ParticleEmitter

Humanoid.Died:connect(function()

end)

--//=================================\\
--||	     DAMAGE FUNCTIONS
--\\=================================//

function StatLabel(CFRAME, TEXT, COLOR)
	local STATPART = CreatePart(3, Effects, "SmoothPlastic", 0, 1, "Really black", "Effect", VT())
	STATPART.CFrame = CF(CFRAME.p,CFRAME.p+VT(MRANDOM(-5,5),MRANDOM(0,5),MRANDOM(-5,5)))
	local BODYGYRO = IT("BodyGyro", STATPART)
	game:GetService("Debris"):AddItem(STATPART ,5)
	local BILLBOARDGUI = Instance.new("BillboardGui", STATPART)
	BILLBOARDGUI.Adornee = STATPART
	BILLBOARDGUI.Size = UD2(2.5, 0, 2.5 ,0)
	BILLBOARDGUI.StudsOffset = VT(-2, 2, 0)
	BILLBOARDGUI.AlwaysOnTop = false
	local TEXTLABEL = Instance.new("TextLabel", BILLBOARDGUI)
	TEXTLABEL.BackgroundTransparency = 1
	TEXTLABEL.Size = UD2(2.5, 0, 2.5, 0)
	TEXTLABEL.Text = TEXT
	TEXTLABEL.Font = "Antique"
	TEXTLABEL.FontSize="Size42"
	TEXTLABEL.TextColor3 = COLOR
	TEXTLABEL.TextStrokeTransparency = 0
	TEXTLABEL.TextScaled = true
	TEXTLABEL.TextWrapped = true
	coroutine.resume(coroutine.create(function(THEPART, THEBODYPOSITION, THETEXTLABEL)
		for i = 1, 50 do
			Swait()
			STATPART.CFrame = STATPART.CFrame * CF(0,0,-0.2)
			TEXTLABEL.TextTransparency = TEXTLABEL.TextTransparency + (1/50)
			TEXTLABEL.TextStrokeTransparency = TEXTLABEL.TextTransparency
		end
		THEPART.Parent = nil
	end),STATPART, TEXTLABEL)
end

--//=================================\\
--||			DAMAGING
--\\=================================//

function ApplyDamage(Humanoid,Damage,TorsoPart)

end

function EffectsAoE(POSITION,RANGE,MINDMG,MAXDMG,EFFECTS,TYPES,INSTAKILL)
	local CHILDREN = workspace:GetDescendants()
	local knock=false
	local Poisoning=false
	local Fire=false
	local Durability=0
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local HEAD = CHILD:FindFirstChild("Head")
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if INSTAKILL == true or HUM.MaxHealth > 5000 then
							CHILD:BreakJoints()
						else
							local DMG = MRANDOM(MINDMG,MAXDMG)
							ApplyDamage(HUM,DMG,TORSO)
						end

						if EFFECTS > 0 then
							for _, c in pairs(CHILD:GetChildren()) do
								if c:IsA("BasePart") then
									local bv = Instance.new("BodyVelocity",c) 
									bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									if TYPES=="Fling" then
										bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									elseif TYPES=="Up" then
										bv.maxForce = Vector3.new(0, 1e9, 0)
									elseif TYPES=="UpKnock" then
										knock=true
										bv.maxForce = Vector3.new(0, 1e9, 0)
									elseif TYPES=="Knock" then
										knock=true
										bv.maxForce = Vector3.new(0, 0, 0)
									elseif TYPES=="KnockOut" then
										knock=true
										bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									elseif TYPES=="Poison" then
										Poisoning=true
										bv.maxForce = Vector3.new(0, 0, 0)
									elseif TYPES=="Fire" then
										Fire=true
										bv.maxForce = Vector3.new(0, 0, 0)
									elseif TYPES=="Move" then
										bv.maxForce = Vector3.new(1e9, 0, 1e9)
									end
									if TYPES~="Normal" then
										bv.velocity = CF(POSITION,TORSO.Position).lookVector*EFFECTS
									end
									coroutine.resume(coroutine.create(function()
										if knock==true then
											HUM.PlatformStand = true
											wait(EFFECTS/25)
											if HUM.PlatformStand== true then
												HUM.PlatformStand = false
											end
										end
										if Poisoning==true then
											Durability=1+EFFECTS/1.5
											repeat
												CreateSound(264001217,TORSO,0.01,0.6)
												HUM.Health = HUM.Health - math.random(1/0.9999999,5/4.999999)*EFFECTS/350
												Durability=Durability-1
												HUM.Sit = true
												HUM.Sit = false
												HUM.Jump = true
												HUM.Jump = false
												wait(1)
											until Durability<1 or Durability==0
										end
									end))
									Debris:AddItem(bv,0.05)
								end
							end
						end
					end
				end
			end
		end
	end
end

function KillChildren(v)

end

function ApplyAoE(POSITION,RANGE)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local LISTED = false
			if LISTED == false then
				local HUM = CHILD:FindFirstChildOfClass("Humanoid")
				if HUM then
					local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
					if TORSO then
						if (TORSO.Position - POSITION).Magnitude <= RANGE+TORSO.Size.Magnitude then
							KillChildren(CHILD)
						end
					end
				end
			end
		end
	end
end

function ApplyDamage(Humanoid,Damage,TorsoPart)

end

function ApplyAoE2(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD.Parent ~= Effects then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if INSTAKILL == true then
							CHILD:BreakJoints()
						else
							local DMG = MRANDOM(MINDMG,MAXDMG)
							ApplyDamage(HUM,DMG,TORSO)
						end
						if FLING > 0 then
							for _, c in pairs(CHILD:GetChildren()) do
								if c:IsA("BasePart") then
									local bv = Instance.new("BodyVelocity") 
									bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
									bv.Parent = c
									Debris:AddItem(bv,0.05)
								end
							end
						end
					end
				end
			end
		end
	end
end

--//=================================\\
--||	     RAGDOLL STUFF
--\\=================================//

function recurse(root,callback,i)
	i= i or 0
	for _,v in pairs(root:GetChildren()) do
		i = i + 1
		callback(i,v)

		if #v:GetChildren() > 0 then
			i = recurse(v,callback,i)
		end
	end

	return i
end

function ragdollJoint(character, part0, part1, attachmentName, className, properties)
	attachmentName = attachmentName.."RigAttachment"
	local constraint = Instance.new(className.."Constraint")
	constraint.Attachment0 = part0:FindFirstChild(attachmentName)
	constraint.Attachment1 = part1:FindFirstChild(attachmentName)
	constraint.Name = "RagdollConstraint"..part1.Name

	for _,propertyData in next,properties or {} do
		constraint[propertyData[1]] = propertyData[2]
	end

	constraint.Parent = character
end

function getAttachment0(character, attachmentName)
	for _,child in next,character:GetChildren() do
		local attachment = child:FindFirstChild(attachmentName)
		if attachment then
			return attachment
		end
	end
end

function ArtificialHitbox(Part)
	local HITBOX = CreatePart(3, Part, "Metal", 0, 1, "Really black", "Hitbox", Part.Size/2, false)
	HITBOX.CanCollide = true
	HITBOX.CFrame = Part.CFrame
	weldBetween(Part,HITBOX)
end

function R15Ragdoll(character,KeepArms)
	character:BreakJoints()
	coroutine.resume(coroutine.create(function()
		recurse(character, function(_,v)
			if v:IsA("Attachment") then
				v.Axis = Vector3.new(0, 1, 0)
				v.SecondaryAxis = Vector3.new(0, 0, 1)
				v.Rotation = Vector3.new(0, 0, 0)
			end
		end)
		for _,child in next,character:GetChildren() do
			if child:IsA("Accoutrement") then
				for _,part in next,child:GetChildren() do
					if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
						local attachment1 = part:FindFirstChildOfClass("Attachment")
						local attachment0 = getAttachment0(character,attachment1.Name)
						if attachment0 and attachment1 then
							local constraint = Instance.new("HingeConstraint")
							constraint.Attachment0 = attachment0
							constraint.Attachment1 = attachment1
							constraint.LimitsEnabled = true
							constraint.UpperAngle = 0
							constraint.LowerAngle = 0
							constraint.Parent = character
						end
						ArtificialHitbox(part)
					elseif part.Name == "HumanoidRootPart" then
						part:remove()
					end
				end
			end
		end

		ragdollJoint(character,character.LowerTorso, character.UpperTorso, "Waist", "BallSocket", {
			{"LimitsEnabled",true};
			{"UpperAngle",5};
		})
		if character:FindFirstChild("Head") then
			ragdollJoint(character,character.UpperTorso, character.Head, "Neck", "BallSocket", {
				{"LimitsEnabled",true};
				{"UpperAngle",15};
			})
		end

		local handProperties = {
			{"LimitsEnabled", true};
			{"UpperAngle",0};
			{"LowerAngle",0};
		}
		ragdollJoint(character,character.LeftLowerArm, character.LeftHand, "LeftWrist", "Hinge", handProperties)
		ragdollJoint(character,character.RightLowerArm, character.RightHand, "RightWrist", "Hinge", handProperties)

		local shinProperties = {
			{"LimitsEnabled", true};
			{"UpperAngle", 0};
			{"LowerAngle", -75};
		}
		ragdollJoint(character,character.LeftUpperLeg, character.LeftLowerLeg, "LeftKnee", "Hinge", shinProperties)
		ragdollJoint(character,character.RightUpperLeg, character.RightLowerLeg, "RightKnee", "Hinge", shinProperties)

		local footProperties = {
			{"LimitsEnabled", true};
			{"UpperAngle", 15};
			{"LowerAngle", -45};
		}
		ragdollJoint(character,character.LeftLowerLeg, character.LeftFoot, "LeftAnkle", "Hinge", footProperties)
		ragdollJoint(character,character.RightLowerLeg, character.RightFoot, "RightAnkle", "Hinge", footProperties)
		if KeepArms == true then
			ragdollJoint(character,character.UpperTorso, character.RightUpperArm, "RightShoulder", "BallSocket")
			ragdollJoint(character,character.RightUpperArm, character.RightLowerArm, "RightElbow", "BallSocket")
			ragdollJoint(character,character.UpperTorso, character.LeftUpperArm, "LeftShoulder", "BallSocket")
			ragdollJoint(character,character.LeftUpperArm, character.LeftLowerArm, "LeftElbow", "BallSocket")
		end
		ragdollJoint(character,character.LowerTorso, character.LeftUpperLeg, "LeftHip", "BallSocket")
		ragdollJoint(character,character.LowerTorso, character.RightUpperLeg, "RightHip", "BallSocket")
		Debris:AddItem(character,5)
	end))
end

function Ragdoll(Character2,CharTorso,KeepArms)
	coroutine.resume(coroutine.create(function()
		Character2:BreakJoints()
		local hum = Character2:findFirstChild("Humanoid")
		hum:remove()
		local function Scan(ch)
			local e
			for e = 1,#ch do
				Scan(ch[e]:GetChildren())
				if ch[e].ClassName == "Weld" or ch[e].ClassName == "Motor6D" then
					ch[e]:remove()
				end
			end
		end
		local NEWHUM = IT("Humanoid")
		NEWHUM.Name = "Corpse"
		NEWHUM.Health = 0
		NEWHUM.MaxHealth = 0
		NEWHUM.PlatformStand = true
		NEWHUM.Parent = Character2
		NEWHUM.DisplayDistanceType = "None"

		local ch = Character2:GetChildren()
		local i
		for i = 1,#ch do
			if ch[i].Name == "THandle1" or ch[i].Name == "THandle2" then
				ch[i]:remove()
			end
		end

		local Torso2 = Character2.Torso
		local movevector = Vector3.new()

		if Torso2 then
			movevector = CFrame.new(CharTorso.Position,Torso2.Position).lookVector
			local Head = Character2:FindFirstChild("Head")
			if Head then
				local Neck = Instance.new("Weld")
				Neck.Name = "Neck"
				Neck.Part0 = Torso2
				Neck.Part1 = Head
				Neck.C0 = CFrame.new(0, 1.5, 0)
				Neck.C1 = CFrame.new()
				Neck.Parent = Torso2

			end
			local Limb = Character2:FindFirstChild("Right Arm")
			if Limb and KeepArms == true then

				Limb.CFrame = Torso2.CFrame * CFrame.new(1.5, 0, 0)
				local Joint = Instance.new("Glue")
				Joint.Name = "RightShoulder"
				Joint.Part0 = Torso2
				Joint.Part1 = Limb
				Joint.C0 = CFrame.new(1.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
				Joint.C1 = CFrame.new(-0, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
				Joint.Parent = Torso2

				local B = Instance.new("Part")
				B.TopSurface = 0
				B.BottomSurface = 0
				B.formFactor = "Symmetric"
				B.Size = Vector3.new(1, 1, 1)
				B.Transparency = 1
				B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
				B.Parent = Character2
				local W = Instance.new("Weld")
				W.Part0 = Limb
				W.Part1 = B
				W.C0 = CFrame.new(0, -0.5, 0)
				W.Parent = Limb

			end
			local Limb = Character2:FindFirstChild("Left Arm")
			if Limb and KeepArms == true then

				Limb.CFrame = Torso2.CFrame * CFrame.new(-1.5, 0, 0)
				local Joint = Instance.new("Glue")
				Joint.Name = "LeftShoulder"
				Joint.Part0 = Torso2
				Joint.Part1 = Limb
				Joint.C0 = CFrame.new(-1.5, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
				Joint.C1 = CFrame.new(0, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
				Joint.Parent = Torso2

				local B = Instance.new("Part")
				B.TopSurface = 0
				B.BottomSurface = 0
				B.formFactor = "Symmetric"
				B.Size = Vector3.new(1, 1, 1)
				B.Transparency = 1
				B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
				B.Parent = Character2
				local W = Instance.new("Weld")
				W.Part0 = Limb
				W.Part1 = B
				W.C0 = CFrame.new(0, -0.5, 0)
				W.Parent = Limb

			end
			local Limb = Character2:FindFirstChild("Right Leg")
			if Limb then

				Limb.CFrame = Torso2.CFrame * CFrame.new(0.5, -2, 0)
				local Joint = Instance.new("Glue")
				Joint.Name = "RightHip"
				Joint.Part0 = Torso2
				Joint.Part1 = Limb
				Joint.C0 = CFrame.new(0.5, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
				Joint.C1 = CFrame.new(0, 1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
				Joint.Parent = Torso2

				local B = Instance.new("Part")
				B.TopSurface = 0
				B.BottomSurface = 0
				B.formFactor = "Symmetric"
				B.Size = Vector3.new(1, 1, 1)
				B.Transparency = 1
				B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
				B.Parent = Character2
				local W = Instance.new("Weld")
				W.Part0 = Limb
				W.Part1 = B
				W.C0 = CFrame.new(0, -0.5, 0)
				W.Parent = Limb

			end
			local Limb = Character2:FindFirstChild("Left Leg")
			if Limb then

				Limb.CFrame = Torso2.CFrame * CFrame.new(-0.5, -2, 0)
				local Joint = Instance.new("Glue")
				Joint.Name = "LeftHip"
				Joint.Part0 = Torso2
				Joint.Part1 = Limb
				Joint.C0 = CFrame.new(-0.5, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
				Joint.C1 = CFrame.new(-0, 1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
				Joint.Parent = Torso2

				local B = Instance.new("Part")
				B.TopSurface = 0
				B.BottomSurface = 0
				B.formFactor = "Symmetric"
				B.Size = Vector3.new(1, 1, 1)
				B.Transparency = 1
				B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
				B.Parent = Character2
				local W = Instance.new("Weld")
				W.Part0 = Limb
				W.Part1 = B
				W.C0 = CFrame.new(0, -0.5, 0)
				W.Parent = Limb

			end
			--[
			local Bar = Instance.new("Part")
			Bar.TopSurface = 0
			Bar.BottomSurface = 0
			Bar.formFactor = "Symmetric"
			Bar.Size = Vector3.new(1, 1, 1)
			Bar.Transparency = 1
			Bar.CFrame = Torso2.CFrame * CFrame.new(0, 0.5, 0)
			Bar.Parent = Character2
			local Weld = Instance.new("Weld")
			Weld.Part0 = Torso2
			Weld.Part1 = Bar
			Weld.C0 = CFrame.new(0, 0.5, 0)
			Weld.Parent = Torso2
			--]]
		end
		Character2.Parent = workspace
		Debris:AddItem(Character2,5)

		return Character2,Torso2
	end))
end

--//=================================\\
--||	ATTACK FUNCTIONS AND STUFF
--\\=================================//


function StartShake(Settings)

end


function CameraEnshaking(TIMER,SHAKE)
	
end

function printbye(Name)
	local MESSAGES = {"You cannot struggle, ","Your existance is an insult, ","Fade, ","Your existance is not desired, ","You are not permitted here, ","You are not to decide your fate, ","Be gone, ","You are already dead, ","Your live is an anomaly, ","Don't dare to return, ","Why are you resisting, ","You cannot exist here, ","Why are you struggling, ","Your fate was already decided, ","Goodbye, ","You cannot ignore my command, ","You cannot resist my command, ","You already died, "}
	warn(MESSAGES[MRANDOM(1,#MESSAGES)]..Name..".")	
end

local TOBANISH = {}

workspace.ChildAdded:connect(function(instance)

end)

function ApplyDamage(Humanoid,Damage,OneShot)
	
end


function Banish(Foe)

end

function ApplyAoE(POSITION,RANGE,ISBANISH)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if ISBANISH == true then
							Banish(CHILD)
						else
							if ISBANISH == "Gravity" then
								HUM.PlatformStand = true
								if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
									local grav = Instance.new("BodyPosition",TORSO)
									grav.D = 15
									grav.P = 20000
									grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
									grav.position = TORSO.Position
									grav.Name = "V3BanishForce"..Player.Name
								else
									TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
									TORSO.RotVelocity = VT(MRANDOM(-2,2),MRANDOM(-2,2),MRANDOM(-2,2))
								end
							else
								HUM.PlatformStand = false
							end
						end
					elseif ISBANISH == "Gravity" then
						if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
							TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
							HUM.PlatformStand = false
						end
					end
				end
			end
		end
	end
end

SSExit = New("Part",hello,"SSExit",{Transparency = 1,Transparency = 1,Size = Vector3.new(0.0, 0.0, 0.299999803),CFrame = CFrame.new(0.0000076, 0.67517471, 0.1282616, 0, 0, 0, -0.173647001, 0.984807968, 0, -0.984807968, -0.173647001, 0),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
Weld = New("ManualWeld",SSExit,"Weld",{Part0 = SSExit,Part1 = hello,C0 = CFrame.new(0, 0, 0, 0, 0, 0.5, 0, 0.984807968, -0.173647001, 1, 0, 0),C1 = CFrame.new(-0.567811257, 0.3, 0.299995422, 0, -0.173647001, -0.984807968, 0, 0.984807968, -0.173647001, 1, 0, 0),})

EffectModel = Create("Model"){
	Parent = Character,
	Name = "Effects",
}

MOUSEHOLD = false



SHOOTSOUND = Instance.new("Sound", BRO)
SHOOTSOUND.Volume = 5
SHOOTSOUND.Looped = true
SHOOTSOUND.SoundId = "rbxassetid://146830885"

SPINSOUND = Instance.new("Sound", BRO)
SPINSOUND.Volume = 2.5
SPINSOUND.Looped = true
SPINSOUND.SoundId = "rbxassetid://2028334518"


function whenthemewhen()
	CreateSound(4473138327,Torso,3,1,false)
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		BODYWELD.C0 = CF(0,0.5,0.3) * ANGLES(RAD(0), RAD(90), RAD(0))
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(40)), 0.2 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.4, 0) * ANGLES(RAD(-17), RAD(40), RAD(0)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.1, 0 + 0.1 * COS(SINE / 35)) * ANGLES(RAD(0), RAD(0), RAD(-40)), 0.2 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.3, 0.3, -0.8) * ANGLES(RAD(100), RAD(-70), RAD(30)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.1 * COS(SINE / 35), -0.01) * ANGLES(RAD(0), RAD(87), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.1 * COS(SINE / 35), -0.01) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.2 / Animation_Speed)
	end
	repeat
		StartShake({
			Duration=.1;
			Intensity=2;
			Position=Vector3.new(.1,.1,.1);
			Rotation=Vector3.new(.2,.2,.2);
		})
		for i=0, 0.5, 0.1 / Animation_Speed do
			Swait()
			BODYWELD.C0 = CF(0,0.5,0.3) * ANGLES(RAD(0), RAD(90), RAD(0))
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(40)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.4, 0) * ANGLES(RAD(-17), RAD(40), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.1, 0 + 0.1 * COS(SINE / 35)) * ANGLES(RAD(0), RAD(0), RAD(-40)), 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.3, 0.3, -0.8) * ANGLES(RAD(100), RAD(-70), RAD(30)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.1 * COS(SINE / 35), -0.01) * ANGLES(RAD(0), RAD(87), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.1 * COS(SINE / 35), -0.01) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			Fire3.Enabled=true
			Fire4.Enabled=true
			Fire5.Enabled=true
			Fire6.Enabled=true
			SPINNING = true
			SHOOTSOUND:Resume()
			SPINSOUND:Resume()
			turnto(Mouse.Hit.Position)
			local RANDOM = MRANDOM(1, 2)
			if RANDOM == 1 then
				Fire:Emit(5)
				local POS1 = CF(Fire.Parent.WorldPosition,Mouse.Hit.p)*CF(0,0,-45).p
				local AIMPOS = CF(Fire.Parent.WorldPosition,POS1) * CF(0,0,-45) * ANGLES(RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)))*CF(0,0,MRANDOM(5,75)/10).p
				local HIT,POS = CastProperRay(Fire.Parent.WorldPosition,AIMPOS,1000,Character)
				local DISTANCE = (POS - Fire.Parent.WorldPosition).Magnitude
				if HIT ~= nil then
					if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
						Banish(HIT.Parent)
					end
				end
				WACKYEFFECT({Time = 5, EffectType = "Box", Size = VT(0.1,0.1,DISTANCE), Size2 = VT(0.05,0.05,DISTANCE), Transparency = 0, Transparency2 = 1, CFrame = CF(Fire.Parent.WorldPosition,POS)*CF(0,0,-DISTANCE/2), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BRICKC"Really red".Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			elseif RANDOM == 2 then
				Fire2:Emit(5)
				local POS1 = CF(Fire2.Parent.WorldPosition,Mouse.Hit.p)*CF(0,0,-45).p
				local AIMPOS = CF(Fire2.Parent.WorldPosition,POS1) * CF(0,0,-45) * ANGLES(RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)))*CF(0,0,MRANDOM(5,75)/10).p
				local HIT,POS = CastProperRay(Fire2.Parent.WorldPosition,AIMPOS,1000,Character)
				local DISTANCE = (POS - Fire2.Parent.WorldPosition).Magnitude
				if HIT ~= nil then
					if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
						Banish(HIT.Parent)
					end
				end
				WACKYEFFECT({Time = 5, EffectType = "Box", Size = VT(0.1,0.1,DISTANCE), Size2 = VT(0.05,0.05,DISTANCE), Transparency = 0, Transparency2 = 1, CFrame = CF(Fire2.Parent.WorldPosition,POS)*CF(0,0,-DISTANCE/2), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BRICKC"Really red".Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			elseif RANDOM == 3 then
				Fire3:Emit(5)
				local POS1 = CF(Fire3.Parent.WorldPosition,Mouse.Hit.p)*CF(0,0,-45).p
				local AIMPOS = CF(Fire3.Parent.WorldPosition,POS1) * CF(0,0,-45) * ANGLES(RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)))*CF(0,0,MRANDOM(5,75)/10).p
				local HIT,POS = CastProperRay(Fire3.Parent.WorldPosition,AIMPOS,1000,Character)
				local DISTANCE = (POS - Fire3.Parent.WorldPosition).Magnitude
				if HIT ~= nil then
					if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
						Banish(HIT.Parent)
					end
				end
				WACKYEFFECT({Time = 5, EffectType = "Box", Size = VT(0.1,0.1,DISTANCE), Size2 = VT(0.05,0.05,DISTANCE), Transparency = 0, Transparency2 = 1, CFrame = CF(Fire3.Parent.WorldPosition,POS)*CF(0,0,-DISTANCE/2), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BRICKC"Really red".Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			elseif RANDOM == 4 then
				Fire4:Emit(5)
				local POS1 = CF(Fire4.Parent.WorldPosition,Mouse.Hit.p)*CF(0,0,-45).p
				local AIMPOS = CF(Fire4.Parent.WorldPosition,POS1) * CF(0,0,-45) * ANGLES(RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)))*CF(0,0,MRANDOM(5,75)/10).p
				local HIT,POS = CastProperRay(Fire4.Parent.WorldPosition,AIMPOS,1000,Character)
				local DISTANCE = (POS - Fire4.Parent.WorldPosition).Magnitude
				if HIT ~= nil then
					if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
						Banish(HIT.Parent)
					end
				end
				WACKYEFFECT({Time = 5, EffectType = "Box", Size = VT(0.1,0.1,DISTANCE), Size2 = VT(0.05,0.05,DISTANCE), Transparency = 0, Transparency2 = 1, CFrame = CF(Fire4.Parent.WorldPosition,POS)*CF(0,0,-DISTANCE/2), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BRICKC"Really red".Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			elseif RANDOM == 5 then
				Fire5:Emit(5)
				local POS1 = CF(Fire5.Parent.WorldPosition,Mouse.Hit.p)*CF(0,0,-45).p
				local AIMPOS = CF(Fire5.Parent.WorldPosition,POS1) * CF(0,0,-45) * ANGLES(RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)))*CF(0,0,MRANDOM(5,75)/10).p
				local HIT,POS = CastProperRay(Fire5.Parent.WorldPosition,AIMPOS,1000,Character)
				local DISTANCE = (POS - Fire5.Parent.WorldPosition).Magnitude
				if HIT ~= nil then
					if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
						Banish(HIT.Parent)
					end
				end
				WACKYEFFECT({Time = 5, EffectType = "Box", Size = VT(0.1,0.1,DISTANCE), Size2 = VT(0.05,0.05,DISTANCE), Transparency = 0, Transparency2 = 1, CFrame = CF(Fire5.Parent.WorldPosition,POS)*CF(0,0,-DISTANCE/2), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BRICKC"Really red".Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			elseif RANDOM == 6 then
				Fire6:Emit(5)
				local POS1 = CF(Fire6.Parent.WorldPosition,Mouse.Hit.p)*CF(0,0,-45).p
				local AIMPOS = CF(Fire6.Parent.WorldPosition,POS1) * CF(0,0,-45) * ANGLES(RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)))*CF(0,0,MRANDOM(5,75)/10).p
				local HIT,POS = CastProperRay(Fire6.Parent.WorldPosition,AIMPOS,1000,Character)
				local DISTANCE = (POS - Fire6.Parent.WorldPosition).Magnitude
				if HIT ~= nil then
					if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
						Banish(HIT.Parent)
					end
				end
				WACKYEFFECT({Time = 5, EffectType = "Box", Size = VT(0.1,0.1,DISTANCE), Size2 = VT(0.05,0.05,DISTANCE), Transparency = 0, Transparency2 = 1, CFrame = CF(Fire6.Parent.WorldPosition,POS)*CF(0,0,-DISTANCE/2), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BRICKC"Really red".Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			end
		end
	until MOUSEHOLD == false
	Fire3.Enabled=false
	Fire4.Enabled=false
	Fire5.Enabled=false
	Fire6.Enabled=false
	CreateSound(4498806901,Head,6,1,false)
	CreateSound(4473119880,Torso,3,1,false)
	SHOOTSOUND:Stop()
	SPINSOUND:Stop()
	SPINNING = false
end

--//=================================\\
--||	  ASSIGN THINGS TO KEYS
--\\=================================//
local sec=0
local sec1=0

SPINNING = false

function MouseDown(Mouse)
	MOUSEHOLD = true
	if ATTACK==false then
		whenthemewhen()
	end
end

function MouseUp(Mouse)
	MOUSEHOLD = false
end

function KeyDown(Key)
	if Key ~= "w" and Key ~= "a" and Key ~= "s" and Key ~= "d" then
		KEYHOLD = true
		if Key == "q" and ATTACK == false then
		elseif Key == "l" and muting==false then
			muting=true
		elseif Key == "l" and muting==true then
			muting=false
		end
	end
end

function KeyUp(Key)
	if Key ~= "w" and Key ~= "a" and Key ~= "s" and Key ~= "d" then
		KEYHOLD = false
	end
end

Mouse = Player:GetMouse()

Mouse.Button1Down:connect(function(NEWKEY)
	MouseDown(NEWKEY)
end)
Mouse.Button1Up:connect(function(NEWKEY)
	MouseUp(NEWKEY)
end)
Mouse.KeyDown:connect(function(NEWKEY)
	KeyDown(NEWKEY)
end)
Mouse.KeyUp:connect(function(NEWKEY)
	KeyUp(NEWKEY)
end)

--//=================================\\
--\\=================================//


--//=================================\\
--||	WRAP THE WHOLE SCRIPT UP
--\\=================================//

Humanoid.Changed:connect(function(Jump)
	if Jump == "Jump" and (Disable_Jump == true) then
		Humanoid.Jump = false
	end
end)

local Blocc = CreatePart(0,RightArm,"Neon",1,1,BrickColor.Random(),"aa",VT(0.005,0.005,0.005),false)
local BW = CreateWeldOrSnapOrMotor("Weld",RightArm,RightArm,Blocc,CF(0,-2,0),CF(0,0,0))

local BLINKLOOP = 0
ANIMATE.Parent = nil

local bguis = Instance.new("BillboardGui",Torso)
bguis.Size = UDim2.new(25, 0, 25, 0)
local imgca = Instance.new("ImageLabel",bguis)
imgca.BackgroundTransparency = 1
imgca.ImageTransparency = 1
imgca.Size = UDim2.new(3,0,3,0)
imgca.Image = "rbxassetid://0"
imgca.ImageColor3 = Color3.new(0,0,0)
local EFFECTPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)

local infrotate = 0.1

ROTATE = 0

game:GetService"RunService".RenderStepped:Connect(function()
	ROTATE = ROTATE + 25
	if SPINNING == true then
		Tween(SPINJOINT, {C0 = ANGLES(RAD(ROTATE), 0, 0)}, .1, "Linear", "Out", 0, false, 0)
		coroutine.resume(coroutine.create(function()
			local hitm = script.Things.Shell:Clone()
			hitm.Parent = EffectModel
			hitm.CFrame = SSExit.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)),math.rad(math.random(-360, 360)),math.rad(math.random(-360, 360)))
			hitm.Velocity = RootPart.CFrame.rightVector*30+Vector3.new(MRANDOM(-5, 5),15,MRANDOM(-5, 5))
			wait(1)
			for i = 0,1,.1 do
				swait()
				hitm.Transparency = i
			end
			hitm:Destroy()
		end))
	elseif SPINNING == false then
		Tween(SPINJOINT, {C0 = ANGLES(0, 0, 0)}, 1.2, "Linear", "Out", 0, false, 0)
	end
end)

while true do
	Swait()
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
		v:Stop();
	end
	ANIMATE.Parent = nil
	SINE = SINE + CHANGE*2
	local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
	local TORSOVERTICALVELOCITY = RootPart.Velocity.y
	local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
	local WALKSPEEDVALUE = 12 / (Humanoid.WalkSpeed / 16)
	if FULL == false then
		if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
			ANIM = "Jump"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), .5 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1) - 1)) * ANGLES(RAD(-20), RAD(0), RAD(0)), .5 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0.2) * ANGLES(RAD(-20), RAD(0), RAD(-15)) * RIGHTSHOULDERC0, .5 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0.2) * ANGLES(RAD(-20), RAD(0), RAD(15)) * LEFTSHOULDERC0, .5 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -.5, -0.5) * ANGLES(RAD(-15), RAD(80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), .5 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(-10), RAD(-80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), .5 / Animation_Speed)
			end
		elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
			ANIM = 'Fall'
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(15), RAD(0), RAD(0)), .5 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), .5 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-10), RAD(0), RAD(25)) * RIGHTSHOULDERC0, .5 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-10), RAD(0), RAD(-25)) * LEFTSHOULDERC0, .5 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -.5, -0.5) * ANGLES(RAD(-15), RAD(80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), .5 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(-10), RAD(-80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), .5 / Animation_Speed)
			end
		elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
			ANIM = "Idle"
			if ATTACK == false then
				BODYWELD.C0 = CF(0,0.5,0.3) * ANGLES(RAD(0), RAD(90), RAD(0))
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 5.5* SIN(SINE / 60)), RAD(10), RAD(40)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.4, 0) * ANGLES(RAD(30), RAD(40), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.1, 0 + 0.05 * COS(SINE / 60)) * ANGLES(RAD(-10), RAD(10), RAD(-40)), 0.5 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.3, 0.3, -0.8) * ANGLES(RAD(150), RAD(-70), RAD(40)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 60), -0.01) * ANGLES(RAD(-20), RAD(87), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 60), -0.01) * ANGLES(RAD(-12), RAD(-75), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			end
		elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
			ANIM = "Walk"
			if ATTACK == false then
				local Testwalk1 = Humanoid.MoveDirection*Torso.CFrame.LookVector
				local Testwalk2 = Humanoid.MoveDirection*Torso.CFrame.RightVector
				LOOKVEC = Testwalk1.X+Testwalk1.Z
				RIGHTVEC = Testwalk2.X+Testwalk2.Z
				local RIGHTHIPSECOND = CF(LOOKVEC/10 * COS(SINE / 18),0,0)*ANGLES(SIN(RIGHTVEC/5) * COS(SINE / 18),0,SIN(-LOOKVEC/2) * COS(SINE / 18))
				local LEFTHIPSECOND = CF(-LOOKVEC/10 * COS(SINE / 18),0,0)*ANGLES(SIN(RIGHTVEC/5) * COS(SINE / 18),0,SIN(-LOOKVEC/2) * COS(SINE / 18))
				BODYWELD.C0 = CF(0,0.5,0.3) * ANGLES(RAD(0), RAD(90), RAD(0))
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.4, 0) * ANGLES(RAD(30), RAD(40), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2* SIN(SINE / 10)), RAD(0), RAD(40)), 0.8 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.3, 0.3, -0.8) * ANGLES(RAD(150), RAD(-70), RAD(40)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.1 , -0.185 + 0.055 * COS(SINE / 10) + -SIN(SINE / 10) / 8) * ANGLES(RAD((LOOKVEC  - LOOKVEC/5  * COS(SINE / 10))*10), RAD((-RIGHTVEC - -RIGHTVEC/5  * COS(SINE / 10))*5) , RAD(-40)), 0.8 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1+ 0.2 * SIN(SINE / 18), -0.5)* ANGLES(RAD(0),RAD(120),RAD(0))*RIGHTHIPSECOND*ANGLES(RAD(0),RAD(0),RAD(0 - 5 * COS(SINE / 18))), 0.8 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1.3, -0.8- 0.2 * SIN(SINE / 18), -.05)* ANGLES(RAD(0),RAD(-50),RAD(0))*LEFTHIPSECOND*ANGLES(RAD(-5),RAD(0),RAD(0 - 5 * COS(SINE / 18))), 0.8 / Animation_Speed)
			end
		end
	end
	Humanoid.MaxHealth = 666666
	Humanoid.Health = 666666
	if Rooted == false then
		Disable_Jump = false
		Humanoid.JumpPower = 0
		Humanoid.WalkSpeed = Speed
	elseif Rooted == true then
		Disable_Jump = true
		Humanoid.WalkSpeed = 0
	end
	sick.SoundId = "rbxassetid://1138145518" --song here
	sick.Looped = true
	sick.Pitch = PITCH
	sick.Volume = VOLUME
	sick.Playing = true
	sick.EmitterSize = 25
	if sick.Parent ~= Torso then
		print("Fixing music")
		sick = IT("Sound", Torso)
		sick.SoundId = "rbxassetid://1138145518" --song here
		sick.Looped = true
		sick.Pitch = PITCH
		sick.Volume = VOLUME
		sick.Playing = true
		sick.EmitterSize = 25
		sick.TimePosition = TIMESTAMP
		FIXING = true
	elseif FIXING == false then
		TIMESTAMP = sick.TimePosition
	else
		FIXING = false
	end
	if muting==false then
		sick.Volume = VOLUME
	else
		sick.Volume = 0
	end
	Humanoid.DisplayDistanceType = "None"
	Humanoid.PlatformStand = false
	Humanoid.Sit = false
end
--//=================================\\
--\\=================================//





--//====================================================\\--
--||			  		 END OF SCRIPT
--\\====================================================//--
end)

Section1:CreateButton("Orange Justice", function()
			local playanother = false
local playing = false
local rtrnv;
local c;
local tbl3;
local v;
local anim;
local count;
local hhhh;
local asdf;
local s;
local animid;
local plr;
local char;
local cframe;
local torso;
local rs;
local ls;
local rh;
local lh;
local n;
local rj;
local rsc0;
local lsc0;
local rhc0;
local lhc0;
local rjc0;
local nc0;
local gc0;
local orsc0;
local olsc0;
local orhc0;
local olhc0;
local orjc0;
local onc0;
local count2;
local maxcount2;

local function getnext(tbl,number)
	c=100
	rtrnv=0
	for i,v in pairs(tbl) do
		if i>number and i-number<c then
			c=i-number
			rtrnv=i
		end
	end
	return(rtrnv)
end
local function wait2(tim)
	if tim<0.1 then
		game:GetService("RunService").Heartbeat:Wait()
	else
		for i=1,tim*40 do
			game:GetService("RunService").Heartbeat:Wait()
		end
	end
end
local function kftotbl(kf) -- Below this is literal pain..
	tbl3 = {}
	for i,v in pairs(kf:GetDescendants()) do
		if v:IsA("Pose") then
			tbl3[string.sub(v.Name,1,1)..string.sub(v.Name,#v.Name,#v.Name)] = v.CFrame
		end
	end
	return(tbl3)
end
        if playanother == true then
				playanother = false
			end
			playing = true
			if workspace.Camera.CameraSubject.Parent:FindFirstChild("Sound") then
				workspace.Camera.CameraSubject.Parent:FindFirstChild("Sound"):Remove()
		end
			s = Instance.new("Sound", workspace.Camera.CameraSubject.Parent)

				s.SoundId = "rbxassetid://2217052122"

			s.Looped = true
			s.Playing = true
			wait(.1) -- Do not change because changing it will break.
			animid="rbxassetid://3262592866"
			plr = game.Players.LocalPlayer
			char = workspace.Camera.CameraSubject.Parent
			cframe = char.HumanoidRootPart.CFrame
			torso = char.Torso
			-----------------------------------------------------------
			rs = torso["Right Shoulder"] -- Just took this from another script(Faster).
			ls = torso["Left Shoulder"]
			rh = torso["Right Hip"]
			lh = torso["Left Hip"]
			n = torso["Neck"]
			rj = char.HumanoidRootPart["RootJoint"]
			rsc0 = rs.C0
			lsc0 = ls.C0
			rhc0 = rh.C0
			lhc0 = lh.C0
			rjc0 = rj.C0
			nc0 = n.C0
			gc0 = CFrame.new()
			orsc0 = rs.C0
			olsc0 = ls.C0
			orhc0 = rh.C0
			olhc0 = lh.C0
			orjc0 = rj.C0
			onc0 = n.C0
			count2 = 100
			maxcount2=100
			-----------------------------------------------------------
			game:GetService("RunService").Heartbeat:Connect(function() -- Speed.
				if playanother == true then
					return nil
				else
					count2 = count2+1
					if count2<=maxcount2 then
						rs.Transform=rs.Transform:Lerp(rsc0,count2/maxcount2)
						ls.Transform=ls.Transform:Lerp(lsc0,count2/maxcount2)
						rh.Transform=rh.Transform:Lerp(rhc0,count2/maxcount2)
						lh.Transform=lh.Transform:Lerp(lhc0,count2/maxcount2)
						n.Transform=n.Transform:Lerp(nc0,count2/maxcount2)
						rj.Transform=rj.Transform:Lerp(rjc0,count2/maxcount2)
					end
				end
			end)
			-----------------------------------------------------------
			animid=game:GetObjects(animid)[1]
			anim={}
			for i,v in pairs(animid:GetChildren()) do
				if v:IsA("Keyframe") then
					anim[v.Time]=kftotbl(v)
				end
			end

			count = 0
			char=workspace.Camera.CameraSubject.Parent
			hhhh=char.Humanoid.Animator
			hhhh.Parent = nil
			for _,v in pairs(char.Humanoid:GetPlayingAnimationTracks()) do
				v:Stop()
			end

			plr.CharacterRemoving:Connect(function()
				if playing == true then
					playing = false
				end
			end)

			while wait() do
				if playanother == true then
					break
				else
					for i,oasjdadlasdkadkldjkl in pairs(anim) do
						asdf=getnext(anim,count)
						v=anim[asdf]
						if v["Lg"] then
							lhc0 = v["Lg"]
						end
						if v["Rg"] then
							rhc0 = v["Rg"]
						end
						if v["Lm"] then
							lsc0 = v["Lm"]
						end
						if v["Rm"] then
							rsc0 = v["Rm"]
						end
						if v["To"] then
							rjc0 = v["To"]
						end
						if v["Hd"] then
							nc0 = v["Hd"]
						end
						count2=0
						maxcount2=asdf-count
						count=asdf
						wait(asdf-count)
						count2=maxcount2
						if v["Lg"] then
							char.Torso["Left Hip"].Transform = v["Lg"]
						end
						if v["Rg"] then
							char.Torso["Right Hip"].Transform = v["Rg"]
						end
						if v["Lm"] then
							char.Torso["Left Shoulder"].Transform = v["Lm"]
						end
						if v["Rm"] then
							char.Torso["Right Shoulder"].Transform = v["Rm"]
						end
						if v["To"] then
							char.HumanoidRootPart["RootJoint"].Transform = v["To"]
						end
						if v["Hd"] then
							char.Torso["Neck"].Transform = v["Hd"]
						end
					end
				end
			end
		--end)
end)

Section1:CreateButton("Thriller", function()
			local playanother = false
local playing = false
local rtrnv;
local c;
local tbl3;
local v;
local anim;
local count;
local hhhh;
local asdf;
local s;
local animid;
local plr;
local char;
local cframe;
local torso;
local rs;
local ls;
local rh;
local lh;
local n;
local rj;
local rsc0;
local lsc0;
local rhc0;
local lhc0;
local rjc0;
local nc0;
local gc0;
local orsc0;
local olsc0;
local orhc0;
local olhc0;
local orjc0;
local onc0;
local count2;
local maxcount2;

local function getnext(tbl,number)
	c=100
	rtrnv=0
	for i,v in pairs(tbl) do
		if i>number and i-number<c then
			c=i-number
			rtrnv=i
		end
	end
	return(rtrnv)
end
local function wait2(tim)
	if tim<0.1 then
		game:GetService("RunService").Heartbeat:Wait()
	else
		for i=1,tim*40 do
			game:GetService("RunService").Heartbeat:Wait()
		end
	end
end
local function kftotbl(kf) -- Below this is literal pain..
	tbl3 = {}
	for i,v in pairs(kf:GetDescendants()) do
		if v:IsA("Pose") then
			tbl3[string.sub(v.Name,1,1)..string.sub(v.Name,#v.Name,#v.Name)] = v.CFrame
		end
	end
	return(tbl3)
end
        if playanother == true then
				playanother = false
			end
			playing = true
			if workspace.Camera.CameraSubject.Parent:FindFirstChild("Sound") then
				workspace.Camera.CameraSubject.Parent:FindFirstChild("Sound"):Remove()
		end
			s = Instance.new("Sound", workspace.Camera.CameraSubject.Parent)

				s.SoundId = "rbxassetid://4517511508"

			s.Looped = true
			s.Playing = true
			wait(.1) -- Do not change because changing it will break.
			animid="rbxassetid://4699820365"
			plr = game.Players.LocalPlayer
			char = workspace.Camera.CameraSubject.Parent
			cframe = char.HumanoidRootPart.CFrame
			torso = char.Torso
			-----------------------------------------------------------
			rs = torso["Right Shoulder"] -- Just took this from another script(Faster).
			ls = torso["Left Shoulder"]
			rh = torso["Right Hip"]
			lh = torso["Left Hip"]
			n = torso["Neck"]
			rj = char.HumanoidRootPart["RootJoint"]
			rsc0 = rs.C0
			lsc0 = ls.C0
			rhc0 = rh.C0
			lhc0 = lh.C0
			rjc0 = rj.C0
			nc0 = n.C0
			gc0 = CFrame.new()
			orsc0 = rs.C0
			olsc0 = ls.C0
			orhc0 = rh.C0
			olhc0 = lh.C0
			orjc0 = rj.C0
			onc0 = n.C0
			count2 = 100
			maxcount2=100
			-----------------------------------------------------------
			game:GetService("RunService").Heartbeat:Connect(function() -- Speed.
				if playanother == true then
					return nil
				else
					count2 = count2+1
					if count2<=maxcount2 then
						rs.Transform=rs.Transform:Lerp(rsc0,count2/maxcount2)
						ls.Transform=ls.Transform:Lerp(lsc0,count2/maxcount2)
						rh.Transform=rh.Transform:Lerp(rhc0,count2/maxcount2)
						lh.Transform=lh.Transform:Lerp(lhc0,count2/maxcount2)
						n.Transform=n.Transform:Lerp(nc0,count2/maxcount2)
						rj.Transform=rj.Transform:Lerp(rjc0,count2/maxcount2)
					end
				end
			end)
			-----------------------------------------------------------
			animid=game:GetObjects(animid)[1]
			anim={}
			for i,v in pairs(animid:GetChildren()) do
				if v:IsA("Keyframe") then
					anim[v.Time]=kftotbl(v)
				end
			end

			count = 0
			char=workspace.Camera.CameraSubject.Parent
			hhhh=char.Humanoid.Animator
			hhhh.Parent = nil
			for _,v in pairs(char.Humanoid:GetPlayingAnimationTracks()) do
				v:Stop()
			end

			plr.CharacterRemoving:Connect(function()
				if playing == true then
					playing = false
				end
			end)

			while wait() do
				if playanother == true then
					break
				else
					for i,oasjdadlasdkadkldjkl in pairs(anim) do
						asdf=getnext(anim,count)
						v=anim[asdf]
						if v["Lg"] then
							lhc0 = v["Lg"]
						end
						if v["Rg"] then
							rhc0 = v["Rg"]
						end
						if v["Lm"] then
							lsc0 = v["Lm"]
						end
						if v["Rm"] then
							rsc0 = v["Rm"]
						end
						if v["To"] then
							rjc0 = v["To"]
						end
						if v["Hd"] then
							nc0 = v["Hd"]
						end
						count2=0
						maxcount2=asdf-count
						count=asdf
						wait(asdf-count)
						count2=maxcount2
						if v["Lg"] then
							char.Torso["Left Hip"].Transform = v["Lg"]
						end
						if v["Rg"] then
							char.Torso["Right Hip"].Transform = v["Rg"]
						end
						if v["Lm"] then
							char.Torso["Left Shoulder"].Transform = v["Lm"]
						end
						if v["Rm"] then
							char.Torso["Right Shoulder"].Transform = v["Rm"]
						end
						if v["To"] then
							char.HumanoidRootPart["RootJoint"].Transform = v["To"]
						end
						if v["Hd"] then
							char.Torso["Neck"].Transform = v["Hd"]
						end
					end
				end
			end
		--end)
end)

Section1:CreateButton("Cruisin'", function()
	local playanother = false
local playing = false
local rtrnv;
local c;
local tbl3;
local v;
local anim;
local count;
local hhhh;
local asdf;
local s;
local animid;
local plr;
local char;
local cframe;
local torso;
local rs;
local ls;
local rh;
local lh;
local n;
local rj;
local rsc0;
local lsc0;
local rhc0;
local lhc0;
local rjc0;
local nc0;
local gc0;
local orsc0;
local olsc0;
local orhc0;
local olhc0;
local orjc0;
local onc0;
local count2;
local maxcount2;

local function getnext(tbl,number)
	c=100
	rtrnv=0
	for i,v in pairs(tbl) do
		if i>number and i-number<c then
			c=i-number
			rtrnv=i
		end
	end
	return(rtrnv)
end
local function wait2(tim)
	if tim<0.1 then
		game:GetService("RunService").Heartbeat:Wait()
	else
		for i=1,tim*40 do
			game:GetService("RunService").Heartbeat:Wait()
		end
	end
end
local function kftotbl(kf) -- Below this is literal pain..
	tbl3 = {}
	for i,v in pairs(kf:GetDescendants()) do
		if v:IsA("Pose") then
			tbl3[string.sub(v.Name,1,1)..string.sub(v.Name,#v.Name,#v.Name)] = v.CFrame
		end
	end
	return(tbl3)
end
        if playanother == true then
				playanother = false
			end
			playing = true
			if workspace.Camera.CameraSubject.Parent:FindFirstChild("Sound") then
				workspace.Camera.CameraSubject.Parent:FindFirstChild("Sound"):Remove()
		end
			s = Instance.new("Sound", workspace.Camera.CameraSubject.Parent)

				s.SoundId = "rbxassetid://313905409"

			s.Looped = true
			s.Playing = true
			wait(.1) -- Do not change because changing it will break.
			animid="rbxassetid://5079952034"
			plr = game.Players.LocalPlayer
			char = workspace.Camera.CameraSubject.Parent
			cframe = char.HumanoidRootPart.CFrame
			torso = char.Torso
			-----------------------------------------------------------
			rs = torso["Right Shoulder"] -- Just took this from another script(Faster).
			ls = torso["Left Shoulder"]
			rh = torso["Right Hip"]
			lh = torso["Left Hip"]
			n = torso["Neck"]
			rj = char.HumanoidRootPart["RootJoint"]
			rsc0 = rs.C0
			lsc0 = ls.C0
			rhc0 = rh.C0
			lhc0 = lh.C0
			rjc0 = rj.C0
			nc0 = n.C0
			gc0 = CFrame.new()
			orsc0 = rs.C0
			olsc0 = ls.C0
			orhc0 = rh.C0
			olhc0 = lh.C0
			orjc0 = rj.C0
			onc0 = n.C0
			count2 = 100
			maxcount2=100
			-----------------------------------------------------------
			game:GetService("RunService").Heartbeat:Connect(function() -- Speed.
				if playanother == true then
					return nil
				else
					count2 = count2+1
					if count2<=maxcount2 then
						rs.Transform=rs.Transform:Lerp(rsc0,count2/maxcount2)
						ls.Transform=ls.Transform:Lerp(lsc0,count2/maxcount2)
						rh.Transform=rh.Transform:Lerp(rhc0,count2/maxcount2)
						lh.Transform=lh.Transform:Lerp(lhc0,count2/maxcount2)
						n.Transform=n.Transform:Lerp(nc0,count2/maxcount2)
						rj.Transform=rj.Transform:Lerp(rjc0,count2/maxcount2)
					end
				end
			end)
			-----------------------------------------------------------
			animid=game:GetObjects(animid)[1]
			anim={}
			for i,v in pairs(animid:GetChildren()) do
				if v:IsA("Keyframe") then
					anim[v.Time]=kftotbl(v)
				end
			end

			count = 0
			char=workspace.Camera.CameraSubject.Parent
			hhhh=char.Humanoid.Animator
			hhhh.Parent = nil
			for _,v in pairs(char.Humanoid:GetPlayingAnimationTracks()) do
				v:Stop()
			end

			plr.CharacterRemoving:Connect(function()
				if playing == true then
					playing = false
				end
			end)

			while wait() do
				if playanother == true then
					break
				else
					for i,oasjdadlasdkadkldjkl in pairs(anim) do
						asdf=getnext(anim,count)
						v=anim[asdf]
						if v["Lg"] then
							lhc0 = v["Lg"]
						end
						if v["Rg"] then
							rhc0 = v["Rg"]
						end
						if v["Lm"] then
							lsc0 = v["Lm"]
						end
						if v["Rm"] then
							rsc0 = v["Rm"]
						end
						if v["To"] then
							rjc0 = v["To"]
						end
						if v["Hd"] then
							nc0 = v["Hd"]
						end
						count2=0
						maxcount2=asdf-count
						count=asdf
						wait(asdf-count)
						count2=maxcount2
						if v["Lg"] then
							char.Torso["Left Hip"].Transform = v["Lg"]
						end
						if v["Rg"] then
							char.Torso["Right Hip"].Transform = v["Rg"]
						end
						if v["Lm"] then
							char.Torso["Left Shoulder"].Transform = v["Lm"]
						end
						if v["Rm"] then
							char.Torso["Right Shoulder"].Transform = v["Rm"]
						end
						if v["To"] then
							char.HumanoidRootPart["RootJoint"].Transform = v["To"]
						end
						if v["Hd"] then
							char.Torso["Neck"].Transform = v["Hd"]
						end
					end
				end
			end
		--end)
end)

Section1:CreateButton("Goopie", function()
	local playanother = false
local playing = false
local rtrnv;
local c;
local tbl3;
local v;
local anim;
local count;
local hhhh;
local asdf;
local s;
local animid;
local plr;
local char;
local cframe;
local torso;
local rs;
local ls;
local rh;
local lh;
local n;
local rj;
local rsc0;
local lsc0;
local rhc0;
local lhc0;
local rjc0;
local nc0;
local gc0;
local orsc0;
local olsc0;
local orhc0;
local olhc0;
local orjc0;
local onc0;
local count2;
local maxcount2;

local function getnext(tbl,number)
	c=100
	rtrnv=0
	for i,v in pairs(tbl) do
		if i>number and i-number<c then
			c=i-number
			rtrnv=i
		end
	end
	return(rtrnv)
end
local function wait2(tim)
	if tim<0.1 then
		game:GetService("RunService").Heartbeat:Wait()
	else
		for i=1,tim*40 do
			game:GetService("RunService").Heartbeat:Wait()
		end
	end
end
local function kftotbl(kf) -- Below this is literal pain..
	tbl3 = {}
	for i,v in pairs(kf:GetDescendants()) do
		if v:IsA("Pose") then
			tbl3[string.sub(v.Name,1,1)..string.sub(v.Name,#v.Name,#v.Name)] = v.CFrame
		end
	end
	return(tbl3)
end
        if playanother == true then
				playanother = false
			end
			playing = true
			if workspace.Camera.CameraSubject.Parent:FindFirstChild("Sound") then
				workspace.Camera.CameraSubject.Parent:FindFirstChild("Sound"):Remove()
		end
			s = Instance.new("Sound", workspace.Camera.CameraSubject.Parent)

				s.SoundId = "rbxassetid://5173160926"

			s.Looped = true
			s.Playing = true
			wait(.1) -- Do not change because changing it will break.
			animid="rbxassetid://5238669868"
			plr = game.Players.LocalPlayer
			char = workspace.Camera.CameraSubject.Parent
			cframe = char.HumanoidRootPart.CFrame
			torso = char.Torso
			-----------------------------------------------------------
			rs = torso["Right Shoulder"] -- Just took this from another script(Faster).
			ls = torso["Left Shoulder"]
			rh = torso["Right Hip"]
			lh = torso["Left Hip"]
			n = torso["Neck"]
			rj = char.HumanoidRootPart["RootJoint"]
			rsc0 = rs.C0
			lsc0 = ls.C0
			rhc0 = rh.C0
			lhc0 = lh.C0
			rjc0 = rj.C0
			nc0 = n.C0
			gc0 = CFrame.new()
			orsc0 = rs.C0
			olsc0 = ls.C0
			orhc0 = rh.C0
			olhc0 = lh.C0
			orjc0 = rj.C0
			onc0 = n.C0
			count2 = 100
			maxcount2=100
			-----------------------------------------------------------
			game:GetService("RunService").Heartbeat:Connect(function() -- Speed.
				if playanother == true then
					return nil
				else
					count2 = count2+1
					if count2<=maxcount2 then
						rs.Transform=rs.Transform:Lerp(rsc0,count2/maxcount2)
						ls.Transform=ls.Transform:Lerp(lsc0,count2/maxcount2)
						rh.Transform=rh.Transform:Lerp(rhc0,count2/maxcount2)
						lh.Transform=lh.Transform:Lerp(lhc0,count2/maxcount2)
						n.Transform=n.Transform:Lerp(nc0,count2/maxcount2)
						rj.Transform=rj.Transform:Lerp(rjc0,count2/maxcount2)
					end
				end
			end)
			-----------------------------------------------------------
			animid=game:GetObjects(animid)[1]
			anim={}
			for i,v in pairs(animid:GetChildren()) do
				if v:IsA("Keyframe") then
					anim[v.Time]=kftotbl(v)
				end
			end

			count = 0
			char=workspace.Camera.CameraSubject.Parent
			hhhh=char.Humanoid.Animator
			hhhh.Parent = nil
			for _,v in pairs(char.Humanoid:GetPlayingAnimationTracks()) do
				v:Stop()
			end

			plr.CharacterRemoving:Connect(function()
				if playing == true then
					playing = false
				end
			end)

			while wait() do
				if playanother == true then
					break
				else
					for i,oasjdadlasdkadkldjkl in pairs(anim) do
						asdf=getnext(anim,count)
						v=anim[asdf]
						if v["Lg"] then
							lhc0 = v["Lg"]
						end
						if v["Rg"] then
							rhc0 = v["Rg"]
						end
						if v["Lm"] then
							lsc0 = v["Lm"]
						end
						if v["Rm"] then
							rsc0 = v["Rm"]
						end
						if v["To"] then
							rjc0 = v["To"]
						end
						if v["Hd"] then
							nc0 = v["Hd"]
						end
						count2=0
						maxcount2=asdf-count
						count=asdf
						wait(asdf-count)
						count2=maxcount2
						if v["Lg"] then
							char.Torso["Left Hip"].Transform = v["Lg"]
						end
						if v["Rg"] then
							char.Torso["Right Hip"].Transform = v["Rg"]
						end
						if v["Lm"] then
							char.Torso["Left Shoulder"].Transform = v["Lm"]
						end
						if v["Rm"] then
							char.Torso["Right Shoulder"].Transform = v["Rm"]
						end
						if v["To"] then
							char.HumanoidRootPart["RootJoint"].Transform = v["To"]
						end
						if v["Hd"] then
							char.Torso["Neck"].Transform = v["Hd"]
						end
					end
				end
			end
		--end)
end)

Section1:CreateButton("Krystal Dance", function()
	-----------//KRYSTAL DANCE V2\\-----------
--[[Movelist
Q = The Swoosher
E = The nutty
R = Spin me right round!
T = Plum juice dance
Y = Moonwalk
U = Slav dance
P = Barrel roll
F = The Jerky
G = The Shuffle
H = The Spongebob
J = Here comes the money!
K = Runnin' in the 90's
---------]]
print([[
Move list:
Q = The Swoosher
E = The nutty
R = Spin me right round!
T = Plum juice dance
Y = Moonwalk
U = Slav dance
P = Barrel roll
F = The Jerky
G = The Shuffle
H = The Spongebob
J = Here comes the money!
K = Runnin' in the 90's
]])

Player=game.Players.LocalPlayer
Character=workspace.Camera.CameraSubject.Parent
hum = Character.Humanoid
LeftArm=Character["Left Arm"]
LeftLeg=Character["Left Leg"]
RightArm=Character["Right Arm"]
RightLeg=Character["Right Leg"]
Root=Character["HumanoidRootPart"]
Head=Character["Head"]
Torso=Character["Torso"]
Neck=Torso["Neck"]
mouse = Player:GetMouse()
walking = false
jumping = false
attacking = false
firsttime = false
tauntdebounce = false
position = nil
MseGuide = true
running = false
settime = 0
sine = 0
t = 0
ws = 14
change = 1
combo1 = true
dancing = false
equip = false
dgs = 75
combo2 = false
switch1 = true
switch2 = false
firsttime2 = false
combo3 = false
gunallowance = false
shooting = false
RunSrv = game:GetService("RunService")
RenderStepped = game:GetService("RunService").RenderStepped
removeuseless = game:GetService("Debris")

screenGui = Instance.new("ScreenGui")
screenGui.Parent = script.Parent

local HEADLERP = Instance.new("ManualWeld")
HEADLERP.Parent = Head
HEADLERP.Part0 = Head
HEADLERP.Part1 = Head
HEADLERP.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local TORSOLERP = Instance.new("ManualWeld")
TORSOLERP.Parent = Root
TORSOLERP.Part0 = Torso
TORSOLERP.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local ROOTLERP = Instance.new("ManualWeld")
ROOTLERP.Parent = Root
ROOTLERP.Part0 = Root
ROOTLERP.Part1 = Torso
ROOTLERP.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local RIGHTARMLERP = Instance.new("ManualWeld")
RIGHTARMLERP.Parent = RightArm
RIGHTARMLERP.Part0 = RightArm
RIGHTARMLERP.Part1 = Torso
RIGHTARMLERP.C0 = CFrame.new(-1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local LEFTARMLERP = Instance.new("ManualWeld")
LEFTARMLERP.Parent = LeftArm
LEFTARMLERP.Part0 = LeftArm
LEFTARMLERP.Part1 = Torso
LEFTARMLERP.C0 = CFrame.new(1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local RIGHTLEGLERP = Instance.new("ManualWeld")
RIGHTLEGLERP.Parent = RightLeg
RIGHTLEGLERP.Part0 = RightLeg
RIGHTLEGLERP.Part1 = Torso
RIGHTLEGLERP.C0 = CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local LEFTLEGLERP = Instance.new("ManualWeld")
LEFTLEGLERP.Parent = LeftLeg
LEFTLEGLERP.Part0 = LeftLeg
LEFTLEGLERP.Part1 = Torso
LEFTLEGLERP.C0 = CFrame.new(0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local function weldBetween(a, b)
    local weld = Instance.new("ManualWeld", a)
    weld.Part0 = a
    weld.Part1 = b
    weld.C0 = a.CFrame:inverse() * b.CFrame
    return weld
end

function MAKETRAIL(PARENT,POSITION1,POSITION2,LIFETIME,COLOR)
A = Instance.new("Attachment", PARENT)
A.Position = POSITION1
A.Name = "A"
B = Instance.new("Attachment", PARENT)
B.Position = POSITION2
B.Name = "B"
tr1 = Instance.new("Trail", PARENT)
tr1.Attachment0 = A
tr1.Attachment1 = B
tr1.Enabled = true
tr1.Lifetime = LIFETIME
tr1.TextureMode = "Static"
tr1.LightInfluence = 0
tr1.Color = COLOR
tr1.Transparency = NumberSequence.new(0, 1)
end

introsound = Instance.new("Sound",Head)
introsound.SoundId = "rbxassetid://236146895"
introsound.Volume = 8
introsound:Play()


fedora = Instance.new("Part",Character)
fedora.Transparency = 1
fedora.Size = Vector3.new(2,2,2)
fedora.CFrame = Head.CFrame
fedora.CanCollide = false
fedoraweld = Instance.new("Weld",fedora)
fedoraweld.Part0 = fedora
fedoraweld.Part1 = Head
fedoraweld.C0 = fedora.CFrame:inverse() * Head.CFrame * CFrame.new(0,-.75,0)
mfedora = Instance.new("SpecialMesh", fedora)
mfedora.MeshType = "FileMesh"
mfedora.Scale = Vector3.new(.97, .97, .97)
mfedora.MeshId,mfedora.TextureId = 'http://www.roblox.com/asset/?id=13640868','http://www.roblox.com/asset/?id=18987684'

shades = Instance.new("Part",Character)
shades.Transparency = 1
shades.Size = Vector3.new(2,2,2)
shades.CFrame = Head.CFrame
shades.CanCollide = false
shadesweld = Instance.new("Weld",shades)
shadesweld.Part0 = shades
shadesweld.Part1 = Head
shadesweld.C0 = shades.CFrame:inverse() * Head.CFrame * CFrame.new(0,-.2,.15)
mshades = Instance.new("SpecialMesh", shades)
mshades.MeshType = "FileMesh"
mshades.Scale = Vector3.new(1.04, 1.28, 1.04)
mshades.MeshId,mshades.TextureId = 'http://www.roblox.com/asset/?id=1577360','http://www.roblox.com/asset/?id=1577349'

for i,v in pairs(Character:GetChildren()) do
if v.ClassName == "Shirt" or v.ClassName == "Pants" or v.ClassName == "Hat" or v.ClassName == "CharacterMesh" or v.ClassName == "Shirt Graphic" then
v:Remove()
end
end

coroutine.wrap(function()
while wait() do
Head.face.Texture = "rbxasset://textures/face.png"
hum.WalkSpeed = ws
LeftArm.BrickColor = BrickColor.new("Really black")
RightArm.BrickColor = BrickColor.new("Really black")
Head.BrickColor = BrickColor.new("White")
Torso.BrickColor = BrickColor.new("Really black")
LeftLeg.BrickColor = BrickColor.new("Really black")
RightLeg.BrickColor = BrickColor.new("Really black")
end
end)()
godmode = coroutine.wrap(function()
for i,v in pairs(Character:GetChildren()) do
if v:IsA("BasePart") and v ~= Root then
v.Anchored = false
end
end
while true do
hum.MaxHealth = math.huge
wait(0.0000001)
hum.Health = math.huge
wait()
end
end)
godmode()
ff = Instance.new("ForceField", Character)
ff.Visible = false

coroutine.wrap(function()
for i,v in pairs(Character:GetChildren()) do
if v.Name == "Animate" then v:Remove()
end
end
end)()

function damagealll(Radius,Position)		
	local Returning = {}		
	for _,v in pairs(workspace:GetChildren()) do		
		if v~=Character and v:FindFirstChildOfClass('Humanoid') and v:FindFirstChild('Torso') or v:FindFirstChild('UpperTorso') then
if v:FindFirstChild("Torso") then		
			local Mag = (v.Torso.Position - Position).magnitude		
			if Mag < Radius then		
				table.insert(Returning,v)		
			end
elseif v:FindFirstChild("UpperTorso") then	
			local Mag = (v.UpperTorso.Position - Position).magnitude		
			if Mag < Radius then		
				table.insert(Returning,v)		
			end
end	
		end		
	end		
	return Returning		
end

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end

for _,n in pairs(Character:GetChildren()) do
--if n:IsA("Accessory") then n:Remove() end
end
for _,x in pairs(Character:GetChildren()) do
--if x:IsA("Decal") then x:Remove() end
end

intro = true
ws = 0

bigfedora = Instance.new("Part",Character)
bigfedora.Size = Vector3.new(2,2,2)
bigfedora.CFrame = bigfedora.CFrame:inverse() * Root.CFrame * CFrame.new(math.random(-60,60),-.2,math.random(-60,60)) * CFrame.Angles(0,math.rad(math.random(-180,180)),0)
bigfedora.CanCollide = false
bigfedora.Anchored = true
bigfedora.Name = "mbigf"
mbigfedora = Instance.new("SpecialMesh", bigfedora)
mbigfedora.MeshType = "FileMesh"
mbigfedora.Scale = Vector3.new(6, 7, 7)
mbigfedora.MeshId,mbigfedora.TextureId = 'http://www.roblox.com/asset/?id=13640868','http://www.roblox.com/asset/?id=18987684'
for i,v in pairs(Character:GetDescendants()) do
if v:IsA("Part") and v.Name ~= "mbigf" then v.Transparency = 1
end
end
for i = 1, 60 do
bigfedora.CFrame = bigfedora.CFrame:lerp(CFrame.new(Root.Position) * CFrame.new(0,-.1,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.09)
swait()
end
wait(.25)
for i,v in pairs(Character:GetDescendants()) do
if v:IsA("Part") and v.Name ~= "mbigf" and v.Name ~= "HumanoidRootPart" then v.Transparency = 1
end
end
for i = 1, 50 do
bigfedora.CFrame = bigfedora.CFrame:lerp(CFrame.new(fedora.Position),.05)
swait()
end
zmc = 0
for i = 1, 29 do
zmc = zmc + 2
mbigfedora.Scale = mbigfedora.Scale - Vector3.new(.25,.25,.25)
bigfedora.CFrame = bigfedora.CFrame * CFrame.Angles(math.rad(0),math.rad(zmc),0)
swait()
end
bigfedora:Remove()

ws = 14

function SOUND(PARENT,ID,VOL,LOOP,REMOVE)
so = Instance.new("Sound")
so.Parent = PARENT
so.SoundId = "rbxassetid://"..ID
so.Volume = VOL
so.Looped = LOOP

so:Play()
removeuseless:AddItem(so,REMOVE)
end

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='k' then
if dancing then
dancing = false
else
dancing = true
ws = 0
change = .5
attacking = true
jam = Instance.new("Sound",Torso)
jam.SoundId = "rbxassetid://665751753"
jam.Volume = 8
jam.Looped = true
jam.TimePosition = 22.3
jam:Play()
lol90 = 0
coroutine.wrap(function()
while dancing do
lol90 = lol90 + 11
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(1 * math.sin(sine/10),.1 + .8 * math.sin(sine/3),0) * CFrame.Angles(math.rad(0),math.rad(0 * math.sin(sine/8)),math.rad(8 * math.sin(sine/7))),.25)
ROOTLERP.C1 = ROOTLERP.C1:lerp(CFrame.new(0 * math.sin(sine/14),0,0) * CFrame.Angles(math.rad(0),math.rad(lol90),0),.25)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,1.45,0) * CFrame.Angles(math.rad(180),math.rad(-5 * math.sin(sine/3)),math.rad(-6 * math.sin(sine/3))),0.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.4,1.45,0) * CFrame.Angles(math.rad(180),math.rad(5 * math.sin(sine/3)),math.rad(6 * math.sin(sine/3))), 0.25)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 , 0) * CFrame.Angles(0, math.rad(0), math.rad(-10 + 5 * math.sin(sine/3))), 0.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(0, math.rad(0), math.rad(10 - 5 * math.sin(sine/3))), 0.25)
swait()
end
ws = 14
jam:Remove()
ROOTLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='j' then
if dancing then
dancing = false
else
dancing = true
ws = 3
change = .5
attacking = true
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
herecomesthemoney = Instance.new("Sound",Torso)
herecomesthemoney.Pitch = 1
herecomesthemoney.SoundId = "rbxassetid://2426693638"
herecomesthemoney.Volume = 8
herecomesthemoney.Looped = true
herecomesthemoney:Play()
robuxpile = Instance.new("Part",Torso)
robuxpile.Size = Vector3.new(1,1,1)
robuxpile.CFrame = LeftArm.CFrame
robuxpile.CanCollide = false
robuxpileweld = Instance.new("Weld",robuxpile)
robuxpileweld.Part0 = robuxpile
robuxpileweld.Part1 = Torso
robuxpileweld.C0 = robuxpile.CFrame:inverse() * LeftArm.CFrame * CFrame.new(1,-.7,1.4)
mrobuxpile = Instance.new("SpecialMesh", robuxpile)
mrobuxpile.MeshType = "FileMesh"
mrobuxpile.Scale = Vector3.new(0.85, .85, .85)
mrobuxpile.MeshId,mrobuxpile.TextureId = 'http://www.roblox.com/asset/?id=1285245','http://www.roblox.com/asset/?id=8587344'
coroutine.wrap(function()
coroutine.wrap(function()
while wait(.35) do
if not dancing then break end
local robux = Instance.new("Part",Torso)
robux.CFrame = robuxpile.CFrame * CFrame.Angles(math.rad(0),math.rad(90),math.rad(90))
robux.Anchored = false
robux.CanCollide = true
robux.Size = Vector3.new(1,1,1)
removeuseless:AddItem(robux,4)
mrobux = Instance.new("SpecialMesh", robux)
mrobux.MeshType = "FileMesh"
mrobux.Scale = Vector3.new(1.25, 1.25, 1.25)
mrobux.MeshId,mrobux.TextureId = 'http://www.roblox.com/asset/?id=667285348','http://www.roblox.com/asset/?id=665939136'
bov = Instance.new("BodyVelocity",robux)
bov.maxForce = Vector3.new(99999,99999,99999)
robux.CFrame = CFrame.new(robux.Position,mouse.Hit.p)
bov.velocity = robux.CFrame.lookVector*45
removeuseless:AddItem(bov,.1)
end
end)()
while dancing do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.4)
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,-.3,0) * CFrame.Angles(math.rad(20),math.rad(0 * math.sin(sine/8)),math.rad(0)),.25)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1,.5 + .5 * math.sin(sine/2),.5) * CFrame.Angles(math.rad(-97),math.rad(40 - 20 * math.sin(sine/2)),math.rad(0)), 0.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1,.5,.5) * CFrame.Angles(math.rad(-87),math.rad(-20),math.rad(0)), 0.25)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 , .5) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(-10)), 0.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, .5) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(10)), 0.25)
swait()
end
ws = 14
removeuseless:AddItem(g1,.001)
robuxpile:Remove()
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='h' then
if dancing then
dancing = false
else
dancing = true
ws = 0
change = .5
attacking = true
jellyfishjam = Instance.new("Sound",Torso)
jellyfishjam.SoundId = "rbxassetid://840189092"
jellyfishjam.Volume = 8
jellyfishjam.Looped = true
jellyfishjam.TimePosition = 14.8
jellyfishjam:Play()
coroutine.wrap(function()
while dancing do
for i = 1, 15 do
if not dancing then break end
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(.5,-.4 + .1 * math.sin(sine/4),0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/8)),math.rad(20)),.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(0.25, 2.05,-0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-35)), 0.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.31, 2.05,-0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(14)), 0.25)
swait()
end
for i = 1, 15 do
if not dancing then break end
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,-.1 * math.sin(sine/4),0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/8)),math.rad(0)),.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.25, .7,1.5) * CFrame.Angles(math.rad(72), math.rad(25), math.rad(-2)), 0.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(0, math.rad(0), math.rad(10)), 0.25)
swait()
end
for i = 1, 15 do
if not dancing then break end
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(-.5,-.4 + .1 * math.sin(sine/4),0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/8)),math.rad(-20)),.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 , 0) * CFrame.Angles(0, math.rad(0), math.rad(-10)), 0.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(-0.25, 2.05,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(35)), 0.25)
swait()
end
for i = 1, 15 do
if not dancing then break end
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(-.5,-.1,0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/8)),math.rad(0)),.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.31, 2.05,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-14)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.25, .7,1.5) * CFrame.Angles(math.rad(72), math.rad(-25), math.rad(-2)), 0.25)
swait()
end
swait()
end
ws = 14
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='g' then
if dancing then
dancing = false
else
dancing = true
ws = 0
change = .5
attacking = true
deadmau7 = Instance.new("Sound",Torso)
deadmau7.SoundId = "rbxassetid://168166611"
deadmau7.Volume = 8
deadmau7.Looped = true
deadmau7:Play()
coroutine.wrap(function()
coroutine.wrap(function()
while dancing do
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(2 * math.sin(sine/9),-.4 + .1 * math.sin(sine/3),0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/9)),0),.25)
swait()
end
end)()
while dancing do
for i = 1, 28 do
if not dancing then break end
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.2,1.5,0) * CFrame.Angles(math.rad(180 - 7 * math.sin(sine/3)),math.rad(7 * math.sin(sine/3)),math.rad(7*math.sin(sine/3))), 0.2)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, .7,1) * CFrame.Angles(math.rad(75 - 10 * math.sin(sine/2)), math.rad(0), math.rad(0)), 0.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.31, 2.05,-.1) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(-2)), 0.3)
swait()
end
for i = 1, 28 do
if not dancing then break end
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.2,1.5,0) * CFrame.Angles(math.rad(180 - 7 * math.sin(sine/3)),math.rad(7 * math.sin(sine/3)),math.rad(7*math.sin(sine/3))), 0.2)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.31, 2.05,.1) * CFrame.Angles(math.rad(-10), math.rad(0), math.rad(-8)), 0.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, .7,1.1) * CFrame.Angles(math.rad(75 - 10 * math.sin(sine/2)), math.rad(0), math.rad(-2)), 0.25)
swait()
end
swait()
end
ws = 14
deadmau7:Remove()
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='f' then
if dancing then
dancing = false
else
dancing = true
ws = 6
change = .5
attacking = true
bennyhill = Instance.new("Sound",Torso)
bennyhill.SoundId = "rbxassetid://138211362"
bennyhill.Volume = 8
bennyhill.Looped = true
bennyhill:Play()
coroutine.wrap(function()
while dancing do
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,-.4,0) * CFrame.Angles(math.rad(20 + 5 * math.sin(sine/2)),math.rad(10 * math.sin(sine/4)),0),.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.89 - .4 * -math.sin(sine/2),.49) * CFrame.Angles(math.rad(-70 + 20 * -math.sin(sine/2)),0,math.rad(0)),.25)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.89 - .4 * math.sin(sine/2),.49) * CFrame.Angles(math.rad(-70  + 20 * math.sin(sine/2)),0,math.rad(0)),.25)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.33, 2, -.2 + .3 * math.sin(sine/2)) * CFrame.Angles(math.rad(-20 - 20 * -math.sin(sine/2)), math.rad(0), math.rad(-8)), 0.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.33, 2.0,-.2 - .3 * math.sin(sine/2)) * CFrame.Angles(math.rad(-20 - 20 * math.sin(sine/2)), math.rad(0), math.rad(8)), 0.25)
swait()
end
ws = 14
bennyhill:Remove()
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='p' then
if dancing then
dancing = false
else
dancing = true
ws = 0
change = .5
attacking = true
barrelspin = 0
barrelrollsound = Instance.new("Sound",Torso)
barrelrollsound.SoundId = "rbxassetid://505320170"
barrelrollsound.Volume = 8
barrelrollsound.Looped = true
barrelrollsound:Play()
barrol = Instance.new("Part",Torso)
barrol.Size = Vector3.new(1,1,1)
barrol.CFrame = Torso.CFrame
barrol.CanCollide = false
barrolweld = Instance.new("Weld",barrol)
barrolweld.Part0 = barrol
barrolweld.Part1 = Torso
barrolweld.C0 = barrol.CFrame:inverse() * Torso.CFrame * CFrame.new(0,0,0)
mbarrol = Instance.new("SpecialMesh", barrol)
mbarrol.MeshType = "FileMesh"
mbarrol.Scale = Vector3.new(1.05, .95, 1.05)
mbarrol.MeshId,mbarrol.TextureId = 'http://www.roblox.com/asset/?id=29873142','http://www.roblox.com/asset/?id=31082268'
coroutine.wrap(function()
while dancing do
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(5 * math.sin(sine/8),-1.8,0) * CFrame.Angles(math.rad(-90),math.rad(180 * math.sin(sine/8)),0),.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,1.5,0) * CFrame.Angles(math.rad(180),0,math.rad(0)),.25)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,1.5,0) * CFrame.Angles(math.rad(180),0,math.rad(0)),.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(.5,2,0) * CFrame.Angles(0,0,0),.25)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-.5,2,0) * CFrame.Angles(0,0,0),.25)
swait()
end
ws = 14
barrol:Remove()
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='q' then
if dancing then
dancing = false
else
dancing = true
ws = 0
change = .5
spinningmove = 0
dbwouldlovethis = Instance.new("Sound",Torso)
dbwouldlovethis.SoundId = "rbxassetid://1532157598"
dbwouldlovethis.Volume = 8
dbwouldlovethis.Looped = true
dbwouldlovethis:Play()
attacking = true
coroutine.wrap(function()
while dancing do
spinningmove = spinningmove + 10
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.52, 1.9, -.35) * CFrame.Angles(math.rad(-30), math.rad(0), math.rad(0)),.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.52, 1.9, .35) * CFrame.Angles(math.rad(30), math.rad(0), math.rad(0)),.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(.2 * math.sin(sine/3), -.52, .2 * math.sin(sine/4)) * CFrame.Angles(math.rad(180),math.rad(spinningmove),math.rad(15 * math.sin(sine/9))),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,1.45,0) * CFrame.Angles(math.rad(180),math.rad(-1),math.rad(-3 * math.sin(sine/2))),0.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.4,1.45,0) * CFrame.Angles(math.rad(180),math.rad(1),math.rad(3 * math.sin(sine/2))), 0.3)
swait()
end
ws = 14
dbwouldlovethis:Remove()
attacking = false
end)()
end
end
end)


mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='u' then
if dancing then
dancing = false
else
dancing = true
ws = 6
change = .5
attacking = true
slavdance = Instance.new("Sound",Torso)
slavdance.SoundId = "rbxassetid://2341226836"
slavdance.Volume = 6
slavdance.Looped = true
slavdance:Play()
coroutine.wrap(function()
while dancing do
for i = 1, 17 do
if not dancing then break end
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.52, 1.5, -.5) * CFrame.Angles(math.rad(-60), math.rad(0), math.rad(0)),.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.52, 1.2, .55) * CFrame.Angles(math.rad(30), math.rad(0), math.rad(0)),.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.8 + .1 * math.sin(sine/3), 0) * CFrame.Angles(math.rad(22 - 2 * math.sin(sine/3)),math.rad(0),math.rad(0)),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1,-.2,.4) * CFrame.Angles(math.rad(-87 + .01 * math.sin(sine/9)),math.rad(80 - 3 * math.sin(sine/9)),math.rad(0)), 0.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.7,-.2,.4) * CFrame.Angles(math.rad(-87 - .01 * math.sin(sine/9)),math.rad(-88 + .7 * math.sin(sine/9)),math.rad(0)), 0.3)
swait()
end
for i = 1, 17 do
if not dancing then break end
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.52, 1.2, .55) * CFrame.Angles(math.rad(30), math.rad(0), math.rad(0)),.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.52, 1.5, -.5) * CFrame.Angles(math.rad(-60), math.rad(0), math.rad(0)),.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.8 + .1 * math.sin(sine/3), 0) * CFrame.Angles(math.rad(22 - 2 * math.sin(sine/3)),math.rad(0),math.rad(0)),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1,-.2,.4) * CFrame.Angles(math.rad(-87 + .01 * math.sin(sine/9)),math.rad(80 - 3 * math.sin(sine/9)),math.rad(0)), 0.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.7,-.2,.4) * CFrame.Angles(math.rad(-87 - .01 * math.sin(sine/9)),math.rad(-88 + .7 * math.sin(sine/9)),math.rad(0)), 0.3)
swait()
end
swait()
end
ws = 14
slavdance:Remove()
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='y' then
if dancing then
dancing = false
else
dancing = true
ws = 0
change = .5
walkforward = 0
walkrotation = 0
attacking = true
truelegend = Instance.new("Sound",Torso)
truelegend.SoundId = "rbxassetid://487872908"
truelegend.TimePosition = 13.98
truelegend.Volume = 8
truelegend.Looped = true
truelegend:Play()
coroutine.wrap(function()
while dancing do
for i = 1, 100 do
if not dancing then break end
walkforward = walkforward + .1
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.31, 2.05 , .1 * math.sin(sine/4)) * CFrame.Angles(math.rad(10 * math.sin(sine/4)), math.rad(0), math.rad(-8)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.31, 2.05, -.15 * math.sin(sine/4)) * CFrame.Angles(math.rad(-10 * math.sin(sine/4)), math.rad(0), math.rad(8)), 0.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, walkforward) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(0,0,math.rad(0)),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,0,0) * CFrame.Angles(0,0,math.rad(0)),.3)
swait()
end
for i = 1, 50 do
if not dancing then break end
walkrotation = walkrotation + 15
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, walkforward) * CFrame.Angles(math.rad(0),math.rad(walkrotation),math.rad(-0)),.2)
swait()
end
walkrotation = 0
for i = 1, 100 do
if not dancing then break end
walkforward = walkforward - .1
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.31, 2 , .1 * math.sin(sine/4)) * CFrame.Angles(math.rad(10 * math.sin(sine/4)), math.rad(0), math.rad(-8)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.31, 2, -.15 * math.sin(sine/4)) * CFrame.Angles(math.rad(-10 * math.sin(sine/4)), math.rad(0), math.rad(8)), 0.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, walkforward) * CFrame.Angles(math.rad(0),math.rad(-180),math.rad(-0)),.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3,.7,.2) * CFrame.Angles(math.rad(220),math.rad(0),math.rad(-30)), 0.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,0,0) * CFrame.Angles(0,0,math.rad(0)),.3)
swait()
end
for i = 1, 50 do
if not dancing then break end
walkrotation = walkrotation + 15
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(0,0,math.rad(0)),.1)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, walkforward) * CFrame.Angles(math.rad(0),math.rad(walkrotation),math.rad(-0)),.2)
swait()
end
walkrotation = 0
swait()
end
ws = 14
truelegend:Remove()
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='t' then
if dancing then
dancing = false
else
dancing = true
ws = 0
change = .5
attacking = true
plummusic = Instance.new("Sound",Torso)
plummusic.Volume = 8
plummusic.Looped = true
plummusic.SoundId = "rbxassetid://2526093213"
plummusic:Play()
coroutine.wrap(function()
while dancing do
for i = 1, 20 do
if not dancing then break end
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.33, 2 , .05) * CFrame.Angles(math.rad(3), math.rad(0), math.rad(-8)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.33, 2.0, -.05) * CFrame.Angles(math.rad(-3), math.rad(0), math.rad(8)), 0.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0),math.rad(0*math.sin(sine/4)),math.rad(15)),.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(.5,1.98,.05) * CFrame.Angles(0,0,math.rad(-140)),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1,1.3,.05) * CFrame.Angles(0,0,math.rad(50)),.2)
swait()
end
for i = 1, 20 do
if not dancing then break end
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.33, 2, .05) * CFrame.Angles(math.rad(3), math.rad(0), math.rad(-8)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.33, 2.0, -.05) * CFrame.Angles(math.rad(-3), math.rad(0), math.rad(8)), 0.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0),math.rad(0*math.sin(sine/4)),math.rad(-15)),.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1,1.4,.05) * CFrame.Angles(0,0,math.rad(-50)),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(-.6,2,.05) * CFrame.Angles(0,0,math.rad(140)),.2)
swait()
end
swait()
end
ws = 14
plummusic:Remove()
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='e' then
if dancing then
dancing = false
else
dancing = true
ws = 0
change = .5
attacking = true
mrozo = Instance.new("Sound",Torso)
mrozo.Volume = 8
mrozo.SoundId = "rbxassetid://335701357"
mrozo.Looped = true
mrozo.TimePosition = 10
mrozo:Play()
coroutine.wrap(function()
while dancing do
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 , 0) * CFrame.Angles(0, math.rad(0), math.rad(-10)), 0.1)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(0, math.rad(0), math.rad(10)), 0.1)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0),math.rad(0*math.sin(sine/4)),math.rad(15*math.sin(sine/4))),.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3 + .3 * math.sin(sine/3.5),.5 * -math.sin(sine/3.5),.1) * CFrame.Angles(math.rad(0 * math.sin(sine/2)),0,math.rad(30 * math.sin(sine/3.5))),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.3 + .3 * math.sin(sine/3.5),.5 * math.sin(sine/3.5),.1) * CFrame.Angles(math.rad(0 * math.sin(sine/2)),0,math.rad(30 * math.sin(sine/3.5))),.2)
swait()
end
mrozo:Remove()
ws = 14
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='r' then
if dancing then
dancing = false
else
ws = 6
recordbaby = 0
dancing = true
change = .5
attacking = true
spinme = Instance.new("Sound",Torso)
spinme.Volume = 8
spinme.SoundId = "rbxassetid://145799973"
spinme.Looped = true
spinme:Play()
coroutine.wrap(function()
while dancing do
recordbaby = recordbaby + 10
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.27, 2 , .1 * math.sin(sine/4)) * CFrame.Angles(math.rad(10 * math.sin(sine/4)), math.rad(0), math.rad(-8)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.27, 2.0, -.1 * math.sin(sine/4)) * CFrame.Angles(math.rad(-10 * math.sin(sine/4)), math.rad(0), math.rad(8)), 0.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(.5 * math.sin(sine/5), -.2, .5 * math.sin(sine/4)) * CFrame.Angles(math.rad(0),math.rad(recordbaby),math.rad(0)),.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.5,1.98,0) * CFrame.Angles(0,0,math.rad(-90)),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.5,1.98,0) * CFrame.Angles(0,0,math.rad(90)),.3)
swait()
end
spinme:Remove()
ws = 14
attacking = false
end)()
end
end
end)

function ray(pos, dir, rang, ignoredesc)
	return workspace:FindPartOnRay(Ray.new(pos, dir.unit * rang), ignoredesc)
end

function ray2(startpos, endpos, distance, ignore)
local dir = CFrame.new(startpos,endpos).lookVector
return ray(startpos, dir, distance, ignore)
end

checks1 = coroutine.wrap(function() -------Checks
while true do
hf = ray(Root.Position,(CFrame.new(Root.Position,Root.Position+Vector3.new(0,-1,0))).lookVector,3*3,Character)
if Root.Velocity.y > 1 then
position = "Jump"
elseif Root.Velocity.y < -1 then
position = "Falling"
elseif Root.Velocity.Magnitude < 2 then
position = "Idle"
elseif Root.Velocity.Magnitude > 2 then
position = "Walking"
elseif Root.Velocity.Magnitude > 20 then
position = "Running"
else
end
wait()
end
end)
checks1()

function ray(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function ray2(StartPos, EndPos, Distance, Ignore)
local DIRECTION = CFrame.new(StartPos,EndPos).lookVector
return ray(StartPos, DIRECTION, Distance, Ignore)
end

OrgnC0 = Neck.C0
local movelimbs = coroutine.wrap(function()
while RunSrv.RenderStepped:wait() do
TrsoLV = Torso.CFrame.lookVector
Dist = nil
Diff = nil
if not MseGuide then
print("Failed to recognize")
else
local _, Point = Workspace:FindPartOnRay(Ray.new(Head.CFrame.p, mouse.Hit.lookVector), Workspace, false, true)
Dist = (Head.CFrame.p-Point).magnitude
Diff = Head.CFrame.Y-Point.Y
local _, Point2 = Workspace:FindPartOnRay(Ray.new(LeftArm.CFrame.p, mouse.Hit.lookVector), Workspace, false, true)
Dist2 = (LeftArm.CFrame.p-Point).magnitude
Diff2 = LeftArm.CFrame.Y-Point.Y
HEADLERP.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
Neck.C0 = Neck.C0:lerp(OrgnC0*CFrame.Angles((math.tan(Diff/Dist)*1), 0, (((Head.CFrame.p-Point).Unit):Cross(Torso.CFrame.lookVector)).Y*1), .1)
end
end
end)
movelimbs()
immortal = {}
for i,v in pairs(Character:GetDescendants()) do
	if v:IsA("BasePart") and v.Name ~= "lmagic" and v.Name ~= "rmagic" then
		if v ~= Root and v ~= Torso and v ~= Head and v ~= RightArm and v ~= LeftArm and v ~= RightLeg and v.Name ~= "lmagic" and v.Name ~= "rmagic" and v ~= LeftLeg then
			v.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		end
		table.insert(immortal,{v,v.Parent,v.Material,v.Color,v.Transparency})
	elseif v:IsA("JointInstance") then
		table.insert(immortal,{v,v.Parent,nil,nil,nil})
	end
end
for e = 1, #immortal do
	if immortal[e] ~= nil then
		local STUFF = immortal[e]
		local PART = STUFF[1]
		local PARENT = STUFF[2]
		local MATERIAL = STUFF[3]
		local COLOR = STUFF[4]
		local TRANSPARENCY = STUFF[5]
if levitate then
		if PART.ClassName == "Part" and PART ~= Root and PART.Name ~= eyo1 and PART.Name ~= eyo2 and PART.Name ~= "lmagic" and PART.Name ~= "rmagic" then
			PART.Material = MATERIAL
			PART.Color = COLOR
			PART.Transparency = TRANSPARENCY
		end
		PART.AncestryChanged:connect(function()
			PART.Parent = PARENT
		end)
else
		if PART.ClassName == "Part" and PART ~= Root and PART.Name ~= "lmagic" and PART.Name ~= "rmagic" then
			PART.Material = MATERIAL
			PART.Color = COLOR
			PART.Transparency = TRANSPARENCY
		end
		PART.AncestryChanged:connect(function()
			PART.Parent = PARENT
		end)
end
	end
end
function immortality()
	for e = 1, #immortal do
		if immortal[e] ~= nil then
			local STUFF = immortal[e]
			local PART = STUFF[1]
			local PARENT = STUFF[2]
			local MATERIAL = STUFF[3]
			local COLOR = STUFF[4]
			local TRANSPARENCY = STUFF[5]
			if PART.ClassName == "Part" and PART == Root then
				PART.Material = MATERIAL
				PART.Color = COLOR
				PART.Transparency = TRANSPARENCY
			end
			if PART.Parent ~= PARENT then
				hum:Remove()
				PART.Parent = PARENT
				hum = Instance.new("Humanoid",Character)
                                hum.Name = "noneofurbusiness"
			end
		end
	end
end
coroutine.wrap(function()
while true do
if hum.Health < .1 then
deadsound = Instance.new("Sound", Torso)
deadsound.Volume = 6
deadsound.SoundId = "rbxassetid://1411352723"
deadsound:Play()
immortality()
end
wait()
end
end)()

local anims = coroutine.wrap(function()
while true do
settime = 0.05
sine = sine + change
if position == "Jump" and attacking == false then
change = 1
spin = false
for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(-3),math.rad(-4)), 0.2)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.2)
elseif position == "Falling" and attacking == false then
change = 1
spin = false
for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(15), math.rad(0), math.rad(0)), 0.15)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(-4), math.rad(0)), 0.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.94 + .02 * math.sin(sine/12),-0) * CFrame.Angles(math.rad(28 + 5 * math.sin(sine/12)),math.rad(0),math.rad(45)), 0.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.94 + .02 * math.sin(sine/12),-0) * CFrame.Angles(math.rad(28 + 5 * math.sin(sine/12)),math.rad(0),math.rad(-45)), 0.2)
elseif position == "Walking" and attacking == false and running == false then
change = 1.2
walking = true
spin = false
for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5 + Root.RotVelocity.Y / 85,.35,-.5*math.sin(sine/11)) * CFrame.Angles(math.rad(35*math.sin(sine/11)),math.rad(0*math.sin(sine/11)),math.rad(-10 + Root.RotVelocity.Y / 10, math.sin(-20 * math.sin(sine/4)))),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5 + Root.RotVelocity.Y / 85,.45,.5*math.sin(sine/11)) * CFrame.Angles(math.rad(-55*math.sin(sine/11)),math.rad(-5*math.sin(sine/8)),math.rad(10 + Root.RotVelocity.Y / 10, math.sin(20 * math.sin(sine/4)))),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.15 * 0.6*-math.sin(sine/5.5), 0) * CFrame.Angles(math.rad(10), math.rad(12 * -math.sin(sine/11)), math.rad(0) + Root.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/10))), 0.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.cos(sine/11)/2.8, -.2  + 0.2 - math.sin(sine/11)/3.4) * CFrame.Angles(math.rad(25 - 25) + -math.sin(sine/11)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0), math.cos(-15 * 25 * math.cos(sine/11))), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.cos(sine/11)/2.8, -.2 + 0.2 + math.sin(sine/11)/3.4) * CFrame.Angles(math.rad(25 - 25) - -math.sin(sine/11)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0) , math.cos(-15 * 25 * math.cos(sine/11))), 0.3)
elseif position == "Idle" and attacking == false and running == false then
change = .5
spin = true
for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(6 * -math.sin(sine/12)),math.rad(0),math.rad(0)),.1)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.27 + .02 * math.sin(sine/12),.20 * -math.sin(sine/12)) * CFrame.Angles(math.rad(20 * math.sin(sine/12)),math.rad(0),math.rad(10)), 0.1)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.27 + .02 * math.sin(sine/12),.20 * -math.sin(sine/12)) * CFrame.Angles(math.rad(20 * math.sin(sine/12)),math.rad(0),math.rad(-10)), 0.1)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(6 * -math.sin(sine/12)), math.rad(0), math.rad(-10)), 0.1)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(6 * -math.sin(sine/12)), math.rad(0), math.rad(10)), 0.1)
elseif position == "Running" and attacking == false then
change = 1
for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(0, .5, 0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(-1.24+.6*math.sin(sine/4)/1.4, 0.54, 0-0.8*math.sin(sine/4))*CFrame.Angles(math.rad(6+140*math.sin(sine/4)/1.2), math.rad(0), math.rad(20+70*math.sin(sine/4))), 0.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(0,.5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(-20 - 0 * math.sin(sine/4)), math.rad(0 + 6 * math.sin(sine/4)), math.rad(0) + Root.RotVelocity.Y / 30, math.sin(10 * math.sin(sine/4))), 0.3)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,-.2 + .5*-math.sin(sine/4)),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.6+0.1*math.sin(sine/4),.7*-math.sin(sine/4)) * CFrame.Angles(math.rad(15+ -50 * math.sin(sine/4)),0,0),.3)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,-.2 + .5*math.sin(sine/4)),.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.6-0.1*math.sin(sine/4),.7*math.sin(sine/4)) * CFrame.Angles(math.rad(15 + 50 * math.sin(sine/4)),0,0),.3)
end
swait()
end
end)
anims()
warn("Back from the past to dance the dance. Made by Supr14(Credits to Krystalteam).")
	
end)

Section2:CreateButton("Voodoo Doll", function()
	print("when finishing this i was lazy lol")
-----------------------
--[[ Name : Voodoo Child ]]--
-------------------------------------------------------
--A script By Creterisk

--Discord Creterisk#2958 

--NOTE THIS SCRIPT WAS PURELY MADE FROM MY FUCKING IMAGINATION
--IF IT HAPPENS TO LOOK LIKE ANOTHER SCRIPT
--DONT CALL IT A FUCKING BOOTLEG THANK YOU AND ENJOY THE SCRIPT
--YOU FUCKING SKIDS,
--For Those who log/decompile this, If you sell or trade this,
--and I find out who you are, i will take massive action.
warn("iTs iMpOsSiBlE tO sEpArAtE tHe TrUtH fRoM tHe FaLsE")
-------------------------------------------------------

local FavIDs = {
	340106355, --Nefl Crystals
	927529620, --Dimension
	876981900, --Fantasy
	398987889, --Ordinary Days
	1117396305, --Oh wait, it's you.
	885996042, --Action Winter Journey
	919231299, --Sprawling Idiot Effigy
	743466274, --Good Day Sunshine
	727411183, --Knife Fight
	1402748531, --The Earth Is Counting On You!
	595230126, --Robot Language
	478890315 --Death Road to Canada: Rotten Shotgun
	}



--[[
SUBJECT NAME : Micheal Lahen
SUBJECT INFO :
He has some kind of doll around him at all time, he doesn't talk much, but when he does he tends to harm others. It is because of a witch that he escaped, and IT IS also because of that witch that he kills.
He seems to have a horn of some kind, which appeared when he transformed into his "voodoo form" as we call it... Seems it controls his brain, and emotions by consequences.
There is absolutely nothing we can do to save him,
He'd have to kill himself, or we'd have to kill him.
He is a threat to humanity.
SUBJECT STATUS : KILL ON SIGHT! NO HESITATION!
...Nothing can save him...
]]--
--The reality of my life isn't real but a Universe -Creterisk
wait(0.2)
local plr = game:service'Players'.LocalPlayer
print('Local User is '..plr.Name..', Mister, You will not regret this~')
print('Voodoo Child Loaded')
print[[
	No please not again, the curse haunts me
	I cannot control my actions or care for others harm,
	because of that damn horn. If it were to be removed I'd die, but...
	The witch says if I do her deeds she will free me, but...
	I cannot do these deeds as my body forcefully moves away from my objective.
	Please, PLEASE, HELP ME.
	I DON'T WANT TO BE ALONE AGAIN I JUST WISH TO SEE MY FAMILY, PLEASE!

	I.. can't.. I just can't.. the witch is too powerful.. send.. help.. | ???
]]
local char = workspace.Camera.CameraSubject.Parent
local hum = char.Humanoid
local hed = char.Head
local root = char.HumanoidRootPart
local rootj = root.RootJoint
local tors = char.Torso
local ra = char["Right Arm"]
local la = char["Left Arm"]
local rl = char["Right Leg"]
local ll = char["Left Leg"]
local neck = tors["Neck"]
local mouse = plr:GetMouse()
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
local maincolor = BrickColor.new("Institutional white")

function Anchor()
ra.Anchored = true
la.Anchored = true
tors.Anchored = true
ll.Anchored = true
rl.Anchored = true
hed.Anchored = true
end

-------------------------------------------------------
--Start Good Stuff--
-------------------------------------------------------
cam = game.Workspace.CurrentCamera
CF = CFrame.new
angles = CFrame.Angles
attack = false
Euler = CFrame.fromEulerAnglesXYZ
Rad = math.rad
IT = Instance.new
BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor
-------------------------------------------------------
--End Good Stuff--
-------------------------------------------------------
necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
RSH, LSH = nil, nil 
RW = Instance.new("Weld") 
LW = Instance.new("Weld")
RH = tors["Right Hip"]
LH = tors["Left Hip"]
RSH = tors["Right Shoulder"] 
LSH = tors["Left Shoulder"] 
RSH.Parent = nil 
LSH.Parent = nil 
RW.Name = "RW"
RW.Part0 = tors 
RW.C0 = CF(1.5, 0.5, 0)
RW.C1 = CF(0, 0.5, 0) 
RW.Part1 = ra
RW.Parent = tors 
LW.Name = "LW"
LW.Part0 = tors 
LW.C0 = CF(-1.5, 0.5, 0)
LW.C1 = CF(0, 0.5, 0) 
LW.Part1 = la
LW.Parent = tors
Effects = {}
-------------------------------------------------------
--Start HeartBeat--
-------------------------------------------------------
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
-------------------------------------------------------
--End HeartBeat--
-------------------------------------------------------

function CreateSound(ID, PARENT, VOLUME, PITCH)
    local NSound = nil
    coroutine.resume(coroutine.create(function()
        NSound = Instance.new("Sound", PARENT)
        NSound.Volume = VOLUME
        NSound.Pitch = PITCH
        NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
        swait()
        NSound:play()
        game:GetService("Debris"):AddItem(NSound, 10)
    end))
    return NSound
end

--Very lazi from here to below except the animations but who cares /shrug
function chatfunc(text)
local chat = coroutine.wrap(function()
if char:FindFirstChild("TalkingBillBoard")~= nil then
char:FindFirstChild("TalkingBillBoard"):destroy()
end
local naeeym2 = Instance.new("BillboardGui",char)
naeeym2.Size = UDim2.new(0,100,0,40)
naeeym2.StudsOffset = Vector3.new(0,3,0)
naeeym2.Adornee = char.Head
naeeym2.Name = "TalkingBillBoard"
local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.BorderSizePixel = 0
tecks2.Text = ""
tecks2.Font = "Fantasy"
tecks2.TextSize = 30
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = Color3.new(255,0,0)
tecks2.TextStrokeColor3 = Color3.new(0,0,0)
tecks2.Size = UDim2.new(1,0,0.5,0)
local tecks3 = Instance.new("TextLabel",naeeym2)
tecks3.BackgroundTransparency = 1
tecks3.BorderSizePixel = 0
tecks3.Text = ""
tecks3.Font = "Fantasy"
tecks3.TextSize = 30
tecks3.TextStrokeTransparency = 0
tecks3.TextColor3 = Color3.new(255,0,0)
tecks3.TextStrokeColor3 = Color3.new(0,0,0)
tecks3.Size = UDim2.new(1,0,0.5,0)
coroutine.resume(coroutine.create(function()
    while tecks3 ~= nil do
        swait()
        tecks3.Position = UDim2.new(math.random(-.2,.2),math.random(-3,3),.05,math.random(-3,3))   
        tecks3.Rotation = math.random(-3,3)
        tecks3.TextColor3 = Color3.new(math.random(0, 255)/255,0,0)
        tecks3.TextStrokeColor3 = Color3.new(math.random(0, 255)/255,0,0)
    end
end))
for i = 1,string.len(text),1 do
tecks2.Text = string.sub(text,1,i)
tecks3.Text = string.sub(text,1,i)
wait(0.01)
end
wait(2)
for i = 1, 50 do
swait()
tecks2.Position = tecks2.Position - UDim2.new(math.random(-.4,.4),math.random(-10,10),.05,math.random(-10,10))
tecks2.Rotation = tecks2.Rotation - 2
tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
tecks2.TextTransparency = tecks2.TextTransparency + .04
tecks3.Position = tecks2.Position - UDim2.new(math.random(-.4,.4),math.random(-10,10),.05,math.random(-10,10))
tecks3.Rotation = tecks2.Rotation + 2
tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
tecks3.TextTransparency = tecks2.TextTransparency + .04
end
naeeym2:Destroy()
end)
chat()
end
function onChatted(msg)
chatfunc(msg)
end
--plr.Chatted:connect(onChatted)

GlowParticle = Instance.new("ParticleEmitter",ra)
GlowParticle.LightEmission = 0
GlowParticle.Color = ColorSequence.new(Color3.new(0,0,0),Color3.new(0,0,0))
GlowParticle.Size = NumberSequence.new(0,0.6)
GlowParticle.Rotation = NumberRange.new(0, 360)
GlowParticle.Texture = "http://www.roblox.com/asset/?id=1523916715"
GlowParticle.Transparency = NumberSequence.new(0,1)
GlowParticle.LockedToPart = true
GlowParticle.Lifetime = NumberRange.new(1)
GlowParticle.Rate = 999
GlowParticle.Speed = NumberRange.new(0)
GlowParticle.VelocitySpread = 500

function TargetSelect(person)
local dd=coroutine.wrap(function()
if targetted ~= person then
targetted = person
GlowParticle.Enabled = true
end
end)
dd()
end

if targetted == nil then
GlowParticle.Enabled = false
end
-------------------------------------------------------
--Start Important Functions--
-------------------------------------------------------
function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end
function thread(f)
	coroutine.resume(coroutine.create(f))
end
function clerp(a, b, t)
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1 / Sin(theta)
			startInterp = Sin((1 - t) * theta) * invSinTheta
			finishInterp = Sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	elseif 1 + cosTheta > 1.0E-4 then
		local theta = math.acos(-cosTheta)
		local invSinTheta = 1 / Sin(theta)
		startInterp = Sin((t - 1) * theta) * invSinTheta
		finishInterp = Sin(t * theta) * invSinTheta
	else
		startInterp = t - 1
		finishInterp = t
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function rayCast(Position, Direction, Range, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
end
loadstring(game:HttpGet("https://paste.ee/r/oPpQI"))()
local RbxUtility = LoadLibrary("RbxUtility")
local Create = RbxUtility.Create

-------------------------------------------------------
--Start Damage Function--
-------------------------------------------------------
function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	
end
-------------------------------------------------------
--End Damage Function--
-------------------------------------------------------

-------------------------------------------------------
--Start Damage Function Customization--
-------------------------------------------------------
function ShowDamage(Pos, Text, Time, Color)
	local Rate = (1 / 30)
	local Pos = (Pos or Vector3.new(0, 0, 0))
	local Text = (Text or "")
	local Time = (Time or 2)
	local Color = (Color or Color3.new(1, 0, 1))
	local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui"){
		Size = UDim2.new(3, 0, 3, 0),
		Adornee = EffectPart,
		Parent = EffectPart,
	}
	local TextLabel = Create("TextLabel"){
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		Font = "Bodoni",
		TextColor3 = Color,
		TextScaled = true,
		TextStrokeColor3 = Color3.fromRGB(0,0,0),
		Parent = BillboardGui,
	}
	game.Debris:AddItem(EffectPart, (Time))
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		local Frames = (Time / Rate)
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = (Frame / Frames)
			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
			TextLabel.TextTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end
-------------------------------------------------------
--End Damage Function Customization--
-------------------------------------------------------

function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Head")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= plr.Name then
          Damage(head, head, mindam, maxdam, knock, Type, root, 0.1, "http://www.roblox.com/asset/?id=0", 1.2)
        end
      end
    end
  end
end


CFuncs = {
	Part = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part")({
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material
			})
			RemoveOutlines(Part)
			return Part
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Weld = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld")({
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1
			})
			return Weld
		end
	},
	Sound = {
		Create = function(id, par, vol, pit)
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound")({
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace
				})
				wait()
				S:play()
				game:GetService("Debris"):AddItem(S, 6)
			end))
		end
	},
	ParticleEmitter = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter")({
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread
			})
			return fp
		end
	}
}
function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end
function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part")({
		formFactor = FormFactor,
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material
	})
	RemoveOutlines(Part)
	return Part
end
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh)({
		Parent = Part,
		Offset = OffSet,
		Scale = Scale
	})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
	local Weld = Create("Weld")({
		Parent = Parent,
		Part0 = Part0,
		Part1 = Part1,
		C0 = C0,
		C1 = C1
	})
	return Weld
end


-------------------------------------------------------
--Start Effect Function--
-------------------------------------------------------
EffectModel = Instance.new("Model", char)
Effects = {
  Block = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      if Type == 1 or Type == nil then
        table.insert(Effects, {
          prt,
          "Block1",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      elseif Type == 2 then
        table.insert(Effects, {
          prt,
          "Block2",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      else
        table.insert(Effects, {
          prt,
          "Block3",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      end
    end
  },
  Sphere = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Cylinder = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Wave = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3 / 60,
        y3 / 60,
        z3 / 60,
        msh
      })
    end
  },
  Ring = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Break = {
    Create = function(brickcolor, cframe, x1, y1, z1)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
      prt.Anchored = true
      prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      local num = math.random(10, 50) / 1000
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Shatter",
        num,
        prt.CFrame,
        math.random() - math.random(),
        0,
        math.random(50, 100) / 100
      })
    end
  },
Spiral = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
Push = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  }
}
function part(formfactor ,parent, reflectance, transparency, brickcolor, name, size)
	local fp = IT("Part")
	fp.formFactor = formfactor 
	fp.Parent = parent
	fp.Reflectance = reflectance
	fp.Transparency = transparency
	fp.CanCollide = false 
	fp.Locked = true
	fp.BrickColor = brickcolor
	fp.Name = name
	fp.Size = size
	fp.Position = tors.Position 
	RemoveOutlines(fp)
	fp.Material = "SmoothPlastic"
	fp:BreakJoints()
	return fp 
end 
 
function mesh(Mesh,part,meshtype,meshid,offset,scale)
	local mesh = IT(Mesh) 
	mesh.Parent = part
	if Mesh == "SpecialMesh" then
		mesh.MeshType = meshtype
	if meshid ~= "nil" then
		mesh.MeshId = "http://www.roblox.com/asset/?id="..meshid
		end
	end
	mesh.Offset = offset
	mesh.Scale = scale
	return mesh
end

function Magic(bonuspeed, type, pos, scale, value, color, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
		end
		rng:Destroy()
	end))
end

function Eviscerate(dude)

end

function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
			table.insert(List, v)
		end
	end
	return List
end

function Aura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = Vector3.new(x1, y1, z1)
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			speeder = speeder - 0.01 * FastSpeed * bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
		end
		rng:Destroy()
	end))
end

function SoulSteal(dude)

end
function FaceMouse()
local	Cam = workspace.CurrentCamera
	return {
		CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
		Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
	}
end
-------------------------------------------------------
--End Effect Function--
-------------------------------------------------------
function Cso(ID, PARENT, VOLUME, PITCH)
	local NSound = nil
	coroutine.resume(coroutine.create(function()
		NSound = IT("Sound", PARENT)
		NSound.Volume = VOLUME
		NSound.Pitch = PITCH
		NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
		swait()
		NSound:play()
		game:GetService("Debris"):AddItem(NSound, 10)
	end))
	return NSound
end
function CameraEnshaking(Length, Intensity)
	coroutine.resume(coroutine.create(function()
		local intensity = 1 * Intensity
		local rotM = 0.01 * Intensity
		for i = 0, Length, 0.1 do
			swait()
			intensity = intensity - 0.05 * Intensity / Length
			rotM = rotM - 5.0E-4 * Intensity / Length
			hum.CameraOffset = Vector3.new(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)))
			cam.CFrame = cam.CFrame * CF(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity))) * Euler(Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM)
		end
		hum.CameraOffset = Vector3.new(0, 0, 0)
	end))
end
-------------------------------------------------------
--End Important Functions--
-------------------------------------------------------




New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end
	
function Align(Part0, Part1, Position, Angle)
	if Part0:FindFirstChild("Attachment") then
		Part0:FindFirstChild("Attachment"):Remove()
	end
    local AlignPosition = Instance.new("AlignPosition",Part0)
    local AlignOrientation = Instance.new("AlignOrientation",Part0)
    
    local Attachment1 = Instance.new("Attachment", Part0)
    local Attachment2 = Instance.new("Attachment", Part1)

    AlignPosition.Attachment0 = Attachment1
    AlignPosition.Attachment1 = Attachment2
    
    AlignOrientation.Attachment0 = Attachment1
    AlignOrientation.Attachment1 = Attachment2
    
    Attachment2.Position = Position or Vector3.new(0,0,0)
    Attachment2.Orientation = Angle or Vector3.new(0,0,0)
    
    AlignOrientation.MaxTorque = math.huge
    AlignOrientation.MaxAngularVelocity = math.huge
    AlignOrientation.PrimaryAxisOnly = false 
    AlignOrientation.Responsiveness = 200
    AlignOrientation.RigidityEnabled = false
    AlignOrientation.ReactionTorqueEnabled = false
    AlignPosition.MaxForce = math.huge
    AlignPosition.MaxVelocity = math.huge
    AlignPosition.ReactionForceEnabled = false
    AlignPosition.Responsiveness = 200
    AlignPosition.ApplyAtCenterOfMass = true
    AlignPosition.RigidityEnabled = true
    game:GetService("RunService").Heartbeat:Connect(function()
        Part0.Velocity = Vector3.new(-29.99,0,0)
    end)
    if Part0.Parent:IsA("Accessory") then
    	Part0:BreakJoints()
    end
end
	
Doll = New("Model",char,"Doll",{})
Handle = New("Part",Doll,"Handle",{BrickColor = BrickColor.new("Beige"),FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.755005181, 0.52783519, 0.664805532),CFrame = CFrame.new(17.7066402, 4.04866695, 4.38868618, -0.408491671, 0.666965187, -0.623126268, 0.353551745, 0.745008111, 0.565648913, 0.841502249, 0.0107554942, -0.540138841),Color = Color3.new(0.792157, 0.74902, 0.639216),})
Mesh = New("CylinderMesh",Handle,"Mesh",{})
Decal = New("Decal",Handle,"Decal",{Face = Enum.NormalId.Back,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Handle,"Decal",{Face = Enum.NormalId.Left,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Handle,"Decal",{Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Handle,"Decal",{Face = Enum.NormalId.Right,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Handle,"Decal",{Face = Enum.NormalId.Top,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Handle,"Decal",{Face = Enum.NormalId.Bottom,Texture = "http://www.roblox.com/asset/?id=512493661",})
Part = New("Part",Doll,"Part",{BrickColor = BrickColor.new("Beige"),FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.354117572, 0.611353397, 0.337414026),CFrame = CFrame.new(17.8601875, 3.91987228, 3.94369364, 0.725253046, -0.0676794797, 0.685131192, -0.652452052, -0.385200739, 0.652613878, 0.219753951, -0.920328677, -0.3235268),Color = Color3.new(0.792157, 0.74902, 0.639216),})
Mesh = New("CylinderMesh",Part,"Mesh",{})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Back,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Left,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Right,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Top,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Bottom,Texture = "http://www.roblox.com/asset/?id=512493661",})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.725257337, -0.652455866, 0.219753742, -0.0676780641, -0.385204077, -0.920336843, 0.685135007, 0.652616382, -0.323529661),C1 = CFrame.new(-0.482725382, 0.00167179108, 0.0718259811, -0.408491671, 0.353551745, 0.841502249, 0.666965187, 0.745008111, 0.0107554942, -0.623126268, 0.565648913, -0.540138841),})
Part = New("Part",Doll,"Part",{BrickColor = BrickColor.new("Beige"),Shape = Enum.PartType.Ball,Size = Vector3.new(0.357458174, 0.357458174, 0.357458174),CFrame = CFrame.new(17.834486, 3.79168725, 3.64936543, 0.0676793754, -0.685130835, 0.725253344, 0.385200799, -0.652614176, -0.652451873, 0.920328736, 0.323526919, 0.219753981),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.792157, 0.74902, 0.639216),})
Decal = New("Decal",Part,"Decal",{Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Top,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Left,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Back,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Right,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Bottom,Texture = "http://www.roblox.com/asset/?id=512493661",})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.0676779449, 0.385204136, 0.920336902, -0.685134649, -0.65261662, 0.32352975, 0.725257695, -0.652455688, 0.219753742),C1 = CFrame.new(-0.765227079, -0.114135742, 0.174312592, -0.408491671, 0.353551745, 0.841502249, 0.666965187, 0.745008111, 0.0107554942, -0.623126268, 0.565648913, -0.540138841),})
Part = New("Part",Doll,"Part",{BrickColor = BrickColor.new("Beige"),FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.354117572, 0.611353397, 0.337414026),CFrame = CFrame.new(17.469902, 4.25766516, 4.74769306, 0.445832253, 0.789082885, 0.422561586, -0.410611928, -0.239177942, 0.879868925, 0.795366764, -0.565779567, 0.217372388),Color = Color3.new(0.792157, 0.74902, 0.639216),})
Mesh = New("CylinderMesh",Part,"Mesh",{})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Back,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Left,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Right,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Top,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Bottom,Texture = "http://www.roblox.com/asset/?id=512493661",})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.445833862, -0.410613358, 0.795372128, 0.789088428, -0.239180744, -0.565785825, 0.422562867, 0.879873633, 0.217374772),C1 = CFrame.new(0.472706556, 0.0016708374, 0.0718240738, -0.408491671, 0.353551745, 0.841502249, 0.666965187, 0.745008111, 0.0107554942, -0.623126268, 0.565648913, -0.540138841),})
Part = New("Part",Doll,"Part",{BrickColor = BrickColor.new("Beige"),Shape = Enum.PartType.Ball,Size = Vector3.new(0.357458174, 0.357458174, 0.357458174),CFrame = CFrame.new(17.1839867, 3.98582673, 3.75731707, 0.429396152, -0.706048965, 0.563108683, -0.389012426, -0.70731467, -0.590215027, 0.815025091, 0.0343795903, -0.578376234),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.792157, 0.74902, 0.639216),})
Decal = New("Decal",Part,"Decal",{Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Top,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Left,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Back,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Right,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Bottom,Texture = "http://www.roblox.com/asset/?id=512493661",})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.429397583, -0.389013648, 0.815030634, -0.706052482, -0.707317889, 0.0343799815, 0.563113213, -0.590219498, -0.57838279),C1 = CFrame.new(-0.340019703, -0.402200699, 0.631163597, -0.408491671, 0.353551745, 0.841502249, 0.666965187, 0.745008111, 0.0107554942, -0.623126268, 0.565648913, -0.540138841),})
Part = New("Part",Doll,"Part",{BrickColor = BrickColor.new("Beige"),FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.354117572, 0.611353397, 0.337414026),CFrame = CFrame.new(17.3263435, 3.86502314, 4.01973581, 0.563109279, -0.429397821, 0.706047297, -0.590211987, 0.389013797, 0.707316399, -0.578378439, -0.815023482, -0.0343782082),Color = Color3.new(0.792157, 0.74902, 0.639216),})
Mesh = New("CylinderMesh",Part,"Mesh",{})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Back,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Left,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Right,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Top,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Bottom,Texture = "http://www.roblox.com/asset/?id=512493661",})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.563113868, -0.590216458, -0.578384995, -0.429399252, 0.389015079, -0.815029025, 0.706050813, 0.707319558, -0.0343785957),C1 = CFrame.new(-0.220053911, -0.394431114, 0.332381248, -0.408491671, 0.353551745, 0.841502249, 0.666965187, 0.745008111, 0.0107554942, -0.623126268, 0.565648913, -0.540138841),})
Part = New("Part",Doll,"Part",{BrickColor = BrickColor.new("Beige"),FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.354117572, 0.611353397, 0.337414026),CFrame = CFrame.new(17.1463699, 4.02708626, 4.39648008, 0.0949088037, -0.73499012, 0.671386242, -0.165235519, 0.653441608, 0.738708198, -0.981658518, -0.181056261, -0.0594294369),Color = Color3.new(0.792157, 0.74902, 0.639216),})
Mesh = New("CylinderMesh",Part,"Mesh",{})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Back,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Left,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Right,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Top,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Bottom,Texture = "http://www.roblox.com/asset/?id=512493661",})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.0949110687, -0.165237904, -0.981667101, -0.734994531, 0.653445482, -0.181055605, 0.67138958, 0.738711536, -0.0594298989),C1 = CFrame.new(0.227796555, -0.389676094, 0.33270359, -0.408491671, 0.353551745, 0.841502249, 0.666965187, 0.745008111, 0.0107554942, -0.623126268, 0.565648913, -0.540138841),})
Part = New("Part",Doll,"Part",{BrickColor = BrickColor.new("Beige"),Shape = Enum.PartType.Ball,Size = Vector3.new(0.357458174, 0.357458174, 0.357458174),CFrame = CFrame.new(16.9056702, 4.23298216, 4.33822775, 0.734989643, -0.671386659, 0.0949084461, -0.65344131, -0.738707781, -0.165238559, 0.18105793, 0.0594319291, -0.981658101),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.792157, 0.74902, 0.639216),})
Decal = New("Decal",Part,"Decal",{Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Top,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Left,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Back,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Right,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Bottom,Texture = "http://www.roblox.com/asset/?id=512493661",})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.734994054, -0.653445184, 0.181057304, -0.671389878, -0.738711119, 0.0594324097, 0.0949106514, -0.165240943, -0.981666625),C1 = CFrame.new(0.349896908, -0.397447586, 0.630620956, -0.408491671, 0.353551745, 0.841502249, 0.666965187, 0.745008111, 0.0107554942, -0.623126268, 0.565648913, -0.540138841),})
Part = New("Part",Doll,"Part",{BrickColor = BrickColor.new("Beige"),Shape = Enum.PartType.Ball,Size = Vector3.new(0.668146014, 0.668146014, 0.668146014),CFrame = CFrame.new(17.5317345, 3.8532939, 4.38586617, -0.408485681, -0.666960537, 0.62312144, 0.353546619, -0.745002985, -0.565644801, 0.841490149, -0.01075528, 0.540134549),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.792157, 0.74902, 0.639216),})
Decal = New("Decal",Part,"Decal",{Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Top,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Left,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Back,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Right,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Bottom,Texture = "http://www.roblox.com/asset/?id=512493661",})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -0.408489615, 0.353550047, 0.841498256, -0.666963577, -0.745006442, -0.0107553881, 0.623124659, -0.565647602, 0.540137351),C1 = CFrame.new(2.38418579e-07, -0.262242317, -9.53674316e-07, -0.408491671, 0.353551745, 0.841502249, 0.666965187, 0.745008111, 0.0107554942, -0.623126268, 0.565648913, -0.540138841),})
Part = New("Part",Doll,"Part",{BrickColor = BrickColor.new("Beige"),Shape = Enum.PartType.Ball,Size = Vector3.new(0.357458174, 0.357458174, 0.357458174),CFrame = CFrame.new(17.2187252, 4.32988024, 4.93205738, 0.445832521, -0.422561586, 0.789083481, -0.410612077, -0.879869342, -0.239178166, 0.795367122, -0.217372417, -0.565779924),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.792157, 0.74902, 0.639216),})
Decal = New("Decal",Part,"Decal",{Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Top,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Left,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Back,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Right,Texture = "http://www.roblox.com/asset/?id=512493661",})
Decal = New("Decal",Part,"Decal",{Face = Enum.NormalId.Bottom,Texture = "http://www.roblox.com/asset/?id=512493661",})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.4458341, -0.410613567, 0.795372486, -0.422562897, -0.879873991, -0.217374831, 0.789088964, -0.239180893, -0.565786123),C1 = CFrame.new(0.755987883, -0.110072136, 0.169605255, -0.408491671, 0.353551745, 0.841502249, 0.666965187, 0.745008111, 0.0107554942, -0.623126268, 0.565648913, -0.540138841),})
Part = New("Part",Doll,"Part",{FormFactor = Enum.FormFactor.Symmetric,Size = Vector3.new(0.668145955, 0.668145835, 0.668145955),CFrame = CFrame.new(18.08988, 4.4767499, 4.39486742, 0.408485681, 0.666960537, 0.62312144, -0.353546619, 0.745002985, -0.565644801, -0.841490149, 0.01075528, 0.540134549),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
Mesh = New("SpecialMesh",Part,"Mesh",{Scale = Vector3.new(0.267258376, 0.267258346, 0.267258376),MeshId = "rbxassetid://511959728",TextureId = "rbxassetid://511959832",MeshType = Enum.MeshType.FileMesh,})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.408489615, -0.353550047, -0.841498256, 0.666963577, 0.745006442, 0.0107553881, 0.623124659, -0.565647602, 0.540137351),C1 = CFrame.new(7.15255737e-07, 0.574602127, -9.53674316e-07, -0.408491671, 0.353551745, 0.841502249, 0.666965187, 0.745008111, 0.0107554942, -0.623126268, 0.565648913, -0.540138841),})
ConeMesh = New("Part",Doll,"ConeMesh",{Material = Enum.Material.SmoothPlastic,Elasticity = 0,FormFactor = Enum.FormFactor.Symmetric,Size = Vector3.new(0.200000003, 0.334072918, 0.200000003),CFrame = CFrame.new(17.9875202, 4.01644802, 3.77061558, -0.0676794201, -0.685131192, -0.725253105, -0.385200799, -0.652613878, 0.652452171, -0.920328856, 0.3235268, -0.219753891),CanCollide = false,})
Mesh = New("SpecialMesh",ConeMesh,"Mesh",{Scale = Vector3.new(0.0100221895, 0.334072918, 0.0100221895),MeshId = "http://www.roblox.com/asset/?id=1033714",MeshType = Enum.MeshType.FileMesh,})
mot = New("Motor",ConeMesh,"mot",{Part0 = ConeMesh,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -0.0676780194, -0.385204077, -0.920336962, -0.685135007, -0.652616382, 0.323529661, -0.725257397, 0.652455926, -0.219753653),C1 = CFrame.new(-0.646242142, 0.156686783, 0.14059639, -0.408491671, 0.353551745, 0.841502249, 0.666965187, 0.745008111, 0.0107554942, -0.623126268, 0.565648913, -0.540138841),})
ConeMesh = New("Part",Doll,"ConeMesh",{Material = Enum.Material.SmoothPlastic,Elasticity = 0,FormFactor = Enum.FormFactor.Symmetric,Size = Vector3.new(0.200000003, 0.334072918, 0.200000003),CFrame = CFrame.new(17.5272255, 4.25228214, 4.19855928, 0.0679666698, 0.36827448, 0.927217185, -0.212974086, -0.902587652, 0.374107033, 0.974675775, -0.222893685, 0.017090857),CanCollide = false,})
Mesh = New("SpecialMesh",ConeMesh,"Mesh",{Scale = Vector3.new(0.0100221895, 0.334072918, 0.0100221895),MeshId = "http://www.roblox.com/asset/?id=1033714",MeshType = Enum.MeshType.FileMesh,})
mot = New("Motor",ConeMesh,"mot",{Part0 = ConeMesh,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.0679656863, -0.212973878, 0.974683523, 0.368277669, -0.902593136, -0.22289744, 0.927222073, 0.374108285, 0.0170900673),C1 = CFrame.new(-0.0147144794, 0.0299873352, 0.329668999, -0.408491671, 0.353551745, 0.841502249, 0.666965187, 0.745008111, 0.0107554942, -0.623126268, 0.565648913, -0.540138841),})
Part = New("Part",Doll,"Part",{BrickColor = BrickColor.new("Crimson"),Material = Enum.Material.SmoothPlastic,Shape = Enum.PartType.Ball,Size = Vector3.new(0.200000003, 0.200000003, 0.200000003),CFrame = CFrame.new(18.0725803, 4.09775925, 3.73087263, 0.0676794201, 0.685131252, -0.725253105, 0.385200679, 0.652613938, 0.652452171, 0.920328856, -0.32352671, -0.219753891),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.768628, 0.156863, 0.109804),})
Mesh = New("SpecialMesh",Part,"Mesh",{Scale = Vector3.new(0.334072977, 0.334072918, 0.334072977),MeshType = Enum.MeshType.Sphere,})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.0676779896, 0.385204017, 0.920336962, 0.685135067, 0.652616382, -0.323529571, -0.725257397, 0.652455926, -0.219753653),C1 = CFrame.new(-0.685684681, 0.273569107, 0.155054092, -0.408491671, 0.353551745, 0.841502249, 0.666965187, 0.745008111, 0.0107554942, -0.623126268, 0.565648913, -0.540138841),})
Part = New("Part",Doll,"Part",{BrickColor = BrickColor.new("Crimson"),Material = Enum.Material.SmoothPlastic,Shape = Enum.PartType.Ball,Size = Vector3.new(0.200000003, 0.200000003, 0.200000003),CFrame = CFrame.new(17.4762096, 4.37637663, 4.2292285, 0.0679666698, 0.927216947, -0.368275285, -0.212974086, 0.374107838, 0.902587295, 0.974675775, 0.0170910954, 0.222893804),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.768628, 0.156863, 0.109804),})
Mesh = New("SpecialMesh",Part,"Mesh",{Scale = Vector3.new(0.334072977, 0.334072918, 0.334072977),MeshType = Enum.MeshType.Sphere,})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.0679656863, -0.212973878, 0.974683523, 0.927221835, 0.374109089, 0.0170903057, -0.368278474, 0.902592778, 0.22289747),C1 = CFrame.new(0.0758080482, 0.0887422562, 0.4150877, -0.408491671, 0.353551745, 0.841502249, 0.666965187, 0.745008111, 0.0107554942, -0.623126268, 0.565648913, -0.540138841),})

--lazi xd
Needle = New("Model",char,"Needle",{})
Handle2 = New("Part",Needle,"Handle2",{FormFactor = Enum.FormFactor.Plate,Size = Vector3.new(1, 2.4000001, 1),CFrame = CFrame.new(16.3492584, 4.78270006, 4.07852173, 0.0870969296, 0.578728557, -0.810855865, 0.54097569, -0.710955501, -0.449318945, -0.836516261, -0.399518967, -0.375000119),BackSurface = Enum.SurfaceType.Weld,BottomSurface = Enum.SurfaceType.Weld,FrontSurface = Enum.SurfaceType.Weld,LeftSurface = Enum.SurfaceType.Weld,RightSurface = Enum.SurfaceType.Weld,TopSurface = Enum.SurfaceType.Weld,})
Mesh = New("SpecialMesh",Handle2,"Mesh",{Scale = Vector3.new(0.100000001, 0.800000012, 0.100000001),MeshId = "http://www.roblox.com/asset/?id=1082802",MeshType = Enum.MeshType.FileMesh,})

-- -gh 4684948729,5164616038

Align(game.Players.LocalPlayer.Character["Meshes/Spook DollAccessory"].Handle, Handle, Vector3.new(0,0.2,0.1), Vector3.new(0,-180,0))
Align(game.Players.LocalPlayer.Character["YandereKnife"].Handle, Handle2, Vector3.new(-0.05, 0.8, 0), Vector3.new(0,90,90))

for _, v in pairs(Doll:GetChildren()) do
    if v:IsA'BasePart' then
    v.CanCollide = false
    v.Transparency = 1
	end
end

for _, v in pairs(Doll:GetDescendants()) do
    if v:IsA'Decal' then
		v:Remove()
	end
end

for _, v in pairs(Needle:GetChildren()) do
    if v:IsA'BasePart' then
    v.CanCollide = false
    v.Transparency = 1
	end
end


local NewInstance = function(instance,parent,properties)
	local inst = Instance.new(instance,parent)
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end
local HW = NewInstance('Weld',char,{Part0=ra,Part1=Handle,C0 = CFrame.new(-.2,-.8,-.4)*CFrame.Angles(math.rad(-30),math.rad(220),math.rad(65))})

local HW2 = NewInstance('Weld',char,{Part0=la,Part1=Handle2,C0 = CFrame.new(0,-1,0)*CFrame.Angles(math.rad(0),math.rad(125),math.rad(90))})

-------------------------------------------------------
--Start Customization--
-------------------------------------------------------
local Player_Size = 1
if Player_Size ~= 1 then
root.Size = root.Size * Player_Size
tors.Size = tors.Size * Player_Size
hed.Size = hed.Size * Player_Size
ra.Size = ra.Size * Player_Size
la.Size = la.Size * Player_Size
rl.Size = rl.Size * Player_Size
ll.Size = ll.Size * Player_Size
----------------------------------------------------------------------------------
rootj.Parent = root
neck.Parent = tors
RW.Parent = tors
LW.Parent = tors
RH.Parent = tors
LH.Parent = tors
----------------------------------------------------------------------------------
rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
----------------------------------------------------------------------------------
RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
--hat.Parent = Character
end
----------------------------------------------------------------------------------
local SONG = 486598641
local SONG2 = 0
local Music = Instance.new("Sound",tors)
Music.Volume = 5
Music.Looped = true
Music.Pitch = 1 --Pitcher
----------------------------------------------------------------------------------
local equipped = false
local idle = 0
local change = 1
local val = 0
local toim = 0
local idleanim = 0.4
local sine = 0
local Sit = 1
----------------------------------------------------------------------------------
hum.WalkSpeed = 8
hum.JumpPower = 57
hum.Animator.Parent = nil
hed.face.Texture = "rbxassetid://138140944"
----------------------------------------------------------------------------------
for i = 1, 35 do
	local FACE = CreatePart(3, char, "Fabric", 0, 0+(i-1)/35.2, "Dark stone grey", "FaceGradient", Vector3.new(1.01,0.5,1.01),false)
	FACE.Color = Color3.new(0,0,0)
	hed:FindFirstChildOfClass("SpecialMesh"):Clone().Parent = FACE
	CreateWeldOrSnapOrMotor("Weld", hed, hed, FACE, CF(0,0.35-(i-1)/75,0), CF(0, 0, 0))
	FACE.Transparency = 1
end
local LASTPART = hed
for i = 1, 42 do
	local MATH = (1-(i/30))
	if LASTPART == hed then
		local Horn = CreatePart(3, char, "SmoothPlastic", 0, 0, "Dirt brown", "Horn", Vector3.new(0.15*MATH,0.15,0.15*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0.3, 0.7, -0.35) * angles(Rad(25), Rad(15), Rad(-15)), CF(0, 0, 0))
		LASTPART = Horn
		Horn.Transparency = 1
		Horn.Color = Color3.new((i*2-2)/140,0,0)
	else
		local Horn = CreatePart(3, char, "SmoothPlastic", 0, 0, "Dirt brown", "Horn", Vector3.new(0.15*MATH,0.15,0.15*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0, Horn.Size.Y/1.8, 0) * angles(Rad(6), Rad(-0.3), Rad(0)), CF(0, 0, 0))
		LASTPART = Horn
		Horn.Transparency = 1
		Horn.Color = Color3.new((i*2-4)/140,0,0)
	end
end

-------------------------------------------------------
--End Customization--
-------------------------------------------------------


-------------------------------------------------------
--Start Attacks N Stuff--
-------------------------------------------------------

function dmg(dude)

end

--lazi
function kdown(dd)
if dd.Name ~= char then
dd.Humanoid.PlatformStand = true
local bgf = Instance.new("BodyGyro",dd.Head)
bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(math.rad(-90),0,0)
local val = Instance.new("BoolValue",dd)
val.Name = "IsHit"
end
end

function mdmg(Part, Magnitude)--, MinimumDamage, MaximumDamage, KnockBack, Type, HitSound, HitPitch)
    --local buddy
	for _, c in pairs(workspace:children()) do
		local hum = c:findFirstChild("Humanoid")
		if hum ~= nil then
			local head = c:findFirstChild("Torso")
			if head ~= nil then
				local targ = head.Position - Part.Position
				local mag = targ.magnitude
				if mag <= Magnitude and c.Name ~= plr.Name then 
				if c.Name ~= char then
				if c.Name ~= "Creterisk" and c.Name ~= "Nebula_Zorua" and c.Name ~= "KillerDarkness0105" and c.Name ~= "XXUNORIBOASXX" then
			local asd = Instance.new("ParticleEmitter",c.Torso)
			asd.Color = ColorSequence.new(Color3.new(1, 0, 0), Color3.new(.5, 0, 0))
			asd.LightEmission = .1
			asd.Size = NumberSequence.new(0.2)
			asd.Texture = "http://www.roblox.com/asset/?ID=771221224"
			aaa = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.2),NumberSequenceKeypoint.new(1, 5)})
			bbb = NumberSequence.new({NumberSequenceKeypoint.new(0, 1),NumberSequenceKeypoint.new(0.0636, 0), NumberSequenceKeypoint.new(1, 1)})
			asd.Transparency = bbb
			asd.Size = aaa
			asd.ZOffset = .9
			asd.Acceleration = Vector3.new(0, -5, 0)
			asd.LockedToPart = false
			asd.EmissionDirection = "Back"
			asd.Lifetime = NumberRange.new(1, 2)
			asd.Rate = 1000
			asd.Rotation = NumberRange.new(-100, 100)
			asd.RotSpeed = NumberRange.new(-100, 100)
			asd.Speed = NumberRange.new(6)
			asd.VelocitySpread = 10000
			asd.Enabled=true
					--Damage(head, head, MinimumDamage, MaximumDamage, KnockBack, Type, RootPart, .1, "rbxassetid://" .. HitSound, HitPitch)
					dmg(c)
					CFuncs["Sound"].Create("http://www.roblox.com/asset/?id=206082273", c.Torso, 1.2, .8)
					coroutine.wrap(function()
					wait(.2)
					asd.Enabled = false
					wait(2)
					asd:Remove()
					end)()
				       else
        CFuncs["Sound"].Create("http://www.roblox.com/asset/?id=240429289", c.Torso, 1.5, math.random(1,1.3))		
        Effects.Sphere.Create(BrickColor.new("Crimson"), c.Torso.CFrame, 30, 30, 30, .5, .5, .5, 0.04)

					end
				end
			end
		end
	end
	end
end

local sine=0
function targett()
if mouse.Target.Parent ~= char and mouse.Target.Parent.Parent ~= char and mouse.Target.Parent:FindFirstChild("Humanoid") ~= nil then
TargetSelect(mouse.Target.Parent)
CreateSound("743521450", char, 1, .8)
end
end

function HAAH()
	attack = true
	hum.WalkSpeed = 0
	Cso("300208779", hed, 10, 1)
	for i = 0,9,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 2)) * angles(Rad(-30), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-30 - 2.5 * Sin(sine / 2)), Rad(0), Rad(0)), 0.3)
		if Mrandom(1,15) == 1 then
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * CF(0, 0, 0 + ((1) - 1)) * angles(Rad(Mrandom(-15,15)), Rad(Mrandom(-15,15)), Rad(Mrandom(-15,15))), 1)
		end
		RH.C0 = clerp(RH.C0, CF(1, -1 - 0.1 * Cos(sine / 2), 0.025 * Cos(sine / 2)) * RHCF * angles(Rad(-4.5 - 7.5 * Sin(sine / 2)), Rad(0), Rad(-30)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -1 - 0.1 * Cos(sine / 2), 0.025 * Cos(sine / 2)) * LHCF * angles(Rad(-6.5 - 7.5 * Sin(sine / 2)), Rad(0), Rad(30)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 2), 0.025 * Cos(sine / 2)) * angles(Rad(-35 - 7.5 * Sin(sine / 2)), Rad(0), Rad(15 - 7.5 * Sin(sine / 2))), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 2), 0.025 * Cos(sine / 2)) * angles(Rad(-35 - 7.5 * Sin(sine / 2)), Rad(0), Rad(-15 - 7.5 * Sin(sine / 2))), 0.1)
	end
	attack = false
	hum.WalkSpeed = 10
end

function doot_n_die()
    attack = true
    hum.WalkSpeed = 0
    if targetted.Name ~= "Creterisk" and targetted.Name ~= "XXUNORIBOASXX" and targetted.Name ~= "Nebula_Zorua" and targetted.Name ~= "KillerDarkness0105" then
        local torsy = targetted:FindFirstChild("UpperTorso") or targetted:FindFirstChild("Torso")
            local partasdeff = Instance.new("ParticleEmitter",torsy)
            partasdeff.Color = ColorSequence.new(Color3.new(1, 0, 0), Color3.new(.5, 0, 0))
            partasdeff.LightEmission = .1
            partasdeff.Size = NumberSequence.new(0.2)
            partasdeff.Texture = "http://www.roblox.com/asset/?ID=771221224"
            aaa = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.2),NumberSequenceKeypoint.new(1, 5)})
            bbb = NumberSequence.new({NumberSequenceKeypoint.new(0, 1),NumberSequenceKeypoint.new(0.0636, 0), NumberSequenceKeypoint.new(1, 1)})
            partasdeff.Transparency = bbb
            partasdeff.Size = aaa
            partasdeff.ZOffset = .9
            partasdeff.Acceleration = Vector3.new(0, -5, 0)
            partasdeff.LockedToPart = false
            partasdeff.EmissionDirection = "Back"
            partasdeff.Lifetime = NumberRange.new(1, 2)
            partasdeff.Rate = 1000
            partasdeff.Rotation = NumberRange.new(-100, 100)
            partasdeff.RotSpeed = NumberRange.new(-100, 100)
            partasdeff.Speed = NumberRange.new(6)
            partasdeff.VelocitySpread = 10000
            partasdeff.Enabled=false
    for i = 0, 2.4, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(10), Rad(0), Rad(0)), 0.15)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(15), Rad(0), Rad(-25)), 0.3)
        if Mrandom(1,15) == 1 then
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(Mrandom(-20,20)), Rad(Mrandom(-20,20)), Rad(Mrandom(-20,20))), 0.3)
        end
        RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-10)), 0.15)
        LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), -.2 + 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-10)), 0.15)
        RW.C0 = clerp(RW.C0, CF(1.4, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(-15)), 0.1)
        LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30),  -.3 + 0.025 * Cos(sine / 20)) * angles(Rad(175), Rad(0), Rad(20)), 0.1)
    end
    for i = 0, 1.4, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(10), Rad(0), Rad(0)), 0.15)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-15), Rad(0), Rad(-25)), 0.3)
        if Mrandom(1,15) == 1 then
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(Mrandom(-50,50)), Rad(Mrandom(-50,50)), Rad(Mrandom(-50,50))), 0.3)
        end
        RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-10)), 0.15)
        LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), -.2 + 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-10)), 0.15)
        RW.C0 = clerp(RW.C0, CF(1.4, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(85), Rad(0), Rad(-15)), 0.1)
        LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30),  -.3 + 0.025 * Cos(sine / 20)) * angles(Rad(175), Rad(0), Rad(20)), 0.1)
    end
    dmg(targetted)
    partasdeff.Enabled=true
CreateSound("429400881", torsy, 10, .8)
    for i = 0, 1.4, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(10), Rad(0), Rad(0)), 0.15)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(15), Rad(0), Rad(-25)), 0.3)
        if Mrandom(1,15) == 1 then
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(Mrandom(-20,20)), Rad(Mrandom(-20,20)), Rad(Mrandom(-20,20))), 0.3)
        end
        RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-10)), 0.15)
        LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), -.2 + 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-10)), 0.15)
        RW.C0 = clerp(RW.C0, CF(1.4, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(-15)), 0.1)
        LW.C0 = clerp(LW.C0, CF(-.4, 0.5 + 0.05 * Sin(sine / 30),  -.3 + 0.025 * Cos(sine / 20)) * angles(Rad(75), Rad(0), Rad(65)), 0.1)
    end
    partasdeff.Enabled=false
    for i = 0, 1.4, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(10), Rad(0), Rad(0)), 0.15)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-15), Rad(0), Rad(-25)), 0.3)
        if Mrandom(1,15) == 1 then
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(Mrandom(-20,20)), Rad(Mrandom(-20,20)), Rad(Mrandom(-20,20))), 0.3)
        end
        RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-10)), 0.15)
        LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), -.2 + 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-10)), 0.15)
        RW.C0 = clerp(RW.C0, CF(1.4, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(-15)), 0.1)
        LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30),  -.3 + 0.025 * Cos(sine / 20)) * angles(Rad(175), Rad(0), Rad(20)), 0.1)
        end
    attack = false
    hum.WalkSpeed = 8
    elseif targetted.Name == "Creterisk" then
    for i = 0, 2.4, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(10), Rad(0), Rad(0)), 0.15)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(15), Rad(0), Rad(-25)), 0.3)
        if Mrandom(1,15) == 1 then
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(Mrandom(-20,20)), Rad(Mrandom(-20,20)), Rad(Mrandom(-20,20))), 0.3)
        end
        RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-10)), 0.15)
        LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), -.2 + 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-10)), 0.15)
        RW.C0 = clerp(RW.C0, CF(1.4, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(-15)), 0.1)
        LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30),  -.3 + 0.025 * Cos(sine / 20)) * angles(Rad(175), Rad(0), Rad(20)), 0.1)
    end
    for i = 0, 2.4, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(10), Rad(0), Rad(0)), 0.15)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(15), Rad(0), Rad(-25 * Cos(sine / 20))), 0.3)
        if Mrandom(1,15) == 1 then
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(Mrandom(-20,20)), Rad(Mrandom(-20,20)), Rad(Mrandom(-20,20))), 0.3)
        end
        RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-10)), 0.15)
        LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), -.2 + 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-10)), 0.15)
        RW.C0 = clerp(RW.C0, CF(1.4, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(-15)), 0.1)
        LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30),  -.3 + 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-10)), 0.1)
    end
    coroutine.wrap(function()
    wait(2)
    --partasdeff:Remove()
    end)()
    local sel = Mrandom(1,3)
    if sel == 1 then   
    chatfunc("Damn, I am dumb.")
    elseif sel == 2 then   
    chatfunc("CREATOR, HELP ME.")
    elseif sel == 3 then
    chatfunc("Senpai, notice me.")
    end
    wait(2)
    hum.WalkSpeed = 8
    attack = false
    elseif targetted.Name == "XXUNORIBOASXX" then
        for i = 0, 2.4, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(10), Rad(0), Rad(0)), 0.15)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(15), Rad(0), Rad(-25)), 0.3)
        if Mrandom(1,15) == 1 then
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(Mrandom(-20,20)), Rad(Mrandom(-20,20)), Rad(Mrandom(-20,20))), 0.3)
        end
        RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-10)), 0.15)
        LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), -.2 + 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-10)), 0.15)
        RW.C0 = clerp(RW.C0, CF(1.4, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(-15)), 0.1)
        LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30),  -.3 + 0.025 * Cos(sine / 20)) * angles(Rad(175), Rad(0), Rad(20)), 0.1)
    end
        for i = 0, 2.4, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(10), Rad(0), Rad(0)), 0.15)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(15), Rad(0), Rad(-25 * Cos(sine / 20))), 0.3)
        if Mrandom(1,15) == 1 then
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(Mrandom(-20,20)), Rad(Mrandom(-20,20)), Rad(Mrandom(-20,20))), 0.3)
        end
        RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-10)), 0.15)
        LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), -.2 + 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-10)), 0.15)
        RW.C0 = clerp(RW.C0, CF(1.4, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(-15)), 0.1)
        LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30),  -.3 + 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-10)), 0.1)
    end
    coroutine.wrap(function()
    wait(2)
    --partasdeff:Remove()
    end)()
    local sel = Mrandom(1,3)
    if sel == 1 then   
    chatfunc("HEHEHEHEHEHEHE")
    elseif sel == 2 then   
    chatfunc("ducc.")
    elseif sel == 3 then
    chatfunc("Excuse me what?")
    end
    wait(2)
    hum.WalkSpeed = 8
    attack = false
    elseif targetted.Name == "Nebula_Zorua" then
        for i = 0, 2.4, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(10), Rad(0), Rad(0)), 0.15)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(15), Rad(0), Rad(-25)), 0.3)
        if Mrandom(1,15) == 1 then
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(Mrandom(-20,20)), Rad(Mrandom(-20,20)), Rad(Mrandom(-20,20))), 0.3)
        end
        RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-10)), 0.15)
        LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), -.2 + 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-10)), 0.15)
        RW.C0 = clerp(RW.C0, CF(1.4, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(-15)), 0.1)
        LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30),  -.3 + 0.025 * Cos(sine / 20)) * angles(Rad(175), Rad(0), Rad(20)), 0.1)
    end
        for i = 0, 2.4, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(10), Rad(0), Rad(0)), 0.15)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(15), Rad(0), Rad(-25 * Cos(sine / 20))), 0.3)
        if Mrandom(1,15) == 1 then
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(Mrandom(-20,20)), Rad(Mrandom(-20,20)), Rad(Mrandom(-20,20))), 0.3)
        end
        RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-10)), 0.15)
        LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), -.2 + 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-10)), 0.15)
        RW.C0 = clerp(RW.C0, CF(1.4, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(-15)), 0.1)
        LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30),  -.3 + 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-10)), 0.1)
    end
    coroutine.wrap(function()
    wait(2)
    --partasdeff:Remove()
    end)()
    local sel = Mrandom(1,3)
    if sel == 1 then   
    chatfunc("floof.")
    elseif sel == 2 then   
    chatfunc("Wh-what?")
    elseif sel == 3 then
    chatfunc("I have mistaken..")
    end
    wait(2)
    hum.WalkSpeed = 8
    attack = false
    elseif targetted.Name == "KillerDarkness0105" then
        for i = 0, 2.4, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(10), Rad(0), Rad(0)), 0.15)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(15), Rad(0), Rad(-25)), 0.3)
        if Mrandom(1,15) == 1 then
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(Mrandom(-20,20)), Rad(Mrandom(-20,20)), Rad(Mrandom(-20,20))), 0.3)
        end
        RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-10)), 0.15)
        LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), -.2 + 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-10)), 0.15)
        RW.C0 = clerp(RW.C0, CF(1.4, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(-15)), 0.1)
        LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30),  -.3 + 0.025 * Cos(sine / 20)) * angles(Rad(175), Rad(0), Rad(20)), 0.1)
    end
        for i = 0, 2.4, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(10), Rad(0), Rad(0)), 0.15)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(15), Rad(0), Rad(-25 * Cos(sine / 20))), 0.3)
        if Mrandom(1,15) == 1 then
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(Mrandom(-20,20)), Rad(Mrandom(-20,20)), Rad(Mrandom(-20,20))), 0.3)
        end
        RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-10)), 0.15)
        LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), -.2 + 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-10)), 0.15)
        RW.C0 = clerp(RW.C0, CF(1.4, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(-15)), 0.1)
        LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30),  -.3 + 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-10)), 0.1)
    end
    coroutine.wrap(function()
    wait(2)
    --partasdeff:Remove()
    end)()
    local sel = Mrandom(1,3)
    if sel == 1 then   
    chatfunc("Gale Fighter was a nice script, after all.")
    elseif sel == 2 then   
    chatfunc("Ding dong, bing bong.")
    elseif sel == 3 then
    chatfunc("hehe.. hehehe..")
    end
    wait(2)
    hum.WalkSpeed = 8
    attack = false
    end
end
 
function doot_die_pls()
    attack = true
    hum.WalkSpeed = 0
    local torsy = targetted:FindFirstChild("UpperTorso") or targetted:FindFirstChild("Torso")
    for i = 0, 2, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(10), Rad(0), Rad(25)), 0.15)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
        if Mrandom(1,15) == 1 then
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(Mrandom(-20,20)), Rad(Mrandom(-20,20)), Rad(Mrandom(-20,20))), 0.3)
        end
        RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-10)), 0.15)
        LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-10)), 0.15)
        RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(10)), 0.1)
        LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-10)), 0.1)
        end
    coroutine.resume(coroutine.create(function()
        for i = 1,10 do
            swait()
        local Pully = Create("BodyPosition")({
            P = 9000,
            D = 1000,
            maxForce = Vector3.new(math.huge, math.huge, math.huge),
            position = ra.Position - ra.CFrame.lookVector * 6,
            Parent = torsy
          })
          game:GetService("Debris"):AddItem(Pully, 0.2)
          wait()
        end
    end))
    CreateSound("541909814", torsy, 10, 1)
    CreateSound("131228548", hed, 10, 1)
    for i = 0, 2.2, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-35)), 0.15)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(35)), 0.3)
        if Mrandom(1,15) == 1 then
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(Mrandom(-20,20)), Rad(Mrandom(-20,20)), Rad(Mrandom(-20,20))), 0.3)
        end
        RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(17), Rad(-10)), 0.15)
        LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-0)), 0.15)
        RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(5)), 0.1)
        LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(40), Rad(0), Rad(-5)), 0.1)
        end
    attack = false
    hum.WalkSpeed = 8
end
 
code = 1678 --jk it doesnt work

function abc()
    thing = true
    chatfunc("WHY...")
    wait(0.85)
    chatfunc("WHY?!")
    wait(1)
    chatfunc("WHY MUST MY LIFE BE LIKE THIS?! I can't.. take it anymore...")
    wait(1)
    Music:Stop()
    attack = true
    hum.WalkSpeed = 0
    hum.JumpPower = 0
    for i = 0,6,0.1 do
	swait()
	rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
	tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
	RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
	LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
	RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(5)), 0.1)
	LW.C0 = clerp(LW.C0, CF(-1.3, 0.8 + 0.05 * Sin(sine / 30), -0.025 * Cos(sine / 20)) * angles(Rad(140), Rad(0), Rad(15)), 0.1)
    end
    CreateSound("1093102664", hed, 10, 1)
    for _, v in pairs(Needle:GetChildren()) do
    if v:IsA'BasePart' then
     v:Remove()
    end
    end
    for i = 0,4,0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(5), Rad(0), Rad(0)), 0.15)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(5), Rad(0), Rad(0)), 0.4)
        RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
        LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
        RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(5)), 0.1)
        LW.C0 = clerp(LW.C0, CF(-1.3, 0.8 + 0.05 * Sin(sine / 30), -0.025 * Cos(sine / 20)) * angles(Rad(40), Rad(0), Rad(40)), 0.4)
    end
    for i = 0,6,0.1 do
        swait()
	rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -1.4 + 0.1 * Cos(sine / 20)) * angles(Rad(45), Rad(0), Rad(0)), 0.15)
	tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(35), Rad(0), Rad(0)), 0.3)
	RH.C0 = clerp(RH.C0, CF(1, .4 - 0.1 * Cos(sine / 20), -.6 + 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-5), Rad(0), Rad(45)), 0.15)
	LH.C0 = clerp(LH.C0, CF(-1, -0.6 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-5), Rad(0), Rad(-0)), 0.15)
	RW.C0 = clerp(RW.C0, CF(1.5, 0.1 + 0.05 * Sin(sine / 30), -.4 + 0.025 * Cos(sine / 20)) * angles(Rad(65), Rad(0), Rad(25)), 0.1)
	LW.C0 = clerp(LW.C0, CF(-1.5, 0.1 + 0.05 * Sin(sine / 30), -.4 + 0.025 * Cos(sine / 20)) * angles(Rad(65), Rad(0), Rad(-25)), 0.1)
    end
    for i = 0,6,0.1 do
	swait()
	rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -3 + 0.1) * angles(Rad(90), Rad(0), Rad(0)), 0.15)
	tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-30 - 2.5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.3)
	RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(80), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.08)
	LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-80), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.08)
	RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 20), 0.025 * Cos(sine / 20)) * angles(Rad(200), Rad(0), Rad(25 - 2.5 * Sin(sine / 20))), 0.1)
	LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(20), Rad(0 - 4.5 * Sin(sine / 20)), Rad(-13)), 0.1)
   end
Anchor()
    wait(2)
   chatfunc("I hope I never see you again..")
   wait(1)
   dmg(char)
print("It seems you've died! CONGRATS!")
    for _, v in pairs(Doll:GetChildren()) do
    if v:IsA'BasePart' then
    v:Remove()
    end
    end
thing = false
end

csosoundyi = Instance.new("Sound", hed)
csosoundyi.SoundId = "rbxassetid://178038408"
csosoundyi.Volume = 10
csosoundyi.Pitch = 1

function HAAH()
	attack = true
	hum.WalkSpeed = 0
	csosoundyi:Play()
	repeat
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 2)) * angles(Rad(-30), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-30 - 2.5 * Sin(sine / 2)), Rad(0), Rad(0)), 0.3)
		if Mrandom(1,15) == 1 then
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * CF(0, 0, 0 + ((1) - 1)) * angles(Rad(Mrandom(-15,15)), Rad(Mrandom(-15,15)), Rad(Mrandom(-15,15))), 1)
		end
		RH.C0 = clerp(RH.C0, CF(1, -1 - 0.1 * Cos(sine / 2), 0.025 * Cos(sine / 2)) * RHCF * angles(Rad(-4.5 - 7.5 * Sin(sine / 2)), Rad(0), Rad(-30)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -1 - 0.1 * Cos(sine / 2), 0.025 * Cos(sine / 2)) * LHCF * angles(Rad(-6.5 - 7.5 * Sin(sine / 2)), Rad(0), Rad(30)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 2), 0.025 * Cos(sine / 2)) * angles(Rad(-35 - 7.5 * Sin(sine / 2)), Rad(0), Rad(15 - 7.5 * Sin(sine / 2))), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 2), 0.025 * Cos(sine / 2)) * angles(Rad(-35 - 7.5 * Sin(sine / 2)), Rad(0), Rad(-15 - 7.5 * Sin(sine / 2))), 0.1)
	until csosoundyi.Playing == false
	attack = false
	hum.WalkSpeed = 10
end

thing = false

mouse.Button1Down:connect(function()
    if attack == false and targetted ~= nil and thing == false then
        doot_n_die()
	GlowParticle.Enabled = false
    end
end)

mouse.KeyDown:connect(function(key)
if attack == false then
    if key == 'q' and thing == false then
        targett()
    elseif key == 'x' and targetted ~= nil and thing == false then
        doot_die_pls()
    elseif key == 'r' and targetted ~= nil and thing == false then
        CreateSound("174271590", hed, .4, math.random(5, 15) / 5)
        root.CFrame = targetted.Head.CFrame * CFrame.new(0, 0, 6)
    elseif key == 'p' then
        abc()
    elseif key == 't' and thing == false then
	HAAH()
        end
    end
end)

-------------------------------------------------------
--End Attacks N Stuff--
-------------------------------------------------------


 






-------------------------------------------------------
--Start Animations--
-------------------------------------------------------
print("By Makhail07, FINISHED BY XXUNORIBOASXX >:D")
Music.SoundId = "rbxassetid://"..SONG
Music.Looped = true
Music.Pitch = 1
Music.Volume = 2
Music.Parent = char
Music:Resume()
--AAAAAAAAAAAAAAAA
while true do
	swait()
	sine = sine + change
	local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
	local velderp = root.Velocity.y
	hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, char)
	if equipped == true or equipped == false then
		if attack == false then
			idle = idle + 1
		else
			idle = 0
		end
		if 1 < root.Velocity.y and hitfloor == nil then
			Anim = "Jump"
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(10), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.2 - 0.1 * Cos(sine / 20), -.3* Player_Size) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 20), 0* Player_Size) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif -1 > root.Velocity.y and hitfloor == nil then
			Anim = "Fall"
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-10), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(35 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-8.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-.6), Rad(165 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-.6), Rad(-165 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif torvel < 1 and hitfloor ~= nil then
			Anim = "Idle"
			change = 1
			if attack == false then
				HeadTwitch = false
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(20), Rad(0), Rad(0)), 0.15)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(25 - 2.5 * Sin(sine / 30)), Rad(0), Rad(-20 + 2 * Cos(sine / .25))), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, -0.1* Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-9.5), Rad(0), Rad(20)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, -0.1* Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-9.5), Rad(0), Rad(-20)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(75), Rad(5), Rad(13)), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(20), Rad(0 - 4.5 * Sin(sine / 20)), Rad(-13)), 0.1)
				if HeadTwitch == false and Mrandom(1, 25) == 1 then
					tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(Mrandom(-90, 90)), Rad(Mrandom(-90, 90)), Rad(Mrandom(-90, 90))), 0.15)
				end
			end
		elseif torvel < 50 and hitfloor ~= nil then
			Anim = "Walk"
			change = 1
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(25 - 2.5 * Sin(sine / 7)), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-10 - 25 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
         		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-10 + 25 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(75)  , Rad(8 * Cos(sine / 7)), Rad(6) - ra.RotVelocity.Y / 75), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-37)  * Cos(sine / 7) , Rad(8 * Cos(sine / 7)) ,	Rad(-6) + la.RotVelocity.Y / 75), 0.1)
			end
		end
	end
	if 0 < #Effects then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					local IncZ = Thing[6]
					if 1 >= Thing[1].Transparency then
						if Thing[2] == "Block1" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block2" then
							Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block3" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Cylinder" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Blood" then
							local Mesh = Thing[7]
							Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Elec" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Disappear" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Shatter" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
							Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
							Thing[6] = Thing[6] + Thing[5]
						end
					else
						Part.Parent = nil
						table.remove(Effects, e)
					end
				end
			end
		end
	end
end
--[[
	A bit of lore for those who are wondering :
	
	Micheal (Voodoo Child) was born in a lone village with his sister, father, and mother
	his mother died when he was age 6 and felt that it was his fault she died, as though it was not.
	The village whereabouts was in a forest that some named "The Dead Woods" for whoever went in there,
	never came back.
	A few years past after the death and funeral of his mother, his sister caught a deadly disease, the guilt he felt
	like he did from his mother came upon him once again, for this time was his fault, as they were playing near the oaks of hell,
	which can give others an un-curable sickness or instant death, his sister got the worse fate.
	The only cure known is to get herbs from the witch of the dead woods and do her deeds, but as others know
	those who enter never return, but he was a brave boy and set out to find the witch, his father worried forced him not to go,
	But during the night he snuck out of his home and went...
	His adventure began but not for long as he already saw a hut above, he knocks on the door and waits for a respond,
	nothing.
	After some time the door finally opened and there she was the horrible wrinkle faced creature, he spoke
	"Ma-May I have some of your herbs so I may heal my sister?"
	The witch replied, "Yes you may my little child, but only on one condition, you must do 5 ta-" Micheal cuts her off.
	"I DON'T WANT TO DO ANY TASK I JUST WISH TO SAVE MY SISTER, so please only this once?"
	The witches anger grew, she's never been interrupted, and she knew what she must do.
	"YOU DARE CUT OFF THE SACRED WORDS OF ME? I SHALL CURSE YOU WITH THE SOULS OF THE INNOCENT!" She screamed.
	Micheal terrified, a storm brew, and the witches words could be heard from echoes from every angle, lightning strikes trees and rain pours down,
	covering his head, closing his eyes, and putting himself into a ball, after time everything stopped.
	He looked up cautiously, looking around up and finally down, he sees a pin, and a doll. He bends down and grabs them both,
	looking at them he remembers that he didn't get any herbs but he didn't have enough time he quickly ran back to the village and put both the pin and doll into his pockets...
	
	He was already to late. His sister passed away he bent to his knees and cried, some sang and others left and cried.
	He pulled the doll and pin, from his pocket and laid it on her body and went to his room.
	Moving he gets pinned and looks behind him, the doll and pin... he was terrified, he couldn't say a word and couldn't scream, he passes out.
	Waking up he notices his home and village into shambles, dead ones laying everywhere.
	T O B E C O N T I N U E D !
also there's a code in the script which i have hidden, if you say it in chat it'll say something
--]]
-------------------------------------------------------
--End Animations And Script--
-------------------------------------------------------
warn("my dms : LOL U COPIED FW CUZ OF HATS SKID LMAO!")
end)

Section2:CreateButton("Shotgun", function()
	warn("Black Magic reject by SezHu")
wait(1 / 60)
Effects = { }
local Player = game.Players.localPlayer
local Mouse = Player:GetMouse()
local Character = workspace.Camera.CameraSubject.Parent
local Humanoid = Character.Humanoid
local Head = Character.Head
local RootPart = Character.HumanoidRootPart
local Torso = Character.Torso
local LeftArm = Character["Left Arm"]
local RightArm = Character["Right Arm"]
local LeftLeg = Character["Left Leg"]
local RightLeg = Character["Right Leg"]
local Camera = game.Workspace.CurrentCamera
local RootJoint = RootPart.RootJoint
local Equipped = false
local Attack = false
local Anim = 'Idle'
local Idle = 0
local Combo = 1
local TorsoVelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude 
local Velocity = RootPart.Velocity.y
local Sine = 0
local Change = 1
local maxammo = 6 -- max ammo
local AmmoCount = 6 --ammo in gun
local AmmoUsage = 1 --boolets used
local currentammo = AmmoCount
loadstring(game:HttpGet("https://paste.ee/r/oPpQI"))()
local RbxUtility = LoadLibrary("RbxUtility")
local Create = RbxUtility.Create
local relodee = false
local UIS = game:GetService("UserInputService")    
local stance = false
local maincol = "Rust"
local skillcolorscheme = BrickColor.new(maincol).Color
local maincol2 = "Grey"
local skillcolorscheme2 = BrickColor.new(maincol2).Color
local desirefont = "SourceSansLight"

local coZ = 6
local coX = 0
local coXZ = 5
local coXC = 8
local coXV = 10
local coC = 20
local coV = 25


local cooldownZ = 0
local cooldownX = 0
local cooldownXZ = 0
local cooldownXC = 0
local cooldownXV = 0
local cooldownC = 0
local cooldownV = 0



local scrn = Instance.new('ScreenGui', Player.PlayerGui)
function makeframe(par, trans, pos, size, color)
	local frame = Instance.new('Frame', par)
	frame.BackgroundTransparency = trans
	frame.BorderSizePixel = 0
	frame.Position = pos
	frame.Size = size
	frame.BackgroundColor3 = color
	return frame
end


frameskZ = makeframe(scrn, .8, UDim2.new(.8, 0, .85, 0), UDim2.new(.14, 0, .08, 0), skillcolorscheme)
frameskX = makeframe(scrn, .8, UDim2.new(.8, 0, .74, 0), UDim2.new(.14, 0, .08, 0), skillcolorscheme)
frameskXZ = makeframe(scrn, .8, UDim2.new(.8, 0, .85, 0), UDim2.new(.14, 0, .08, 0), skillcolorscheme)
frameskXC = makeframe(scrn, .8, UDim2.new(.8, 0, .63, 0), UDim2.new(.14, 0, .08, 0), skillcolorscheme)
frameskXV = makeframe(scrn, .8, UDim2.new(.8, 0, .52, 0), UDim2.new(.14, 0, .08, 0), skillcolorscheme)
frameskC = makeframe(scrn, .8, UDim2.new(.8, 0, .63, 0), UDim2.new(.14, 0, .08, 0), skillcolorscheme)
frameskV = makeframe(scrn, .8, UDim2.new(.8, 0, .52, 0), UDim2.new(.14, 0, .08, 0), skillcolorscheme)

barZ = makeframe(frameskZ, 0, UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0), skillcolorscheme2)
barX = makeframe(frameskX, 0, UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0), skillcolorscheme2)
barXZ = makeframe(frameskXZ, 0, UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0), skillcolorscheme2)
barXC = makeframe(frameskXC, 0, UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0), skillcolorscheme2)
barXV = makeframe(frameskXV, 0, UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0), skillcolorscheme2)
barC = makeframe(frameskC, 0, UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0), skillcolorscheme2)
barV = makeframe(frameskV, 0, UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0), skillcolorscheme2)
text1 =  Instance.new('TextLabel', frameskZ)
	text1.BackgroundTransparency = 1
	text1.Size = UDim2.new(1, 0, 1, 0)
	text1.Position = UDim2.new(0, 0, 0, 0)
	text1.TextColor3 = Color3.new(255, 255, 255)
	text1.TextStrokeTransparency = 0
	text1.FontSize = Enum.FontSize.Size18
	text1.Font = desirefont
	text1.BorderSizePixel = 0
	text1.TextScaled = true
text2 =  Instance.new('TextLabel', frameskX)
	text2.BackgroundTransparency = 1
	text2.Size = UDim2.new(1, 0, 1, 0)
	text2.Position = UDim2.new(0, 0, 0, 0)
	text2.TextColor3 = Color3.new(255, 255, 255)
	text2.TextStrokeTransparency = 0
	text2.FontSize = Enum.FontSize.Size18
	text2.Font = desirefont
	text2.BorderSizePixel = 0
	text2.TextScaled = true
text3 =  Instance.new('TextLabel', frameskC)
	text3.BackgroundTransparency = 1
	text3.Size = UDim2.new(1, 0, 1, 0)
	text3.Position = UDim2.new(0, 0, 0, 0)
	text3.TextColor3 = Color3.new(255, 255, 255)
	text3.TextStrokeTransparency = 0
	text3.FontSize = Enum.FontSize.Size18
	text3.Font = desirefont
	text3.BorderSizePixel = 0
	text3.TextScaled = false
text4 =  Instance.new('TextLabel', frameskV)
	text4.BackgroundTransparency = 1
	text4.Size = UDim2.new(1, 0, 1, 0)
	text4.Position = UDim2.new(0, 0, 0, 0)
	text4.TextColor3 = Color3.new(255, 255, 255)
	text4.TextStrokeTransparency = 0
	text4.FontSize = Enum.FontSize.Size18
	text4.Font = desirefont
	text4.BorderSizePixel = 0
	text4.TextScaled = true
	
        text1.Text = "[Z]\n Reposition"
        text2.Text = "[X]\n Battle Stance"
        text3.Text = "[C]\n Mend"
        text4.Text = "[V]\n Unload"

textXZ =  Instance.new('TextLabel', frameskXZ)
	textXZ.BackgroundTransparency = 1
	textXZ.Size = UDim2.new(1, 0, 1, 0)
	textXZ.Position = UDim2.new(0, 0, 0, 0)
	textXZ.TextColor3 = Color3.new(255, 255, 255)
	textXZ.TextStrokeTransparency = 0
	textXZ.FontSize = Enum.FontSize.Size18
	textXZ.Font = desirefont
	textXZ.BorderSizePixel = 0
	textXZ.TextScaled = true
textXC =  Instance.new('TextLabel', frameskXC)
	textXC.BackgroundTransparency = 1
	textXC.Size = UDim2.new(1, 0, 1, 0)
	textXC.Position = UDim2.new(0, 0, 0, 0)
	textXC.TextColor3 = Color3.new(255, 255, 255)
	textXC.TextStrokeTransparency = 0
	textXC.FontSize = Enum.FontSize.Size18
	textXC.Font = desirefont
	textXC.BorderSizePixel = 0
	textXC.TextScaled = true
	textXV =  Instance.new('TextLabel', frameskXV)
	textXV.BackgroundTransparency = 1
	textXV.Size = UDim2.new(1, 0, 1, 0)
	textXV.Position = UDim2.new(0, 0, 0, 0)
	textXV.TextColor3 = Color3.new(255, 255, 255)
	textXV.TextStrokeTransparency = 0
	textXV.FontSize = Enum.FontSize.Size18
	textXV.Font = desirefont
	textXV.BorderSizePixel = 0
	textXV.TextScaled = false
	
	    textXZ.Text = " "
        textXC.Text = " "
        textXV.Text = " "



frameskXZ.BackgroundTransparency = 1
frameskXC.BackgroundTransparency = 1
frameskXV.BackgroundTransparency = 1
barXZ.BackgroundTransparency = 1
barXC.BackgroundTransparency = 1
barXV.BackgroundTransparency = 1


reloadframe = makeframe(scrn, .8, UDim2.new(.8, 0, .4, 0), UDim2.new(.14, 0, .05, 0), skillcolorscheme)
reloadbar = makeframe(reloadframe, 0, UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0), skillcolorscheme2)

	relodetext =  Instance.new('TextLabel', reloadframe)
	relodetext.BackgroundTransparency = 1
	relodetext.Size = UDim2.new(1, 0, 1, 0)
	relodetext.Position = UDim2.new(0, 0, 0, 0)
	relodetext.TextColor3 = Color3.new(255, 255, 255)
	relodetext.TextStrokeTransparency = 0
	relodetext.FontSize = Enum.FontSize.Size24
	relodetext.Font = desirefont
	relodetext.BorderSizePixel = 0
	relodetext.TextScaled = false
	relodetext.Text = currentammo..'/'..maxammo




Humanoid.WalkSpeed = 16
Humanoid.JumpPower = 60
Humanoid.Animator.Parent = nil
Character.Animate.Parent = nil

local newMotor = function(part0, part1, c0, c1)
	local w = Create('Motor'){
		Parent = part0,
		Part0 = part0,
		Part1 = part1,
		C0 = c0,
		C1 = c1,
	}
	return w
end



function clerp(a, b, t)
	return a:lerp(b, t)
end

RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
NeckCF = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)

local RW = newMotor(Torso, RightArm, CFrame.new(1.5, 0, 0), CFrame.new(0, 0, 0)) 
local LW = newMotor(Torso, LeftArm, CFrame.new(-1.5, 0, 0), CFrame.new(0, 0, 0))
local RH = newMotor(Torso, RightLeg, CFrame.new(.5, -2, 0), CFrame.new(0, 0, 0))
local LH = newMotor(Torso, LeftLeg, CFrame.new(-.5, -2, 0), CFrame.new(0, 0, 0))
RootJoint.C1 = CFrame.new(0, 0, 0)
RootJoint.C0 = CFrame.new(0, 0, 0)
Torso.Neck.C1 = CFrame.new(0, 0, 0)
Torso.Neck.C0 = CFrame.new(0, 1.5, 0)

local rarmc1 = RW.C1
local larmc1 = LW.C1
local rlegc1 = RH.C1
local llegc1 = LH.C1

local resetc1 = false

function PlayAnimationFromTable(table, speed, bool)
	RootJoint.C0 = clerp(RootJoint.C0, table[1], speed) 
	Torso.Neck.C0 = clerp(Torso.Neck.C0, table[2], speed) 
	RW.C0 = clerp(RW.C0, table[3], speed) 
	LW.C0 = clerp(LW.C0, table[4], speed) 
	RH.C0 = clerp(RH.C0, table[5], speed) 
	LH.C0 = clerp(LH.C0, table[6], speed) 
	if bool == true then
		if resetc1 == false then
			resetc1 = true
			RootJoint.C1 = RootJoint.C1
			Torso.Neck.C1 = Torso.Neck.C1
			RW.C1 = rarmc1
			LW.C1 = larmc1
			RH.C1 = rlegc1
			LH.C1 = llegc1
		end
	end
end

ArtificialHB = Create("BindableEvent"){
	Parent = script,
	Name = "Heartbeat",
}

script:WaitForChild("Heartbeat")

frame = 1 / 35
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.Heartbeat:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function swait(num)
	if num == 0 or num == nil then
		ArtificialHB.Event:wait()
	else
		for i = 0, num do
			ArtificialHB.Event:wait()
		end
	end
end

local m = Create("Model"){
	Parent = Character,
	Name = "WeaponModel"
}

function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
	
CFuncs = {	
	Part = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part"){
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material,
			}
			RemoveOutlines(Part)
			if Size == Vector3.new() then
				Part.Size = Vector3.new(0.2, 0.2, 0.2)
			else
				Part.Size = Size
			end
			return Part
		end;
	};
	
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end;
	};

	Weld = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld"){
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1,
			}
			return Weld
		end;
	};

	Sound = {
		Create = function(id, par, vol, pit) 
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound"){
					Volume = vol,
					Pitch = pit or 1,
					SoundId = "rbxassetid://" .. id,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 10)
			end))
		end;
	};
	
	ParticleEmitter = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local Particle = Create("ParticleEmitter"){
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread,
			}
			return Particle
		end;
	};
	
	CreateTemplate = {
		
	};
}

--Shotgun Model

function Align(Part0, Part1, Position, Angle)
	if Part0:FindFirstChild("Attachment") then
		Part0:FindFirstChild("Attachment"):Remove()
	end
    local AlignPosition = Instance.new("AlignPosition",Part0)
    local AlignOrientation = Instance.new("AlignOrientation",Part0)
    
    local Attachment1 = Instance.new("Attachment", Part0)
    local Attachment2 = Instance.new("Attachment", Part1)

    AlignPosition.Attachment0 = Attachment1
    AlignPosition.Attachment1 = Attachment2
    
    AlignOrientation.Attachment0 = Attachment1
    AlignOrientation.Attachment1 = Attachment2
    
    Attachment2.Position = Position or Vector3.new(0,0,0)
    Attachment2.Orientation = Angle or Vector3.new(0,0,0)
    
    AlignOrientation.MaxTorque = math.huge
    AlignOrientation.MaxAngularVelocity = math.huge
    AlignOrientation.PrimaryAxisOnly = false 
    AlignOrientation.Responsiveness = 200
    AlignOrientation.RigidityEnabled = false
    AlignOrientation.ReactionTorqueEnabled = false
    AlignPosition.MaxForce = math.huge
    AlignPosition.MaxVelocity = math.huge
    AlignPosition.ReactionForceEnabled = false
    AlignPosition.Responsiveness = 200
    AlignPosition.ApplyAtCenterOfMass = true
    AlignPosition.RigidityEnabled = true
    game:GetService("RunService").Heartbeat:Connect(function()
        Part0.Velocity = Vector3.new(-29.99,0,0)
    end)
    if Part0.Parent:IsA("Accessory") then
    	Part0:BreakJoints()
    end
end

-- -gh 5064344615

Handle=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,1,"Medium stone grey","Handle",Vector3.new(0.230977222, 0.505653977, 0.244424))
Align(game.Players.LocalPlayer.Character["Type-12Accessory"].Handle, Handle, Vector3.new(1, 0.4, 0), Vector3.new(-90, 90, 0))
HandleWeld=CFuncs.Weld.Create(m,Character["Left Arm"],Handle,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.489551544, 0.226313591, 0.00205421448, -0.0140927732, -0.988225222, -0.15235588, -0.120409302, 0.152939469, -0.980872691, 0.992624283, 0.00452187657, -0.121146858))

fHandle=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,1,"Medium stone grey","fHandle",Vector3.new(0.230977222, 0.505653977, 0.244424))
fHandleWeld=CFuncs.Weld.Create(m,Handle,fHandle,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.489551544, 0.226313591, 0.00205421448, -0.0140927732, -0.988225222, -0.15235588, -0.120409302, 0.152939469, -0.980872691, 0.992624283, 0.00452187657, -0.121146858))

Stockbox=CFuncs.Part.Create(m,Enum.Material.Plastic,0,1,"Medium stone grey","Stockbox",Vector3.new(1.35000181, 1.25999975, 1.21000016))
StockboxWeld=CFuncs.Weld.Create(m,fHandle,Stockbox,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.624462128, -0.121447086, -0.0863800049, 0.0217821598, 0.976389289, 0.214917779, -0.119256809, 0.215971515, -0.969089329, -0.992624402, -0.00452160835, 0.121145353))
Shellmaker=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,1,"Medium stone grey","Shellmaker",Vector3.new(0.294364125, 0.10708534, 0.0960408598))
ShellmakerWeld=CFuncs.Weld.Create(m,fHandle,Shellmaker,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.01054192, -0.63139534, -0.123239517, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
bulletmaker=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,1,"Medium stone grey","bulletmaker",Vector3.new(0.0773126334, 0.0921989903, 0.084515892))
bulletmakerWeld=CFuncs.Weld.Create(m,fHandle,bulletmaker,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-3.09943199, -0.656896591, -0.0268611908, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
--[[
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.0763523355, 0.74047333, 0.0622474775))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.020904541, -2.09744072, -0.430066109, 1.1920929e-07, -7.4505806e-07, 1.00000012, 1, -2.98023224e-08, -1.78813934e-07, 2.98023224e-08, 1, 7.59959221e-07))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 1, 0.678870738))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.182476982, 0.119570628, 0.16326943))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.0352497101, 0.183197975, -0.0285701752, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.183437362, 0.465309709, 0.16326943))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.0454616547, -0.0627765656, -0.0285644531, 0.866025507, -0.499999702, -1.78813934e-07, 0.499999762, 0.866025507, 8.04662704e-07, -3.27825546e-07, -8.19563866e-07, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0753918514, 0.119570628, 0.172873542))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.129617691, 0.184212685, -0.0285587311, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0753918514, 0.371197164, 0.172873527))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.0450191498, 0.00573158264, -0.0285778046, 0.866025507, -0.499999702, -1.78813934e-07, 0.499999762, 0.866025507, 8.04662704e-07, -3.27825546e-07, -8.19563866e-07, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.486446053, 0.144061252))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.084405899, -0.0508937836, -0.0285682678, 0.866025507, -0.499999702, -1.78813934e-07, 0.499999762, 0.866025507, 8.04662704e-07, -3.27825546e-07, -8.19563866e-07, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.0540017299, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.119090639, 0.144061252))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.16843605, 0.182041168, -0.0285587311, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.0540017299, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.154145062, 0.159900382, 0.16326943))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.22857666, -0.191133022, -0.0285720825, 0.965925932, 0.258818686, 0, -0.258818686, 0.965925872, -9.9465251e-07, -3.27825546e-07, 9.53674316e-07, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0753918514, 0.112847812, 0.172873542))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.00222587585, -0.22913456, -0.0285568237, 0.965925932, -0.258819044, 7.74860382e-07, 0.258818984, 0.965925813, 1.57952309e-06, -1.22189522e-06, -1.32620335e-06, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.113808274, 0.144061252))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.0371608734, -0.228617668, -0.0285663605, 0.965925932, -0.258819044, 7.74860382e-07, 0.258818984, 0.965925813, 1.57952309e-06, -1.22189522e-06, -1.32620335e-06, 1))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.0540017299, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.113808274, 0.144061252))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.105619431, -0.289684772, -0.0285644531, 0.965925932, 0.258818686, 0, -0.258818686, 0.965925872, -9.9465251e-07, -3.27825546e-07, 9.53674316e-07, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.0540017299, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.0854762271, 0.172873542))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.12963295, -0.276510715, -0.0285644531, 0.965925932, 0.258818686, 0, -0.258818686, 0.965925872, -9.9465251e-07, -3.27825546e-07, 9.53674316e-07, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.717440903, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.112847812, 0.172873542))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.316268921, -0.173998833, -0.0285587311, 0.500002027, 0.866024256, 2.11596489e-06, -0.866024196, 0.500001967, 5.96046448e-08, -1.07288361e-06, -1.86264515e-06, 1))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.54772383, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.113808274, 0.144061252))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.298994064, -0.173471451, -0.0285644531, 0.500002027, 0.866024256, 2.11596489e-06, -0.866024196, 0.500001967, 5.96046448e-08, -1.07288361e-06, -1.86264515e-06, 1))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.239147544, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.0950803086, 0.172873542))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.208971024, -0.221178055, -0.0285568237, 0.866025448, 0.499999702, -2.38418579e-07, -0.499999732, 0.866025507, 8.7916851e-07, 6.2584877e-07, -6.55651093e-07, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.717440903, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.146461785, 0.196876034, 0.16326943))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.327466965, -0.178565979, -0.0285739899, 0.707106829, 0.70710665, -2.08616257e-07, -0.70710665, 0.707106888, 1.93715096e-07, 2.08616257e-07, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.0622474775, 0.246817216, 0.16326943))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.409929276, -0.000652313232, -0.0285587311, -5.96046448e-08, 0.999999881, -1.49011612e-08, -1, -2.98023224e-08, 2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.987445176, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.256908506, 0.250178576, 0.175754741))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.0943717957, -0.513149977, -0.0285682678, 0.965925932, 0.258818686, 0, -0.258818686, 0.965925872, -9.9465251e-07, -3.27825546e-07, 9.53674316e-07, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.81730479, 0.0997623056, 0.0997624695))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.471679688, -0.463490486, -0.0529289246, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.504212916, 0.0997623056, 0.0997624695))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.374668121, -0.534323692, -0.0529251099, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0744314641, 0.272275418, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.242843628, -0.510847807, -0.0285606384, 0.965925932, 0.258818686, 0, -0.258818686, 0.965925872, -9.9465251e-07, -3.27825546e-07, 9.53674316e-07, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0744314641, 1.11887383, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.454176903, -0.655622482, -0.0285568237, 5.96046448e-08, -0.999999881, 1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.296285421, 0.194002435))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.280355453, 0.50044775, -0.0285720825, -0.965925932, -0.258818686, 0, 0.258818686, -0.965925872, 9.9465251e-07, -3.27825546e-07, 9.53674316e-07, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.200575769, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.283319652, 0.249225661, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.314329147, -0.559855938, -0.0285587311, 0.995653629, 0.0931321532, 2.32458115e-06, -0.0931321681, 0.995653749, 7.5250864e-07, -2.29477882e-06, -9.83476639e-07, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.133496568, 0.172873542))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.349269867, -0.24421072, -0.0285644531, 0.866025448, 0.499999702, -2.38418579e-07, -0.499999732, 0.866025507, 8.7916851e-07, 6.2584877e-07, -6.55651093e-07, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.717440903, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.192081362, 0.172873542))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.293024063, -0.294204473, -0.0285720825, 0.965925932, 0.258818686, 0, -0.258818686, 0.965925872, -9.9465251e-07, -3.27825546e-07, 9.53674316e-07, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.717440903, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.0979615301, 0.172873542))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.356941223, 0.0116996765, -0.0285701752, 0.707106829, 0.70710665, -2.08616257e-07, -0.70710665, 0.707106888, 1.93715096e-07, 2.08616257e-07, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.717440903, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.0979615301, 0.172873542))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.28327179, 0.268438339, -0.0285663605, 0.258818686, 0.965925872, 1.57952309e-06, -0.965925932, 0.258818716, -5.66244125e-07, -1.07288361e-06, -1.37090683e-06, 1))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.717440903, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.0979615301, 0.172873542))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.192222595, 0.423189163, -0.0285587311, -5.96046448e-08, 0.999999881, -1.49011612e-08, -1, -2.98023224e-08, 2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.717440903, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.0979615301, 0.172873542))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.0651254654, 0.542451859, -0.0285663605, -0.500002563, 0.866023898, -1.69873238e-06, -0.866023898, -0.500002503, -5.36441803e-07, -1.37090683e-06, 1.1920929e-06, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.717440903, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.0622474775, 0.172873542))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.349715233, 0.488988876, -0.0285606384, -0.866025507, 0.499999702, 1.78813934e-07, -0.499999762, -0.866025507, -8.04662704e-07, -3.27825546e-07, -8.19563866e-07, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.717440903, 0.62486881, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.0622474775, 0.172873542))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.468893051, 0.414321899, -0.0285682678, -0.965925932, 0.258819044, -7.74860382e-07, -0.258818984, -0.965925813, -1.57952309e-06, -1.22189522e-06, -1.32620335e-06, 1))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.717440903, 0.62486881, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.166150421, 0.172873542))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.564922333, 0.374081612, -0.0285587311, -0.999999881, 1.49011612e-08, 2.98023224e-08, 1.49011612e-08, -0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.717440903, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.0622474775, 0.0622474775))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.446313858, 0.0350942612, -0.0285625458, 0.707106829, 0.70710665, -2.08616257e-07, -0.70710665, 0.707106888, 1.93715096e-07, 2.08616257e-07, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.393159211, 0.862414598, 0.327713668))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.0622474775, 0.0622474775))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.391670227, -0.236137867, -0.0285568237, 0.965925932, 0.258818686, 0, -0.258818686, 0.965925872, -9.9465251e-07, -3.27825546e-07, 9.53674316e-07, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.393159211, 0.862414598, 0.327713668))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.10526102, 0.0622474775))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.208478928, -0.470833778, -0.0285587311, 0.965925932, -0.258819044, 7.74860382e-07, 0.258818984, 0.965925813, 1.57952309e-06, -1.22189522e-06, -1.32620335e-06, 1))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.393159211, 1, 0.327713668))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.853799939, 0.249225661, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.811216354, -0.600500107, -0.0285625458, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(1.86222541, 0.142131716, 0.142131925))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.88418007, -0.649424553, -0.0289115906, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.919107974, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.843883514, -0.728718758, -0.0285587311, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.11571791, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.919107974, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.843877792, -0.746054649, -0.0285568237, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.11571791, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.919107974, 0.0622474775, 0.152704939))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.843877792, -0.734283447, -0.0285568237, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.401151627, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.391284943, -0.759021759, -0.0285587311, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.223722026, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.433917999, -0.758702278, -0.0285682678, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.479598999, -0.758406639, -0.0285568237, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.519172668, -0.759467125, -0.0285625458, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.564876556, -0.759284019, -0.0285587311, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.74656105, -0.757936478, -0.0285720825, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.700839996, -0.758119583, -0.0285701752, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.615558624, -0.759425163, -0.0285568237, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.661268234, -0.759130478, -0.0285720825, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.790523529, -0.757699966, -0.0285625458, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.10312653, -0.756930351, -0.0285625458, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.05741501, -0.757115364, -0.0285663605, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.836206436, -0.757403374, -0.0285663605, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.875770569, -0.75846386, -0.0285644531, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.972162247, -0.758422852, -0.0285606384, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.01785469, -0.758123398, -0.0285606384, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.921495438, -0.758282661, -0.0285682678, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.23103142, -0.755340576, -0.0285606384, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.14575386, -0.756649017, -0.0285682678, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.26502037, -0.755158424, -0.0285644531, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.19145584, -0.756355286, -0.0285701752, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.29557228, -0.757285118, -0.0285549164, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.223722026, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.148310468, 0.123276234, 0.12327645))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.608816147, 0.439056396, -0.133686066, -5.96046448e-08, 0.999999881, -1.49011612e-08, -1, -2.98023224e-08, 2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.148310468, 0.123276234, 0.12327645))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.608924866, 0.559501648, -0.141916275, -5.96046448e-08, 0.999999881, -1.49011612e-08, -1, -2.98023224e-08, 2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.148310468, 0.123276234, 0.12327645))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.609196663, 0.676843643, -0.133676529, -5.96046448e-08, 0.999999881, -1.49011612e-08, -1, -2.98023224e-08, 2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Br. yellowish orange","Part",Vector3.new(0.0622474775, 0.118231699, 0.118231893))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.695789337, 0.558382034, -0.141908646, -5.96046448e-08, 0.999999881, -1.49011612e-08, -1, -2.98023224e-08, 2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("SpecialMesh",Part,Enum.MeshType.Cylinder,"",Vector3.new(0, 0, 0),Vector3.new(0.170620233, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Cocoa","Part",Vector3.new(0.163862169, 0.112265885, 0.112266079))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.612273216, 0.558391571, -0.141902924, -5.96046448e-08, 0.999999881, -1.49011612e-08, -1, -2.98023224e-08, 2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Cocoa","Part",Vector3.new(0.164241493, 0.112265885, 0.112266079))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.612018585, 0.438463211, -0.137260437, -5.96046448e-08, 0.999999881, -1.49011612e-08, -1, -2.98023224e-08, 2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Br. yellowish orange","Part",Vector3.new(0.0622474775, 0.118231699, 0.118231893))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.695731163, 0.438491821, -0.137289047, -5.96046448e-08, 0.999999881, -1.49011612e-08, -1, -2.98023224e-08, 2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("SpecialMesh",Part,Enum.MeshType.Cylinder,"",Vector3.new(0, 0, 0),Vector3.new(0.170620233, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Cocoa","Part",Vector3.new(0.164620817, 0.112265885, 0.112266079))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.611670494, 0.676483154, -0.133932114, -5.96046448e-08, 0.999999881, -1.49011612e-08, -1, -2.98023224e-08, 2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Br. yellowish orange","Part",Vector3.new(0.0622474775, 0.118231699, 0.118231893))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.695570946, 0.676485062, -0.133947372, -5.96046448e-08, 0.999999881, -1.49011612e-08, -1, -2.98023224e-08, 2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("SpecialMesh",Part,Enum.MeshType.Cylinder,"",Vector3.new(0, 0, 0),Vector3.new(0.170620233, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.427860439, 0.156066164, 0.156066418))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.02061081, -0.622268677, -0.0845718384, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0773126855, 0.309250325, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.805314064, -1.1217041, -0.0285644531, 0.866025507, -0.499999702, -1.78813934e-07, 0.499999762, 0.866025507, 8.04662704e-07, -3.27825546e-07, -8.19563866e-07, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.261230201, 0.185357824, 0.158467412))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.552032471, -1.27363014, -0.0285682678, 5.96046448e-08, -0.999999881, 1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.983454704, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.876041412, -0.700925827, -0.0285625458, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.655727208, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.983454704, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.822029114, -0.663985252, -0.0285663605, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.655727208, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.983454704, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.787355423, -0.642092705, -0.0285625458, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.655727208, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.228096232, 1.19426513, 0.0672286227))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.572554588, -1.87078285, -0.0285701752, 5.96046448e-08, -0.999999881, 1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(1.1721741, 0.0672284812, 0.0672286004))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.94434929, -0.457939148, -0.0285606384, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0960405394, 1.18610215, 0.119090654))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.60875988, -1.8666954, -0.0285606384, 5.96046448e-08, -0.999999881, 1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0960405394, 0.837954462, 0.119090654))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.593738556, -1.92202759, -0.0285644531, 5.96046448e-08, -0.999999881, 1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.217051655, 0.74047333, 0.0622474775))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.51939106, -2.09714317, 0.0765304565, 3.62284482e-07, -0.965925813, -0.258818895, 0.99999994, 3.27825546e-07, 8.94069672e-08, 0, -0.258818865, 0.965925932))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 1, 0.948875785))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.217051655, 0.74047333, 0.0622474775))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.508298635, -2.09652901, -0.119865417, -1.25169754e-06, -0.965925932, 0.258818418, 1, -1.11758709e-06, 6.85453415e-07, -4.76837158e-07, 0.258818418, 0.965926051))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 1, 0.948875785))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(1.51359856, 0.108333342, 0.108333521))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.70987511, -0.587060928, -0.0289077759, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.116297506, 0.126513839, 0.126514062))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-2.51787376, -0.492711067, -0.0289020538, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.281487226, 0.0818847269, 0.0818848684))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-2.59470558, -0.490480423, -0.0289134979, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.128214061, 0.210328475, 0.119090654))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.553534508, -2.6796627, -0.0285625458, 5.96046448e-08, -0.999999881, 1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.133873656, 0.0622474775, 0.0622474775))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.0289173126, -0.551986694, -2.5983963, -1.1920929e-07, 7.4505806e-07, -1.00000012, -5.96046448e-08, 1, 7.4505806e-07, 1, 7.4505806e-08, -1.49011612e-07))
CFuncs.Mesh.Create("SpecialMesh",Part,Enum.MeshType.Cylinder,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.644316077, 0.644317031))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.133873656, 0.0622474775, 0.0622474775))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.0289115906, -0.555045128, -2.70437813, -1.1920929e-07, 7.4505806e-07, -1.00000012, -5.96046448e-08, 1, 7.4505806e-07, 1, 7.4505806e-08, -1.49011612e-07))
CFuncs.Mesh.Create("SpecialMesh",Part,Enum.MeshType.Cylinder,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.644316077, 0.644317031))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.133873656, 0.0622474775, 0.0622474775))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.0289211273, -0.556861877, -2.75073242, -1.1920929e-07, 7.4505806e-07, -1.00000012, -5.96046448e-08, 1, 7.4505806e-07, 1, 7.4505806e-08, -1.49011612e-07))
CFuncs.Mesh.Create("SpecialMesh",Part,Enum.MeshType.Cylinder,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.644316077, 0.644317031))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.325578123, 0.120581053, 0.120581254))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-2.89797592, -0.653188705, -0.0289173126, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0812890455, 0.0622474775))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(2.78231049, 0.759439468, 0.0285625458, -0.866025448, -0.499999702, 2.38418579e-07, -0.499999732, 0.866025507, 8.7916851e-07, -6.2584877e-07, 6.55651093e-07, -1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.61715281, 1, 0.482340217))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0745662153, 0.0622474775))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(2.76589775, -0.741744041, 0.0285568237, -0.999999881, 1.49011612e-08, 2.98023224e-08, -1.49011612e-08, 0.999999881, 0, 2.98023224e-08, 0, -1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.61715281, 1, 0.482340217))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Lily white","Part",Vector3.new(0.0622474775, 0.0622474775, 0.0622474775))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-2.76446533, -0.764004707, -0.028553009, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("SpecialMesh",Part,Enum.MeshType.Cylinder,"",Vector3.new(0, 0, 0),Vector3.new(0.617152989, 0.408864677, 0.339435399))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(1.09150016, 0.159420162, 0.175754741))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.903377533, -0.564111233, -0.0285682678, 0.999867797, 0.0162549913, 7.74860382e-07, -0.0162550062, 0.999867916, 8.7916851e-07, -7.15255737e-07, -8.94069672e-07, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.799536645, 0.156538948, 0.175754741))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.757575989, -0.625374794, -0.0285549164, 0.985511184, 0.169610262, -6.2584877e-07, -0.169610262, 0.985511243, 3.87430191e-07, 6.85453415e-07, -2.68220901e-07, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.15222393, 0.0696221218, 0.175754741))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.413620949, -0.488759995, -0.0285682678, 0.0912402272, 0.995828867, 1.47521496e-06, -0.995828867, 0.0912402719, 5.66244125e-07, 3.27825546e-07, -1.5348196e-06, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.523900926, 0.0622474775, 0.175754741))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.716959, -0.339764595, -0.0285701752, 0.995828986, -0.0912401676, -5.06639481e-07, 0.0912401378, 0.995828927, 7.15255737e-07, 3.27825546e-07, -7.89761543e-07, 1))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.871611476, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.523900926, 0.0622474775, 0.175754741))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.607765198, -0.601490259, -0.0285663605, 0.908034444, 0.418895423, -5.66244125e-07, -0.418895513, 0.908034563, -2.60770321e-07, 3.57627869e-07, 4.61935997e-07, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.871611476, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.294364095, 0.0622474775, 0.0864367038))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.873703957, 0.431451797, -0.0285663605, 0.639640331, -0.768674433, -4.61935997e-07, 0.768674374, 0.639640331, 5.66244125e-07, -1.78813934e-07, -7.30156898e-07, 1))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.871611476, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.294364095, 0.0622474775, 0.0864367038))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.909405231, 0.553689957, -0.0285549164, 0.639640331, -0.768674433, -4.61935997e-07, 0.768674374, 0.639640331, 5.66244125e-07, -1.78813934e-07, -7.30156898e-07, 1))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.871611476, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.294364095, 0.0622474775, 0.0864367038))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.927492619, 0.657333374, -0.0285587311, 0.639640331, -0.768674433, -4.61935997e-07, 0.768674374, 0.639640331, 5.66244125e-07, -1.78813934e-07, -7.30156898e-07, 1))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.871611476, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.294364095, 0.0622474775, 0.0864367038))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.11587906, -0.356192112, -0.028547287, 0.985511184, 0.169610262, -6.2584877e-07, -0.169610262, 0.985511243, 3.87430191e-07, 6.85453415e-07, -2.68220901e-07, 1))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.871611476, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.495088696, 0.0622474775, 0.0864367038))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.322112083, -1.28462601, -0.0285587311, 0.345870823, 0.938282073, -7.4505806e-07, -0.938282132, 0.345870882, 1.07288361e-06, 1.25169754e-06, 3.27825546e-07, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.871611476, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.257387787, 0.159420162, 0.175754741))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.3693037, 0.223978043, -0.0285739899, 0.874038696, -0.485856384, 3.57627869e-07, 0.485856295, 0.874038756, 3.57627869e-07, -5.66244125e-07, -1.78813934e-07, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.706377685, 0.0622474775, 0.0864367038))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.269904137, -1.45611191, -0.0285568237, -0.000838190317, 0.999999642, 7.74860382e-07, -0.999999642, -0.000838235021, 2.38418579e-07, 1.1920929e-07, -7.89761543e-07, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.871611476, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.107085116, 0.0622474775, 0.0864367038))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.4155426, 0.194704056, -0.028553009, 0.995828986, -0.0912401676, -5.06639481e-07, 0.0912401378, 0.995828927, 7.15255737e-07, 3.27825546e-07, -7.89761543e-07, 1))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.964184403, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.181996748, 0.0622474775, 0.0864367038))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.30640793, -0.446501732, -0.0285644531, 0.985511184, 0.169610262, -6.2584877e-07, -0.169610262, 0.985511243, 3.87430191e-07, 6.85453415e-07, -2.68220901e-07, 1))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.964184403, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.196883038, 0.188232288, 0.0864367038))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.27062798, -0.612149715, -0.0285511017, 0.985511184, 0.169610262, -6.2584877e-07, -0.169610262, 0.985511243, 3.87430191e-07, 6.85453415e-07, -2.68220901e-07, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.116208896, 0.737585008, 0.175754741))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.52254105, -0.293103695, -0.0285682678, 0.999867797, 0.0162549913, 7.74860382e-07, -0.0162550062, 0.999867916, 8.7916851e-07, -7.15255737e-07, -8.94069672e-07, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.116208896, 0.400002003, 0.175754741))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.57855415, -0.319172859, -0.0285606384, 0.997218013, -0.0745394826, 8.94069672e-07, 0.0745394677, 0.997218013, -1.1920929e-07, -9.83476639e-07, 1.49011612e-07, 1.00000024))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.112847485, 0.34814018, 0.175754741))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.5480423, -0.172746658, -0.0285549164, 0.997943401, 0.0641013086, -2.98023224e-08, -0.0641013458, 0.997943401, 8.49366188e-07, 0, -8.64267349e-07, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Br. yellowish orange","Part",Vector3.new(0.0622474775, 0.118231699, 0.118231893))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.696815491, -0.553442001, -0.102174759, -5.96046448e-08, 0.999999881, -1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, 2.98023224e-08, 0, -1.00000012))
CFuncs.Mesh.Create("SpecialMesh",Part,Enum.MeshType.Cylinder,"",Vector3.new(0, 0, 0),Vector3.new(0.170620233, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Br. yellowish orange","Part",Vector3.new(0.0622474775, 0.118231699, 0.118231893))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.696748734, -0.673355103, -0.0975265503, -5.96046448e-08, 0.999999881, -1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, 2.98023224e-08, 0, -1.00000012))
CFuncs.Mesh.Create("SpecialMesh",Part,Enum.MeshType.Cylinder,"",Vector3.new(0, 0, 0),Vector3.new(0.170620233, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Br. yellowish orange","Part",Vector3.new(0.0622474775, 0.118231699, 0.118231893))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.696596146, -0.435348511, -0.094203949, -5.96046448e-08, 0.999999881, -1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, 2.98023224e-08, 0, -1.00000012))
CFuncs.Mesh.Create("SpecialMesh",Part,Enum.MeshType.Cylinder,"",Vector3.new(0, 0, 0),Vector3.new(0.170620233, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Cocoa","Part",Vector3.new(0.163862169, 0.112265885, 0.112266079))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.613293648, -0.553445816, -0.102149963, -5.96046448e-08, 0.999999881, -1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, 2.98023224e-08, 0, -1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Cocoa","Part",Vector3.new(0.164241493, 0.112265885, 0.112266079))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.613039017, -0.673345566, -0.0975208282, -5.96046448e-08, 0.999999881, -1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, 2.98023224e-08, 0, -1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.148310468, 0.123276234, 0.12327645))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.609944344, -0.552326202, -0.102172852, -5.96046448e-08, 0.999999881, -1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, 2.98023224e-08, 0, -1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.148310468, 0.123276234, 0.12327645))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.610219002, -0.434988022, -0.0939350128, -5.96046448e-08, 0.999999881, -1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, 2.98023224e-08, 0, -1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.148310468, 0.123276234, 0.12327645))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.609839439, -0.672796249, -0.0939388275, -5.96046448e-08, 0.999999881, -1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, 2.98023224e-08, 0, -1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Cocoa","Part",Vector3.new(0.164620817, 0.112265885, 0.112266079))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.612697601, -0.435344696, -0.0941925049, -5.96046448e-08, 0.999999881, -1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, 2.98023224e-08, 0, -1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.0622474775, 0.330372602, 0.16326943))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.190822601, -0.254428864, -0.0285701752, 5.96046448e-08, -0.999999881, 1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.648010492, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.0622474775, 0.216564372, 0.16326943))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.217577934, -0.165513992, -0.0285587311, 5.96046448e-08, -0.999999881, 1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.648010492, 1, 1))

--]]

function RayCast(Position, Direction, Range, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore) 
end 

FindNearestTorso = function(pos)
	local list = (game.Workspace:children())
	local torso = nil
	local dist = 1000
	local temp, human, temp2 = nil, nil, nil
	for x = 1, #list do
		temp2 = list[x]
		if temp2.className == "Model" and temp2.Name ~= Character.Name then
			temp = temp2:findFirstChild("Torso")
			human = temp2:findFirstChild("Humanoid")
			if temp ~= nil and human ~= nil and human.Health > 0 and (temp.Position - pos).magnitude < dist then
				local dohit = true
				if dohit == true then
					torso = temp
					dist = (temp.Position - pos).magnitude
				end
			end
		end
	end
	return torso, dist
end

function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	
end

function ShowDamage(Pos, Text, Time, Color)
	local Rate = (1 / 30)
	local Pos = (Pos or Vector3.new(0, 0, 0))
	local Text = (Text or "")
	local Time = (Time or 2)
	local Color = (Color or Color3.new(1, 0, 1))
	local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui"){
		Size = UDim2.new(3, 0, 3, 0),
		Adornee = EffectPart,
		Parent = EffectPart,
	}
	local TextLabel = Create("TextLabel"){
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		Font = "SourceSansLight",
		TextColor3 = Color,
		TextScaled = true,
		Parent = BillboardGui,
	}
	game.Debris:AddItem(EffectPart, (Time))
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		local Frames = (Time / Rate)
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = (Frame / Frames)
			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
			TextLabel.TextTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end

function MagnitudeDamage(Part, Magnitude, MinimumDamage, MaximumDamage, KnockBack, Type, HitSound, HitPitch)
	for _, c in pairs(workspace:children()) do
		local hum = c:findFirstChild("Humanoid")
		if hum ~= nil then
			local head = c:findFirstChild("Torso")
			if head ~= nil then
				local targ = head.Position - Part.Position
				local mag = targ.magnitude
				if mag <= Magnitude and c.Name ~= Player.Name then 
					Damage(head, head, MinimumDamage, MaximumDamage, KnockBack, Type, RootPart, 0, "rbxassetid://" .. HitSound, HitPitch)
				end
			end
		end
	end
end

EffectModel = Create("Model"){
	Parent = Character,
	Name = "EffectModel",
}

Effects = {
	Block = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type, Part)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			if Type == 1 or Type == nil then
				table.insert(Effects, {
					prt,
					"Block1",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			elseif Type == 2 then
				table.insert(Effects, {
					prt,
					"Block2",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			elseif Type == 3 then
				table.insert(Effects, {
					prt,
					"Block3",
					delay,
					x3,
					y3,
					z3,
					msh,
					Part
				})
			elseif Type == 4 then
				table.insert(Effects, {
					prt,
					"Block2Fire",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			end
		end
	};

	Sphere = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, parent)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			if parent == nil then
				prt.Parent = workspace
			else
				prt.Parent = parent
			end
			local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end
	};

	Blood = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Blood",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end
	};

	Blast = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Part)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "1323306", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Block4",
				delay,
				x3,
				y3,
				z3,
				msh,
				Part
			})
		end
	};

	Ring = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end
	};

	Cylinder = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end
	};

	Head = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Head", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end
	};

	Wave = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "20329976", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end
	};

	Break = {
		Create = function(brickcolor, cframe, x1, y1, z1)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
			prt.Anchored = true
			prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
			game:GetService("Debris"):AddItem(prt, 10)
			local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			local num = math.random(10, 50) / 1000
			table.insert(Effects, {
				prt,
				"Shatter",
				num,
				prt.CFrame,
				math.random() - math.random(),
				0,
				math.random(50, 100) / 100
			})
		end
	};

	Elec = {
		Create = function(brickcolor, cff, x, y, z)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Part", Vector3.new(1, 1, 1))
			prt.Anchored = true
			prt.CFrame = cff * CFrame.new(math.random(-x * 100, x * 100) / 100, math.random(-y * 100, y * 100) / 100, math.random(-z * 100, z * 100) / 100)
			prt.CFrame = CFrame.new(prt.Position)
			game:GetService("Debris"):AddItem(prt, 10)
			xval = math.random() / 9
			yval = math.random() / 9
			zval = math.random() / 9
			msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(xval, yval, zval))
			eul1 = math.random(-50, 50)
			eul2 = math.random(-50, 50)
			eul3 = math.random(-50, 50)
			euld = CFrame.fromEulerAnglesXYZ(eul1, eul2, eul3)
			euld2 = CFrame.fromEulerAnglesXYZ(-eul1, -eul2, -eul3)
			table.insert(Effects, {
				prt,
				"Elec",
				.05,
				x,
				y,
				z,
				xval,
				yval,
				zval,
				msh,
				euld,
				euld2
			})
		end
	};

	Elec2 = {
		Create = function(brickcolor, cff, x, y, z)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Part", Vector3.new(1, 1, 1))
			prt.Anchored = true
			prt.CFrame = cff * CFrame.new(math.random(-x * 100, x * 100) / 100, math.random(-y * 100, y * 100) / 100, math.random(-z * 100, z * 100) / 100)
			prt.CFrame = CFrame.new(prt.Position)
			game:GetService("Debris"):AddItem(prt, 10)
			xval = math.random() / 7
			yval = math.random() / 7
			zval = math.random() / 7
			msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(xval, yval, zval))
			eul1 = math.random(-50, 50)
			eul2 = math.random(-50, 50)
			eul3 = math.random(-50, 50)
			euld = CFrame.fromEulerAnglesXYZ(eul1, eul2, eul3)
			euld2 = CFrame.fromEulerAnglesXYZ(-eul1, -eul2, -eul3)
			table.insert(Effects, {
				prt,
				"Elec",
				.1,
				x,
				y,
				z,
				xval,
				yval,
				zval,
				msh,
				euld,
				euld2
			})
		end
	};

	Clone = {
		Create = function() 
			for _, v in pairs(Torso.Parent:children()) do
				if v.className == "Part" and v.Name ~= "HumanoidRootPart" then
					local c = CFuncs.Part.Create(EffectModel, "Neon", 0, .5, BrickColor.new("Bright blue"), "Effect", v.Size)
					c.Anchored = true
					c.CFrame = v.CFrame
					game:GetService("Debris"):AddItem(c, 5)
					local cmsh = nil
					if v.Name == "Head" then
						cmsh = CFuncs.Mesh.Create("SpecialMesh", c, "Head", "", Vector3.new(0, 0, 0), v.Mesh.Scale)
					else
						cmsh = CFuncs.Mesh.Create("BlockMesh", c, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
					end
					table.insert(Effects, {
						c,
						"Cylinder",
						0.05,
						0.1,
						0.1,
						0.1,
						cmsh
					})
				end
			end
		end
	};

	EffectTemplate = {

	};
}


Laser = function(brickcolor, reflect, cframe, x1, y1, z1, x3, y3, z3, delay)
	
	prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", reflect, 0, brickcolor, "Effect", Vector3.new(.1, 0.5, 0.1))
	prt.Anchored = true
	prt.CFrame = cframe
	prt.Material = "Neon"
	local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 1)
	coroutine.resume(coroutine.create(function(Part, Mesh)
		
		for i = 0, 1, delay do
			swait()
			Part.Transparency = i
			Mesh.Scale = Mesh.Scale + Vector3.new(x3, y3, z3)
		end
		Part.Parent = nil
	end
), prt, msh)
end

wshoot = function(mouse, aoe , partt, SpreadAmount, multiply)
	
	local SpreadVectors = Vector3.new(math.random(-SpreadAmount, SpreadAmount), math.random(-SpreadAmount, SpreadAmount), math.random(-SpreadAmount, SpreadAmount))
	local MainPos = partt.Position
	local MainPos2 = mouse.Hit.p + SpreadVectors
	local MouseLook = CFrame.new((MainPos + MainPos2) / 2, MainPos2)
	local speed = 1000
	local num = .5
	coroutine.resume(coroutine.create(function()
		
		repeat
			swait()
			local hit, pos = RayCast(MainPos, MouseLook.lookVector, speed, RootPart.Parent)
			local mag = (MainPos - pos).magnitude                                                            
			Laser(BrickColor.new("Gold"), 0, CFrame.new((MainPos + pos)/2, pos) * CFrame.Angles(1.57, 0, 0), 5, mag * (speed / (speed / 2)), .2, .2, 0, .2, 0.1)
			MainPos = MainPos + MouseLook.lookVector * speed
			num = num - 1
			MouseLook = MouseLook * CFrame.Angles(math.rad(-1), 0, 0)
			if hit ~= nil then
									if hit.Name == "Torso" or hit.Name == "Right Leg" or hit.Name == "Left Leg" or hit.Name == "Right Arm" or hit.Name == "Left Arm" then
				num = 0
				local refpart = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 1, "Really black", "Effect", Vector3.new())
				refpart.Anchored = true
				refpart.CFrame = CFrame.new(pos)
				local hitsound = math.random(1,3)
				if hitsound == 1 then
					CFuncs.Sound.Create("898398743", refpart, .5, 1)
						elseif hitsound == 2 then
							CFuncs.Sound.Create("898398730", refpart, .5, 1)	
								elseif hitsound == 3 then
									CFuncs.Sound.Create("898398706", refpart, .5, 1)
				end
local smonk = Instance.new("ParticleEmitter",refpart)
			smonk.LightEmission = .1
			smonk.Size = NumberSequence.new(0.2)
			smonk.Texture = "http://www.roblox.com/asset/?ID=256293532"
			aaa = NumberSequence.new({NumberSequenceKeypoint.new(0, .2),NumberSequenceKeypoint.new(1, 1)})
			bbb = NumberSequence.new({NumberSequenceKeypoint.new(0, .3),NumberSequenceKeypoint.new(0.0636, 0), NumberSequenceKeypoint.new(1, 1)})
			smonk.Transparency = bbb
			smonk.Size = aaa
			smonk.ZOffset = 0
			smonk.Acceleration = Vector3.new(0, -5, 0)
			smonk.LockedToPart = false
			smonk.EmissionDirection = "Back"
			smonk.Lifetime = NumberRange.new(.1, .5)
			smonk.Rate = 50
			smonk.Rotation = NumberRange.new(-100, 100)
			smonk.RotSpeed = NumberRange.new(-100, 100)
			smonk.Speed = NumberRange.new(4)
			smonk.VelocitySpread = 50
			smonk.Enabled=true
game:GetService("Debris"):AddItem(smonk, .3)
							elseif hit.Name == "Head" then
						num = 0
				local refpart = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 1, "Really black", "Effect", Vector3.new())
				refpart.Anchored = true
				refpart.CFrame = CFrame.new(pos)
				game:GetService("Debris"):AddItem(refpart, 2)
            local smonk = Instance.new("ParticleEmitter",refpart)
			smonk.LightEmission = .1
			smonk.Size = NumberSequence.new(0.2)
			smonk.Texture = "http://www.roblox.com/asset/?ID=256293532"
			aaa = NumberSequence.new({NumberSequenceKeypoint.new(0, .2),NumberSequenceKeypoint.new(1, 1.5)})
			bbb = NumberSequence.new({NumberSequenceKeypoint.new(0, .3),NumberSequenceKeypoint.new(0.0636, 0), NumberSequenceKeypoint.new(1, 1)})
			smonk.Transparency = bbb
			smonk.Size = aaa
			smonk.ZOffset = 0
			smonk.Acceleration = Vector3.new(0, -5, 0)
			smonk.LockedToPart = false
			smonk.EmissionDirection = "Back"
			smonk.Lifetime = NumberRange.new(.1, .5)
			smonk.Rate = 50
			smonk.Rotation = NumberRange.new(-100, 100)
			smonk.RotSpeed = NumberRange.new(-100, 100)
			smonk.Speed = NumberRange.new(4)
			smonk.VelocitySpread = 100
			smonk.Enabled=true
game:GetService("Debris"):AddItem(smonk, .3)
				else
					num = 0
				local refpart = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 1, "Really black", "Effect", Vector3.new())
				refpart.Anchored = true
				refpart.CFrame = CFrame.new(pos)
			        CFuncs.Sound.Create("342190504", prt, 1, 1)
				game:GetService("Debris"):AddItem(refpart, 0)		
				end
				end
			do
				if num <= 0 then
					local refpart = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 1, 1, "Really black", "Effect", Vector3.new())
					refpart.Anchored = true
					refpart.CFrame = CFrame.new(pos)
					if hit ~= nil then
		MagnitudeDamage(refpart, 5, 2, 2, .01, "Normal", " ", 1)			
					end
					game:GetService("Debris"):AddItem(refpart, 1)
				end
			end
		until num <= 0
	end
))
end



shoot = function(mouse, aoe , partt, SpreadAmount, multiply)
	
	local SpreadVectors = Vector3.new(math.random(-SpreadAmount, SpreadAmount), math.random(-SpreadAmount, SpreadAmount), math.random(-SpreadAmount, SpreadAmount))
	local MainPos = partt.Position
	local MainPos2 = mouse.Hit.p + SpreadVectors
	local MouseLook = CFrame.new((MainPos + MainPos2) / 2, MainPos2)
	local speed = 1000
	local num = .5
	coroutine.resume(coroutine.create(function()
		
		repeat
			swait()
			local hit, pos = RayCast(MainPos, MouseLook.lookVector, speed, RootPart.Parent)
			local mag = (MainPos - pos).magnitude                                                            
			Laser(BrickColor.new("Gold"), 0, CFrame.new((MainPos + pos)/2, pos) * CFrame.Angles(1.57, 0, 0), 5, mag * (speed / (speed / 2)), .2, .2, 0, .2, 0.1)
			MainPos = MainPos + MouseLook.lookVector * speed
			num = num - 1
			MouseLook = MouseLook * CFrame.Angles(math.rad(-1), 0, 0)
			if hit ~= nil then
									if hit.Name == "Torso" or hit.Name == "Right Leg" or hit.Name == "Left Leg" or hit.Name == "Right Arm" or hit.Name == "Left Arm" then
				num = 0
				local refpart = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 1, "Really black", "Effect", Vector3.new())
				refpart.Anchored = true
				refpart.CFrame = CFrame.new(pos)
				local hitsound = math.random(1,3)
				if hitsound == 1 then
					CFuncs.Sound.Create("898398743", refpart, .5, 1)
						elseif hitsound == 2 then
							CFuncs.Sound.Create("898398730", refpart, .5, 1)	
								elseif hitsound == 3 then
									CFuncs.Sound.Create("898398706", refpart, .5, 1)
				end
local smonk = Instance.new("ParticleEmitter",refpart)
			smonk.LightEmission = .1
			smonk.Size = NumberSequence.new(0.2)
			smonk.Texture = "http://www.roblox.com/asset/?ID=256293532"
			aaa = NumberSequence.new({NumberSequenceKeypoint.new(0, .2),NumberSequenceKeypoint.new(1, 1)})
			bbb = NumberSequence.new({NumberSequenceKeypoint.new(0, .3),NumberSequenceKeypoint.new(0.0636, 0), NumberSequenceKeypoint.new(1, 1)})
			smonk.Transparency = bbb
			smonk.Size = aaa
			smonk.ZOffset = 0
			smonk.Acceleration = Vector3.new(0, -5, 0)
			smonk.LockedToPart = false
			smonk.EmissionDirection = "Back"
			smonk.Lifetime = NumberRange.new(.1, .5)
			smonk.Rate = 50
			smonk.Rotation = NumberRange.new(-100, 100)
			smonk.RotSpeed = NumberRange.new(-100, 100)
			smonk.Speed = NumberRange.new(4)
			smonk.VelocitySpread = 50
			smonk.Enabled=true
game:GetService("Debris"):AddItem(smonk, .3)
							elseif hit.Name == "Head" then
						num = 0
				local refpart = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 1, "Really black", "Effect", Vector3.new())
				refpart.Anchored = true
				refpart.CFrame = CFrame.new(pos)
				game:GetService("Debris"):AddItem(refpart, 2)
            local smonk = Instance.new("ParticleEmitter",refpart)
			smonk.LightEmission = .1
			smonk.Size = NumberSequence.new(0.2)
			smonk.Texture = "http://www.roblox.com/asset/?ID=256293532"
			aaa = NumberSequence.new({NumberSequenceKeypoint.new(0, .2),NumberSequenceKeypoint.new(1, 1.5)})
			bbb = NumberSequence.new({NumberSequenceKeypoint.new(0, .3),NumberSequenceKeypoint.new(0.0636, 0), NumberSequenceKeypoint.new(1, 1)})
			smonk.Transparency = bbb
			smonk.Size = aaa
			smonk.ZOffset = 0
			smonk.Acceleration = Vector3.new(0, -5, 0)
			smonk.LockedToPart = false
			smonk.EmissionDirection = "Back"
			smonk.Lifetime = NumberRange.new(.1, .5)
			smonk.Rate = 50
			smonk.Rotation = NumberRange.new(-100, 100)
			smonk.RotSpeed = NumberRange.new(-100, 100)
			smonk.Speed = NumberRange.new(4)
			smonk.VelocitySpread = 100
			smonk.Enabled=true
game:GetService("Debris"):AddItem(smonk, .3)
				else
					num = 0
				local refpart = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 1, "Really black", "Effect", Vector3.new())
				refpart.Anchored = true
				refpart.CFrame = CFrame.new(pos)
			        CFuncs.Sound.Create("342190504", prt, 1, 1)
				game:GetService("Debris"):AddItem(refpart, 0)		
				end
				end
			do
				if num <= 0 then
					local refpart = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 1, 1, "Really black", "Effect", Vector3.new())
					refpart.Anchored = true
					refpart.CFrame = CFrame.new(pos)
					if hit ~= nil then
		MagnitudeDamage(refpart, 3, 2, 5, 0, "Normal", " ", 1)			
					end
					game:GetService("Debris"):AddItem(refpart, 1)
				end
			end
		until num <= 0
	end
))
end





function fire()
	Attack = true	
	Humanoid.WalkSpeed = 8
    Humanoid.JumpPower = 0
Humanoid.AutoRotate = false
		local bodygyro = Instance.new("BodyGyro",RootPart)
		bodygyro.MaxTorque = Vector3.new(50000,50000,50000)
				bodygyro.P = 8000
				CFuncs.Sound.Create("873073703", Handle, 1, 1)
	for i = 0, 1, 0.1 do
		swait()
		PlayAnimationFromTable({
         CFrame.new(0.757158816, 0.024620086, -0.316807836, 0.00376787782, -0.197771132, 0.98024106, -0.0522153527, 0.978872001, 0.197695583, -0.998628855, -0.0519285128, -0.00663840771) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),  
         CFrame.new(0.0513084419, 1.52798402, -0.0491129272, 0.503341198, 0.0593924709, -0.862044334, -0.0388650261, 0.998181403, 0.0460789353, 0.86321336, 0.0103099495, 0.504734159) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(1.62060225, 0.561005533, -0.67263329, 0.184799463, -0.818805337, -0.543513656, -0.980174243, -0.113341682, -0.162518218, 0.0714680403, 0.56277138, -0.823517323) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.181243077, 0.716829836, -0.982703269, 0.117607087, -0.980847061, -0.15526706, -0.30332914, 0.113398649, -0.946114302, 0.945600331, 0.158366859, -0.284183025) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.628674686, -1.98509169, -0.25950858, 1.00000024, 0, 0, -7.4505806e-09, 0.98480773, -0.173648342, -2.98023224e-08, 0.173648342, 0.984807909) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.442586422, -1.94206905, -0.503501356, 0.984808087, 0, -0.173647165, -0.0301535428, 0.98480773, -0.171010256, 0.171009004, 0.173648342, 0.969846487) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
		bodygyro.CFrame = CFrame.new(RootPart.Position, Vector3.new(Mouse.Hit.p.X, RootPart.Position.Y, Mouse.Hit.p.Z))
	end
	
	AmmoCount = AmmoCount - AmmoUsage
	for i = 0, 9, 1 do
shoot(Mouse, 3 , bulletmaker, .15 + (Torso.Position - Mouse.Hit.p).magnitude/math.random(17,20) , 0)
	end
	Torso.Velocity=RootPart.CFrame.lookVector*-20
	Effects.Block.Create(BrickColor.new("Flame reddish orange"), bulletmaker.CFrame, .5, .5, .5, .5, .5, .5, .1, 1)
	CFuncs.Sound.Create("1132379030", Handle, 1, 1)
		bodygyro:Destroy()
	for i = 0, 1, 0.1 do
		swait()
		PlayAnimationFromTable({
         CFrame.new(0.588929892, -1.11013651e-06, -0.0153462738, 0.466293842, -0.234925136, 0.85287708, 0.171010062, 0.969846427, 0.17364794, -0.867954016, 0.0648796037, 0.492407978) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.160780251, 1.50000441, 0.0393266231, 0.488946259, -0.0697783977, -0.869518578, -0.125678584, 0.980760813, -0.149376884, 0.863213003, 0.182317138, 0.470769644) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(1.67061281, 0.704267323, -0.691583157, 0.423231184, -0.709484339, -0.563477933, -0.879032731, -0.472217411, -0.065669328, -0.219492719, 0.52310884, -0.823517084) * CFrame.new(-.2, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.0540117994, 0.73741293, -0.982708097, 0.0631480217, -0.978079677, 0.198425397, -0.319141895, -0.208172753, -0.924560905, 0.945600986, -0.00494170189, -0.325291872) * CFrame.new(0, 1, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.378202379, -1.77786493, -0.298971295, 0.837791204, 0.33804059, -0.428759336, -0.235888705, 0.932314754, 0.274127543, 0.492404819, -0.128522187, 0.860825062) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.773099661, -1.83571112, -0.503498793, 0.964610457, 0.171010062, -0.200704694, -0.200705469, 0.969846427, -0.138258308, 0.171009183, 0.17364794, 0.969846606) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
	end
	Humanoid.AutoRotate = true
	CFuncs.Sound.Create("131072992", Handle, 1, 1)
		for i = 0, 1, 0.1 do
		swait()
		PlayAnimationFromTable({
         CFrame.new(0.588927984, -1.34110451e-07, -0.0153470635, 0.500004232, -0.15038535, 0.852876961, 0, 0.98480773, 0.173648342, -0.86603415, -0.0868248865, 0.492408037) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.0697273612, 1.49668336, 0.0200494975, 0.503342092, 0.208182395, -0.838634133, -0.0388649404, 0.975015461, 0.218711212, 0.863212883, -0.0774930716, 0.49885726) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(1.51687121, 0.252128333, -0.305914342, -0.106392592, -0.288472205, -0.951559067, -0.959828019, 0.279683411, 0.0225289911, 0.259636283, 0.915729821, -0.306639969) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.342295825, 0.26239565, -1.10844982, 0.117607087, -0.938983917, -0.323230654, -0.30332914, 0.275967002, -0.912049174, 0.945600331, 0.205308735, -0.2523655) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.54057467, -1.946859, -0.234844446, 0.866025031, 0, -0.500000834, -0.0868243054, 0.98480773, -0.15038377, 0.49240464, 0.173648342, 0.85286808) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.44258678, -1.94206941, -0.503499508, 0.984808087, 0, -0.173647165, -0.0301535428, 0.98480773, -0.171010256, 0.171009004, 0.173648342, 0.969846487) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
		end
				local shell = CFuncs.Part.Create(EffectModel, "SmoothPlastic", .1, 0, "Bright red", "Effect", Vector3.new(.5,.8,.5))
				local shllmsh = CFuncs.Mesh.Create("CylinderMesh", shell, "", "", Vector3.new(0, 0, 0), Vector3.new(.3, .4, .3))
				shell.Anchored = false
				shell.Position = Shellmaker.Position
				shell.CanCollide = true
				shell.Velocity=RootPart.CFrame.rightVector*20
				game:GetService("Debris"):AddItem(shell, 3)
				local shellsound = math.random(1,2)
				if shellsound == 1 then
				    CFuncs.Sound.Create("1132378823", shell, .5, 1)
				elseif shellsound  == 2 then
					CFuncs.Sound.Create("1132378791", shell, .5, 1)
				end
	for i = 0, 1, 0.1 do
		swait()
		PlayAnimationFromTable({
         CFrame.new(0.588927984, -1.34110451e-07, -0.0153470635, 0.500004232, -0.15038535, 0.852876961, 0, 0.98480773, 0.173648342, -0.86603415, -0.0868248865, 0.492408037) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.0697273612, 1.49668336, 0.0200494975, 0.503342092, 0.208182395, -0.838634133, -0.0388649404, 0.975015461, 0.218711212, 0.863212883, -0.0774930716, 0.49885726) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(1.64014888, 0.224238992, -0.403565288, 0.0212229788, -0.603865683, -0.796803713, -0.989261985, 0.102589145, -0.104097351, 0.144604191, 0.790456831, -0.595203996) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.522896647, 0.315473199, -1.06896186, 0.117607087, -0.938983917, -0.323230654, -0.30332914, 0.275967002, -0.912049174, 0.945600331, 0.205308735, -0.2523655) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.54057467, -1.946859, -0.234844446, 0.866025031, 0, -0.500000834, -0.0868243054, 0.98480773, -0.15038377, 0.49240464, 0.173648342, 0.85286808) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.44258678, -1.94206941, -0.503499508, 0.984808087, 0, -0.173647165, -0.0301535428, 0.98480773, -0.171010256, 0.171009004, 0.173648342, 0.969846487) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
	end
	for i = 0, .2, 0.1 do
	swait()
			PlayAnimationFromTable({
         CFrame.new(0.038382329, -2.14204192e-08, -0.0314837135, 0.984807849, 0.0301536452, 0.171009868, 0, 0.98480773, -0.173648119, -0.173647985, 0.171010017, 0.969846368) * CFrame.new(0, 0 + 0.05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0 + 0.005 * math.cos(Sine/25), 0), 
          CFrame.new(-0.00987245888, 1.54137087, -0.232474566, 0.983905733, 0.0593912564, -0.168529823, 0.000888057693, 0.941511214, 0.336980611, 0.17868638, -0.331706822, 0.926305413) * CFrame.new(0, 0, 0) * CFrame.Angles(0 - 0.05 * math.cos(Sine/25), 0, 0), 
         CFrame.new(1.00599754, 0.00645497441, -0.987730443, 0.387630165, 0.322637081, -0.863509297, -0.802340508, 0.579304218, -0.143723249, 0.453864068, 0.748539925, 0.483420581) * CFrame.new(0, 0 + 0.02 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.927108586, 0.209949538, -0.179899275, 0.68265909, -0.539921403, -0.492403984, -0.24406442, 0.4666816, -0.850082874, 0.688773632, 0.700495183, 0.18680881) * CFrame.new(0, 0 + 0.02 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.628665984, -2.00964737, 0.120245621, 1.00000012, 0, 0, 1.86264515e-09, 0.98480773, 0.173648119, 0, -0.173648119, 0.984807849) * CFrame.new(0, 0 - 0.05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.44258371, -1.99715459, 0.19109571, 0.939692676, 0, 0.342020601, -0.0593912229, 0.98480773, 0.163175851, -0.336824536, -0.173648119, 0.925416529) * CFrame.new(0, 0 - 0.05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
	end
Humanoid.WalkSpeed = 16
Humanoid.JumpPower = 60
	Attack = false
end


function dryfire()
	Attack = true	
	Humanoid.WalkSpeed = 8
    Humanoid.JumpPower = 0
Humanoid.AutoRotate = false
		local bodygyro = Instance.new("BodyGyro",RootPart)
		bodygyro.MaxTorque = Vector3.new(50000,50000,50000)
				bodygyro.P = 8000
				CFuncs.Sound.Create("873073703", Handle, 1, 1)
	for i = 0, 1, 0.1 do
		swait()
		PlayAnimationFromTable({
         CFrame.new(0.757158816, 0.024620086, -0.316807836, 0.00376787782, -0.197771132, 0.98024106, -0.0522153527, 0.978872001, 0.197695583, -0.998628855, -0.0519285128, -0.00663840771) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),  
         CFrame.new(0.0513084419, 1.52798402, -0.0491129272, 0.503341198, 0.0593924709, -0.862044334, -0.0388650261, 0.998181403, 0.0460789353, 0.86321336, 0.0103099495, 0.504734159) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(1.62060225, 0.561005533, -0.67263329, 0.184799463, -0.818805337, -0.543513656, -0.980174243, -0.113341682, -0.162518218, 0.0714680403, 0.56277138, -0.823517323) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.181243077, 0.716829836, -0.982703269, 0.117607087, -0.980847061, -0.15526706, -0.30332914, 0.113398649, -0.946114302, 0.945600331, 0.158366859, -0.284183025) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.628674686, -1.98509169, -0.25950858, 1.00000024, 0, 0, -7.4505806e-09, 0.98480773, -0.173648342, -2.98023224e-08, 0.173648342, 0.984807909) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.442586422, -1.94206905, -0.503501356, 0.984808087, 0, -0.173647165, -0.0301535428, 0.98480773, -0.171010256, 0.171009004, 0.173648342, 0.969846487) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
		bodygyro.CFrame = CFrame.new(RootPart.Position, Vector3.new(Mouse.Hit.p.X, RootPart.Position.Y, Mouse.Hit.p.Z))
	end
	CFuncs.Sound.Create("132464034", Handle, 1, 1)
		for i = 0, .5, 0.1 do
		swait()
		PlayAnimationFromTable({
         CFrame.new(0.757158816, 0.024620086, -0.316807836, 0.00376787782, -0.197771132, 0.98024106, -0.0522153527, 0.978872001, 0.197695583, -0.998628855, -0.0519285128, -0.00663840771) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),  
         CFrame.new(0.0513084419, 1.52798402, -0.0491129272, 0.503341198, 0.0593924709, -0.862044334, -0.0388650261, 0.998181403, 0.0460789353, 0.86321336, 0.0103099495, 0.504734159) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(1.62060225, 0.561005533, -0.67263329, 0.184799463, -0.818805337, -0.543513656, -0.980174243, -0.113341682, -0.162518218, 0.0714680403, 0.56277138, -0.823517323) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.181243077, 0.716829836, -0.982703269, 0.117607087, -0.980847061, -0.15526706, -0.30332914, 0.113398649, -0.946114302, 0.945600331, 0.158366859, -0.284183025) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.628674686, -1.98509169, -0.25950858, 1.00000024, 0, 0, -7.4505806e-09, 0.98480773, -0.173648342, -2.98023224e-08, 0.173648342, 0.984807909) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.442586422, -1.94206905, -0.503501356, 0.984808087, 0, -0.173647165, -0.0301535428, 0.98480773, -0.171010256, 0.171009004, 0.173648342, 0.969846487) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
		bodygyro.CFrame = CFrame.new(RootPart.Position, Vector3.new(Mouse.Hit.p.X, RootPart.Position.Y, Mouse.Hit.p.Z))
	end
		bodygyro:Destroy()
	Humanoid.AutoRotate = true
Humanoid.WalkSpeed = 16
Humanoid.JumpPower = 60
	Attack = false
end







function relode()
	Attack = true
	relodee = true	
Humanoid.WalkSpeed = 5
CFuncs.Sound.Create("1132378728", Handle, .5, 1)
		for i = 0, 1, 0.1 do
		swait()
		PlayAnimationFromTable({
       CFrame.new(0.038382329, -2.14204192e-08, -0.0314837135, 0.984807849, 0.0301536452, 0.171009868, 0, 0.98480773, -0.173648119, -0.173647985, 0.171010017, 0.969846368) * CFrame.new(0, 0 + 0.05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0 + 0.005 * math.cos(Sine/25), 0),  
         CFrame.new(-0.100350231, 1.4967103, -0.061891377, 0.64132297, 0.208182856, -0.738488197, -0.0762534291, 0.975015342, 0.208640277, 0.763472557, -0.0774935335, 0.641174316) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),  
         CFrame.new(1.07593381, -0.046435535, 0.399106979, -0.603867352, -0.0212483108, -0.796801686, 0.102590129, 0.989258587, -0.104129925, 0.790455341, -0.144624621, -0.595201015) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.52289784, 0.315474898, -1.0689652, 0.117606997, -0.938983917, -0.323230416, -0.303329468, 0.275966793, -0.912049174, 0.945600212, 0.205308646, -0.252365857) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.628665984, -2.00964737, 0.120245621, 1.00000012, 0, 0, 1.86264515e-09, 0.98480773, 0.173648119, 0, -0.173648119, 0.984807849) * CFrame.new(0, 0 - 0.05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.44258371, -1.99715459, 0.19109571, 0.939692676, 0, 0.342020601, -0.0593912229, 0.98480773, 0.163175851, -0.336824536, -0.173648119, 0.925416529) * CFrame.new(0, 0 - 0.05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
		fHandleWeld.C0 = clerp(fHandleWeld.C0, CFrame.new(-.4, .2, 0) * CFrame.Angles(math.rad(90), math.rad(5), math.rad(90)), 0.3)
		end	
	for i = 0, 1, 0.1 do
		swait()
		PlayAnimationFromTable({
       CFrame.new(0.038382329, -2.14204192e-08, -0.0314837135, 0.984807849, 0.0301536452, 0.171009868, 0, 0.98480773, -0.173648119, -0.173647985, 0.171010017, 0.969846368) * CFrame.new(0, 0 + 0.05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0 + 0.005 * math.cos(Sine/25), 0),  
         CFrame.new(-0.100350231, 1.4967103, -0.061891377, 0.64132297, 0.208182856, -0.738488197, -0.0762534291, 0.975015342, 0.208640277, 0.763472557, -0.0774935335, 0.641174316) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(1.28816545, 0.371927321, -0.785959482, 0.833941579, -0.0145216882, -0.551661849, -0.529568017, -0.302267253, -0.79258585, -0.155239552, 0.953112662, -0.25976342) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.522895455, 0.31547451, -1.06896842, -0.0472328961, -0.986910462, -0.154198274, -0.250799775, 0.161142588, -0.954532683, 0.966886103, -0.0064124465, -0.255128086) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.628665984, -2.00964737, 0.120245621, 1.00000012, 0, 0, 1.86264515e-09, 0.98480773, 0.173648119, 0, -0.173648119, 0.984807849) * CFrame.new(0, 0 - 0.05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.44258371, -1.99715459, 0.19109571, 0.939692676, 0, 0.342020601, -0.0593912229, 0.98480773, 0.163175851, -0.336824536, -0.173648119, 0.925416529) * CFrame.new(0, 0 - 0.05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
		fHandleWeld.C0 = clerp(fHandleWeld.C0, CFrame.new(-.4, .2, 0) * CFrame.Angles(math.rad(90), math.rad(5), math.rad(90)), 0.3)
	end
	AmmoCount = AmmoCount + AmmoUsage
	print(AmmoCount)
    CFuncs.Sound.Create("1001714844", Handle, 1, 1)
Humanoid.WalkSpeed = 16
Humanoid.JumpPower = 60
Attack = false
end


function hop()
				Attack = true
			CFuncs.Sound.Create("158149887", Torso, 1, 1)
			Humanoid.Jump = true
			Humanoid.JumpPower = 60
				for i = 0, .5, 0.1 do
		swait()
					PlayAnimationFromTable({
         CFrame.new(-0, -1.01481628, -8.04662704e-07, 1, 0, 0, 0, 0.866025686, 0.499999642, -0, -0.499999642, 0.866025686) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0, 1.45637476, -0.213752031, 1, 0, 0, 0, 0.939692676, 0.342020601, 0, -0.342020601, 0.939692676) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(1.80887365, 0.563777864, 0.393151999, 0.642787039, -0.766044915, -1.2109125e-06, 0.754407167, 0.633021533, 0.173648313, -0.133021653, -0.111619815, 0.984807789) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-1.67181289, 0.594474256, -0.03263852, 0.499999285, 0.866025865, 1.98491279e-07, -0.750001073, 0.433012605, -0.499998599, -0.43301177, 0.249998808, 0.866026282) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.5, -1.80666828, -0.689023316, 1, 0, 0, 0, 0.984807849, 0.173648134, 0, -0.173648164, 0.984807849) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.5, -1.42673647, -0.144118369, 1, 0, 0, 0, 0.766044736, 0.642787457, 0, -0.642787457, 0.766044736) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
					}, .3, false)
				end
				Torso.Velocity=RootPart.CFrame.lookVector*100
	for i = 0, .9, 0.1 do
		swait()
		PlayAnimationFromTable({
         CFrame.new(0.708232701, 0.127894983, 0.246774122, 0.76604414, -0.111618884, 0.633022666, 0, 0.984807849, 0.173648044, -0.642788053, -0.13302207, 0.754406214) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.0324593484, 1.43977821, -0.119624585, 0.995960355, -0.0868238062, -0.0229113102, 0.0894833133, 0.938373625, 0.333838284, -0.00748568773, -0.334539831, 0.942351937) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(1.69410944, 0.329396009, -0.667013586, 0.977326989, -0.133022755, 0.164733544, 0.196574897, 0.280932605, -0.939380229, 0.0786799788, 0.95046401, 0.30071193) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-1.50714529, 0.0157378055, -0.431941032, 0.884520769, 0.235685706, -0.402585804, -0.362369925, 0.890611291, -0.274772465, 0.29378742, 0.388926923, 0.873169541) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.618915975, -1.85825384, -0.515439391, 0.98480773, 0.173648864, -1.81794167e-06, -0.17101045, 0.969846725, 0.173646331, 0.0301553011, -0.171007901, 0.984808087) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.523646474, -1.39458823, -0.171092927, 0.939692676, 0.342020273, 3.57627869e-07, -0.262003183, 0.719847083, 0.642786682, 0.219845772, -0.604022026, 0.766045213) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
	end
	Torso.Velocity=RootPart.CFrame.upVector*0
Humanoid.WalkSpeed = 16
Humanoid.JumpPower = 60
	Attack = false	
end



function pump()
	Attack = true
Humanoid.WalkSpeed = 8
	CFuncs.Sound.Create("131072992", Handle, 1, 1)
		for i = 0, 1, 0.1 do
		swait()
		PlayAnimationFromTable({
         CFrame.new(0.588927984, -1.34110451e-07, -0.0153470635, 0.500004232, -0.15038535, 0.852876961, 0, 0.98480773, 0.173648342, -0.86603415, -0.0868248865, 0.492408037) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.0697273612, 1.49668336, 0.0200494975, 0.503342092, 0.208182395, -0.838634133, -0.0388649404, 0.975015461, 0.218711212, 0.863212883, -0.0774930716, 0.49885726) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(1.51687121, 0.252128333, -0.305914342, -0.106392592, -0.288472205, -0.951559067, -0.959828019, 0.279683411, 0.0225289911, 0.259636283, 0.915729821, -0.306639969) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.342295825, 0.26239565, -1.10844982, 0.117607087, -0.938983917, -0.323230654, -0.30332914, 0.275967002, -0.912049174, 0.945600331, 0.205308735, -0.2523655) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.54057467, -1.946859, -0.234844446, 0.866025031, 0, -0.500000834, -0.0868243054, 0.98480773, -0.15038377, 0.49240464, 0.173648342, 0.85286808) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.44258678, -1.94206941, -0.503499508, 0.984808087, 0, -0.173647165, -0.0301535428, 0.98480773, -0.171010256, 0.171009004, 0.173648342, 0.969846487) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
		fHandleWeld.C0 = clerp(fHandleWeld.C0, CFrame.new(-.4, .2, 0) * CFrame.Angles(math.rad(90), math.rad(-5), math.rad(90)), 0.3)
		end
	for i = 0, 1, 0.1 do
		swait()
		PlayAnimationFromTable({
         CFrame.new(0.588927984, -1.34110451e-07, -0.0153470635, 0.500004232, -0.15038535, 0.852876961, 0, 0.98480773, 0.173648342, -0.86603415, -0.0868248865, 0.492408037) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.0697273612, 1.49668336, 0.0200494975, 0.503342092, 0.208182395, -0.838634133, -0.0388649404, 0.975015461, 0.218711212, 0.863212883, -0.0774930716, 0.49885726) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(1.64014888, 0.224238992, -0.403565288, 0.0212229788, -0.603865683, -0.796803713, -0.989261985, 0.102589145, -0.104097351, 0.144604191, 0.790456831, -0.595203996) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.522896647, 0.315473199, -1.06896186, 0.117607087, -0.938983917, -0.323230654, -0.30332914, 0.275967002, -0.912049174, 0.945600331, 0.205308735, -0.2523655) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.54057467, -1.946859, -0.234844446, 0.866025031, 0, -0.500000834, -0.0868243054, 0.98480773, -0.15038377, 0.49240464, 0.173648342, 0.85286808) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.44258678, -1.94206941, -0.503499508, 0.984808087, 0, -0.173647165, -0.0301535428, 0.98480773, -0.171010256, 0.171009004, 0.173648342, 0.969846487) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
		fHandleWeld.C0 = clerp(fHandleWeld.C0, CFrame.new(-.4, .2, 0) * CFrame.Angles(math.rad(90), math.rad(-5), math.rad(90)), 0.3)
	end	
Humanoid.WalkSpeed = 16
Humanoid.JumpPower = 60
	Attack = false
end


function patchedup()
	Attack = true
Humanoid.WalkSpeed = 0
Humanoid.JumpPower = 0
		for i = 0, .5, 0.1 do
		swait()
		PlayAnimationFromTable({
         CFrame.new(0.0266105551, -0.00228797412, -0.00301300199, 0.984924495, 0.00856173038, 0.172772706, -0.0739319623, 0.923793733, 0.375685036, -0.156389832, -0.382794857, 0.91050005) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.0833636597, 1.5589056, -0.0514357612, 0.983785033, 0.098459132, -0.149909437, -0.0804414302, 0.989283204, 0.121852726, 0.160300359, -0.107818037, 0.98116219) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(1.75938904, 0.357653558, -0.556756616, 0.863215625, -0.470763803, -0.182319537, -0.20867531, -0.00388178229, -0.977977395, 0.459688604, 0.882250845, -0.101587564) * CFrame.new(0, 0 + 0.02 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-1.14530098, -0.0176402628, -0.497072637, 0.927982748, -0.326782674, -0.179056004, 0.238273218, 0.889843524, -0.389107317, 0.286485285, 0.318420619, 0.903622985) * CFrame.new(0, 0 + 0.02 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.600150764, -1.42493248, -0.842450619, 0.983785033, 0.0984595343, -0.149909154, -0.0804414302, 0.989282846, 0.121855408, 0.160300359, -0.10782069, 0.981161833) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.608668685, -1.83582413, -0.778081357, 0.983785033, 0.0412500128, -0.174543589, -0.0804414302, 0.971299112, -0.22384648, 0.160300359, 0.234257326, 0.958867729) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
		end
		
			local heals2 = Instance.new("ParticleEmitter",LeftArm)
			heals2.Size = NumberSequence.new(.5,0)
			heals2.Texture = "rbxassetid://242856226"
			heals2.ZOffset = 0
			heals2.Acceleration = Vector3.new(0, -5, 0)
			heals2.Lifetime = NumberRange.new(1)
			heals2.Rate = 5
			heals2.Rotation = NumberRange.new(0, 0)
			heals2.RotSpeed = NumberRange.new(0, 0)
			heals2.Speed = NumberRange.new(2)
			heals2.VelocitySpread = 10
			heals2.Enabled=true
			heals2.EmissionDirection = "Front"
			local particol1 = Color3.new(0,1,0)
			local particol2 = Color3.new(1,1,1)
            heals2.Color = ColorSequence.new(particol1,particol2)
 			game:GetService("Debris"):AddItem(heals2, 3.5)
 			CFuncs.Sound.Create("1489909826", LeftArm, 1, .9)
				for i = 0, 4, 1 do
			for i = 0, .5, 0.1 do
		swait()
		PlayAnimationFromTable({
         CFrame.new(-0, -1.04790533, -1.78813934e-07, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0 + 0.005 * math.cos(Sine/25), 0), 
         CFrame.new(0, 1.53909004, -0.194619089, 1, 0, 0, 0, 0.939692736, 0.342019886, 0, -0.342019916, 0.939692736) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0 - 0.08 * math.cos(Sine/25), 0), 
         CFrame.new(0.587695718, 0.719740391, -0.886763453, -0.226821065, 0.740158081, -0.633023083, -0.919379234, -0.377204776, -0.111617722, -0.321394086, 0.556670964, 0.766043901) * CFrame.new(0, 0 + 0.05 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.178292572, 0.354673386, -1.05802333, 0.173647001, -0.984807968, 0, 0, 0, -1, 0.984807968, 0.173647001, 0) * CFrame.new(0, 0 + 0.02 * math.cos(Sine/25), 0 + 0.05 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.5, -1.50897241, 0.416451782, 1, 0, 0, 0, 0.173647985, 0.984807849, 0, -0.984807849, 0.173647985) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.5, -1.0367974, -0.558902025, 1, 0, -0, 0, 0.984807849, -0.173647985, 0, 0.173647985, 0.984807849) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
			end
				for i = 0, .5, 0.1 do
		swait()
		PlayAnimationFromTable({
         CFrame.new(-0, -1.04790533, -1.78813934e-07, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849) * CFrame.new(0, 0 + 0.005 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0, 1.53909004, -0.194619089, 1, 0, 0, 0, 0.939692736, 0.342019886, 0, -0.342019916, 0.939692736) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0 - 0.08 * math.cos(Sine/25), 0), 
         CFrame.new(0.579867244, 0.441816211, -1.01476061, 0.218706101, 0.498854131, -0.838637173, -0.975016475, 0.0774877518, -0.208179355, -0.0388670191, 0.863215089, 0.503337979) * CFrame.new(0, 0 + 0.05 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.178292572, 0.354673386, -1.05802333, 0.173647001, -0.984807968, 0, 0, 0, -1, 0.984807968, 0.173647001, 0) * CFrame.new(0, 0 + 0.02 * math.cos(Sine/25), 0 + 0.05 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.5, -1.50897241, 0.416451782, 1, 0, 0, 0, 0.173647985, 0.984807849, 0, -0.984807849, 0.173647985) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.5, -1.0367974, -0.558902025, 1, 0, -0, 0, 0.984807849, -0.173647985, 0, 0.173647985, 0.984807849) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
	end
				for i = 0, .5, 0.1 do
		swait()
		PlayAnimationFromTable({         
			CFrame.new(-0, -1.04790533, -1.78813934e-07, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849) * CFrame.new(0, 0 + 0.005 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0, 1.53909004, -0.194619089, 1, 0, 0, 0, 0.939692736, 0.342019886, 0, -0.342019916, 0.939692736) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0 - 0.08 * math.cos(Sine/25), 0), 
         CFrame.new(0.684166193, 0.417331696, -0.85110873, 0.302008986, 0.453297824, -0.838636816, -0.946748018, 0.245620534, -0.208179712, 0.111619003, 0.856849909, 0.503338397) * CFrame.new(0, 0 + 0.05 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.178292572, 0.354673386, -1.05802333, 0.173647001, -0.984807968, 0, 0, 0, -1, 0.984807968, 0.173647001, 0) * CFrame.new(0, 0 + 0.02 * math.cos(Sine/25), 0 + 0.05 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.5, -1.50897241, 0.416451782, 1, 0, 0, 0, 0.173647985, 0.984807849, 0, -0.984807849, 0.173647985) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.5, -1.0367974, -0.558902025, 1, 0, -0, 0, 0.984807849, -0.173647985, 0, 0.173647985, 0.984807849) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
				end
					for i = 0, .5, 0.1 do
		swait()
		PlayAnimationFromTable({
                  CFrame.new(-0, -1.04790533, -1.78813934e-07, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849) * CFrame.new(0, 0 + 0.005 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0, 1.53909004, -0.194619089, 1, 0, 0, 0, 0.939692736, 0.342019886, 0, -0.342019916, 0.939692736) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0 - 0.08 * math.cos(Sine/25), 0), 
         CFrame.new(0.889964521, 0.489984095, -0.478169471, 0.218706101, 0.498854131, -0.838637173, -0.975016475, 0.0774877518, -0.208179355, -0.0388670191, 0.863215089, 0.503337979) * CFrame.new(0, 0 + 0.05 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.178292572, 0.354673386, -1.05802333, 0.173647001, -0.984807968, 0, 0, 0, -1, 0.984807968, 0.173647001, 0) * CFrame.new(0, 0 + 0.02 * math.cos(Sine/25), 0 + 0.05 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.5, -1.50897241, 0.416451782, 1, 0, 0, 0, 0.173647985, 0.984807849, 0, -0.984807849, 0.173647985) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.5, -1.0367974, -0.558902025, 1, 0, -0, 0, 0.984807849, -0.173647985, 0, 0.173647985, 0.984807849) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
					end
				end
		Attack = false
Humanoid.WalkSpeed = 16
Humanoid.JumpPower = 60
					for i = 0, 9, 1 do
						if Humanoid.Health < 100 then 
			Humanoid.Health = Humanoid.Health + 2
			ShowDamage((Head.CFrame * CFrame.new(0, 0, (Torso.Size.Z / 4)).p + Vector3.new(0, 2, 0)), "+2", 1, BrickColor.new("Lime green").Color)			
			CFuncs.Sound.Create("588737722", Torso, .5, 1)
			wait(1)
			end
				end
end


function fireatwill()
	Attack = true	
	Humanoid.WalkSpeed = 8
	Humanoid.AutoRotate = false
		local bodygyro = Instance.new("BodyGyro",RootPart)
		bodygyro.MaxTorque = Vector3.new(50000,50000,50000)
				bodygyro.P = 8000	
							
	for i = 0, 6, 1 do
	if AmmoCount <= 0 then 
		break
		end	
	Torso.Velocity=RootPart.CFrame.lookVector*-5
		for i = 0, .5, 0.1 do
		swait()
		PlayAnimationFromTable({
         CFrame.new(0.757158816, 0.024620086, -0.316807836, 0.00376787782, -0.197771132, 0.98024106, -0.0522153527, 0.978872001, 0.197695583, -0.998628855, -0.0519285128, -0.00663840771) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),  
         CFrame.new(0.0513084419, 1.52798402, -0.0491129272, 0.503341198, 0.0593924709, -0.862044334, -0.0388650261, 0.998181403, 0.0460789353, 0.86321336, 0.0103099495, 0.504734159) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(1.62060225, 0.561005533, -0.67263329, 0.184799463, -0.818805337, -0.543513656, -0.980174243, -0.113341682, -0.162518218, 0.0714680403, 0.56277138, -0.823517323) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.181243077, 0.716829836, -0.982703269, 0.117607087, -0.980847061, -0.15526706, -0.30332914, 0.113398649, -0.946114302, 0.945600331, 0.158366859, -0.284183025) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.628674686, -1.98509169, -0.25950858, 1.00000024, 0, 0, -7.4505806e-09, 0.98480773, -0.173648342, -2.98023224e-08, 0.173648342, 0.984807909) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.442586422, -1.94206905, -0.503501356, 0.984808087, 0, -0.173647165, -0.0301535428, 0.98480773, -0.171010256, 0.171009004, 0.173648342, 0.969846487) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
		bodygyro.CFrame = CFrame.new(RootPart.Position, Vector3.new(Mouse.Hit.p.X, RootPart.Position.Y, Mouse.Hit.p.Z))
		end			
Effects.Block.Create(BrickColor.new("Flame reddish orange"), bulletmaker.CFrame, .5, .5, .5, .5, .5, .5, .1, 1)
CFuncs.Sound.Create("1132379030", Handle, 1, 1)
AmmoCount = AmmoCount - AmmoUsage
for i = 0, 9, 1 do
wshoot(Mouse, 3 , bulletmaker, .15 + (Torso.Position - Mouse.Hit.p).magnitude/15 , 0)
	end
	for i = 0, .5, 0.1 do
		swait()
		PlayAnimationFromTable({
         CFrame.new(0.588929892, -1.11013651e-06, -0.0153462738, 0.466293842, -0.234925136, 0.85287708, 0.171010062, 0.969846427, 0.17364794, -0.867954016, 0.0648796037, 0.492407978) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.160780251, 1.50000441, 0.0393266231, 0.488946259, -0.0697783977, -0.869518578, -0.125678584, 0.980760813, -0.149376884, 0.863213003, 0.182317138, 0.470769644) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(1.67061281, 0.704267323, -0.691583157, 0.423231184, -0.709484339, -0.563477933, -0.879032731, -0.472217411, -0.065669328, -0.219492719, 0.52310884, -0.823517084) * CFrame.new(-.2, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.0540117994, 0.73741293, -0.982708097, 0.0631480217, -0.978079677, 0.198425397, -0.319141895, -0.208172753, -0.924560905, 0.945600986, -0.00494170189, -0.325291872) * CFrame.new(0, 1, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.378202379, -1.77786493, -0.298971295, 0.837791204, 0.33804059, -0.428759336, -0.235888705, 0.932314754, 0.274127543, 0.492404819, -0.128522187, 0.860825062) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.773099661, -1.83571112, -0.503498793, 0.964610457, 0.171010062, -0.200704694, -0.200705469, 0.969846427, -0.138258308, 0.171009183, 0.17364794, 0.969846606) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
	bodygyro.CFrame = CFrame.new(RootPart.Position, Vector3.new(Mouse.Hit.p.X, RootPart.Position.Y, Mouse.Hit.p.Z))
	end
	end
bodygyro:Destroy()
Humanoid.WalkSpeed = 16
Humanoid.JumpPower = 60
Humanoid.AutoRotate = true
	Attack = false
	
end	

function stanceintro()
	Attack = true
	Humanoid.WalkSpeed = 0
		swait()
		PlayAnimationFromTable({
         CFrame.new(0.401558101, -0.0234151632, 0.119796708, 0.764670074, 0.00020499996, 0.644422114, 0.024826102, 0.999248326, -0.02977648, -0.643943787, 0.0387676619, 0.764090121) * CFrame.new(0,0 + .05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.0190042555, 1.53773534, -0.193438619, 0.64132297, 0.076782994, -0.763419509, 0.0574810207, 0.987376094, 0.147595912, 0.765114963, -0.138538778, 0.628813386) * CFrame.new(0, 0, 0) * CFrame.Angles(0 - 0.05 * math.cos(Sine/25), 0, 0), 
         CFrame.new(1.56287539, 0.196361139, -0.218576014, -0.0478557944, -0.26976496, -0.961736321, -0.464462936, 0.858424187, -0.217674509, 0.884298742, 0.436273903, -0.166376382) * CFrame.new(0, 0 + 0.02 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.354559392, 0.216858774, -0.992860973, -0.0544251502, -0.876319766, -0.478645861, -0.108326986, 0.481708944, -0.86961019, 0.992624402, 0.00452160835, -0.121146157) * CFrame.new(0, 0 + 0.02 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.540573061, -1.95806193, 0.106789596, 0.93969214, 0, -0.342021883, 0, 1, 0, 0.342021853, 0, 0.93969208) * CFrame.new(0, 0 - 0.05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.461303771, -1.99999595, -0.0524673536, 1.00000012, 0, 0, 0, 1, 0, 0, 0, 1.00000012) * CFrame.new(0, 0 - 0.05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
		fHandleWeld.C0 = clerp(fHandleWeld.C0, CFrame.new(-.4, .2, 0) * CFrame.Angles(math.rad(90), math.rad(-10), math.rad(90)), 0.3)
	Humanoid.WalkSpeed = 16
    Humanoid.JumpPower = 60
		Attack = false
end


function quickkick()
	Attack = true
	Humanoid.WalkSpeed = 0
    Humanoid.JumpPower = 20
	Humanoid.Jump = true
		for i = 0, .3, 0.1 do
		swait()
		PlayAnimationFromTable({
         CFrame.new(0, 0, -0, 1, 0, -0, 0, 0.984807849, -0.173647985, 0, 0.173647985, 0.984807849) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0, 1.50351071, 0.0460739173, 1, 0, -0, 0, 1.00000012, 0, -0, 0, 1.00000012) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(1.50000381, 0.0324970335, 0.425725073, 1, 0, 0, 0, 0.866025686, 0.499999642, -0, -0.499999642, 0.866025686) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-1.5, -0.159844279, 0.285122991, 1, 0, 0, 0, 0.866025686, 0.499999642, -0, -0.499999642, 0.866025686) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.5, -1.15181708, -0.124861211, 1, 0, 0, 0, 0.866025686, 0.499999642, -0, -0.499999642, 0.866025686) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.5, -1.8810792, 0.500639379, 1, 0, 0, 0, 0.866025686, 0.499999642, -0, -0.499999642, 0.866025686) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
		end
		CFuncs.Sound.Create("200632136", Handle, 1, 1)
	local con = RightLeg.Touched:connect(function(hit)
	Damage(RightLeg, hit, 8, 12, 5, "Normal", RootPart, 0.2, "743521272", 1)end)
		Torso.Velocity=RootPart.CFrame.lookVector*50
			for i = 0, 1, 0.1 do
		swait()
		PlayAnimationFromTable({
         CFrame.new(0, 0, -0, 1, 0, -0, 0, 0.939692736, -0.342019886, 0, 0.342019916, 0.939692736) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0, 1.56996083, -0.261622638, 1, 0, 0, 0, 0.939692736, 0.342019916, -0, -0.342019886, 0.939692736) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(1.50000381, 0.27931872, 0.728133559, 1, 0, 0, 0, 0.499999821, 0.866025627, -0, -0.866025567, 0.499999821) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-1.5, 0.34596175, 0.570588231, 1, 0, 0, 0, 0.499999821, 0.866025627, -0, -0.866025567, 0.499999821) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.5, -1.39599705, -1.111431, 1, 0, -0, 0, 0.642786562, -0.766045451, -0, 0.766045451, 0.642786503) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.5, -1.70923471, 0.977958977, 1, 0, 0, 0, 0.499999821, 0.866025627, -0, -0.866025567, 0.499999821) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
			end
			Torso.Velocity=RootPart.CFrame.lookVector*0
			con:Disconnect()
	Humanoid.WalkSpeed = 16
    Humanoid.JumpPower = 60
		Attack = false
end

function hedbap()
	Attack = true
		for i = 0, 1, 0.1 do
		swait()
		PlayAnimationFromTable({
         CFrame.new(-0, -0.115550078, 0.250714004, 1, 0, -0, 0, 0.939692736, -0.342019886, 0, 0.342019916, 0.939692736) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0, 1.51567197, 0.00248532044, 1, 0, -0, 0, 1, 2.98023224e-08, -0, 2.98023224e-08, 1) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(1.00599754, 0.00645497441, -0.987730443, 0.387630165, 0.322637081, -0.863509297, -0.802340508, 0.579304218, -0.143723249, 0.453864068, 0.748539925, 0.483420581) * CFrame.new(0, 0 + 0.02 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.927108586, 0.209949538, -0.179899275, 0.68265909, -0.539921403, -0.492403984, -0.24406442, 0.4666816, -0.850082874, 0.688773632, 0.700495183, 0.18680881) * CFrame.new(0, 0 + 0.02 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.5, -1.48346758, 0.057243526, 1, 0, 0, 0, 0.766044796, 0.642787218, -0, -0.642787218, 0.766044855) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.499999523, -1.82032359, 0.395741045, 0.984807849, 0, 0.173647985, -0.0593910702, 0.939692736, 0.33682391, -0.163175747, -0.342019886, 0.925416768) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
		end
	Torso.Velocity=RootPart.CFrame.lookVector*40
	CFuncs.Sound.Create("200632136", Handle, 1, 1)
	local con = Head.Touched:connect(function(hit)
	Damage(RightLeg, hit, 15, 18, 3, "Knockdown", RootPart, 0.2, "1296132303", 1) Humanoid.Health = Humanoid.Health - 5 end)
	for i = 0, 1, 0.1 do
		swait()
		PlayAnimationFromTable({
         CFrame.new(0, 0.0488227382, -0.156543747, 1, 0, 0, 0, 0.76604414, 0.642788053, 0, -0.642788053, 0.76604414) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0, 1.52236009, -0.201607227, 1, 0, 0, 0, 0.939692438, 0.34202075, 0, -0.34202075, 0.939692438) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(1.00599754, 0.00645497441, -0.987730443, 0.387630165, 0.322637081, -0.863509297, -0.802340508, 0.579304218, -0.143723249, 0.453864068, 0.748539925, 0.483420581) * CFrame.new(0, 0 - 0.1 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.927108586, 0.209949538, -0.179899275, 0.68265909, -0.539921403, -0.492403984, -0.24406442, 0.4666816, -0.850082874, 0.688773632, 0.700495183, 0.18680881) * CFrame.new(0, 0 - 0.1 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.5, -2.03161407, -0.00965765119, 1, 0, 0, 0, 0.98480773, 0.173648447, 0, -0.173648447, 0.98480773) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.5, -1.83802676, -0.920656502, 1, 0, 0, 0, 0.939692438, -0.342020959, 0, 0.342020929, 0.939692438) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
	end
	Attack = false
	con:Disconnect()
end


function stockcrash()
	Attack = true
	Humanoid.WalkSpeed = 5
    Humanoid.JumpPower = 0
	CFuncs.Sound.Create("1073355392", Stockbox, 1, 1)
	for i = 0, 1.5, 0.1 do
		swait()
		PlayAnimationFromTable({
         CFrame.new(0.0377655476, -0, -0.109542102, 0.64278698, 0, -0.766044974, 0, 1, 0, 0.766044974, 0, 0.64278698) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-4.17232513e-07, 1.49999011, -3.93390656e-06, 0.856849194, 0.197328225, -0.476309896, -0.163177073, 0.980159342, 0.112521209, 0.489063263, -0.0186908543, 0.87204814) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(1.75000632, 0.42197898, -0.563352466, 0.766044974, -0.64278698, -0, 0, 0, -1, 0.64278698, 0.766044974, 0) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.420839459, 0.476516426, -1.11699474, 0.418066114, -0.903488457, -0.09449514, -0.139175028, 0.0390909165, -0.989495933, 0.897692144, 0.42682609, -0.109400436) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.637096405, -1.86514843, -0.291526765, 1, 0, 0, 0, 0.984807849, 0.173648059, 0, -0.173648059, 0.984807849) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.48112309, -1.99999511, 0.0593808591, 0.766043782, 0, 0.64278847, 0, 1, 0, -0.64278847, 0, 0.766043782) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
		fHandleWeld.C0 = clerp(fHandleWeld.C0, CFrame.new(3, .5, 1) * CFrame.Angles(math.rad(-80), math.rad(0), math.rad(-100)), 0.3)
	end
	CFuncs.Sound.Create("1073356365", Stockbox, 1, 1)
	local con = Stockbox.Touched:connect(function(hit)
	Damage(Stockbox, hit, 18, 23, 5, "Knockdown", RootPart, 1, "146163534", 1) end)
	for i = 0, .2, 0.1 do
		swait()
		PlayAnimationFromTable({
         CFrame.new(0.441541791, 2.43237423e-07, 0.00331187248, 0.336825132, -0.0593909472, 0.939692259, 0.173648059, 0.984807849, -3.82394944e-07, -0.92541635, 0.163175866, 0.342021108) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.104509205, 1.59855092, -0.215072125, 0.890994191, 0.0636333674, -0.449533641, 0.0275982097, 0.980707407, 0.193524063, 0.453175396, -0.184835091, 0.872048259) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(1.75627017, 0.431958854, -0.449601173, 0.754407525, -0.653558016, -0.0610871017, -0.13302204, -0.0610866398, -0.989228785, 0.642786741, 0.754407406, -0.133021802) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.367935598, 0.648825228, -1.07648134, 0.387547314, -0.915556669, -0.107533015, -0.209657595, 0.0260535926, -0.977427781, 0.897691965, 0.401344508, -0.181856394) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.358966112, -1.63310397, -0.651200593, 0.984807909, 0.17100957, 0.0301558673, -0.173648059, 0.969846368, 0.171010047, -2.23517418e-06, -0.173648521, 0.98480773) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.654243588, -1.85264969, 0.148285508, 0.754406095, -0.0533300862, 0.654238164, -0.133022279, 0.963592768, 0.231935903, -0.642788172, -0.262002051, 0.71984601) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
	end
				for i = 0, 1, 0.1 do
		swait()
		PlayAnimationFromTable({
         CFrame.new(0.278367251, 9.0772329e-07, 0.0731263831, 0.633022964, -0.111618958, 0.766043842, 0.173647985, 0.984807849, 5.96214491e-08, -0.754405856, 0.133021936, 0.64278841) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.104512498, 1.59855139, -0.215077341, 0.727161527, 0.0636337325, 0.683510542, -0.172414482, 0.980707347, 0.0921231061, -0.664461732, -0.184835523, 0.724103987) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.400077015, 0.238431826, -1.01036751, 0.518464565, 0.840397179, 0.157882661, -0.035381794, 0.205562487, -0.978004277, -0.854366899, 0.50147438, 0.13631162) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-1.62448943, 0.329740167, -0.818884015, 0.598198533, 0.795001924, 0.100649826, -0.176135838, 0.25297159, -0.95130527, -0.781751156, 0.551341355, 0.29135555) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.302916914, -1.95092583, 0.295360684, 0.98480773, 0.171009585, 0.0301554501, -0.173648, 0.969846547, 0.1710096, -1.81794167e-06, -0.173648, 0.984807909) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.801789224, -1.60096383, -0.361114919, 0.974819183, 0.117734738, 0.189383537, -0.166570976, 0.949086845, 0.267373323, -0.148262233, -0.292186439, 0.944799304) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
		fHandleWeld.C0 = clerp(fHandleWeld.C0, CFrame.new(1, 1, 0) * CFrame.Angles(math.rad(-90), math.rad(0), math.rad(-50)), 0.3)
				end
	Humanoid.WalkSpeed = 16
    Humanoid.JumpPower = 60
				con:Disconnect()
	Attack = false
end






Mouse.KeyDown:connect(function(Key)
	Key = Key:lower()
		while Attack == false and UIS:IsKeyDown(Enum.KeyCode.R) and AmmoCount >= 0 and AmmoCount <= maxammo - 1 do
			relode()
			if Attack == false and AmmoCount == maxammo then
				pump() 
			end			
	end
end)


Mouse.KeyDown:connect(function(Key)
	Key = Key:lower()
while Attack == false and UIS:IsKeyDown(Enum.KeyCode.X) and cooldownX >=coX do
	stanceintro()
		textXZ.Text = "[X+Z]\n Quick Kick"
        text2.Text = "[X]\n HOLD"
        textXC.Text = "[X+C]\n Headbutt"
        textXV.Text = "[X+V]\n Stock Swing"

		text1.Text = " "
        text3.Text = " "
        text4.Text = " "
frameskXZ.BackgroundTransparency = .5
frameskXC.BackgroundTransparency = .5
frameskXV.BackgroundTransparency = .5
barXZ.BackgroundTransparency = 0
barXC.BackgroundTransparency = 0
barXV.BackgroundTransparency = 0

frameskZ.BackgroundTransparency = 1
frameskC.BackgroundTransparency = 1
frameskV.BackgroundTransparency = 1
barZ.BackgroundTransparency = 1
barC.BackgroundTransparency = 1
barV.BackgroundTransparency = 1


	if UIS:IsKeyDown(Enum.KeyCode.X) and UIS:IsKeyDown(Enum.KeyCode.Z) and cooldownXZ >=coXZ then
		quickkick()
		cooldownXZ = 0
			elseif UIS:IsKeyDown(Enum.KeyCode.X) and UIS:IsKeyDown(Enum.KeyCode.C) and cooldownXC >=coXC then
				hedbap()
				cooldownXC = 0
					elseif UIS:IsKeyDown(Enum.KeyCode.X) and UIS:IsKeyDown(Enum.KeyCode.V) and cooldownXV >=coXV then
						stockcrash()
						cooldownXV = 0
				end
		end
end)



Mouse.KeyDown:connect(function(Key)
			if Attack == false and Key == 'z' and cooldownZ >=coZ then
			cooldownZ = 0		
			hop()
			elseif Attack == false and Key == 'c' and cooldownC >=coC and Humanoid.Health < 100 then
			cooldownC = 0
			patchedup()
			elseif Attack == false and Key == 'v' and cooldownV >=coV then
			cooldownV = 0
			fireatwill()
														
	end
end)


Mouse.Button1Down:connect(function()
	if Attack == false and AmmoCount > 0 then
	fire()
	elseif Attack == false and AmmoCount == 0 then
	dryfire()
	end
end)

	
function updateskills1()
	if cooldownZ <= coZ then
		cooldownZ = cooldownZ + 1 / 35
	end
	if cooldownX <= coX then
		cooldownX = cooldownX + 1 / 35
	end
	if cooldownXZ <= coXZ then
		cooldownXZ = cooldownXZ + 1 / 35
	end
	if cooldownXC <= coXC then
		cooldownXC = cooldownXC + 1 / 35
	end
	if cooldownXV <= coXV then
		cooldownXV = cooldownXV + 1 / 35
	end
	if cooldownC <= coC then
		cooldownC = cooldownC + 1 / 35
		end
	if cooldownV <= coV then
		cooldownV = cooldownV + 1 / 35
	end
end


while true do
	swait()
	for i, v in pairs(Character:GetChildren()) do
		if v:IsA("Part") then
			v.Material = "SmoothPlastic"
		elseif v:IsA("Accessory") then
			v:WaitForChild("Handle").Material = "SmoothPlastic"
		end
	end
	for i, v in pairs(Character:GetChildren()) do
		if v:IsA'Model' then
			for _, c in pairs(v:GetChildren()) do
				if c:IsA'Part' then
					c.CustomPhysicalProperties = PhysicalProperties.new(0.001, 0.001, 0.001, 0.001, 0.001)
				end
			end
		end
	end
	updateskills1()
	barZ:TweenSize(UDim2.new(1 * (cooldownZ / coZ), 0, 1, 0), 'Out', 'Quad', .5)
	barX:TweenSize(UDim2.new(1 * (cooldownX / coX), 0, 1, 0), 'Out', 'Quad', .5)
	barXZ:TweenSize(UDim2.new(1 * (cooldownXZ / coXZ), 0, 1, 0), 'Out', 'Quad', .5)
	barXC:TweenSize(UDim2.new(1 * (cooldownXC / coXC), 0, 1, 0), 'Out', 'Quad', .5)
	barXV:TweenSize(UDim2.new(1 * (cooldownXV / coXV), 0, 1, 0), 'Out', 'Quad', .5)
	barC:TweenSize(UDim2.new(1 * (cooldownC / coC), 0, 1, 0), 'Out', 'Quad', .5)
	barV:TweenSize(UDim2.new(1 * (cooldownV / coV), 0, 1, 0), 'Out', 'Quad', .5)
	
	if AmmoCount ~= 0 then
		relodetext.Text = '[ '..AmmoCount..' / '..maxammo..' ]'
	elseif AmmoCount == 0 then 
		relodetext.Text = '[ Hold R to Reload. ]'
		end


	if UIS:IsKeyDown(Enum.KeyCode.X) == false then
		text1.Text = "[Z]\n Reposition"
        text2.Text = "[X]\n Battle Stance"
        text3.Text = "[C]\n Mend"
        text4.Text = "[V]\n Unload"
	    textXZ.Text = " "
        textXC.Text = " "
        textXV.Text = " "
frameskZ.BackgroundTransparency = .5
frameskC.BackgroundTransparency = .5
frameskV.BackgroundTransparency = .5
barZ.BackgroundTransparency = 0
barC.BackgroundTransparency = 0
barV.BackgroundTransparency = 0

frameskXZ.BackgroundTransparency = 1
frameskXC.BackgroundTransparency = 1
frameskXV.BackgroundTransparency = 1
barXZ.BackgroundTransparency = 1
barXC.BackgroundTransparency = 1
barXV.BackgroundTransparency = 1
end
	TorsoVelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude 
	Velocity = RootPart.Velocity.y
	Sine = Sine + Change
	local hit, pos = RayCast(RootPart.Position, (CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0))).lookVector, 4, Character)
	if RootPart.Velocity.y > 1 and hit == nil then 
		Anim = "Jump"
		if Attack == false then
			Change = 1
		PlayAnimationFromTable({
         CFrame.new(-0, -1.01481628, -8.04662704e-07, 1, 0, 0, 0, 0.866025686, 0.499999642, -0, -0.499999642, 0.866025686) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0, 1.45637476, -0.213752031, 1, 0, 0, 0, 0.939692676, 0.342020601, 0, -0.342020601, 0.939692676) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(1.80887365, 0.563777864, 0.393151999, 0.642787039, -0.766044915, -1.2109125e-06, 0.754407167, 0.633021533, 0.173648313, -0.133021653, -0.111619815, 0.984807789) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-1.67181289, 0.594474256, -0.03263852, 0.499999285, 0.866025865, 1.98491279e-07, -0.750001073, 0.433012605, -0.499998599, -0.43301177, 0.249998808, 0.866026282) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.5, -1.80666828, -0.689023316, 1, 0, 0, 0, 0.984807849, 0.173648134, 0, -0.173648164, 0.984807849) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.5, -1.42673647, -0.144118369, 1, 0, 0, 0, 0.766044736, 0.642787457, 0, -0.642787457, 0.766044736) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
		fHandleWeld.C0 = clerp(fHandleWeld.C0, CFrame.new(-.4, .2, 0) * CFrame.Angles(math.rad(90), math.rad(-10), math.rad(90)), 0.3)
		end	
	elseif RootPart.Velocity.y < -1 and hit == nil then 
		Anim = "Fall"
		if Attack == false then
			Change = 1
		PlayAnimationFromTable({
         CFrame.new(-0, -1.01481628, -8.04662704e-07, 1, 0, 0, 0, 0.866025686, 0.499999642, -0, -0.499999642, 0.866025686) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0, 1.45637476, -0.213752031, 1, 0, 0, 0, 0.939692676, 0.342020601, 0, -0.342020601, 0.939692676) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(1.53209591, 0.16416876, 0.0263971146, 0.98480773, -0.173648164, -1.55591565e-07, 0.171010092, 0.969846427, 0.173648164, -0.0301535316, -0.171010077, 0.984807849) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-1.64498818, 0.287739754, -0.209731221, 0.86602509, 0.500000656, 7.92254752e-07, -0.433013529, 0.750000894, -0.499998152, -0.25, 0.433010578, 0.86602664) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.5, -1.26449406, -1.10387921, 1, 0, 0, 0, 0.984807849, -0.173647985, 0, 0.173647985, 0.984807849) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.5, -1.24956489, -0.292783707, 1, 0, 0, 0, 0.642787695, 0.766044557, 0, -0.766044557, 0.642787695) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
		fHandleWeld.C0 = clerp(fHandleWeld.C0, CFrame.new(-.4, .2, 0) * CFrame.Angles(math.rad(90), math.rad(-10), math.rad(90)), 0.3)
		end		
	elseif TorsoVelocity < 1 and hit ~= nil then
		Anim = "Idle"
		if Attack == false then
			Change = 1
		PlayAnimationFromTable({
         CFrame.new(0.038382329, -2.14204192e-08, -0.0314837135, 0.984807849, 0.0301536452, 0.171009868, 0, 0.98480773, -0.173648119, -0.173647985, 0.171010017, 0.969846368) * CFrame.new(0, 0 + 0.05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0 + 0.005 * math.cos(Sine/25), 0), 
          CFrame.new(-0.00987245888, 1.54137087, -0.232474566, 0.983905733, 0.0593912564, -0.168529823, 0.000888057693, 0.941511214, 0.336980611, 0.17868638, -0.331706822, 0.926305413) * CFrame.new(0, 0, 0) * CFrame.Angles(0 - 0.05 * math.cos(Sine/25), 0, 0), 
         CFrame.new(1.00599754, 0.00645497441, -0.987730443, 0.387630165, 0.322637081, -0.863509297, -0.802340508, 0.579304218, -0.143723249, 0.453864068, 0.748539925, 0.483420581) * CFrame.new(0, 0 + 0.02 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.927108586, 0.209949538, -0.179899275, 0.68265909, -0.539921403, -0.492403984, -0.24406442, 0.4666816, -0.850082874, 0.688773632, 0.700495183, 0.18680881) * CFrame.new(0, 0 + 0.02 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
         CFrame.new(0.628665984, -2.00964737, 0.120245621, 1.00000012, 0, 0, 1.86264515e-09, 0.98480773, 0.173648119, 0, -0.173648119, 0.984807849) * CFrame.new(0, 0 - 0.05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.44258371, -1.99715459, 0.19109571, 0.939692676, 0, 0.342020601, -0.0593912229, 0.98480773, 0.163175851, -0.336824536, -0.173648119, 0.925416529) * CFrame.new(0, 0 - 0.05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
		fHandleWeld.C0 = clerp(fHandleWeld.C0, CFrame.new(-.4, .2, 0) * CFrame.Angles(math.rad(90), math.rad(-10), math.rad(90)), 0.3)
		end
	elseif TorsoVelocity > 2 and hit ~= nil then
		Anim = "Walk"
            if Attack == false then
                            PlayAnimationFromTable({
         CFrame.new(-0, -0, 0, 1, 0, 0, 0, 0.996187985, 0.0871556774, 0, -0.0871556699, 0.996194661) * CFrame.new(0, 0 + .05 * math.cos(Sine/25), 0) * CFrame.Angles(-.2 + 0.05 * math.cos(Sine/25), 0 + 0.05 * math.cos(Sine/5), 0),
         CFrame.new(0, 1.49999499, 1.11760201e-08, 1, 0, 0, 0, 0.999998331, -7.45067918e-09, 0, 7.45069251e-09, 1) * CFrame.new(0, 0, 0 + 0.05 * math.cos(Sine/30)) * CFrame.Angles(0 + 0.05 * math.cos(Sine/15), 0, 0),
         CFrame.new(1.00599754, 0.00645497441, -0.987730443, 0.387630165, 0.322637081, -0.863509297, -0.802340508, 0.579304218, -0.143723249, 0.453864068, 0.748539925, 0.483420581) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
         CFrame.new(-0.927108586, 0.209949538, -0.179899275, 0.68265909, -0.539921403, -0.492403984, -0.24406442, 0.4666816, -0.850082874, 0.688773632, 0.700495183, 0.18680881) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		 CFrame.new(0.5, -2.00000334, 2.67028881e-005, 1, 0, 0, 0, 1.00000024, 0, 0, 0, 1.00000024) * CFrame.new(0, .21 - .1 * math.cos((Sine) / 2), -.1 + 1 * math.cos((Sine) / 4)) * CFrame.Angles(math.rad(1 - 50 * math.cos((Sine) / 4)), math.rad(0), math.rad(0 - .5 * math.cos((Sine) / 5))),
	     CFrame.new(-0.5, -2.00000334, 2.67028881e-005, 1, 0, 0, 0, 1.00000024, 0, 0, 0, 1.00000024) * CFrame.new(0, .21 - .1 * math.cos((Sine) / 2), .1 - 1 * math.cos((Sine) / 4)) * CFrame.Angles(math.rad(-1 + 50 * math.cos((Sine) / 4)), math.rad(0), math.rad(0 + .5 * math.cos((Sine) / 5))),
}, .3, false)
fHandleWeld.C0 = clerp(fHandleWeld.C0, CFrame.new(-.4, .2, 0) * CFrame.Angles(math.rad(90), math.rad(-10), math.rad(90)), 0.3)
end
	end
	if #Effects > 0 then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					if Thing[1].Transparency <= 1 then
						if Thing[2] == "Block1" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Ice" then
							if Thing[6] <= Thing[5] then
								Thing[6] = Thing[6] + .05
								Thing[1].CFrame = Thing[1].CFrame * CFrame.new(0, .4, 0)
							else
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							end
						elseif Thing[2] == "Shatter" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
							Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
							Thing[6] = Thing[6] + Thing[5]
						elseif Thing[2] == "Block2" then
							Thing[1].CFrame = Thing[1].CFrame
							Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block3" then
							Thing[1].CFrame = Thing[8].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block4" then
							Thing[1].CFrame = Thing[8].CFrame * CFrame.new(0, -Thing[7].Scale.Y, 0) * CFrame.fromEulerAnglesXYZ(3.14, 0, 0)
							Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block2Fire" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							if Thing[1].Transparency >= .3 then
								Thing[1].BrickColor = BrickColor.new("Bright red")
							else
								Thing[1].BrickColor = BrickColor.new("Bright yellow")
							end
						elseif Thing[2] == "Cylinder" then
							Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Blood" then
							Mesh = Thing[7]
							Thing[1].CFrame = Thing[1].CFrame * CFrame.new(0, -.5, 0)
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Elec" then
							Mesh = Thing[10]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[1].CFrame = Thing[1].CFrame * Thing[11] * CFrame.new(0, 0, .2)
							Thing[1].Rotation = Vector3.new(0, 0, 0)
						elseif Thing[2] == "Disappear" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						end
					else
						Part.Parent = nil
						table.remove(Effects, e)
					end
				end
			end
		end
	end	
end
end)

Section2:CreateButton("Ethereal Glitcher", function()
local script = game:GetObjects("rbxassetid://7692609730")[1]

script.WingPiece.qPerfectionWeld:Destroy()

do
	local NEVER_BREAK_JOINTS = false

	local function CallOnChildren(Instance, FunctionToCall)
		FunctionToCall(Instance)

		for _, Child in next, Instance:GetChildren() do
			CallOnChildren(Child, FunctionToCall)
		end
	end

	local function GetBricks(StartInstance)
		local List = {}
		CallOnChildren(StartInstance, function(Item)
			if Item:IsA("BasePart") then
				List[#List+1] = Item;
			end
		end)

		return List
	end

	local function Modify(Instance, Values)
		assert(type(Values) == "table", "Values is not a table");

		for Index, Value in next, Values do
			if type(Index) == "number" then
				Value.Parent = Instance
			else
				Instance[Index] = Value
			end
		end
		return Instance
	end

	local function Make(ClassType, Properties)
		return Modify(Instance.new(ClassType), Properties)
	end

	local Surfaces = {"TopSurface", "BottomSurface", "LeftSurface", "RightSurface", "FrontSurface", "BackSurface"}
	local HingSurfaces = {"Hinge", "Motor", "SteppingMotor"}

	local function HasWheelJoint(Part)
		for _, SurfaceName in pairs(Surfaces) do
			for _, HingSurfaceName in pairs(HingSurfaces) do
				if Part[SurfaceName].Name == HingSurfaceName then
					return true
				end
			end
		end

		return false
	end

	local function ShouldBreakJoints(Part)
		if NEVER_BREAK_JOINTS then
			return false
		end

		if HasWheelJoint(Part) then
			return false
		end

		local Connected = Part:GetConnectedParts()

		if #Connected == 1 then
			return false
		end

		for _, Item in pairs(Connected) do
			if HasWheelJoint(Item) then
				return false
			elseif not Item:IsDescendantOf(script.Parent) then
				return false
			end
		end

		return true
	end

	local function WeldTogether(Part0, Part1, JointType, WeldParent)

		JointType = JointType or "Weld"
		local RelativeValue = Part1:FindFirstChild("qRelativeCFrameWeldValue")

		local NewWeld = Part1:FindFirstChild("qCFrameWeldThingy") or Instance.new(JointType)
		Modify(NewWeld, {
			Name = "qCFrameWeldThingy";
			Part0  = Part0;
			Part1  = Part1;
			C0     = CFrame.new();--Part0.CFrame:inverse();
			C1     = RelativeValue and RelativeValue.Value or Part1.CFrame:toObjectSpace(Part0.CFrame); --Part1.CFrame:inverse() * Part0.CFrame;-- Part1.CFrame:inverse();
			Parent = Part1;
		})

		if not RelativeValue then
			RelativeValue = Make("CFrameValue", {
				Parent     = Part1;
				Name       = "qRelativeCFrameWeldValue";
				Archivable = true;
				Value      = NewWeld.C1;
			})
		end

		return NewWeld
	end

	local function WeldParts(Parts, MainPart, JointType, DoNotUnanchor)

		for _, Part in pairs(Parts) do
			if ShouldBreakJoints(Part) then
				Part:BreakJoints()
			end
		end

		for _, Part in pairs(Parts) do
			if Part ~= MainPart then
				WeldTogether(MainPart, Part, JointType, MainPart)
			end
		end

		if not DoNotUnanchor then
			for _, Part in pairs(Parts) do
				Part.Anchored = false
			end
			MainPart.Anchored = false
		end
	end

	local function PerfectionWeld()	
		local Parts = GetBricks(script.WingPiece)
		WeldParts(Parts, script.WingPiece.Main, "Weld", false)
	end
	PerfectionWeld()
end

wait(0.111111156)

wait(1/60)
-- Ethereal Rewrite --
-- Ezzy can go fuck himself --

-- If you logged this, shame on you, jump off a bridge. --
-- You're a disgrace to the whole human race. --

--[[
	DEVELOPERS:
		Jungle_DragonYharon [Also known as Nebula the Zorua, Drahazar]
		wanTH092 [Also known as Filano/Fil/Fox]
		GodzPlayzRB [Also known as SpectrumEeveez]
		Salvo_Starly [Also known as Blaze the Braixen]
		UnfairGaming1 [Also known as Unfair]
		KillerzTH_1596 [Also known as Killerz]
		DerpzDeNugget_YT [Also known as Derpz]
]]

--[[
	TO MAKE FE:
	Copy the script's code and all of the script's children into a new 'Script' (not localscript)
	..Done!
	
	That's literally it.
]]

warn([[
	Credit to DM DOKURO for the songs of these modes:
		COMMOTIAUS (Cosmic Disgust)
		PANDEMONIUM (Blood Coagulant)
	
	You're the best!

	~ The Dev Team
		
	
	(Fyi, if you remove this credit, you're a disrespectful jackass who doesnt care about DM DOKURO or his works.)
]])

local Changelogs = [[
	KEY:
		M+: New Mode
		M*: Upgraded Mode
		M-: Deleted Mode
		A+: New attack (List the mode it's for)
		A-: Removed attack (List the mode it's from)
		A*: Upgraded attack (List the mode it's from)
		B*: Bugfixes
		??: Misc stuff
		//: Comments
		
	DRAHAZAR'S LOGS:
		M+|INSTRUMENTAL (Luminosity's major)
		   PANDEMONIUM (Commotiaus's major)
		M*| Oblivion's run now fits the walkspeed
		
		// List your logs like I did above, using the key as I did. Thank you!
]]



--// Shortcut Variables \\--
local S = setmetatable({},{__index = function(s,i) return game:service(i) end})
local CF = {N=CFrame.new,A=CFrame.Angles,fEA=CFrame.fromEulerAnglesXYZ}
local C3 = {tRGB= function(c3) return c3.r*255,c3.g*255,c3.b*255 end,N=Color3.new,RGB=Color3.fromRGB,HSV=Color3.fromHSV,tHSV=Color3.toHSV}
local V3 = {N=Vector3.new,FNI=Vector3.FromNormalId,A=Vector3.FromAxis}
local M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}
local R3 = {N=Region3.new}
local De = S.Debris
local WS = workspace
local Lght = S.Lighting
local RepS = S.ReplicatedStorage
local IN = Instance.new
local Plrs = S.Players

--// Initializing \\--
local Plr = Plrs.LocalPlayer
mouse = Plr:GetMouse()
Mouse = Plr:GetMouse()
local Char = workspace.Camera.CameraSubject.Parent
local Hum = Char:FindFirstChildOfClass'Humanoid'
local RArm = Char["Right Arm"]
local LArm = Char["Left Arm"]
local RLeg = Char["Right Leg"]
local LLeg = Char["Left Leg"]	
local Root = Char:FindFirstChild'HumanoidRootPart'
local Morph = script:FindFirstChild'Morph'
local Torso = Char.Torso
local Head = Char.Head
local NeutralAnims = true
local Attack = false
local Debounces = {Debounces={}}
local Mouse = Plr:GetMouse()
local Hit = {}
local Sine = 0
local Change = 1
local BloodPuddles = {}
local Penetrated = {Who=nil,Weld=nil}
local FXFolder = script:FindFirstChild'Effects'
FXFolder.Parent = nil
local legAnims = true
local WingSine=0;
local lastMacabEffect = 0
local lastGlacier = 0 
local lastSkull = 0 
local BurnParticles = FXFolder:WaitForChild'BurnParticles'
BurnParticles.Parent=nil
local wsVal = 4 
local walkChange = .5;
local movement = 8
local ChatGUI = script:WaitForChild'ChatGUI'
ChatGUI.Parent=nil
local Camera = newproxy(true)
local Mode = 'COMMOTIAUS'
local Combo = 1

local Effects = IN("Folder",Char)
Effects.Name = "Effects"

--// Client Control \\--



--// Debounce System \\--


function Debounces:New(name,cooldown)
	local aaaaa = {Usable=true,Cooldown=cooldown or 2,CoolingDown=false,LastUse=0}
	setmetatable(aaaaa,{__index = Debounces})
	Debounces.Debounces[name] = aaaaa
	return aaaaa
end

function Debounces:Use(overrideUsable)
	assert(self.Usable ~= nil and self.LastUse ~= nil and self.CoolingDown ~= nil,"Expected ':' not '.' calling member function Use")
	if(self.Usable or overrideUsable)then
		self.Usable = false
		self.CoolingDown = true
		local LastUse = time()
		self.LastUse = LastUse
		delay(self.Cooldown or 2,function()
			if(self.LastUse == LastUse)then
				self.CoolingDown = false
				self.Usable = true
			end
		end)
	end
end

function Debounces:Get(name)
	assert(typeof(name) == 'string',("bad argument #1 to 'get' (string expected, got %s)"):format(typeof(name) == nil and "no value" or typeof(name)))
	for i,v in next, Debounces.Debounces do
		if(i == name)then
			return v;
		end
	end
end

function Debounces:GetProgressPercentage()
	assert(self.Usable ~= nil and self.LastUse ~= nil and self.CoolingDown ~= nil,"Expected ':' not '.' calling member function Use")
	if(self.CoolingDown and not self.Usable)then
		return math.max(
			math.floor(
				(
					(time()-self.LastUse)/self.Cooldown or 2
				)*100
			)
		)
	else
		return 100
	end
end

--// Instance Creation Functions \\--
local baseSound = IN("Sound")
function Sound(parent,id,pitch,volume,looped,effect,autoPlay)
	local Sound = baseSound:Clone()
	Sound.SoundId = "rbxassetid://".. tostring(id or 0)
	Sound.Pitch = pitch or 1
	Sound.Volume = volume or 1
	Sound.Looped = looped or false
	if(autoPlay)then
		coroutine.wrap(function()
			repeat wait() until Sound.IsLoaded
			Sound.Playing = autoPlay or false
		end)()
	end
	if(not looped and effect)then
		Sound.Stopped:connect(function()
			Sound.Volume = 0
			Sound:destroy()
		end)
	elseif(effect)then
		warn("Sound can't be looped and a sound effect!")
	end
	Sound.Parent =parent or Torso
	return Sound
end
function Part(parent,color,material,size,cframe,anchored,cancollide)
	local part = IN("Part")
	part.Parent = parent or Char
	part[typeof(color) == 'BrickColor' and 'BrickColor' or 'Color'] = color or C3.N(0,0,0)
	part.Material = material or Enum.Material.SmoothPlastic
	part.TopSurface,part.BottomSurface=10,10
	part.Size = size or V3.N(1,1,1)
	part.CFrame = cframe or CF.N(0,0,0)
	part.CanCollide = cancollide or false
	part.Anchored = anchored or false
	return part
end

function Weld(part0,part1,c0,c1)
	local weld = IN("Weld")
	weld.Parent = part0
	weld.Part0 = part0
	weld.Part1 = part1
	weld.C0 = c0 or CF.N()
	weld.C1 = c1 or CF.N()
	return weld
end

function Mesh(parent,meshtype,meshid,textid,scale,offset)
	local part = IN("SpecialMesh")
	part.MeshId = meshid or ""
	part.TextureId = textid or ""
	part.Scale = scale or V3.N(1,1,1)
	part.Offset = offset or V3.N(0,0,0)
	part.MeshType = meshtype or Enum.MeshType.Sphere
	part.Parent = parent
	return part
end

NewInstance = function(instance,parent,properties)
	local inst = Instance.new(instance)
	inst.Parent = parent
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end

function Clone(instance,parent,properties)
	local inst = instance:Clone()
	inst.Parent = parent
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end

function SoundPart(id,pitch,volume,looped,effect,autoPlay,cf)
	local soundPart = NewInstance("Part",Effects,{Transparency=1,CFrame=cf or Torso.CFrame,Anchored=true,CanCollide=false,Size=V3.N()})
	local Sound = IN("Sound")
	Sound.SoundId = "rbxassetid://".. tostring(id or 0)
	Sound.Pitch = pitch or 1
	Sound.Volume = volume or 1
	Sound.Looped = looped or false
	if(autoPlay)then
		coroutine.wrap(function()
			repeat wait() until Sound.IsLoaded
			Sound.Playing = autoPlay or false
		end)()
	end
	if(not looped and effect)then
		Sound.Stopped:connect(function()
			Sound.Volume = 0
			soundPart:destroy()
		end)
	elseif(effect)then
		warn("Sound can't be looped and a sound effect!")
	end
	Sound.Parent = soundPart
	return Sound
end


--// Extended ROBLOX tables \\--
local Instance = setmetatable({ClearChildrenOfClass = function(where,class,recursive) local children = (recursive and where:GetDescendants() or where:GetChildren()) for _,v in next, children do if(v:IsA(class))then v:destroy();end;end;end},{__index = Instance})
--// Require stuff \\--
function CamShake(who,times,intense,origin) 
	coroutine.wrap(function()
		if(FXFolder:FindFirstChild'CamShake')then
			local cam = FXFolder.CamShake:Clone()
			cam:WaitForChild'intensity'.Value = intense
			cam:WaitForChild'times'.Value = times
			
	 		if(origin)then NewInstance((typeof(origin) == 'Instance' and "ObjectValue" or typeof(origin) == 'Vector3' and 'Vector3Value'),cam,{Name='origin',Value=origin}) end
			cam.Parent = who
			wait()
			cam.Disabled = false
		end
	end)()
end

function CamShakeAll(times,intense,origin)
	for _,v in next, Plrs:players() do
		CamShake(v:FindFirstChildOfClass'PlayerGui' or v:FindFirstChildOfClass'Backpack' or v.Character,times,intense,origin)
	end
end

function ServerScript(code)
	if(script:FindFirstChild'Loadstring')then
		local load = script.Loadstring:Clone()
		load:WaitForChild'Sauce'.Value = code
		load.Disabled = false
		load.Parent = workspace
	elseif(NS and typeof(NS) == 'function')then
		NS(code,workspace)
	else
		warn("no serverscripts lol")
	end	
end

function LocalOnPlayer(who,code)
	ServerScript([[
		wait()
		script.Parent=nil
		if(not _G.Http)then _G.Http = game:service'HttpService' end
		
		local Http = _G.Http or game:service'HttpService'
		
		local source = ]].."[["..code.."]]"..[[
		local link = "https://api.vorth.xyz/R_API/R.UPLOAD/NEW_LOCAL.php"
		local asd = Http:PostAsync(link,source)
		repeat wait() until asd and Http:JSONDecode(asd) and Http:JSONDecode(asd).Result and Http:JSONDecode(asd).Result.Require_ID
		local ID = Http:JSONDecode(asd).Result.Require_ID
		local vs = require(ID).VORTH_SCRIPT
		vs.Parent = game:service'Players'.]]..who.Name..[[.Character
	]])
end

function Nametag(color,tag)
	local r,g,b = C3.tRGB(color)
	local c3 = C3.RGB(r/2,g/2,b/2)
	local name = script:FindFirstChild'Nametag' and script.Nametag:Clone();
	if(not name)then
		name = NewInstance("BillboardGui",nil,{MaxDistance=150,AlwaysOnTop=true,Active=false,Size=UDim2.new(5,0,1,0),SizeOffset=Vector2.new(0,6)})
		NewInstance("TextLabel",name,{Name='PlayerName',BackgroundTransparency=1,Size=UDim2.new(1,0,1,0),Text=Plr.Name,Font=Enum.Font.Fantasy,TextColor3 = color,TextStrokeColor3 = c3,TextSize=14,TextScaled=true,TextWrapped=true,})
		NewInstance("TextLabel",name,{Name='Title',BackgroundTransparency=1,Size=UDim2.new(2.5,0,1.5,0),Position=UDim2.new(-.75,0,.9,0),Text=tag,Font=Enum.Font.Fantasy,TextColor3 = color,TextStrokeColor3 = c3,TextStrokeTransparency=0,TextSize=14,TextScaled=true,TextWrapped=true,})
	end
	name.Title.Text = tag
	name.Title.TextColor3 = color
	name.Title.TextStrokeColor3 = c3
	
	name.PlayerName.Text = Plr.Name
	name.PlayerName.TextColor3 = color
	name.PlayerName.TextStrokeColor3 = c3
	
	name.Parent = Char
	name.Adornee = Head
	name.PlayerToHideFrom = Plr
		
	return name
end

--// Customization \\--

local Frame_Speed = 60 -- The frame speed for swait. 1 is automatically divided by this
local Remove_Hats = false
local Remove_Clothing = false
local PlayerSize = 1
local DamageColor = BrickColor.new'Crimson'
local MusicID = 2071274388
local VisSong = 2718536074
local Names = {}
local God = false
local Muted = false
local Volume = 2
local Pitch = 1
local Colorables = {}
local Secondaries = {}
local PrimaryColor;
local SecondColor;
local WingAnim;
local WingPiece = script:WaitForChild'WingPiece'
WingPiece.Parent=nil
local WingAnims={}
local WingVis={0,0,0,0,0,0}
local Pitch = 1
local VisPitch = 1

local ModeIndex = 1;
local Modes = {
	{Name="COMMOTIAUS",WalkSpeed=16,Font=Enum.Font.Arcade,Theme=2071274388,Volume=2,Pitch=1,TextMain=C3.N(.6,0,0),TextStroke=C3.N(0,0,0),Primary=C3.N(.4,0,0),Secondary=C3.N(.4,0,0),LeftWingMat=Enum.Material.Neon,RightWingMat=Enum.Material.Neon,LeftWingTrans=0,RightWingTrans=0,WingAnim='StarG'};
	{Name="DURABITINE",WalkSpeed=16,Font=Enum.Font.Fantasy,Theme=692083837,Volume=2,Pitch=1,TextMain=C3.RGB(39,70,45),TextStroke=C3.RGB(31,128,29),Primary=C3.RGB(31,128,29),Secondary=C3.RGB(31,128,29),LeftWingMat=Enum.Material.Neon,RightWingMat=Enum.Material.Neon,LeftWingTrans=0,RightWingTrans=0,WingAnim='Spin1'};
	{Name="ENCHANTER",WalkSpeed=16,Font=Enum.Font.SourceSansItalic,Theme=436447939,Volume=2,Pitch=1,TextMain=C3.RGB(50,0,50),TextStroke=C3.RGB(170,0,170),Primary=C3.RGB(170,0,170),Secondary=C3.RGB(90,0,90),LeftWingMat=Enum.Material.Neon,RightWingMat=Enum.Material.Neon,LeftWingTrans=0,RightWingTrans=0,WingAnim='OldEnchanter'};
	{Name="MACABRE",WalkSpeed=16,Font=Enum.Font.Antique,Theme=2979962272,Volume=2,Pitch=1,TextMain=C3.N(1,1,1),TextStroke=C3.N(0,0,0),Primary=C3.N(1,1,1),Secondary=C3.N(1,1,1),LeftWingMat=Enum.Material.Neon,RightWingMat=Enum.Material.Neon,LeftWingTrans=0,RightWingTrans=0,WingAnim='Glitchy'};
	{Name="AMBUSTUME",WalkAnimSpeed=0.8,Movement=14,WalkSpeed=48,Font=Enum.Font.Fantasy,Theme=1290419263,Volume=2,Pitch=1,TextMain=C3.RGB(255,121,44),TextStroke=C3.RGB(0,0,0),Primary=C3.RGB(255,98,19),Secondary=C3.RGB(255,98,19),LeftWingMat=Enum.Material.Neon,RightWingMat=Enum.Material.Neon,LeftWingTrans=0,RightWingTrans=0,WingAnim='Ambustume'};
	{Name="GLACIAL",WalkSpeed=16,Font=Enum.Font.Code,Theme=340106355,Volume=2,Pitch=1,TextMain=C3.N(1,1,1),TextStroke=C3.N(0,1,1),Primary=C3.RGB(36,195,238),Secondary=C3.RGB(36,195,238),LeftWingMat=Enum.Material.Ice,RightWingMat=Enum.Material.Ice,LeftWingTrans=0,RightWingTrans=0,WingAnim='Glacial'};
	{Name="SHAMBOLIAC",WalkAnimSpeed=0.8,WalkSpeed=40,Movement=14,Font=Enum.Font.SciFi,Theme=844654533,Volume=2,Pitch=1,TextMain=C3.N(0,0,0),TextStroke=C3.RGB(150,0,0),Primary=C3.RGB(0,0,0),Secondary=C3.RGB(150,0,0),LeftWingMat=Enum.Material.Neon,RightWingMat=Enum.Material.Neon,LeftWingTrans=0,RightWingTrans=0,WingAnim='Chaotic'};
	{Name="PHANTASMAGORION",WalkAnimSpeed=1,WalkSpeed=50,Font=Enum.Font.Code,Theme=1144419666,Volume=3.5,Pitch=1,TextMain=C3.N(0.5,0,0.5),TextStroke=C3.N(1,0,0.25),Primary=C3.RGB(125,20,125),Secondary=C3.RGB(150,0,90),LeftWingMat=Enum.Material.Neon,RightWingMat=Enum.Material.Neon,LeftWingTrans=0,RightWingTrans=0,WingAnim='Spin3'};
	{Name="SINISTER",WalkSpeed=64,WalkAnimSpeed=0.875,Movement=14,Font=Enum.Font.Fantasy,Theme=2984349070,Volume=2,Pitch=1,TextMain=C3.RGB(127,0,0),TextStroke=C3.RGB(0,0,0),Primary=C3.RGB(27, 42, 53),Secondary=C3.N(.2,0,0),LeftWingMat=Enum.Material.Neon,RightWingMat=Enum.Material.Neon,LeftWingTrans=0,RightWingTrans=0,WingAnim='Spin2'};
	{Name="SECLUSION",WalkSpeed=16,Font=Enum.Font.Fantasy,Theme=705302406,Volume=2,Pitch=.8,TextMain=C3.RGB(27, 42, 53),TextStroke=C3.N(0,0,0),Primary=C3.RGB(27, 42, 53),Secondary=C3.RGB(27, 42, 53),LeftWingMat=Enum.Material.Neon,RightWingMat=Enum.Material.Neon,LeftWingTrans=0,RightWingTrans=0,WingAnim='StarG'};
	{Name="ASCENTED",WalkSpeed=45,Font=Enum.Font.Arcade,Theme=150384451,Volume=2,Pitch=1.155,TextMain=C3.RGB(44, 93, 165),TextStroke=C3.RGB(96, 47, 165),Primary=C3.RGB(96, 47, 165),Secondary=C3.RGB(44, 93, 165),LeftWingMat=Enum.Material.Neon,RightWingMat=Enum.Material.Neon,LeftWingTrans=0,RightWingTrans=0,WingAnim='StarG'};
	{Name="UNSANCTIFIED",WalkSpeed=12,WalkAnimSpeed=.4,Movement=6,Font=Enum.Font.Bodoni,Theme=343860759,Volume=2,Pitch=0.65,TextMain=C3.RGB(14, 14, 14),TextStroke=C3.RGB(0, 0, 0),Primary=C3.RGB(0, 0, 0),Secondary=C3.RGB(12, 12, 12),LeftWingMat=Enum.Material.Neon,RightWingMat=Enum.Material.Neon,LeftWingTrans=0,RightWingTrans=0,WingAnim='Unsanct'};
	{Name="LUMINOSITY",WalkSpeed=36,WalkAnimSpeed=0.8,Movement=14,Font=Enum.Font.Code,Theme=437866677,Volume=2,Pitch=1,TextMain=C3.RGB(14, 14, 14),TextStroke=C3.RGB(0, 0, 0),Primary=C3.RGB(0, 0, 0),Secondary=C3.RGB(12, 12, 12),LeftWingMat=Enum.Material.Neon,RightWingMat=Enum.Material.Neon,LeftWingTrans=0,RightWingTrans=0,WingAnim='Visy'};
	{Name="DESIRABILITY",WalkSpeed=16,Font=Enum.Font.Gotham,Theme=146414661,Volume=2,Pitch=1,TextMain=C3.N(14, 14, 0),TextStroke=C3.N(20, 20, 0),Primary=C3.N(14, 14, 0),Secondary=C3.N(20, 20, 0),LeftWingMat=Enum.Material.DiamondPlate,RightWingMat=Enum.Material.DiamondPlate,LeftWingTrans=0,RightWingTrans=0,WingAnim='Birdy'};
	{Name="SYNOPHASIS",WalkSpeed=50,Font=Enum.Font.Code,Theme=2619399246,Volume=2,Pitch=1,TextMain=C3.RGB(98, 37, 209),TextStroke=C3.RGB(98, 37, 186),Primary=C3.RGB(98, 37, 209),Secondary=C3.RGB(98, 37, 186),LeftWingMat=Enum.Material.Neon,RightWingMat=Enum.Material.Neon,LeftWingTrans=0,RightWingTrans=0,WingAnim='Spin4'};
	{Name="EXTINCTION",WalkSpeed=53,Font=Enum.Font.Legacy,Theme=549985098,Volume=2,Pitch=1.02,TextMain=C3.RGB(0, 0, 0),TextStroke=C3.RGB(239, 184, 56),Primary=C3.RGB(68, 34, 0),Secondary=C3.RGB(239, 184, 56),LeftWingMat=Enum.Material.Neon,RightWingMat=Enum.Material.Neon,LeftWingTrans=0,RightWingTrans=0,WingAnim='boi'};
	{Name="EUCATASTROPHE",WalkSpeed=20,Font=Enum.Font.Arcade,Theme=1035328286,Volume=2,Pitch=1.02,TextMain=BrickColor.new("Cyan").Color,TextStroke=BrickColor.new("Deep blue").Color,Primary=C3.RGB(0, 0, 255),Secondary=C3.RGB(0, 0, 150),LeftWingMat=Enum.Material.DiamondPlate,RightWingMat=Enum.Material.Neon,LeftWingTrans=0.5,RightWingTrans=0,WingAnim='Eucat'};
}

--2159459369
local Majors = {
	{Major="COMMOTIAUS",Name="PANDEMONIUM",WalkSpeed=32,Font=Enum.Font.Antique,Theme=1566197356,Volume=2,Pitch=1,TextMain=C3.RGB(14,0,0),TextStroke=C3.RGB(0, 0, 0),Primary=C3.N(.1,0,0),Secondary=C3.N(.1,0,0),LeftWingMat=Enum.Material.DiamondPlate,RightWingMat=Enum.Material.DiamondPlate,LeftWingTrans=0,RightWingTrans=0,WingAnim='Chaotic'};
	{Major="SYNOPHASIS",Name="HELPLESS",WalkSpeed=24,Font=Enum.Font.Code,Theme=2159459369,Volume=2,Pitch=1,TextMain=C3.RGB(98, 37, 209),TextStroke=C3.RGB(98, 37, 186),Primary=C3.RGB(98, 37, 209),Secondary=C3.RGB(98, 37, 186),LeftWingMat=Enum.Material.Neon,RightWingMat=Enum.Material.Neon,LeftWingTrans=0,RightWingTrans=0,WingAnim='Spin1'};
	{Major="AMBUSTUME",Name="ARSONIST",WalkSpeed=16,Font=Enum.Font.SciFi,Theme=2968561228,Volume=2,Pitch=1,TextMain=C3.RGB(255,167,44),TextStroke=C3.RGB(255, 100, 10),Primary=C3.RGB(255,100,10),Secondary=C3.RGB(255,100,10),LeftWingMat=Enum.Material.Neon,RightWingMat=Enum.Material.Neon,LeftWingTrans=0,RightWingTrans=0,WingAnim='Spin1'};
	{Major="DURABITINE",Name="OBLIVION",WalkSpeed=36,WalkAnimSpeed=0.8,Movement=14,Font=Enum.Font.Garamond,Theme=657361420,Volume=2,Pitch=1,TextMain=C3.RGB(93, 117, 80),TextStroke=C3.RGB(0, 0, 0),Primary=C3.RGB(93, 117, 80),Secondary=C3.RGB(0, 0, 0),LeftWingMat=Enum.Material.Neon,RightWingMat=Enum.Material.Neon,LeftWingTrans=0,RightWingTrans=0,WingAnim='NewEnchanter'};
	{Major="SINISTER",Name="MALEVOLENT",WalkSpeed=20,Font=Enum.Font.Antique,Theme=1594042527,Volume=2,Pitch=1,TextMain=C3.RGB(53,0,0),TextStroke=C3.RGB(0, 0, 0),Primary=C3.RGB(53,0,0),Secondary=C3.RGB(14,14,14),LeftWingMat=Enum.Material.Neon,RightWingMat=Enum.Material.Neon,LeftWingTrans=0,RightWingTrans=0,WingAnim='Vol'};
	{Major="LUMINOSITY",Name="INSTRUMENTAL",WalkSpeed=16,Font=Enum.Font.Arcade,Theme=VisSong,Volume=2,Pitch=1,TextMain=C3.RGB(14, 14, 14),TextStroke=C3.RGB(0, 0, 0),Primary=C3.RGB(0, 0, 0),Secondary=C3.RGB(12, 12, 12),LeftWingMat=Enum.Material.Neon,RightWingMat=Enum.Material.Neon,LeftWingTrans=0,RightWingTrans=0,WingAnim='Eucat'};

}


local WalkSpeed = 16

--// Weapon and GUI creation, and Character Customization \\--

if(Remove_Hats)then Instance.ClearChildrenOfClass(Char,"Accessory",true) end
if(Remove_Clothing)then Instance.ClearChildrenOfClass(Char,"Clothing",true) Instance.ClearChildrenOfClass(Char,"ShirtGraphic",true) end

if(PlayerSize ~= 1)then
	for _,v in next, Char:GetDescendants() do
		if(v:IsA'BasePart' and not v:IsDescendantOf(script))then
			v.Size = v.Size*PlayerSize
		end
	end
end

local Music = Sound(Char,MusicID,1,3,true,false,true)
Music.Name = 'Music'

--// Stop animations \\--
for _,v in next, Hum:GetPlayingAnimationTracks() do
	v:Stop();
end

pcall(game.Destroy,Char:FindFirstChild'Animate')
pcall(game.Destroy,Hum:FindFirstChild'Animator')

--// Joints \\--

local LS = NewInstance('Motor',Char,{Part0=Torso,Part1=LArm,C0 = CF.N(-1.5 * PlayerSize,0.5 * PlayerSize,0),C1 = CF.N(0,.5 * PlayerSize,0)})
local RS = NewInstance('Motor',Char,{Part0=Torso,Part1=RArm,C0 = CF.N(1.5 * PlayerSize,0.5 * PlayerSize,0),C1 = CF.N(0,.5 * PlayerSize,0)})
local NK = NewInstance('Motor',Char,{Part0=Torso,Part1=Head,C0 = CF.N(0,1.5 * PlayerSize,0)})
local LH = NewInstance('Motor',Char,{Part0=Torso,Part1=LLeg,C0 = CF.N(-.5 * PlayerSize,-1 * PlayerSize,0),C1 = CF.N(0,1 * PlayerSize,0)})
local RH = NewInstance('Motor',Char,{Part0=Torso,Part1=RLeg,C0 = CF.N(.5 * PlayerSize,-1 * PlayerSize,0),C1 = CF.N(0,1 * PlayerSize,0)})
local RJ = NewInstance('Motor',Char,{Part0=Root,Part1=Torso})

local LSC0 = LS.C0
local RSC0 = RS.C0
local NKC0 = NK.C0
local LHC0 = LH.C0
local RHC0 = RH.C0
local RJC0 = RJ.C0

--// Morph \\--

local wingModel = Instance.new("Model",Char)
wingModel.Name="NGRWings"..script.Name
local rightWing = NewInstance("Model",wingModel,{Name='Right'})
local leftWing = NewInstance("Model",wingModel,{Name='Left'})

local LWP1 = WingPiece:Clone();
LWP1.Parent = leftWing
local LWP2 = WingPiece:Clone();
LWP2.Parent = leftWing
local LWP3 = WingPiece:Clone();
LWP3.Parent = leftWing
local RWP1 = WingPiece:Clone();
RWP1.Parent = rightWing
local RWP2 = WingPiece:Clone();
RWP2.Parent = rightWing
local RWP3 = WingPiece:Clone();
RWP3.Parent = rightWing
local welder = Part(wingModel,C3.N(1,1,1),Enum.Material.SmoothPlastic,V3.N(.05,.05,.05),Torso.CFrame,false,false)
welder.Transparency=1

local WELDER=Weld(welder,Torso,CF.N(0,0,0)*CF.A(0,0,0))
local LWP1W=Weld(LWP1.PrimaryPart,welder,CF.N(2,-2,-1)*CF.A(0,0,0))
local LWP2W=Weld(LWP2.PrimaryPart,welder,CF.N(4.25,-1,-1)*CF.A(0,0,M.R(15)))
local LWP3W=Weld(LWP3.PrimaryPart,welder,CF.N(6.5,.5,-1)*CF.A(0,0,M.R(30)))
local RWP1W=Weld(RWP1.PrimaryPart,welder,CF.N(-2,-2,-1)*CF.A(0,0,0))
local RWP2W=Weld(RWP2.PrimaryPart,welder,CF.N(-4.25,-1,-1)*CF.A(0,0,M.R(-15)))
local RWP3W=Weld(RWP3.PrimaryPart,welder,CF.N(-6.5,.5,-1)*CF.A(0,0,M.R(-30)))

local MPASword = {}
for _,v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
	if v:IsA("Accessory") and v.Name == "MeshPartAccessory" and v.Handle.Size == Vector3.new(4,4,1) then
		table.insert(MPASword,v)
		v.Name = "LMAOSWORDYES"
	end
end
for _,v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
	if v:IsA("Accessory") and v.Name == "MeshPartAccessory" and v.Handle.Size == Vector3.new(5.15097, 5.15097, 0.425024) then
		table.insert(MPASword,v)
		v.Name = "LMAOSWORDYES"
	end
end
numberlolololol = 1
function Align(Part0, Part1, Position, Angle)
	if Part0:FindFirstChild("Attachment") then
		Part0:FindFirstChild("Attachment"):Remove()
	end
    local AlignPosition = Instance.new("AlignPosition",Part0)
    local AlignOrientation = Instance.new("AlignOrientation",Part0)
    
    local Attachment1 = Instance.new("Attachment", Part0)
    local Attachment2 = Instance.new("Attachment", Part1)

    AlignPosition.Attachment0 = Attachment1
    AlignPosition.Attachment1 = Attachment2
    
    AlignOrientation.Attachment0 = Attachment1
    AlignOrientation.Attachment1 = Attachment2
    
    Attachment2.Position = Position or Vector3.new(0,0,0)
    Attachment2.Orientation = Angle or Vector3.new(0,0,0)
    
    AlignOrientation.MaxTorque = math.huge
    AlignOrientation.MaxAngularVelocity = math.huge
    AlignOrientation.PrimaryAxisOnly = false 
    AlignOrientation.Responsiveness = 200
    AlignOrientation.RigidityEnabled = false
    AlignOrientation.ReactionTorqueEnabled = false
    AlignPosition.MaxForce = math.huge
    AlignPosition.MaxVelocity = math.huge
    AlignPosition.ReactionForceEnabled = false
    AlignPosition.Responsiveness = 200
    AlignPosition.ApplyAtCenterOfMass = true
    AlignPosition.RigidityEnabled = true
    game:GetService("RunService").Heartbeat:Connect(function()
        Part0.Velocity = Vector3.new(-29.99,0,0)
        for _,v in pairs(Part1.Parent:GetChildren()) do
		if v:IsA("BasePart") then
			v.Transparency = 1
		end
	end
    end)
    if Part0.Parent:IsA("Accessory") then
    	Part0:BreakJoints()
    end
    Part0.Parent.Name = "swordlmao_"..numberlolololol
    numberlolololol = numberlolololol + 1
end


	for _,v in pairs(LWP1:GetChildren()) do
		if v:IsA("BasePart") then
			v.Transparency = 1
		end
	end
	local HatChoice = MPASword[1]

	Align(HatChoice.Handle, LWP1.Main, Vector3.new(0, -2, 0), Vector3.new(0, 0, 45))

	table.remove(MPASword,1)
	
		for _,v in pairs(LWP2:GetChildren()) do
		if v:IsA("BasePart") then
			v.Transparency = 1
		end
	end
	local HatChoice = MPASword[1]

	Align(HatChoice.Handle, LWP2.Main, Vector3.new(0, -2, 0), Vector3.new(0, 0, 45))

	table.remove(MPASword,1)
	
		for _,v in pairs(LWP3:GetChildren()) do
		if v:IsA("BasePart") then
			v.Transparency = 1
		end
	end
	local HatChoice = game.Players.LocalPlayer.Character["ShadowBladeMasterAccessory"]

	Align(HatChoice.Handle, LWP3.Main, Vector3.new(0, -2, 0), Vector3.new(0, 0, 45))

	table.remove(MPASword,1)
	
	--- right wings ---
	
		for _,v in pairs(RWP1:GetChildren()) do
		if v:IsA("BasePart") then
			v.Transparency = 1
		end
	end
	local HatChoice = MPASword[1]

	Align(HatChoice.Handle, RWP1.Main, Vector3.new(0, -2, 0), Vector3.new(0, 0, 45))

	table.remove(MPASword,1)
	
		for _,v in pairs(RWP2:GetChildren()) do
		if v:IsA("BasePart") then
			v.Transparency = 1
		end
	end
	
	local lmaoseord = game.Players.LocalPlayer.Character.LMAOSWORDYES
	
	local HatChoice = MPASword[1]
	print(HatChoice)
	Align(lmaoseord.Handle, RWP2.Main, Vector3.new(0, -2, 0), Vector3.new(0, 0, 45))

	table.remove(MPASword,1)
	
		for _,v in pairs(RWP3:GetChildren()) do
		if v:IsA("BasePart") then
			v.Transparency = 1
		end
	end
	local HatChoice = game.Players.LocalPlayer.Character["BladeMasterAccessory"]

	Align(HatChoice.Handle, RWP3.Main, Vector3.new(0, -2, 0), Vector3.new(0, 0, 45))

	table.remove(MPASword,1)

local tag = script:WaitForChild'Nametag'
tag.Parent=Char
tag.Adornee=Head
local title = tag.Title
for _,v in next, leftWing:GetDescendants() do
	if(v:IsA'BasePart')then
		table.insert(Colorables,v)
	end
end

for _,v in next, rightWing:GetDescendants() do
	if(v:IsA'BasePart')then
		table.insert(Secondaries,v)
	end
end
--// Artificial HB \\--


local ArtificialHB = IN("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"

script:WaitForChild("Heartbeat")

local tf = 0
local allowframeloss = false
local tossremainder = false
local lastframe = tick()
local frame = 1/Frame_Speed
ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function swait(num)
	if num == 0 or num == nil then
		ArtificialHB.Event:wait()
	else
		for i = 0, num do
			ArtificialHB.Event:wait()
		end
	end
end

--// Wing Animations \\--
WingAnims.StarG=function()
	WELDER.C0 = WELDER.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(0),M.R(0)),.2)

	LWP1W.C0 = LWP1W.C0:lerp(CF.N(2,-2,-1-.025*M.S(WingSine/32))*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(0+5*M.C(WingSine/32))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-1,-1-.05*M.S(WingSine/32))*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(15+7.5*M.C(WingSine/32))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(6.5,.5,-1-0.1*M.C(WingSine/32))*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(30+9*M.C(WingSine/32))),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-2,-2,-1-.025*M.S(WingSine/32))*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(0-5*M.C(WingSine/32))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-1,-1-.05*M.S(WingSine/32))*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(-15-7.5*M.C(WingSine/32))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(-6.5,.5,-1-.1*M.S(WingSine/32))*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(-30-9*M.C(WingSine/32))),.2)
end

WingAnims.Eucat=function() --by killerz bc why not
	for i=6,2,-1 do
		WingVis[i]=WingVis[i-1]
	end
	WingVis[1]=Music.PlaybackLoudness/350

	WELDER.C0 = WELDER.C0:lerp(CF.N(2,-2,-.3)*CF.A(M.R(0),M.R(0),M.R(45)),.5)

	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,0+WingVis[1],-2)*CF.A(M.R(0),0,M.R(0)),.5)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,0+WingVis[2],-2)*CF.A(M.R(0),0,M.R(90)),.5)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,0+WingVis[3],-2)*CF.A(M.R(0),0,M.R(45)),.5)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,0+WingVis[4],-2)*CF.A(M.R(0),0,M.R(180)),.5)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,0+WingVis[5],-2)*CF.A(M.R(0),0,M.R(-90)),.5)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,0+WingVis[6],-2)*CF.A(M.R(0),0,M.R(-140)),.5)

end

WingAnims.Glacial=function()
	WELDER.C0 = WELDER.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(0),M.R(0)),.2)

	LWP1W.C0 = LWP1W.C0:lerp(CF.N(.15,1.5,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(60)),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(.1,1.5,-1)*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(90)),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(.25,1.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(120)),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-.15,1.5,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(-60)),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-.1,1.5,-1)*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(-90)),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(-.25,1.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(-120)),.2)
end

WingAnims.boi=function()
	WELDER.C0 = WELDER.C0:lerp(CF.N(0,0,-1.85)*CF.A(M.R(0),M.R(90),M.R(0)),.2)

	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,2.5,-1)*CF.A(M.R(0),M.R(0+2.5*M.C(WingSine/36)),M.R(0-WingSine)),.8)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,2.5,-1)*CF.A(M.R(0),M.R(0+7.5*M.C(WingSine/32)),M.R(135-WingSine)),.8)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,2.5,-1)*CF.A(M.R(0),M.R(0+5*M.C(WingSine/39)),M.R(225-WingSine)),.8)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,2.5,5)*CF.A(M.R(0),M.R(0+2.5*M.C(WingSine/36)),M.R(0+WingSine)),.8)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,2.5,5)*CF.A(M.R(0),M.R(0+7.5*M.C(WingSine/32)),M.R(135+WingSine)),.8)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,2.5,5)*CF.A(M.R(0),M.R(0+5*M.C(WingSine/39)),M.R(225+WingSine)),.8)

	return math.max((Music.PlaybackLoudness)/40,.5)
end

WingAnims.Birdy=function()
	WELDER.C0 = WELDER.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(0),M.R(0)),.2)

	LWP1W.C0 = LWP1W.C0:lerp(CF.N(.15,1.5,-1-.025*M.S(WingSine/32))*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(75)),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(.25,1.5,-1-.05*M.S(WingSine/32))*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(120)),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(.40,1.5,-1-.1*M.S(WingSine/32))*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(180)),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-.15,1.5,-1-.025*M.S(WingSine/32))*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(-75)),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-.25,1.5,-1-.05*M.S(WingSine/32))*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(-120)),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(-.40,1.5,-1-.1*M.S(WingSine/32))*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(-180)),.2)
end
--[[
This is the old wingmesh i made for my skidded edit of universal lol - derpz <-- why did you put it in here? -Unfair


lwing1weld.C1=clerp(lwing1weld.C1,cf(2.5,-1,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0 + 5 * math.cos(sine / 50)),math.rad(0 + 20 * math.cos(sine / 50)),math.rad(0 + 5 * math.cos(sine / 50))),.3)
lwing2weld.C1=clerp(lwing2weld.C1,cf(4,-1,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0 + 10 * math.cos(sine / 50)),math.rad(0 + 20 * math.cos(sine / 50)),math.rad(0 + 10 * math.cos(sine / 50))),.3)
lwing3weld.C1=clerp(lwing3weld.C1,cf(5.75,-1,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0 + 30 * math.cos(sine / 50)),math.rad(0 + 20 * math.cos(sine / 50)),math.rad(0 + 20 * math.cos(sine / 50))),.3)
rwing1weld.C1=clerp(rwing1weld.C1,cf(-2.5,-1,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0 + 5 * math.cos(sine / 50)),math.rad(0 - 20 * math.cos(sine / 50)),math.rad(0 - 5 * math.cos(sine / 50))),.3)
rwing2weld.C1=clerp(rwing2weld.C1,cf(-4,-1,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0 + 10 * math.cos(sine / 50)),math.rad(0 - 20 * math.cos(sine / 50)),math.rad(0 - 10 * math.cos(sine / 50))),.3)
rwing3weld.C1=clerp(rwing3weld.C1,cf(-5.75,-1,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0 + 30 * math.cos(sine / 50)),math.rad(0 - 20 * math.cos(sine / 50)),math.rad(0 - 20 * math.cos(sine / 50))),.3)
]]
WingAnims.Spin1=function()
	WELDER.C0 = WELDER.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(0),M.R(0)),.2)

	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,1+1*M.C(WingSine/100),-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(0+WingSine)),.8)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,1+1*M.C(WingSine/100),-1)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(135+WingSine)),.8)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,1+1*M.C(WingSine/100),-1)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(225+WingSine)),.8)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,1.5-1.5*M.C(WingSine/100),-1.5)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(0-WingSine)),.8)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,1.5-1.5*M.C(WingSine/100),-1.5)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(135-WingSine)),.8)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,1.5-1.5*M.C(WingSine/100),-1.5)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(225-WingSine)),.8)
	
	return math.max((Music.PlaybackLoudness)/50,.5)
end

WingAnims.Visy=function()
	for i=6,2,-1 do
		WingVis[i]=WingVis[i-1]
	end
	WingVis[1]=Music.PlaybackLoudness/100000
	WELDER.C0 = WELDER.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(0),M.R(0)),.2)

	LWP1W.C0 = LWP1W.C0:lerp(CF.N(2,-3.5-WingVis[3],-1.2-.025*M.S(WingSine/32))*CF.A(M.R(5+.10*M.C(WingSine/32)),0,M.R(0+.5*M.C(WingSine/32))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-4-WingVis[2],-1.2-.05*M.S(WingSine/32))*CF.A(M.R(10+.15*M.C(WingSine/32)),0,M.R(-15+.75*M.C(WingSine/32))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(6.5,-5-WingVis[1],-1.2-.1*M.C(WingSine/32))*CF.A(M.R(15+.20*M.C(WingSine/32)),0,M.R(-30+.9*M.C(WingSine/32))),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-2,-3.5-WingVis[6],-1.2-.025*M.S(WingSine/32))*CF.A(M.R(5+.10*M.C(WingSine/32)),0,M.R(0-.5*M.C(WingSine/32))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-4-WingVis[5],-1.2-.05*M.S(WingSine/32))*CF.A(M.R(10+.15*M.C(WingSine/32)),0,M.R(15-.75*M.C(WingSine/32))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(-6.5,-5-WingVis[4],-1.2-.1*M.S(WingSine/32))*CF.A(M.R(15+.20*M.C(WingSine/32)),0,M.R(30-.9*M.C(WingSine/32))),.2)
end

WingAnims.NewEnchanter=function()
	WELDER.C0 = WELDER.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(0),M.R(0)),.2)

	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0-0.125*M.C(WingSine/99),4-0.25*M.C(WingSine/93),0.75-0.1*M.C(WingSine/115))*CF.A(M.R(175-5*M.C(WingSine/115)),M.R(0),M.R(0+2.5*M.C(WingSine/95))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(1.5-0.25*M.C(WingSine/78),3.5-0.25*M.C(WingSine/63),0.75-0.1*M.C(WingSine/125))*CF.A(M.R(175-5*M.C(WingSine/121)),M.R(0),M.R(45-5*M.C(WingSine/65))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(-1.5-0.25*M.C(WingSine/86),3.5-0.25*M.C(WingSine/73),0.75-0.1*M.C(WingSine/118))*CF.A(M.R(175-5*M.C(WingSine/118)),M.R(0),M.R(-45+5*M.C(WingSine/58))),.2)

	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0-0.125*M.C(WingSine/76),-2-0.25*M.C(WingSine/66),-1)*CF.A(M.R(5-5*M.C(WingSine/104)),M.R(0),M.R(0-2.5*M.C(WingSine/87))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-2-0.25*M.C(WingSine/94),0-0.25*M.C(WingSine/79),-1)*CF.A(M.R(5-5*M.C(WingSine/111)),M.R(0),M.R(-45+5*M.C(WingSine/54))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(2-0.25*M.C(WingSine/81),0-0.25*M.C(WingSine/74),-1)*CF.A(M.R(5-5*M.C(WingSine/109)),M.R(0),M.R(45-5*M.C(WingSine/61))),.2)
end

WingAnims.Unsanct=function()
	WELDER.C0 = WELDER.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(0),M.R(0)),.2)

	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0-.125*M.C(WingSine/99),0,1)*CF.A(M.R(175-5*M.C(WingSine/115)),M.R(0),M.R(0+2.5*M.C(WingSine/75))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(1.5-.25*M.C(WingSine/120),0,1)*CF.A(M.R(175-5*M.C(WingSine/121)),M.R(0),M.R(45+5*M.C(WingSine/75))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(-1.5-.55*M.C(WingSine/176),0,1)*CF.A(M.R(175-5*M.C(WingSine/118)),M.R(0),M.R(-45+7.5*M.C(WingSine/78))),.2)

	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0-0.125*M.C(WingSine/99),0,-1.15)*CF.A(M.R(5-5*M.C(WingSine/115)),M.R(0),M.R(0-2.5*M.C(WingSine/75))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-1.5-0.25*M.C(WingSine/120),0,-1.15)*CF.A(M.R(5-5*M.C(WingSine/121)),M.R(0),M.R(-45-5*M.C(WingSine/75))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(1.5-0.55*M.C(WingSine/176),0,-1.15)*CF.A(M.R(5-5*M.C(WingSine/118)),M.R(0),M.R(45-7.5*M.C(WingSine/78))),.2)
end

WingAnims.OldEnchanter=function()
	WELDER.C0=WELDER.C0:lerp(CF.N(0,0,-1)*CF.A(M.R(0),M.R(0),M.R(0)),.3)
	RWP1W.C0=RWP1W.C0:lerp(CF.N(-5.25,3+ 1 * M.C(WingSine / 23.5),0)*CF.A(M.R(0),M.R(0),M.R(0))*CF.A(M.R(0),M.R(0+ 20 * M.C(WingSine / 47)),M.R(135+ 10 * M.C(WingSine / 47))),.3)
	RWP2W.C0=RWP2W.C0:lerp(CF.N(0,-10 + 0.75 * M.C(WingSine / 34),0)*CF.A(M.R(0),M.R(0),M.R(0))*CF.A(M.R(0),M.R(0),M.R(0 + 10 * M.C(WingSine / 47))),.3)
	RWP3W.C0=RWP3W.C0:lerp(CF.N(5.25,3+ 1 * M.C(WingSine / 23.5),0)*CF.A(M.R(0),M.R(0),M.R(0))*CF.A(M.R(0),M.R(0+ 20 * M.C(WingSine / 47)),M.R(-135+ 10 * M.C(WingSine / 47))),.3)
	LWP1W.C0=LWP1W.C0:lerp(CF.N(-3.75,-2,0)*CF.A(M.R(0),M.R(0),M.R(0))*CF.A(M.R(0),M.R(0+ 20 * M.C(WingSine / 47)),M.R(-135+ 10 * M.C(WingSine / 47))),.3)
	LWP2W.C0=LWP2W.C0:lerp(CF.N(0,1 + 0.75 * M.C(WingSine / 34),0)*CF.A(M.R(0),M.R(0),M.R(0))*CF.A(M.R(0),M.R(0),M.R(180 + 10 * M.C(WingSine / 47))),.3)
	LWP3W.C0=LWP3W.C0:lerp(CF.N(3.75,-2,0)*CF.A(M.R(0),M.R(0),M.R(0))*CF.A(M.R(0),M.R(0+ 20 * M.C(WingSine / 47)),M.R(135+ 10 * M.C(WingSine / 47))),.3)

end
WingAnims.Spin2=function()
	WELDER.C0 = WELDER.C0:lerp(CF.N(0,0,0)*CF.A(M.R(90),M.R(0),M.R(0)),.2)

	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,2,-1.5+1.3*M.C(WingSine/100))*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(0+WingSine)),.8)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,2,-1.5+1.3*M.C(WingSine/100))*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(135+WingSine)),.8)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,2,-1.5+1.3*M.C(WingSine/100))*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(225+WingSine)),.8)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,2.5,1.5-1.3*M.C(WingSine/100))*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(0-WingSine)),.8)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,2.5,1.5-1.3*M.C(WingSine/100))*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(135-WingSine)),.8)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,2.5,1.5-1.3*M.C(WingSine/100))*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(225-WingSine)),.8)
	
	return math.max((Music.PlaybackLoudness)/75,.5)
end

WingAnims.Glitchy=function()
	WELDER.C0 = WELDER.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(0),M.R(0)),.2)

	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0+M.RNG(-300,300)/100,1.5+M.RNG(-300,300)/100,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(0+WingSine+M.RNG(-300,300)/10)),.8)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0+M.RNG(-300,300)/100,1.5+M.RNG(-300,300)/100,-1)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(135+WingSine+M.RNG(-300,300)/10)),.8)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(0+M.RNG(-300,300)/100,1.5+M.RNG(-300,300)/100,-1)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(225+WingSine+M.RNG(-300,300)/10)),.8)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0+M.RNG(-300,300)/100,1.5+M.RNG(-300,300)/100,-1.5)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(0-WingSine+M.RNG(-300,300)/10)),.8)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(0+M.RNG(-300,300)/100,1.5+M.RNG(-300,300)/100,-1.5)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(135-WingSine+M.RNG(-300,300)/10)),.8)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(0+M.RNG(-300,300)/100,1.5+M.RNG(-300,300)/100,-1.5)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(225-WingSine+M.RNG(-300,300)/10)),.8)
end

WingAnims.Ambustume=function()
	WELDER.C0 = WELDER.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(0),M.R(0)),.2)

	LWP1W.C0 = LWP1W.C0:lerp(CF.N(2,-2 + 0.3 * M.C(WingSine/32),-1)*CF.A(M.R(0),0,M.R(0-2.5*M.C(WingSine/32))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-2 + 0.2 * M.C(WingSine/32),-1)*CF.A(M.R(0),0,M.R(0-5*M.C(WingSine/32))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(6.5,-2 + 0.1 * M.C(WingSine/32),-1)*CF.A(M.R(0),0,M.R(0-10*M.C(WingSine/32))),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-2,-2 + 0.3 * M.C(WingSine/32),-1)*CF.A(M.R(0),0,M.R(0+2.5*M.C(WingSine/32))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-2 + 0.2 * M.C(WingSine/32),-1)*CF.A(M.R(0),0,M.R(0+5*M.C(WingSine/32))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(-6.5,-2 + 0.1 * M.C(WingSine/32),-1)*CF.A(M.R(0),0,M.R(0+10*M.C(WingSine/32))),.2)
end

WingAnims.Chaotic=function()
	WELDER.C0 = WELDER.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(0),M.R(0)),.2)

	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,4-0.5*M.C(WingSine/32),1.5)*CF.A(M.R(180),M.R(0),M.R(0)),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(-1.5,3.5-1*M.C(WingSine/32),1.5)*CF.A(M.R(180),M.R(0),M.R(15-6*M.S(WingSine/32))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(1.5,3.5-1*M.C(WingSine/32),1.5)*CF.A(M.R(180),M.R(0),M.R(-15+6*M.S(WingSine/32))),.2)

	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,-2-0.5*M.C(WingSine/32),-1.5)*CF.A(M.R(0),M.R(0),M.R(0)),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-1.5,-1.5-1*M.C(WingSine/32),-1.5)*CF.A(M.R(0),M.R(0),M.R(15-6*M.S(WingSine/32))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(1.5,-1.5-1*M.C(WingSine/32),-1.5)*CF.A(M.R(0),M.R(0),M.R(-15+6*M.S(WingSine/32))),.2)
end

WingAnims.Spin3=function()
	WELDER.C0 = WELDER.C0:lerp(CF.N(0,0,-1.85)*CF.A(M.R(90),M.R(0),M.R(0)),.2)

	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,1+1*M.C(WingSine/100),-1.5)*CF.A(M.R(0),M.R(0+2.5*M.C(WingSine/36)),M.R(0+WingSine)),.8)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,1+1*M.C(WingSine/100),-1.5)*CF.A(M.R(0),M.R(0+7.5*M.C(WingSine/32)),M.R(135+WingSine)),.8)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,1+1*M.C(WingSine/100),-1.5)*CF.A(M.R(0),M.R(0+5*M.C(WingSine/39)),M.R(225+WingSine)),.8)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,1.5-1.5*M.C(WingSine/100),-1)*CF.A(M.R(0),M.R(0+2.5*M.C(WingSine/36)),M.R(0-WingSine)),.8)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,1.5-1.5*M.C(WingSine/100),-1)*CF.A(M.R(0),M.R(0+7.5*M.C(WingSine/32)),M.R(135-WingSine)),.8)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,1.5-1.5*M.C(WingSine/100),-1)*CF.A(M.R(0),M.R(0+5*M.C(WingSine/39)),M.R(225-WingSine)),.8)

	return math.max((Music.PlaybackLoudness)/40,.5)
end

WingAnims.Spin4=function()
	WELDER.C0 = WELDER.C0:lerp(CF.N(0,0,-1.5)*CF.A(M.R(90),M.R(0),M.R(0)),.2)

	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,1+0.5*M.C(WingSine/100),4)*CF.A(M.R(0),M.R(0+2.5*M.C(WingSine/36)),M.R(0+WingSine)),.8)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,1+0.5*M.C(WingSine/100),4)*CF.A(M.R(0),M.R(0+7.5*M.C(WingSine/32)),M.R(135+WingSine)),.8)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,1+0.5*M.C(WingSine/100),4)*CF.A(M.R(0),M.R(0+5*M.C(WingSine/39)),M.R(225+WingSine)),.8)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,3-0.5*M.C(WingSine/100),4)*CF.A(M.R(0),M.R(0+2.5*M.C(WingSine/36)),M.R(0-WingSine)),.8)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,3-0.5*M.C(WingSine/100),4)*CF.A(M.R(0),M.R(0+7.5*M.C(WingSine/32)),M.R(135-WingSine)),.8)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,3-0.5*M.C(WingSine/100),4)*CF.A(M.R(0),M.R(0+5*M.C(WingSine/39)),M.R(225-WingSine)),.8)

	return math.max((Music.PlaybackLoudness)/40,.5)
end

WingAnims.Vol=function()
	WELDER.C0 = WELDER.C0:lerp(CF.N(0,0,-7.5)*CF.A(M.R(90),M.R(0),M.R(0)),.2)

	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,1+0.5*M.C(WingSine/100),4)*CF.A(M.R(0),M.R(0+2.5*M.C(WingSine/36)),M.R(0+WingSine)),.8)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,1+0.5*M.C(WingSine/100),4)*CF.A(M.R(0),M.R(0+7.5*M.C(WingSine/32)),M.R(135+WingSine)),.8)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,1+0.5*M.C(WingSine/100),4)*CF.A(M.R(0),M.R(0+5*M.C(WingSine/39)),M.R(225+WingSine)),.8)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,1+0.5*M.C(WingSine/100),4)*CF.A(M.R(0),M.R(0+2.5*M.C(WingSine/36)),M.R(0-WingSine)),.8)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,1+0.5*M.C(WingSine/100),4)*CF.A(M.R(0),M.R(0+7.5*M.C(WingSine/32)),M.R(135-WingSine)),.8)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,1+0.5*M.C(WingSine/100),4)*CF.A(M.R(0),M.R(0+5*M.C(WingSine/39)),M.R(225-WingSine)),.8)
	
	return math.max((Music.PlaybackLoudness)/50,1)
end
--// Effect Function(s) \\--

function Puddle(hit,pos,norm,data)
	local material = data.Material or Enum.Material.Glass
	local color = data.Color or C3.N(.7,0,0)
	local size = data.Size or 1
		
	if(hit.Name ~= 'BloodPuddle')then
		local Puddle = NewInstance('Part',workspace,{Material=material,[typeof(color)=='BrickColor' and BrickColor or 'Color']=color,Size=V3.N(size,.1,size),CFrame=CF.N(pos,pos+norm)*CF.A(90*M.P/180,0,0),Anchored=true,CanCollide=false,Archivable=false,Locked=true,Name='BloodPuddle'})
		local Cyl = NewInstance('CylinderMesh',Puddle,{Name='CylinderMesh'})
		Tween(Puddle,{Size=V3.N(size*2,.1,size*2)},.2,Enum.EasingStyle.Linear,Enum.EasingDirection.Out,0,false)
		BloodPuddles[Puddle] = 0
	else
		local cyl = hit:FindFirstChild'CylinderMesh'
		if(cyl)then
			BloodPuddles[hit] = 0
			--cyl.Scale = cyl.Scale + V3.N(size,0,size)
			hit.Color = hit.Color:lerp(color,.05)
			Tween(cyl,{Scale = cyl.Scale + V3.N(size,0,size)},.2,Enum.EasingStyle.Linear,Enum.EasingDirection.Out,0,false)
			hit.Transparency = 0
		end
	end
end

local fromaxisangle = function(x, y, z) -- credit to phantom forces devs
	if not y then
		x, y, z = x.x, x.y, x.z
	end
	local m = (x * x + y * y + z * z) ^ 0.5
	if m > 1.0E-5 then
		local si = M.S(m / 2) / m
		return CFrame.new(0, 0, 0, si * x, si * y, si * z, M.C(m / 2))
	else
		return CFrame.new()
	end
end

function fakePhysics(elapsed,cframe,velocity,rotation,acceleration)
	local pos = cframe.p
	local matrix = cframe-pos
	return fromaxisangle(elapsed*rotation)*matrix+pos+elapsed*velocity+elapsed*elapsed*acceleration
end

function Droplet(data)
	local Size = data.Size or 1;
	local Origin = data.Origin or Torso.CFrame;
	local Velocity = data.Velocity or Vector3.new(0,100,0);
	local Gravity = data.Gravity or workspace.Gravity;
	local Color = data.Color or C3.N(.7,0,0);
	local Lifetime = data.Lifetime or 1;
	local Material = data.Material or Enum.Material.Glass;
	local ignore = data.Ignorelist or {Char};
	
	local drop = Part(Effects,Color,Material,V3.N(Size,Size,Size),Origin,true,false)
	Mesh(drop,Enum.MeshType.Sphere)
	local startTick = tick();
	coroutine.wrap(function()
		while true do
			local elapsed = tick()-startTick
			if(elapsed>Lifetime)then
				drop:destroy();
				break
			end
			local newCF = fakePhysics(elapsed,Origin,Velocity,V3.N(),V3.N(0,-Gravity,0))
			local dist = (drop.Position-newCF.p).magnitude
			local hit,pos,norm = CastRay(drop.Position,newCF.p,dist,ignore)
			if(hit and (hit.CanCollide or hit.Name=='BloodPuddle' or BloodPuddles[hit]) and not hit.Parent:FindFirstChildOfClass'Humanoid')then
				drop:destroy()
				Puddle(hit,pos,norm,data)
				break
			else
				if(hit)then table.insert(ignore,hit) end
				drop.CFrame = newCF
			end
			swait()
		end
	end)()
end

function Tween(obj,props,time,easing,direction,repeats,backwards)
	local info = TweenInfo.new(time or .5, easing or Enum.EasingStyle.Quad, direction or Enum.EasingDirection.Out, repeats or 0, backwards or false)
	local tween = S.TweenService:Create(obj, info, props)
	
	tween:Play()
end
local tweensrtjgutrjgu = game:GetObjects('rbxassetid://7692653707')[1]
local EasingFunctions = tweensrtjgutrjgu

local function numLerp(Start,Finish,Alpha)
    return Start + (Finish- Start) * Alpha
end

local EffectInfo={}
function Effect(data)
	local color = data.Color or Color3.new(1,1,1);
	local transparency = data.Transparency or {0,1}
	local lifetime = data.Lifetime or 1
	local cframe = data.CFrame or CFrame.new(0,10,0)
	local acceleration = data.Acceleration or Vector3.new(0,0,0)
	local endpos = data.EndPos or nil
	local rotation = data.Rotation or {0,0,0}
	local meshData = data.Mesh or {Type=Enum.MeshType.Brick}
	local size = data.Size or Vector3.new(1,1,1)
	local material = data.Material or Enum.Material.Neon
	local setpart = typeof(data.Part)=='string' and FXFolder:FindFirstChild(tostring(data.Part)):Clone() or typeof(data.Part)=='Instance' and data.Part or nil
	local endSize = data.EndSize or nil
	local drag = data.Drag or 0
	local sizeTween = data.TweenSize;
	local moveTween = data.TweenPos;
	local transTween = data.TweenTrans;
	local accelTween = data.TweenAccel;
	local parent = data.Parent or Effects
	if(endSize and typeof(size)=='Vector3')then size={size,endSize} end
	
	if(typeof(size)=='Vector3')then
		size={size,size}
	end
	
	if(typeof(transparency)=='number')then
		transparency={transparency,transparency}
	end
	
	if(typeof(color)=='BrickColor')then
		color=color.Color
	end
	
	local PM;
	
	local part = setpart or Part(parent,color,material,V3.N(1,1,1),cframe,true,false)
	if(not part:IsA'MeshPart' and not part:IsA'UnionOperation')then
		local scale = size[1]
		if(meshData == "Blast")then
			PM = Mesh(part,Enum.MeshType.FileMesh,'rbxassetid://20329976','',scale,Vector3.new(0,0,-scale.X/8))
		elseif(meshData == 'Ring')then
			PM = Mesh(part,Enum.MeshType.FileMesh,'rbxassetid://559831844','',scale,Vector3.new(0,0,0))
		elseif(meshData == 'Slash1')then
			PM = Mesh(part,Enum.MeshType.FileMesh,'rbxassetid://662586858','',Vector3.new(scale.X/10,.001,scale.Z/10),Vector3.new(0,0,0))
		elseif(meshData == 'Slash2')then
			PM = Mesh(part,Enum.MeshType.FileMesh,'rbxassetid://448386996','',Vector3.new(scale.X/1000,scale.Y/100,scale.Z/100),Vector3.new(0,0,0))
		elseif(meshData == 'Tornado1')then
			PM = Mesh(part,Enum.MeshType.FileMesh,'rbxassetid://443529437','',scale/10,Vector3.new(0,0,0))
		elseif(meshData == 'Tornado2')then
			PM = Mesh(part,Enum.MeshType.FileMesh,'rbxassetid://168892432','',scale/4,Vector3.new(0,0,0))
		elseif(meshData == 'Skull')then
			PM = Mesh(part,Enum.MeshType.FileMesh,'rbxassetid://4770583','',scale*2,Vector3.new(0,0,0))
		elseif(meshData == 'Crystal')then
			PM = Mesh(part,Enum.MeshType.FileMesh,'rbxassetid://9756362','',scale,Vector3.new(0,0,0))
		elseif(meshData == 'Cloud')then
			PM = Mesh(part,Enum.MeshType.FileMesh,'rbxassetid://1095708','',scale,Vector3.new(0,0,0))
		elseif(typeof(meshData) == 'table' or typeof(meshData) == 'Instance')then
			local Type = meshData.MeshType or meshData.Type or Enum.MeshType.Brick
			local ID = meshData.MeshId or meshData.Mesh or '';
			local Tex = meshData.TextureId or meshData.Texture or '';
			local Offset = meshData.Offset or Vector3.new(0,0,0)
			PM = Mesh(part,Type,ID,Tex,scale,Offset)
		elseif(not part:FindFirstChildOfClass('DataModelMesh'))then
			PM = Mesh(part,Enum.MeshType.Brick,'','',scale)
		else
			PM = part:FindFirstChildOfClass('DataModelMesh')
		end
	end
	
	part.Material = material
	part.CFrame = cframe
	part.Color = color
	part.Anchored = true
	part.CanCollide = false
	part.Transparency = transparency[1]
	part.Size = (PM and V3.N(1,1,1) or size[1])
	part.Parent = parent
	
	local start = tick()
	local t0 = tick()
	local t01 = tick()
	local lastTrans='Nil';
	local lastSize='Nil';
	local lastColor='Nil';
	local info = {start,lifetime,t0,transTween,sizeTween,moveTween,accelTween,color,transparency,size,part,PM,rotation,acceleration,endpos,cframe,drag,acceleration}
	table.insert(EffectInfo,info)
end

coroutine.wrap(function()
	while true do
		swait()
		for i,v in next, EffectInfo do
			local start,lifetime,t0,transTween,sizeTween,moveTween,accelTween,color,transparency,size,part,mesh,rotation,acceleration,endpos,cframe,drag,startacc=unpack(v)
			local elapsed = tick()-start
			local left = elapsed/lifetime
			local dt = tick()-t0
			t0 = tick()
			if(mesh)then
				mesh.Scale = size[1]:lerp(size[2],(sizeTween and sizeTween(elapsed,0,1,lifetime) or left))
			else
				part.Size = size[1]:lerp(size[2],(sizeTween and sizeTween(elapsed,0,1,lifetime) or left))
			end
			part.Transparency = numLerp(transparency[1],transparency[2],(transTween and transTween(elapsed,0,1,lifetime) or left))
			
			local newRot={0,0,0}
			if(rotation=='random')then
				newRot={M.R(M.RNG(0,360)),M.R(M.RNG(0,360)),M.R(M.RNG(0,360))}
			elseif(typeof(rotation)=='table')then
				local x,y,z=M.R(rotation[1]),M.R(rotation[2]),M.R(rotation[3])
				if(rotation[1]==0)then x=0 end
				if(rotation[2]==0)then y=0 end
				if(rotation[3]==0)then z=0 end
				newRot={x,y,z}
			end
			
			local accelMult=(accelTween and 1-accelTween(elapsed,0,1,lifetime) or 1)

			local accel=(acceleration*dt)
			if(endpos)then
				part.CFrame = cframe:lerp(endpos,(moveTween and moveTween(elapsed,0,1,lifetime) or left))
			elseif(accel and (accel.x~=0 or accel.y~=0 or accel.z~=0))then
				part.CFrame = part.CFrame*CF.A(unpack(newRot))+(accel*accelMult)
			elseif(newRot and (newRot[1]~=0 or newRot[2]~=0 or newRot[3]~=0))then
				part.CFrame = part.CFrame*CF.A(unpack(newRot))
			end
			if(drag>0)then
				acceleration=acceleration-V3.N(
					0.05*startacc.x/(drag/1.5),
					0.05*startacc.y/(drag/1.5),
					0.05*startacc.z/(drag/1.5)
				)
			end
			if(elapsed>lifetime)then
				part:destroy()
				EffectInfo[i]=nil
			else
				EffectInfo[i]={start,lifetime,t0,transTween,sizeTween,moveTween,accelTween,color,transparency,size,part,mesh,rotation,acceleration,endpos,cframe,drag,startacc}
			end
		end
	end
end)()

function LegacyEffect(data)
	-- just for easy reference
	local color = data.Color or Color3.new(.7,.7,.7);
	local endcolor = data.EndColor or nil;
	local mat = data.Material or Enum.Material.SmoothPlastic;
	local cframe = data.CFrame or CFrame.new();
	local endpos = data.EndPos or nil;
	local meshdata = data.Mesh or {}
	local sounddata = data.Sound or {}
	local size = data.Size or Vector3.new(1,1,1)
	local endsize = data.EndSize or Vector3.new(6,6,6)
	local rotinc = data.RotInc or {0,0,0} -- ONLY FOR LEGACY SYSTEM
	local transparency = data.Transparency or NumberRange.new(0,1)
	local acceleration = data.Acceleration or nil; -- ONLY FOR LEGACY SYSTEM
	local endrot = data.EndRotation or {0,0,0} -- ONLY FOR EXPERIMENTAL SYSTEM
	local style = data.Style or false; -- ONLY FOR EXPERIMENTAL SYSTEM
	local lifetime = data.Lifetime or 1;
	local system = data.FXSystem;
	local setpart = typeof(data.Part)=='string' and FXFolder:FindFirstChild(tostring(data.Part)):Clone() or typeof(data.Part)=='Instance' and data.Part or nil
	
	local S,PM;
	
	local P = setpart or Part(nil,color,mat,Vector3.new(1,1,1),cframe,true,false)
	
	if(not P:IsA'MeshPart' and not P:IsA'UnionOperation')then
		if(meshdata == "Blast")then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://20329976','',size,Vector3.new(0,0,-size.X/8))
		elseif(meshdata == 'Ring')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://559831844','',size,Vector3.new(0,0,0))
		elseif(meshdata == 'Slash1')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://662586858','',Vector3.new(size.X/10,.001,size.Z/10),Vector3.new(0,0,0))
		elseif(meshdata == 'Slash2')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://448386996','',Vector3.new(size.X/1000,size.Y/100,size.Z/100),Vector3.new(0,0,0))
		elseif(meshdata == 'Tornado1')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://443529437','',size/10,Vector3.new(0,0,0))
		elseif(meshdata == 'Tornado2')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://168892432','',size/4,Vector3.new(0,0,0))
		elseif(meshdata == 'Skull')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://4770583','',size*2,Vector3.new(0,0,0))
		elseif(meshdata == 'Crystal')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://9756362','',size,Vector3.new(0,0,0))
		elseif(meshdata == 'Cloud')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://1095708','',size,Vector3.new(0,0,0))
		elseif(typeof(meshdata) == 'table')then
			local Type = meshdata.Type or Enum.MeshType.Brick
			local ID = meshdata.ID or '';
			local Tex = meshdata.Texture or '';
			local Offset = meshdata.Offset or Vector3.new(0,0,0)
			PM = Mesh(P,Type,ID,Tex,size,Offset)
		else
			PM = Mesh(P,Enum.MeshType.Brick,'','',size)
		end
	end
	local startTrans = typeof(transparency) == 'number' and transparency or typeof(transparency) == 'NumberRange' and transparency.Min or typeof(transparency) == 'table' and transparency[1] or 0
	local endTrans = typeof(transparency) == 'NumberRange' and transparency.Max or typeof(transparency) == 'table' and transparency[2] or 1
	
	P.Material = mat
	P.CFrame = cframe
	P.Color = (typeof(color)=='BrickColor' and color.Color or color)
	P.Anchored = true
	P.CanCollide = false
	P.Transparency = startTrans
	P.Parent = Effects
	local random = Random.new();
	game:service'Debris':AddItem(P,lifetime+3)
	
	
	-- actual effect stuff
	local mult = 1;
	if(PM)then
		if(PM.MeshId == 'rbxassetid://20329976')then
			PM.Offset = Vector3.new(0,0,-PM.Scale.Z/8)
		elseif(PM.MeshId == 'rbxassetid://4770583')then
			mult = 2
		elseif(PM.MeshId == 'rbxassetid://168892432')then
			mult = .25
		elseif(PM.MeshId == 'rbxassetid://443529437')then
			mult = .1
		elseif(PM.MeshId == 'rbxassetid://443529437')then
			mult = .1
		end
	end	
	coroutine.wrap(function()
		if(system == 'Legacy' or system == 1 or system == nil)then
			local frames = (typeof(lifetime) == 'NumberRange' and random:NextNumber(lifetime.Min,lifetime.Max) or typeof(lifetime) == 'number' and lifetime or 1)*Frame_Speed
			for i = 0, frames do
				local div = (i/frames)
				P.Transparency=(startTrans+(endTrans-startTrans)*div)
				
				if(PM)then PM.Scale = size:lerp(endsize*mult,div) else P.Size = size:lerp(endsize*mult,div) end
				
				local RotCF=CF.A(0,0,0)
				
				if(rotinc == 'random')then
					RotCF=CF.A(M.R(random:NextNumber(-180,180)),M.R(random:NextNumber(-180,180)),M.R(random:NextNumber(-180,180)))
				elseif(typeof(rotinc) == 'table')then
					RotCF=CF.A(unpack(rotinc))
				end
				
				if(PM and PM.MeshId == 'rbxassetid://20329976')then
					PM.Offset = Vector3.new(0,0,-PM.Scale.Z/8)
				end
				
				if(endpos and typeof(endpos) == 'CFrame')then
					P.CFrame=cframe:lerp(endpos,div)*RotCF
				elseif(acceleration and typeof(acceleration) == 'table' and acceleration.Force)then
					local force = acceleration.Force;
					if(typeof(force)=='CFrame')then
						force=force.p;
					end
					if(typeof(force)=='Vector3')then
						if(acceleration.LookAt)then
							P.CFrame=(CFrame.new(P.Position,force)+force)*RotCF
						else
							P.CFrame=(P.CFrame+force)*RotCF
						end
					end
				else
					P.CFrame=P.CFrame*RotCF
				end
				
				if(endcolor and typeof(endcolor) == 'Color3')then
					P.Color = color:lerp(endcolor,div)
				end
				swait()
			end
			P:destroy()
		elseif(system == 'Experimental' or system == 2)then
			local info = TweenInfo.new(lifetime,style,Enum.EasingDirection.InOut,0,false,0)
			local info2 = TweenInfo.new(lifetime,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut,0,false,0)
			if(style == Enum.EasingStyle.Elastic)then
				info = TweenInfo.new(lifetime*2,style,Enum.EasingDirection.Out,0,false,0)
			elseif(style == Enum.EasingStyle.Bounce)then
				info = TweenInfo.new(lifetime,style,Enum.EasingDirection.Out,0,false,0)
			end
			local tweenPart = game:service'TweenService':Create(P,info2,{
				CFrame=(typeof(endpos) == 'CFrame' and endpos or P.CFrame)*CF.A(unpack(endrot)),
				Color=typeof(endcolor) == 'Color3' and endcolor or color,
				Transparency=endTrans,
			})
			local off = Vector3.new(0,0,0)
			if(PM.MeshId == 'rbxassetid://20329976')then off=Vector3.new(0,0,(endsize*mult).Z/8) end
			
			local tweenMesh = game:service'TweenService':Create(PM,info,{
				Scale=endsize*mult,
				Offset=off,
			})
			tweenPart:Play()
			tweenMesh:Play()
		end
	end)()
end


--// Other Functions \\ --

function CastRay(startPos,endPos,range,ignoreList)
	local ray = Ray.new(startPos,(endPos-startPos).unit*range)
	local part,pos,norm = workspace:FindPartOnRayWithIgnoreList(ray,ignoreList or {Char},false,true)
	return part,pos,norm,(pos and (startPos-pos).magnitude)
end

function getRegion(point,range,ignore)
    return workspace:FindPartsInRegion3WithIgnoreList(R3.N(point-V3.N(1,1,1)*range/2,point+V3.N(1,1,1)*range/2),ignore,100)
end

function clerp(startCF,endCF,alpha)
	return startCF:lerp(endCF, alpha)
end

function GetTorso(char)
	return char:FindFirstChild'Torso' or char:FindFirstChild'UpperTorso' or char:FindFirstChild'LowerTorso' or char:FindFirstChild'HumanoidRootPart'
end


function ShowDamage(Pos, Text, Time, Color)
	coroutine.wrap(function()
	local Rate = (1 / Frame_Speed)
	local Pos = (Pos or Vector3.new(0, 0, 0))
	local Text = (Text or "")
	local Time = (Time or 2)
	local Color = (Color or Color3.new(1, 0, 1))
	local EffectPart = NewInstance("Part",Effects,{
		Material=Enum.Material.SmoothPlastic,
		Reflectance = 0,
		Transparency = 1,
		BrickColor = BrickColor.new(Color),
		Name = "Effect",
		Size = Vector3.new(0,0,0),
		Anchored = true,
		CFrame = CF.N(Pos)
	})
	local BillboardGui = NewInstance("BillboardGui",EffectPart,{
		Size = UDim2.new(1.25, 0, 1.25, 0),
		Adornee = EffectPart,
	})
	local TextLabel = NewInstance("TextLabel",BillboardGui,{
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		Font = "Bodoni",
		TextColor3 = Color,
		TextStrokeColor3 = Color3.new(0,0,0),
		TextStrokeTransparency=0,
		TextScaled = true,
	})
	S.Debris:AddItem(EffectPart, (Time))
	EffectPart.Parent = workspace
	delay(0, function()
		Tween(EffectPart,{CFrame=CF.N(Pos)*CF.N(0,3,0)},Time,Enum.EasingStyle.Elastic,Enum.EasingDirection.Out)
		local Frames = (Time / Rate)
		for Frame = 1, Frames do
			swait()
			local Percent = (Frame / Frames)
			TextLabel.TextTransparency = Percent
			TextLabel.TextStrokeTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end) end)()
end

function DealDamage(data)
	
end

function AOEDamage(where,range,options)
	local hit = {}
	for _,v in next, getRegion(where,range,{Char}) do
		if(v.Parent and v.Parent:FindFirstChildOfClass'Humanoid' and not hit[v.Parent])then
			local callTable = {Who=v.Parent}
			hit[v.Parent] = true
			for _,v in next, options do callTable[_] = v end
			DealDamage(callTable)
		end
	end
	return hit
end

function AOEHeal(where,range,amount)
	local healed = {}
	for _,v in next, getRegion(where,range,{Char}) do
		local hum = (v.Parent and v.Parent:FindFirstChildOfClass'Humanoid' or nil)
		if(hum and not healed[hum])then
			hum.Health = hum.Health + amount
			if(v.Parent:FindFirstChild'Head' and hum.Health > 0)then
				ShowDamage((v.Parent.Head.CFrame * CF.N(0, 0, (v.Parent.Head.Size.Z / 2)).p+V3.N(0,1.5,0)), "+"..amount, 1.5, BrickColor.new'Lime green'.Color)
			end
		end
	end
end

function BossChat(text)

end

function Kill(who,knockout,snapneck,slitneck,beheaded)

end

function GetModeInformation(name)
	for _,v in next, Modes do
		if(v.Name==name)then
			return v
		end
	end
end

function ColorStuff(nameOrInfo,leaveMusic,justColors,dontSetEffectColors) -- mainly used for majors
	local info = typeof(nameOrInfo)=='table' and nameOrInfo or GetMajor(nameOrInfo) or GetModeInformation(nameOrInfo)
	if(info)then
		for _,p in next, Colorables do
			p[typeof(info.Primary)=='Color3' and 'Color' or 'BrickColor'] = info.Primary
		end
		for _,p in next, Secondaries do
			p[typeof(info.Secondary)=='Color3' and 'Color' or 'BrickColor'] = info.Secondary
		end
		if(not dontSetEffectColors)then
			PrimaryColor=info.Primary;
			SecondColor=info.EffectColor or info.Secondary;
		end
		WingAnim=info.WingAnim or WingAnim;
		if(not leaveMusic)then
			MusicID=info.Theme
			Volume=info.Volume
			if(not Muted)then Music.Volume=Volume end
			Pitch=info.Pitch
		end
		if(not justColors) then
			WalkSpeed=info.WalkSpeed or WalkSpeed
			movement=info.Movement or 8
			walkChange=info.WalkAnimSpeed or .5;
		end
		for _,v in next, leftWing:GetDescendants() do
			if(v:IsA'BasePart')then
				v.Transparency=(v.Name=='Main' and 1 or info.LeftWingTrans or 0)
				v.Material=info.LeftWingMat or v.Material
			elseif(v:IsA'Trail')then
				v.Transparency=NumberSequence.new((info.LeftWingTrans or 0),1)
				v.Color = ColorSequence.new(typeof(info.Primary)=='BrickColor' and info.Primary.Color or info.Primary)
			end
		end
		for _,v in next, rightWing:GetDescendants() do
			if(v:IsA'BasePart')then
				v.Transparency=(v.Name=='Main' and 1 or info.RightWingTrans or 0)
				v.Material=info.RightWingMat or v.Material
			elseif(v:IsA'Trail')then
				v.Transparency=NumberSequence.new((info.RightWingTrans or 0),1)
				v.Color = ColorSequence.new(typeof(info.Secondary)=='BrickColor' and info.Secondary.Color or info.Secondary)
			end
		end
		title.Text=info.Name or title.Text
		title.Font=info.Font or title.Font
		local mainColor = (info.TextMain or info.Secondary)
		local secondColor = (info.TextStroke or info.Primary)
		title.TextColor3 = (typeof(mainColor)=='BrickColor' and mainColor.Color or mainColor)
		title.TextStrokeColor3 = (typeof(secondColor)=='BrickColor' and secondColor.Color or secondColor)
		if(not justColors)then Mode=info.Name end
		return true;
	end
	return false;
end

function GetMajorOf(name)
	for i,v in next, Majors do
		if(v.Major==name)then
			return v
		end
	end
	return nil
end

function GetMajor(name)
	for i,v in next, Majors do
		if(v.Name==name)then
			return v
		end
	end
	return nil
end

--// Wrap it all up \\--

function AttackOne()
	Attack = true
	NeutralAnims = false
	for i = 0, 1, 0.1 do
		local Alpha = .3
		   RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(-25),M.R(0)),Alpha)
		   LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(10),M.R(6),M.R(-3)),Alpha)
		   RH.C0 = RH.C0:lerp(CF.N(0.5,-1,0)*CF.A(M.R(-10),M.R(-6),M.R(3)),Alpha)
		   LS.C0 = LS.C0:lerp(CF.N(-1.5,0.5,0)*CF.A(M.R(0),M.R(0),M.R(-15)),Alpha)
		   RS.C0 = RS.C0:lerp(CF.N(1.6,0.4,0.2)*CF.A(M.R(90),M.R(0),M.R(15)),Alpha)
		   NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(-10),M.R(20),M.R(0)),Alpha)
		   swait()
	end
	Sound(RArm,200632136,1.1,5,false,true,true)
	for i = 0, 0.8, 0.1 do
		local Alpha = .4
					Effect{
						
						Lifetime=1;
						CFrame=RArm.CFrame;
						Transparency={0,1};
						Size=Vector3.new(1,2,1);
						EndSize=V3.N(0,0,0);
						Material=Enum.Material.Glass;
						Color=PrimaryColor;
					}
		AOEDamage(RArm.CFrame.p,2,{MinimumDamage=5,MaximumDamage=15})
		   RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(-10),M.R(35),M.R(0)),Alpha)
		   LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(-10),M.R(6),M.R(-3)),Alpha)
		   RH.C0 = RH.C0:lerp(CF.N(0.5,-1,0)*CF.A(M.R(10),M.R(-6),M.R(3)),Alpha)
		   LS.C0 = LS.C0:lerp(CF.N(-1.5,0.5,0)*CF.A(M.R(0),M.R(0),M.R(-15)),Alpha)
		   RS.C0 = RS.C0:lerp(CF.N(1,0.4,-0.6)*CF.A(M.R(90),M.R(0),M.R(-25)),Alpha)
		   NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(-10),M.R(-20),M.R(0)),Alpha)
	swait()
	end
	Combo = 2
	Attack = false
	NeutralAnims = true
end

function AttackTwo()
	Attack = true
	NeutralAnims = false
	for i = 0, 1, 0.1 do
		swait()
		local Alpha = .3
		   RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(25),M.R(0)),Alpha)
		   LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(-10),M.R(6),M.R(-3)),Alpha)
		   RH.C0 = RH.C0:lerp(CF.N(0.5,-1,0)*CF.A(M.R(10),M.R(-6),M.R(3)),Alpha)
		   LS.C0 = LS.C0:lerp(CF.N(-1.5,0.5,0.2)*CF.A(M.R(90),M.R(0),M.R(15)),Alpha)
		   RS.C0 = RS.C0:lerp(CF.N(1.5,0.4,0)*CF.A(M.R(0),M.R(0),M.R(15)),Alpha)
		   NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(-10),M.R(-20),M.R(0)),Alpha)
	end	
	Sound(LArm,200632136,.9,5,false,true,true)
	for i = 0, 0.8, 0.1 do
		local Alpha = .4
					Effect{
						
						Lifetime=1;
						CFrame=LArm.CFrame;
						Transparency={0,1};
						Size=Vector3.new(1,2,1);
						EndSize=V3.N(0,0,0);
						Material=Enum.Material.Glass;
						Color=PrimaryColor;
					}
		AOEDamage(LArm.CFrame.p,2,{MinimumDamage=5,MaximumDamage=15})
		   RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(-10),M.R(-30),M.R(0)),Alpha)
		   LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(10),M.R(6),M.R(-3)),Alpha)
		   RH.C0 = RH.C0:lerp(CF.N(0.5,-1,0)*CF.A(M.R(-10),M.R(-6),M.R(3)),Alpha)
		   LS.C0 = LS.C0:lerp(CF.N(-1,0.4,-0.6)*CF.A(M.R(90),M.R(0),M.R(15)),Alpha)
		   RS.C0 = RS.C0:lerp(CF.N(1.5,0.5,0)*CF.A(M.R(0),M.R(0),M.R(-15)),Alpha)
		   NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(-10),M.R(20),M.R(0)),Alpha)
	swait()
	end
	Combo = 3
	Attack = false
	NeutralAnims = true
end

function AttackThree()
	Attack = true
	NeutralAnims = false
	for i = 0, 1, 0.1 do
		local Alpha = .3
		   RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(-15),M.R(10),M.R(0)),Alpha)
		   LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(-10),M.R(6),M.R(-6)),Alpha)
		   RH.C0 = RH.C0:lerp(CF.N(0.5,-1,0)*CF.A(M.R(12.5),M.R(-6),M.R(6)),Alpha)
		   LS.C0 = LS.C0:lerp(CF.N(-1.5,0.5,0)*CF.A(M.R(0),M.R(0),M.R(-10)),Alpha)
		   RS.C0 = RS.C0:lerp(CF.N(1.5,0.5,0)*CF.A(M.R(0),M.R(0),M.R(10)),Alpha)
		   NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(-10),M.R(-10),M.R(0)),Alpha)
		   swait()
	end
	Sound(LLeg,200632136,1.1,5,false,true,true)
	for i = 0, 0.8, 0.1 do
		local Alpha = .4
					Effect{
						
						Lifetime=1;
						CFrame=LLeg.CFrame;
						Transparency={0,1};
						Size=Vector3.new(1,2,1);
						EndSize=V3.N(0,0,0);
						Material=Enum.Material.Glass;
						Color=PrimaryColor;
					}
		AOEDamage(LLeg.CFrame.p,2,{MinimumDamage=5,MaximumDamage=15})
		   RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(15),M.R(-20),M.R(0)),Alpha)
		   LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(60),M.R(0),M.R(-10)),Alpha)
		   RH.C0 = RH.C0:lerp(CF.N(0.5,-1,0)*CF.A(M.R(-15),M.R(-6),M.R(6)),Alpha)
		   LS.C0 = LS.C0:lerp(CF.N(-1.5,0.5,0)*CF.A(M.R(-10),M.R(0),M.R(-5)),Alpha)
		   RS.C0 = RS.C0:lerp(CF.N(1.5,0.5,0)*CF.A(M.R(-10),M.R(0),M.R(5)),Alpha)
		   NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(-10),M.R(15),M.R(0)),Alpha)
		   swait()
	end
	Combo = 2
	Attack = false
	NeutralAnims = true
end

function AttackFour()
	Attack = true
	NeutralAnims = false
	local spin=0
	for i = 0, 1, 0.1 do
		local Alpha = .3
		   RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(5),M.R(-10),M.R(0)),Alpha)
		   LH.C0 = LH.C0:lerp(CF.N(-0.6,-1,0)*CF.A(M.R(5),M.R(6),M.R(-6)),Alpha)
		   RH.C0 = RH.C0:lerp(CF.N(0.6,-1,0)*CF.A(M.R(5),M.R(-6),M.R(6)),Alpha)
		   LS.C0 = LS.C0:lerp(CF.N(-1.5,0.5,0)*CF.A(M.R(10),M.R(0),M.R(-10)),Alpha)
		   RS.C0 = RS.C0:lerp(CF.N(1.5,0.5,0)*CF.A(M.R(10),M.R(0),M.R(10)),Alpha)
		   NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(-10),M.R(10),M.R(0)),Alpha)
		   swait()
	end
	Sound(LLeg,200632136,1.1,5,false,true,true)
	repeat
		local Alpha = .3
					Effect{
						
						Lifetime=1;
						CFrame=RLeg.CFrame;
						Transparency={0,1};
						Size=Vector3.new(1,2,1);
						EndSize=V3.N(0,0,0);
						Material=Enum.Material.Glass;
						Color=PrimaryColor;
					}
		AOEDamage(RLeg.CFrame.p,2,{MinimumDamage=5,MaximumDamage=15})
		   RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(10),M.R(70-spin),M.R(-5)),Alpha)
		   LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(-10),M.R(10),M.R(-15)),Alpha)
		   RH.C0 = RH.C0:lerp(CF.N(1,-1,-0.5)*CF.A(M.R(80),M.R(-70),M.R(6)),0.2)
		   LS.C0 = LS.C0:lerp(CF.N(-1.5,0.5,0)*CF.A(M.R(-15),M.R(0),M.R(-5)),Alpha)
		   RS.C0 = RS.C0:lerp(CF.N(1,0.5,0)*CF.A(M.R(100),M.R(10),M.R(-90)),0.25)
		   NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(-10),M.R(-70),M.R(0)),Alpha)
		spin=spin+40
		   swait()
	until spin>720
	Combo = 2
	Attack = false
	NeutralAnims = true
end

function Boom()
	Attack=true
	NeutralAnims=false
	Sound(Root,136007472,2,3,false,true,true)
	for i = 0, 2.5, .1 do
		local Alpha = .3
		local pos = CF.N(Root.CFrame*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360))*CF.N(0,0,-1).p,Root.Position)
		Effect{
			Color=PrimaryColor;
			Lifetime=.5;
			CFrame=pos*CF.N(0,0,-10);
			EndPos=pos;
			Size=V3.N(.5,.5,5);
			EndSize=V3.N(.5,.5,10);
			Mesh={Type=Enum.MeshType.Sphere};
		}
		RJ.C0 = RJ.C0:lerp(CF.N(0,0.1,-0.5)*CF.A(M.R(-25),M.R(0),M.R(0)),Alpha)
		LH.C0 = LH.C0:lerp(CF.N(-0.5,-1.2,0.1)*CF.A(M.R(25),M.R(0),M.R(0)),Alpha)
		RH.C0 = RH.C0:lerp(CF.N(0.5,-1.2,0.1)*CF.A(M.R(25),M.R(0),M.R(0)),Alpha)
		LS.C0 = LS.C0:lerp(CF.N(-0.6,0.2,-0.6)*CF.A(M.R(116.1),M.R(-1.4),M.R(80.2)),Alpha)
		RS.C0 = RS.C0:lerp(CF.N(0.6,0.1,-0.6)*CF.A(M.R(-13.6),M.R(-14),M.R(-95.9)),Alpha)
		NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
		swait()
	end	
	AOEDamage(Root.Position,29,{MinimumDamage=38,MaximumDamage=76})
	Effect{
		Color=PrimaryColor;
		Lifetime=.5;
		CFrame=Root.CFrame;
		Size=V3.N(1,1,1);
		EndSize=V3.N(250,250,250);
		Mesh={Type=Enum.MeshType.Sphere};
	}
	Effect{
		Color=SecondColor;
		Lifetime=1;
		CFrame=Root.CFrame;
		Size=V3.N(1,1,1);
		EndSize=V3.N(250,250,250);
		Mesh={Type=Enum.MeshType.Sphere};
	}
	coroutine.wrap(function()
		for i = 0,40 do
			local m=M.RNG(50,100)
			Effect{
				CFrame=CF.N(Root.Position)*CF.N(0,0,0)*CF.A(M.RRNG(-360,360),M.RRNG(-360,360),M.RRNG(-360,360));
				Color=PrimaryColor;
				Material=Enum.Material.SmoothPlastic;
				Size=V3.N(1,.2,1);
				EndSize=V3.N(m,.2,m);
				Lifetime=.35;
				Part='Slash'
			}
			Effect{
				CFrame=Root.CFrame*CF.N(0,-3,0)*CF.A(M.RRNG(-5,5),M.RRNG(-180,180),M.RRNG(-5,5));
				Color=PrimaryColor;
				Material=Enum.Material.Neon;
				Size=V3.N(1,.2,1);
				EndSize=V3.N(60,.2,60);
				Lifetime=.3;
				Part='Smash8';
			}
			local pos = CF.N(Root.CFrame*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360))*CF.N(0,0,-1).p,Root.Position)
			Effect{
				Color=PrimaryColor;
				Lifetime=.5;
				CFrame=pos;
				Size=V3.N(1,1,1);
				EndSize=V3.N(1,1,250);
				Mesh={Type=Enum.MeshType.Sphere};
			}
			swait()
		end
	end)()
	Sound(Root,579687077,1,3,false,true,true)
	for i = 0, 2, .1 do
		local Alpha = .3
		RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(25),M.R(0),M.R(0)),Alpha)
		LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(-25),M.R(0),M.R(0)),Alpha)
		RH.C0 = RH.C0:lerp(CF.N(0.5,-1,0)*CF.A(M.R(-25),M.R(0),M.R(0)),Alpha)
		LS.C0 = LS.C0:lerp(CF.N(-1.4,0.5,0.3)*CF.A(M.R(-6.9),M.R(24.1),M.R(-73.5)),Alpha)
		RS.C0 = RS.C0:lerp(CF.N(1.4,0.5,0.3)*CF.A(M.R(-6.9),M.R(-24.1),M.R(73.5)),Alpha)
		NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
		swait()
	end
	Attack=false
	NeutralAnims=true
end

function OblivionBoom()
	Attack=true
	NeutralAnims=false
	for i = 0, 4, .1 do
		Effect{
			CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
			Color=PrimaryColor;
			Material=Enum.Material.Neon;
			Size=V3.N(0,0,0);
			EndSize=V3.N(.5,M.RNG(3,6),.5);
			Lifetime=.2;
			Transparency={0,1};
			Mesh={Type=Enum.MeshType.Sphere}
		}
  		local Alpha = .3
  		RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(30),M.R(0)),Alpha)
  		LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(0),M.R(5),M.R(0)),Alpha)
  		RH.C0 = RH.C0:lerp(CF.N(0.5,-1,0)*CF.A(M.R(0),M.R(-5),M.R(0)),Alpha)
  		LS.C0 = LS.C0:lerp(CF.N(-1.5,0.5,0)*CF.A(M.R(0),M.R(10),M.R(-90)),Alpha)
  		RS.C0 = RS.C0:lerp(CF.N(1.5,0.6,0)*CF.A(M.R(0),M.R(0),M.R(10)),Alpha)
  		NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0),M.R(-30),M.R(0)),Alpha)
  		swait()
	end	
	for i = 0, 10, .1 do
		Root.CFrame=CF.N(Root.CFrame.p,V3.N(Mouse.Hit.p.X,Root.Position.Y,Mouse.Hit.p.Z))*CF.N(0, 0, 0)
		Effect{
			CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
			Color=PrimaryColor;
			Material=Enum.Material.Neon;
			Size=V3.N(0,0,0);
			EndSize=V3.N(.5,M.RNG(3,6),.5);
			Lifetime=.2;
			Transparency={0,1};
			Mesh={Type=Enum.MeshType.Sphere}
		}
		Effect{
			CFrame=CF.N(Mouse.Hit.p);
			Color=SecondColor;
			Material=Enum.Material.Neon;
			Size=V3.N(35,.2,35);
			EndSize=V3.N(35,.2,35);
			Lifetime=.2;
			Transparency={0,1};
			Mesh={Type=Enum.MeshType.Sphere}
		}
  		local Alpha = .3
  		RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(-50),M.R(0)),Alpha)
  		LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
  		RH.C0 = RH.C0:lerp(CF.N(0.5,-1,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
  		LS.C0 = LS.C0:lerp(CF.N(-1.7,0.7,-0.6)*CF.A(M.R(113.9),M.R(-18.7),M.R(-36)),Alpha)
  		RS.C0 = RS.C0:lerp(CF.N(1.5,0.5,0.1)*CF.A(M.R(3.5),M.R(-9.4),M.R(20.3)),Alpha)
  		NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(18.1),M.R(33.6),M.R(-10.3)),Alpha)
  		swait()
	end
	AOEDamage(Mouse.Hit.p,20,{
		MinimumDamage=15;
		MaximumDamage=35;
	})
	Effect{
		CFrame=CF.N(Mouse.Hit.p);
		Color=SecondColor;
		Material=Enum.Material.Neon;
		Size=V3.N(35,.2,35);
		EndSize=V3.N(35,68,35);
		Lifetime=.3;
		Transparency={0,1};
		Mesh={Type=Enum.MeshType.Sphere}
	}
	for i = 1, 73 do
	 Effect{
		CFrame=CF.N(Mouse.Hit.p)*CF.A(M.RRNG(-6,6),M.RRNG(-180,180),M.RRNG(-6,6));
		Color=PrimaryColor;
		Material=Enum.Material.SmoothPlastic;
		Size=V3.N(1,.2,1);
		EndSize=V3.N(115,.2,115);
		Lifetime=math.random(5,12.5)/25;
		Part='Slash'
	}
	end
	Root.CFrame=CF.N(Root.CFrame.p,V3.N(Mouse.Hit.p.X,Root.Position.Y,Mouse.Hit.p.Z))*CF.N(0, 0, 0)
	for i = 0, 1.5, .1 do
  		local Alpha = .3
  		RJ.C0 = RJ.C0:lerp(CF.N(0,-1.3,-1)*CF.A(M.R(-45),M.R(0),M.R(0)),Alpha)
  		LH.C0 = LH.C0:lerp(CF.N(-0.5,-1.3,-0.7)*CF.A(M.R(-45),M.R(0),M.R(0)),Alpha)
  		RH.C0 = RH.C0:lerp(CF.N(0.5,0.1,-0.2)*CF.A(M.R(55),M.R(0),M.R(0)),Alpha)
  		LS.C0 = LS.C0:lerp(CF.N(-1.4,-0.1,-0.6)*CF.A(M.R(59.8),M.R(9.7),M.R(2.6)),Alpha)
  		RS.C0 = RS.C0:lerp(CF.N(1.6,0.5,0)*CF.A(M.R(0),M.R(0),M.R(50)),Alpha)
  		NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(15),M.R(0),M.R(0)),Alpha)
  		swait()
	end
	Attack=false
	NeutralAnims=true
end

function ZoneOfEradicationButItFailed()
	Attack=true
	NeutralAnims=false
	for i = 0, 6, .1 do
		Effect{
			CFrame=CF.N(Root.Position)*CF.N(0,-3,0);
			Color=PrimaryColor;
			Material=Enum.Material.Neon;
			Size=V3.N(1,.2,1);
			EndSize=V3.N(20,.2,20);
			Lifetime=.3;
			Mesh={Type=Enum.MeshType.Sphere}
		}
  		local Alpha = .3
  		RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
  		LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
  		RH.C0 = RH.C0:lerp(CF.N(0.5,-1,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
  		LS.C0 = LS.C0:lerp(CF.N(-1.6,0.5,0)*CF.A(M.R(0),M.R(-9.7),M.R(-45)),Alpha)
  		RS.C0 = RS.C0:lerp(CF.N(1.6,0.5,0)*CF.A(M.R(0),M.R(9.7),M.R(45)),Alpha)
  		NK.C0 = NK.C0:lerp(CF.N(0,1.5,-0.1)*CF.A(M.R(-10),M.R(0),M.R(0)),Alpha)
  		swait()
	end	
	BossChat('The zone...')
	for i = 0, 13, .1 do
		Effect{
			CFrame=CF.N(Root.Position)*CF.N(0,-3,0);
			Color=PrimaryColor;
			Material=Enum.Material.Neon;
			Size=V3.N(1,.2,1);
			EndSize=V3.N(20,.2,20);
			Lifetime=.3;
			Mesh={Type=Enum.MeshType.Sphere}
		}
			Effect{
				Lifetime=0.5;
				CFrame=Root.CFrame*CF.N(
					M.RNG(-1900,1900)/100,
					M.RNG(100,900)/100,
					M.RNG(-1900,1900)/100
				);
				Color=PrimaryColor;
				Acceleration=V3.N(0,25,0);
				Material=Enum.Material.Neon;
				Mesh={Type=Enum.MeshType.Brick};
				Size=V3.N(.5,.5,.5);
				EndSize=V3.N(0,0,0);
			}
  		local Alpha = .3
  		RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(-15),M.R(0)),Alpha)
  		LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,-0.1)*CF.A(M.R(-5),M.R(5),M.R(0.4)),Alpha)
  		RH.C0 = RH.C0:lerp(CF.N(0.5,-1,0)*CF.A(M.R(0),M.R(-10),M.R(0)),Alpha)
  		LS.C0 = LS.C0:lerp(CF.N(-1.5,0.4,0.2)*CF.A(M.R(27),M.R(13.6),M.R(-25)),Alpha)
  		RS.C0 = RS.C0:lerp(CF.N(1.7,0.5,-0.2)*CF.A(M.R(7.9),M.R(18.7),M.R(21.2)),Alpha)
  		NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(-5.2),M.R(14.9),M.R(1.3)),Alpha)
  		swait()
	end	
	BossChat('OF ERADICA-')
	for i = 0, 9, .1 do
		Effect{
			CFrame=CF.N(Root.Position)*CF.N(0,-3,0);
			Color=PrimaryColor;
			Material=Enum.Material.Neon;
			Size=V3.N(1,.2,1);
			EndSize=V3.N(20,.2,20);
			Lifetime=.3;
			Mesh={Type=Enum.MeshType.Sphere}
		}
		Effect{
			Lifetime=0.1;
			CFrame=Root.CFrame*CF.N(
				M.RNG(-900,900)/100,
				-3,
				M.RNG(-900,900)/100
			);
			Color=PrimaryColor;
			Acceleration=V3.N(0,25,0);
			Material=Enum.Material.Neon;
			Mesh={Type=Enum.MeshType.Brick};
			Size=V3.N(.5,.5,.5);
			EndSize=V3.N(0,0,0);
		}
  		local Alpha = .3
  		RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(-15),M.R(0)),Alpha)
  		LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,-0.1)*CF.A(M.R(-5),M.R(5),M.R(0.4)),Alpha)
  		RH.C0 = RH.C0:lerp(CF.N(0.5,-1,0)*CF.A(M.R(0),M.R(-10),M.R(0)),Alpha)
  		LS.C0 = LS.C0:lerp(CF.N(-1.5,0.3,-0.1)*CF.A(M.R(66.8),M.R(10.6),M.R(-27.6)),Alpha)
  		RS.C0 = RS.C0:lerp(CF.N(1.6,0.4,-0.3)*CF.A(M.R(57.2),M.R(1.9),M.R(24.7)),Alpha)
  		NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(-5.2),M.R(14.9),M.R(1.3)),Alpha)
  		swait()
	end	
	BossChat("Well, nevermind.")
	for i = 0, 5, .1 do
  		local Alpha = .3
  		RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(-10),M.R(0)),Alpha)
  		LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
  		RH.C0 = RH.C0:lerp(CF.N(0.5,-1,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
  		LS.C0 = LS.C0:lerp(CF.N(-1.2,0.3,0.4)*CF.A(M.R(-16.7),M.R(6.7),M.R(34.7)),Alpha)
  		RS.C0 = RS.C0:lerp(CF.N(1.3,1.1,0)*CF.A(M.R(143.7),M.R(-5),M.R(-29.6)),Alpha)
  		NK.C0 = NK.C0:lerp(CF.N(0,1.5,-0.1)*CF.A(M.R(-15.2),M.R(9.7+9*M.C(Sine/12)),M.R(2.6)),Alpha)
  		swait()
	end	
	Attack=false
	NeutralAnims=true
end

function Smash()
	Attack=true
	NeutralAnims=false
	for i = 0, 2, .1 do
		local Alpha = .3
		RJ.C0 = RJ.C0:lerp(CF.N(0,0,0.3)*CF.A(M.R(15),M.R(0),M.R(0)),Alpha)
		LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(-15),M.R(0),M.R(0)),Alpha)
		RH.C0 = RH.C0:lerp(CF.N(0.5,-1,0)*CF.A(M.R(-15),M.R(0),M.R(0)),Alpha)
		LS.C0 = LS.C0:lerp(CF.N(-1,0.7,-0.3)*CF.A(M.R(147.7),M.R(-15.7),M.R(39.5)),Alpha)
		RS.C0 = RS.C0:lerp(CF.N(0.9,0.7,-0.5)*CF.A(M.R(148.5),M.R(8.1),M.R(-34)),Alpha)
		NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(5),M.R(0),M.R(0)),Alpha)
		swait()
	end	
	AOEDamage(Root.Position,40,{MinimumDamage=0,MaximumDamage=50})
	Sound(Root,262562442,1,3,false,true,true)
	--Sound(Root,444667824,0.8,3,false,true,true)
	coroutine.wrap(function()
		Effect{
			Color=PrimaryColor;
			LifeTime=0.5;
			Transparency={0,1};
			CFrame=Root.CFrame*CF.N(0,-3,0);
			EndPos=Root.CFrame*CF.N(0,-3,0);
			Mesh={Type=Enum.MeshType.Sphere};
			Size=V3.N(23,.5,23);
			Material=Enum.Material.Neon;
			EndSize=V3.N(45,.5,45);
		}
		for i = 0, 20 do
			local basePos=Root.CFrame*CF.N(0,-3,0)*CF.N(M.RNG(-10,10),0,M.RNG(-10,10))*CF.A(M.R(M.RNG(-15,15)),M.R(M.RNG(-25,25)),M.R(M.RNG(-25,25)))
			Effect{
				TweenPos=function(t,b,c,d)
					local t=(t/d)
					local d=1
					if(t<.1)then
						return (t/(d*.1))
					elseif(t>.3)then
						return 1-((t-.3)/(d*.3))
					else
						return 1
					end
				end;
				TweenTrans=function(t,b,c,d)
					local t=(t/d)
					local d=1
					if(t<.1)then
						return 1-(t/(d*.1))
					elseif(t>.3)then
						return ((t-.3)/(d*.3))
					else
						return 0
					end
				end;
				Lifetime=2;
				CFrame=basePos*CF.N(0,-2,0);
				Transparency={0,1};
				Size=V3.N(1,5,1);
				EndSize=V3.N(0,10,0);
				EndPos=basePos*CF.N(0,1.5,0);
				Material=Enum.Material.Neon;
				Mesh={Type=Enum.MeshType.Sphere};
				Color=PrimaryColor;
			}
		end
	end)()
	for i = 0, 1.5, .1 do
		local Alpha = .3
		RJ.C0 = RJ.C0:lerp(CF.N(0,-2.1,0.2)*CF.A(M.R(-90),M.R(0),M.R(0)),Alpha)
		LH.C0 = LH.C0:lerp(CF.N(-0.5,-1.1,0.1)*CF.A(M.R(-30),M.R(0),M.R(0)),Alpha)
		RH.C0 = RH.C0:lerp(CF.N(0.5,-1.1,0.1)*CF.A(M.R(-30),M.R(0),M.R(0)),Alpha)
		LS.C0 = LS.C0:lerp(CF.N(-1,0.7,-0.4)*CF.A(M.R(172.7),M.R(-15.7),M.R(39.5)),Alpha)
		RS.C0 = RS.C0:lerp(CF.N(0.9,0.7,-0.6)*CF.A(M.R(173.5),M.R(8.1),M.R(-34)),Alpha)
		NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(5),M.R(0),M.R(0)),Alpha)
		swait()
	end
	Attack=false
	NeutralAnims=true
end


ColorStuff(Mode)
Mouse.Button1Down:connect(function()
	if(Attack)then return end
		
end)

S.UserInputService.InputBegan:connect(function(io,gpe)
	if(gpe or Attack)then return end
	if(io.KeyCode==Enum.KeyCode.Q)then
		ModeIndex=ModeIndex-1
		if(ModeIndex<1)then ModeIndex=#Modes end
		local info = Modes[ModeIndex]
		if(info.Name~=Mode)then
			ColorStuff(info.Name)
		end
	elseif(io.KeyCode==Enum.KeyCode.E)then
		ModeIndex=ModeIndex+1
		if(ModeIndex>#Modes)then ModeIndex=1 end
		local info = Modes[ModeIndex]
		if(info.Name~=Mode)then
			ColorStuff(info.Name)
		end
	elseif(io.KeyCode==Enum.KeyCode.M)then
		local major = GetMajorOf(Mode)
		if(major and Mode~=major.Name)then
			ColorStuff(major.Name)
		elseif(GetMajor(Mode))then
			ColorStuff(GetMajor(Mode).Major)
		end
	elseif(io.KeyCode==Enum.KeyCode.Z and Mode=='ENCHANTER')then
		ZoneOfEradicationButItFailed()
	elseif(io.KeyCode==Enum.KeyCode.Z and Mode=='OBLIVION')then
		OblivionBoom()
	elseif(io.KeyCode==Enum.KeyCode.L)then
		Muted=not Muted
	elseif(io.KeyCode==Enum.KeyCode.H)then
		local dialogues={"testing","testing the bosschattt","worse than salvo's tbh, but it'll do","eth rewritten bosschaatttt","this chat was made by drahazar lol","im bad at gui design"}
		BossChat(dialogues[M.RNG(1,#dialogues)])
	elseif(io.UserInputType==Enum.UserInputType.MouseButton1)then
		if(Combo==1)then
			AttackOne()
			Combo=2
		elseif(Combo==2)then
			AttackTwo()
			Combo=3
		elseif(Combo==3)then
			AttackThree()
			Combo=4
		elseif(Combo==4)then
			AttackFour()
			Combo=5
		elseif(Combo==5)then
			Smash()
			Combo=6
		elseif(Combo==6)then
			Boom()
			Combo=1
		end
	end
end)


Plr.Chatted:connect(function(message)
	if(message:sub(1,3)=='/e')then message=message:sub(4) end
	if(message:sub(1,5)=='play/')then
		local newid = tonumber(message:sub(6)) or 0
		--Chat(txt,timer,clr)
		if(MusicID~=newid)then
			VisSong=newid
			local name = Names[newid] or S.MarketplaceService:GetProductInfo(newid).Name
			if(Mode=='INSTRUMENTAL')then Chat("Now playing "..name.." at the pitch of "..Pitch,5) end
			if(Names[newid]~=name)then Names[newid]=name end
		end
	elseif(message:sub(1,6)=='pitch/')then
		VisPitch=tonumber(message:sub(7)) or 1
		if(Mode=='INSTRUMENTAL')then Chat("Pitch was set to "..VisPitch,2) end
	end
end)

coroutine.wrap(function()
	while true do
		local hit,pos,norm = CastRay(Root.Position,Root.Position-V3.N(0,1,0),4)
		if(Mode=='PANDEMONIUM')then
			local pos = LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RNG(0,360),M.RNG(0,360),M.RNG(0,360))
			Effect{
				Lifetime=M.RNG(25,50)/100;
				CFrame=pos;
				Transparency={0,1};
				Size=V3.N(1,1,1);
				EndSize=V3.N(0,0,0);
				EndPos=pos*CF.N(0,-M.RNG(125,175)/100,0);
				Material=Enum.Material.Neon;
				Mesh={Type=Enum.MeshType.Sphere};
				Color=PrimaryColor;
			}
		end
		if(Mode=='COMMOTIAUS' or Mode=='PANDEMONIUM')then
			local pos = RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RNG(0,360),M.RNG(0,360),M.RNG(0,360))
			Effect{
				Lifetime=M.RNG(25,50)/100;
				CFrame=pos;
				Transparency={0,1};
				Size=V3.N(1,1,1);
				EndSize=V3.N(0,0,0);
				EndPos=pos*CF.N(0,-M.RNG(125,175)/100,0);
				Material=Enum.Material.Neon;
				Mesh={Type=Enum.MeshType.Sphere};
				Color=PrimaryColor;
			}
			
		elseif(Mode=='DURABITINE')then
			Effect{
				Lifetime=2;
				CFrame=CF.N(Torso.Position)*CF.N(
					(M.RNG(-750,750)/100),
					(M.RNG(-350,550)/100),
					(M.RNG(-750,750)/100)
				);
				Color=PrimaryColor;
				Acceleration=V3.N(0,-5,0);
				Material=Enum.Material.Neon;
				Mesh={Type=Enum.MeshType.Sphere};
				Size=V3.N(.2,2,.2);
				EndSize=V3.N(.2,4,.2);
			}
		elseif(Mode=='ENCHANTER')then
			
		local pos = Root.CFrame*CF.A(M.RNG(-15,15),M.RNG(-15,15),M.RNG(-15,15))
			Effect{
				Lifetime=0.5;
				CFrame=pos*CF.N(
					M.RNG(-900,900)/100,
					M.RNG(100,900)/100,
					M.RNG(-900,900)/100
				);
				Color=PrimaryColor;
				Acceleration=V3.N(0,25,0);
				Material=Enum.Material.Neon;
				Mesh={Type=Enum.MeshType.Sphere};
				Size=V3.N(.2,2,.2);
				EndSize=V3.N(0,1,0);
			}
			
			elseif(Mode=="OBLIVION" and hit)then
			Effect{
				CFrame=CF.N(Root.Position)*CF.N(0,-3,0)*CF.A(M.R(90),0,M.R(0+500*M.C(WingSine/360)));
				Color=PrimaryColor;
				Material=Enum.Material.Neon;
				Mesh={Type=Enum.MeshType.Sphere};
				Size=V3.N(.5,18*M.C(WingSine/35),.5);
				EndSize=V3.N(.5,18+2*M.C(WingSine/35),.5);
			}
			Effect{
				CFrame=CF.N(Root.Position)*CF.N(0,-3,0)*CF.A(M.R(90),0,M.R(0-500*M.C(WingSine/360)));
				Color=SecondColor;
				Material=Enum.Material.Neon;
				Mesh={Type=Enum.MeshType.Sphere};
				Size=V3.N(.5,18*M.C(WingSine/35),.5);
				EndSize=V3.N(.5,18-2*M.C(WingSine/35),.5);
			}
		elseif(Mode=='UNSANCTIFIED')then
			local pos1 = RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RNG(0,360),M.RNG(0,360),M.RNG(0,360))
			local pos2 = Root.CFrame*CF.A(M.RNG(-25,96),M.RNG(-45,65),M.RNG(-65,85))
			Effect{
				Lifetime=M.RNG(15,25)/50;
				CFrame=pos1;
				Transparency={0,1};
				Size=V3.N(1,1,1);
				EndSize=V3.N(0,0,0);
				EndPos=pos1*CF.N(0,-M.RNG(75,125)/50,0);
				Material=Enum.Material.Neon;
				Mesh={Type=Enum.MeshType.Sphere};
				Color=PrimaryColor;
			}
			Effect{
				Lifetime=0.5;
				CFrame=pos2*CF.N(
					M.RNG(-900,900)/100,
					M.RNG(100,900)/100,
					M.RNG(-900,900)/100
				);
				Color=PrimaryColor;
				Acceleration=V3.N(0,25,0);
				Material=Enum.Material.Neon;
				Mesh={Type=Enum.MeshType.Sphere};
				Size=V3.N(.2,2,.2);
				EndSize=V3.N(0,1,0);
			}	
		elseif(Mode=='AMBUSTUME')then
			--[[
			local pos = RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RNG(0,360),M.RNG(0,360),M.RNG(0,360))
			Effect{
				TweenPos=function(t,b,c,d) return EasingFunctions.outBack(t,b,c,d,5) end;
				Lifetime=0.2;
				CFrame=pos;
				Transparency={0,1};
				Size=V3.N(.75,.75,.75);
				EndSize=V3.N(0,0,0);
				EndPos=pos*CF.N(0,-M.RNG(75,125)/100,0);
				Material=Enum.Material.Neon;
				Mesh={Type=Enum.MeshType.Sphere};
				Color=PrimaryColor;
			}
			--]]
						local pos = RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RNG(0,360),M.RNG(0,360),M.RNG(0,360))
			Effect{
				Lifetime=M.RNG(25,50)/100;
				CFrame=pos;
				Transparency={0,1};
				Size=V3.N(1,1,1);
				EndSize=V3.N(0,0,0);
				EndPos=pos*CF.N(0,-M.RNG(125,175)/100,0);
				Material=Enum.Material.Neon;
				Mesh={Type=Enum.MeshType.Sphere};
				Color=PrimaryColor;
			}
		elseif(Mode=='ARSONIST')then
			local pos = LArm.CFrame*CF.N(0,-1,0)
			Effect{
				Lifetime=M.RNG(25,75)/100;
				CFrame=pos;
				Transparency={0,1};
				Size=V3.N(.75,.75,.75);
				EndSize=V3.N(0,0,0);
				EndPos=pos+V3.N(M.RNG(-100,100)/100,M.RNG(50,250)/100,M.RNG(-100,100)/100);
				Material=Enum.Material.Neon;
				Mesh={Type=Enum.MeshType.Sphere};
				Color=C3.RGB(M.RNG(240,255),M.RNG(75,100),M.RNG(0,25));
			}
			
		elseif(Mode=='SINISTER')then
			--[[
			local pos1=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RNG(0,360),M.RNG(0,360),M.RNG(0,360))
			local pos2=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RNG(0,360),M.RNG(0,360),M.RNG(0,360))
			Effect{
				TweenPos=EasingFunctions.outBack;
				Lifetime=M.RNG(65,125)/100;
				CFrame=pos1;
				Color=C3.N(.7,0,0);
				EndPos=pos1*CF.N(0,M.RNG(5,125)/100,0);
				Parent=workspace;
				Material=Enum.Material.Glass;
				Size=V3.N(.5,.5,.5);
				Part='LSD';
				Rotation={M.RNG(-5,5),M.RNG(-5,5),M.RNG(-5,5)};
				EndSize=V3.N(0,0,0);
			}
			Effect{
				TweenPos=EasingFunctions.outBack;
				Lifetime=M.RNG(65,125)/100;
				CFrame=pos2;
				Color=C3.N(.7,0,0);
				EndPos=pos2*CF.N(0,M.RNG(5,125)/100,0);
				Parent=workspace;
				Material=Enum.Material.Glass;
				Size=V3.N(.5,.5,.5);
				Part='LSD';
				Rotation={M.RNG(-5,5),M.RNG(-5,5),M.RNG(-5,5)};
				EndSize=V3.N(0,0,0);
			}
			--]]
		elseif(Mode=='MACABRE' and time()-lastMacabEffect>2)then
			lastMacabEffect=time();
			for _,v in next, Char:children() do
				if(v:IsA'BasePart')then
					local mesh = v:FindFirstChildOfClass'DataModelMesh'
					Effect{
						Parent=workspace;
						Lifetime=3;
						CFrame=v.CFrame;
						Transparency={v.Transparency,1};
						Size=v.Size;
						EndSize=V3.N(0,0,0);
						EndPos=v.CFrame*CF.N(M.RNG(-450,450)/100,M.RNG(-450,450)/100,M.RNG(-450,450)/100);
						Material=Enum.Material.Glass;
						Part='LSD';
						Color=PrimaryColor;
					}
				end
			end
		elseif(Mode=='GLACIAL' and time()-lastGlacier>.2)then
			if(hit)then
				lastGlacier=time();
				local basePos=CF.N(pos,pos+norm)*CF.A(M.R(-90),M.R(M.RNG(-360,360)),0)*CF.N(M.RNG(-15,15),0,M.RNG(-15,15))
				Effect{
					TweenTrans=function(t,b,c,d)
						local t=(t/d)
						local d=1
						if(t<.1)then
							return 1-(t/(d*.1))
						elseif(t>.3)then
							return ((t-.3)/(d*.3))
						else
							return 0
						end
					end;
					TweenSize=function(t,b,c,d)
						local t=(t/d)
						local d=1
						if(t<.1)then
							return (t/(d*.1))
						elseif(t>.3)then
							return 1-((t-.3)/(d*.3))
						else
							return 1
						end
					end;
					Lifetime=2;
					CFrame=basePos*CF.A(0,0,M.R(-90));
					Transparency={0,1};
					Size=V3.N(.1,0,0);
					EndSize=V3.N(.1,5,5);
					Material=Enum.Material.Ice;
					Mesh={Type=Enum.MeshType.Cylinder};
					Color=C3.N(0,1,1);
				}
				Effect{
					TweenPos=function(t,b,c,d)
						local t=(t/d)
						local d=1
						if(t<.1)then
							return (t/(d*.1))
						elseif(t>.3)then
							return 1-((t-.3)/(d*.3))
						else
							return 1
						end
					end;
					TweenTrans=function(t,b,c,d)
						local t=(t/d)
						local d=1
						if(t<.1)then
							return 1-(t/(d*.1))
						elseif(t>.3)then
							return ((t-.3)/(d*.3))
						else
							return 0
						end
					end;
					Lifetime=2;
					CFrame=basePos*CF.N(0,-2,0);
					Transparency={0,1};
					Size=V3.N(2,8,3);
					EndSize=V3.N(2,8,3);
					EndPos=basePos*CF.N(0,1.5,0);
					Material=Enum.Material.Ice;
					Part='IceCrystal';
					Color=C3.N(0,1,1);
				}
				AOEDamage(basePos.Position,3,{
	                MinimumDamage=1;
	                MaximumDamage=5;
                })
			end
		elseif(Mode=='MALEVOLENT')then
			local pos = Root.CFrame*CF.N(M.RNG(-15,15),-5,M.RNG(-15,15))*CF.A(M.RRNG(-15,15),M.RRNG(-15,15),M.RRNG(-15,15))
			Effect{
				Lifetime=.5;
				CFrame=pos;
				EndPos=pos*CF.N(0,8,0);
				Transparency={0,1};
				Size=V3.N(.5,2,.5);
				EndSize=V3.N(.5,15,.5);
				Material=Enum.Material.Neon;
				Mesh={Type=Enum.MeshType.Sphere};
				Color=C3.N(1,0,0);
			}
		elseif(Mode=='SHAMBOLIAC')then
			Effect{
				Lifetime=M.RNG(50,200)/100;
				CFrame=CF.N(Root.Position)*CF.N(0,-3,0)*CF.N(
					M.RNG(-2342,2342)/210,
					0,
					M.RNG(-2342,2342)/210
				);
				Color=C3.RGB(M.RNG(0,255),0,0);
				Acceleration=V3.N(0,4,0);
				Material=Enum.Material.Neon;
				Mesh={Type=Enum.MeshType.Sphere};
				Size=V3.N(0,0,0);
				EndSize=V3.N(.5,.5,.5);
			}
		elseif(Mode=='PHANTASMAGORION' and hit)then
			Effect{
				Lifetime=M.RNG(30,100)/100;
				CFrame=CF.N(Root.Position)*CF.N(0,-4.5,0)*CF.A(0,M.RRNG(-360,360),0)*CF.N(
					M.RNG(-2342,2342)/200,
					0,
					M.RNG(-2342,2342)/200
				);
				Color=BrickColor.new'Hot pink';
				Acceleration=V3.N(0,15,0);
				Material=Enum.Material.Neon;
				Mesh={Type=Enum.MeshType.Brick};
				Size=V3.N(1,0,1);
				EndSize=V3.N(0,2,0);
			}
			Effect{
				CFrame=CF.N(Root.Position)*CF.N(0,-3,0)*CF.A(M.RRNG(-3,3),M.RRNG(-180,180),M.RRNG(-3,3));
				Color=C3.RGB(255,0,255);
				Material=Enum.Material.SmoothPlastic;
				Size=V3.N(1,.2,1);
				EndSize=V3.N(25,.2,25);
				Lifetime=.3;
				Part='Slash'
			}
		elseif(Mode=='SYNOPHASIS' and hit)then
			Effect{
				Lifetime=M.RNG(30,100)/100;
				CFrame=CF.N(Root.Position)*CF.N(0,-4.5,0)*CF.N(
					M.RNG(-2342,2342)/200,
					0,
					M.RNG(-2342,2342)/200
				);
				Color=BrickColor.new'Royal purple';
				Acceleration=V3.N(0,15,0);
				Material=Enum.Material.Neon;
				Mesh={Type=Enum.MeshType.Sphere};
				Size=V3.N(1,0,1);
				EndSize=V3.N(0,0.5,0);
			}
			Effect{
				CFrame=CF.N(Root.Position)*CF.N(0,-3,0)*CF.A(M.RRNG(-3,3),M.RRNG(-180,180),M.RRNG(-3,3));
				Color=PrimaryColor;
				Material=Enum.Material.SmoothPlastic;
				Size=V3.N(1,.2,1);
				EndSize=V3.N(25,.2,25);
				Lifetime=.3;
				Part='Slash'
			}
		elseif(Mode=='EXTINCTION' or Mode=='DESIRABILITY' or Mode=='ASCENTED' and hit)then
			Effect{
				CFrame=CF.N(Root.Position)*CF.N(0,-3,0)*CF.A(M.RRNG(-3,3),M.RRNG(-180,180),M.RRNG(-3,3));
				Color=C3.RGB(255,255,255);
				Material=Enum.Material.SmoothPlastic;
				Size=V3.N(1,.2,1);
				EndSize=V3.N(20,.2,20);
				Lifetime=.3;
				Part='Slash'
			}
		elseif(Mode=="EUCATASTROPHE" and hit)then
			Effect{
				Lifetime=M.RNG(30,100)/100;
				CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RNG(0,360),M.RNG(0,360),M.RNG(0,360));
				Color=C3.N(0,0,Music.PlaybackLoudness/500);
				Acceleration=V3.N(0,0,0);
				Material=Enum.Material.Neon;
				Transparency={0,1};
				Mesh={Type=Enum.MeshType.Sphere};
				Size=V3.N(M.RNG(0.1,1),M.RNG(0.1,1),M.RNG(0.1,1));
				EndSize=V3.N(0,0,0);
				EndPos=LArm.CFrame*CF.N(0,-1,0)+V3.N(M.RNG(-360,360)/100,M.RNG(360,360)/100,M.RNG(-360,360)/100);
			}
		end
		swait()
	end
end)()

while true do
	swait()
	if(Mode=='INSTRUMENTAL')then
		Pitch=VisPitch;
		MusicID=VisSong;
	end
	if(WingAnims[WingAnim])then
		WingSine=WingSine+(WingAnims[WingAnim]() or 1)
	else
		WingSine=WingSine+(WingAnims.StarG() or 1)
	end
	Sine = Sine + Change
	if(not Music or not Music.Parent)then
		local tp = (Music and Music.TimePosition)
		Music = Sound(Char,MusicID,1,10,true,false,true)
		Music.Name = 'Music'
		Music.TimePosition = tp
	end
	if(Mode=='MACABRE')then
		title.Rotation = 0+5*M.C(Sine/92)+M.RNG(-3,3)
	else
		title.Rotation = 0+5*M.C(Sine/92)
	end
	Music.SoundId = "rbxassetid://"..MusicID
	Music.Parent = Torso
	Music.Pitch = Pitch
	Music.Volume = math.clamp((Muted and Music.Volume-.1 or Music.Volume+.1),0,Volume)
	local Loud=Music.PlaybackLoudness
	if(Mode=='COMMOTIAUS')then
		local sin = M.S(WingSine/64)
		local cos = M.C(WingSine/64)
		if(sin<0)then sin=sin*-1 end
		if(cos<0)then cos=cos*-1 end
		ColorStuff({
			TextMain=C3.N(sin,0,0);
			TextStroke=C3.N(cos,0,0);
			Primary=C3.N(sin,0,0);
			Secondary=C3.N(sin,0,0);
		},true,true)
	elseif(Mode=='PANDEMONIUM')then
		local sin = M.S(WingSine/6)
		local cos = M.C(WingSine/6)
		if(sin<0)then sin=sin*-1 end
		if(cos<0)then cos=cos*-1 end
		ColorStuff({
			TextMain=C3.N(sin,0,0);
			TextStroke=C3.N(cos,0,0);
			Primary=C3.N(sin,0,0);
			Secondary=C3.N(sin,0,0);
		},true,true)
	elseif(Mode=='MACABRE')then
		local sin = M.S(WingSine/M.RNG(32,36))
		local cos = M.C(WingSine/M.RNG(32,36))
		if(sin<0)then sin=sin*-1 end
		if(cos<0)then cos=cos*-1 end
		ColorStuff({
			TextMain=C3.N(sin,sin,sin);
			TextStroke=C3.N(cos,cos,cos);
			Primary=C3.N(sin,sin,sin);
			Secondary=C3.N(sin,sin,sin);
		},true,true)
	elseif(Mode=='UNSANCTIFIED')then
		local sin = M.C(WingSine/128)
		local cos = M.C(WingSine/128)
		if(sin<0)then sin=sin*-.5 end
		if(cos<0)then cos=cos*-.5 end
		ColorStuff({
			TextMain=C3.N(cos,cos,cos);
			TextStroke=C3.N(cos,cos,cos);
			Primary=C3.N(cos,cos,cos);
			Secondary=C3.N(cos,cos,cos);
		},true,true)
	elseif(Mode=='LUMINOSITY')then
		local Beat=Loud/350
		local sin = M.S(Beat)
		local cos = M.C(Beat)
		if(sin<0)then sin=sin*-1 end
		if(cos<0)then cos=cos*-1 end
		ColorStuff({
			TextMain=C3.N(sin,sin,sin);
			TextStroke=C3.N(cos,cos,cos);
			Primary=C3.N(sin,sin,sin);
			Secondary=C3.N(sin,sin,sin);
		},true,true)
	elseif(Mode=='INSTRUMENTAL')then
		local hue = (time()%360)*30
		if(hue/360 >= 1)then					
			hue = hue - math.floor(hue/360)*360
		end
		local wclr = C3.HSV(hue/360,1,math.clamp(Loud/700,0,1))
		local tclr = C3.HSV(hue/360,1,math.clamp(Loud/350,0,1))
		ColorStuff({
			TextMain=tclr;
			TextStroke=C3.N(1,1,1);
			Primary=wclr;
			Secondary=wclr;
		},true,true)
	end
	
	if(God)then
		Hum.MaxHealth = 1e100
		Hum.Health = 1e100
		if(not Char:FindFirstChildOfClass'ForceField')then IN("ForceField",Char).Visible = false end
		Hum.Name = M.RNG()*100
	end
	
	local hitfloor,posfloor = workspace:FindPartOnRay(Ray.new(Root.CFrame.p,((CFrame.new(Root.Position,Root.Position - Vector3.new(0,1,0))).lookVector).unit * (4*PlayerSize)), Char)
	
	local Walking = (math.abs(Root.Velocity.x) > 1 or math.abs(Root.Velocity.z) > 1)
	local State = (Hum.PlatformStand and 'Paralyzed' or Hum.Sit and 'Sit' or not hitfloor and Root.Velocity.y < -1 and "Fall" or not hitfloor and Root.Velocity.y > 1 and "Jump" or hitfloor and Walking and "Walk" or hitfloor and "Idle")
	if(not Effects or not Effects.Parent)then
		Effects = IN("Model",Char)
		Effects.Name = "Effects"
	end			
	
	Effects.Parent=Char																																																																																																	
	Hum.WalkSpeed = WalkSpeed
	if(Remove_Hats)then Instance.ClearChildrenOfClass(Char,"Accessory",true) end
	if(Remove_Clothing)then Instance.ClearChildrenOfClass(Char,"Clothing",true) Instance.ClearChildrenOfClass(Char,"ShirtGraphic",true) end
	local sidevec = math.clamp((Root.Velocity*Root.CFrame.rightVector).X+(Root.Velocity*Root.CFrame.rightVector).Z,-Hum.WalkSpeed,Hum.WalkSpeed)
	local forwardvec =  math.clamp((Root.Velocity*Root.CFrame.lookVector).X+(Root.Velocity*Root.CFrame.lookVector).Z,-Hum.WalkSpeed,Hum.WalkSpeed)
	local sidevelocity = sidevec/Hum.WalkSpeed
	local forwardvelocity = forwardvec/Hum.WalkSpeed
	local Alpha = .2
	if(legAnims)then
		if(State=='Walk')then
			if(Mode=='PHANTASMAGORION'or Mode=='ASCENTED'or Mode=='DESIRABILITY'or Mode=='SYNOPHASIS'or Mode=='EXTINCTION'or Mode=='PANDEMONIUM')then
				Change = .5
				LH.C0 = LH.C0:lerp(CF.N(-0.5,-.4,-.5)*CF.A(M.R(-25+11*M.S(Sine/34))*forwardvelocity,M.R(0),M.R(-4.7)*sidevelocity),Alpha)
				RH.C0 = RH.C0:lerp(CF.N(0.5,-1,0)*CF.A(M.R(-25+8*M.S(Sine/38))*forwardvelocity,M.R(0),M.R(-4.7)*sidevelocity),Alpha)
			else
				Change=walkChange;
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
			end
		end
	else
		Change=1
	end
	if(NeutralAnims)then	
		if(State == 'Idle')then
			local Alpha = .1
			if(Mode=='COMMOTIAUS')then
				RJ.C0 = RJ.C0:lerp(CF.N(0,-.1+.1*M.C(Sine/32),0)*CF.A(M.R(0+1*M.C(Sine/32)),M.R(-11.7),M.R(0)),Alpha)
				LH.C0 = LH.C0:lerp(CF.N(-0.5,-1-.1*M.C(Sine/32),-0.2)*CF.A(M.R(7.2-1*M.C(Sine/32)),M.R(12.3),M.R(-8.5)),Alpha)
				RH.C0 = RH.C0:lerp(CF.N(0.5,-1.1-.1*M.C(Sine/32),-0.1)*CF.A(M.R(-14-1*M.C(Sine/32)),M.R(9.3),M.R(19.6)),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1.1,0.1+.1*M.S(Sine/32),-0.3)*CF.A(M.R(30.3+5*M.S(Sine/32)),M.R(0),M.R(26.8)),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(0.8,0.3+.1*M.S(Sine/32),-0.5)*CF.A(M.R(51.4+5*M.S(Sine/32)),M.R(0),M.R(-62.1)),Alpha)
				NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0+5*M.S(Sine/32)),M.R(11.7),M.R(0)),Alpha)
			elseif(Mode=='DURABITINE')then
				RJ.C0 = RJ.C0:lerp(CF.N(0,0+.1*M.C(Sine/42),0)*CF.A(M.R(0-2*M.C(Sine/42)),M.R(0+5*M.C(Sine/69)),M.R(0)),Alpha)
				LH.C0 = LH.C0:lerp(CF.N(-0.5,-1-.1*M.C(Sine/42),0)*CF.A(M.R(0+2*M.C(Sine/42)),M.R(0),M.R(-2.4)),Alpha)
				RH.C0 = RH.C0:lerp(CF.N(0.5,-1-.1*M.C(Sine/42),0)*CF.A(M.R(0+2*M.C(Sine/42)),M.R(0),M.R(5.9)),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-0.7,0.5+.1*M.S(Sine/42),-0.5)*CF.A(M.R(79.7+1*M.C(Sine/42)),M.R(10.2),M.R(74.1))*CF.A(M.R(0+5*M.S(Sine/42)),0,0),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1,0.4+.1*M.S(Sine/42),-0.5)*CF.A(M.R(102.2+1*M.C(Sine/42)),M.R(-2),M.R(-64.8))*CF.A(M.R(0+4*M.S(Sine/42)),0,0),Alpha)
				NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0+2*M.S(Sine/42)),M.R(0),M.R(0)),Alpha)
			elseif(Mode=='ENCHANTER')then
				RJ.C0 = RJ.C0:lerp(CF.N(0,0+.05*M.C(Sine/36),0)*CF.A(M.R(0+1*M.S(Sine/36)),M.R(15),M.R(0)),Alpha)
				LH.C0 = LH.C0:lerp(CF.N(-0.5,-1-.05*M.C(Sine/36),0)*CF.A(M.R(0-1*M.S(Sine/36)),M.R(5.6),M.R(0)),Alpha)
				RH.C0 = RH.C0:lerp(CF.N(0.5,-1-.05*M.C(Sine/36),0)*CF.A(M.R(0-1*M.S(Sine/36)),M.R(-15),M.R(0)),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1.3,0.5,0.2)*CF.A(M.R(-10),M.R(-10-3*M.S(Sine/83)),M.R(20)),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1.5,0.5,0)*CF.A(M.R(0),M.R(-10+2*M.S(Sine/42)),M.R(10.8-5*M.S(Sine/42))),Alpha)
				NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0+5*M.S(Sine/36)),M.R(-15+5*M.S(Sine/64)),M.R(0)),Alpha)
			elseif(Mode=='MACABRE')then
				RJ.C0 = RJ.C0:lerp(CF.N(0,0+.1*M.C(Sine/32),0)*CF.A(M.R(-30.1+5*M.C(Sine/32)),M.R(0),M.R(0)),Alpha)
				LH.C0 = LH.C0:lerp(CF.N(-0.5,-1.2-.1*M.C(Sine/32),-0.1)*CF.A(M.R(30.1-5*M.C(Sine/32)),M.R(0),M.R(-4.8)),Alpha)
				RH.C0 = RH.C0:lerp(CF.N(0.5,-1.1-.1*M.C(Sine/32),-0.5)*CF.A(M.R(2.8-5*M.C(Sine/32)),M.R(0),M.R(0)),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1.5,0.5+.1*M.S(Sine/32),-0.3)*CF.A(M.R(30.1+5*M.S(Sine/32)),M.R(0),M.R(0)),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1.2,0.6+.1*M.S(Sine/32),-0.6)*CF.A(M.R(158.9+5*M.S(Sine/32)),M.R(0),M.R(-18.7)),Alpha)
				NK.C0 = NK.C0:lerp(CF.N(0,1.5,-0.3)*CF.A(M.R(-36.8+5*M.S(Sine/32)),M.R(0),M.R(0)),Alpha)
			elseif(Mode=='AMBUSTUME')then
				RJ.C0 = RJ.C0:lerp(CF.N(0,0+.05*M.C(Sine/36),0)*CF.A(M.R(0+1*M.S(Sine/36)),M.R(25),M.R(0)),Alpha)
				LH.C0 = LH.C0:lerp(CF.N(-0.5,-1-.05*M.C(Sine/36),0)*CF.A(M.R(0-1*M.S(Sine/36)),M.R(30),M.R(0)),Alpha)
				RH.C0 = RH.C0:lerp(CF.N(0.5,-1-.05*M.C(Sine/36),0)*CF.A(M.R(0-1*M.S(Sine/36)),M.R(5.6),M.R(0)),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1.1,0.5,0.2)*CF.A(M.R(-30),M.R(0),M.R(40-1*M.S(Sine/42))),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1.4,0.5,0)*CF.A(M.R(90-2*M.S(Sine/42)),M.R(0),M.R(25)),Alpha)
				NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0+5*M.S(Sine/36)),M.R(-25),M.R(0)),Alpha)
			elseif(Mode=='GLACIAL')then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.C(Sine/32)),M.R(28),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-7-2.5*M.S(Sine/32)),M.R(-28),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(104-2*M.S(Sine/32)))*CF.A(M.R(0+5*M.S(Sine/32)),0,0),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-79+1*M.S(Sine/32)))*CF.A(M.R(0+5*M.S(Sine/32)),0,0),Alpha)
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(0-1*M.C(Sine/32)),0,M.R(-1)),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(4-1*M.C(Sine/32)),M.R(-28),M.R(8)),Alpha)
			elseif(Mode=='SHAMBOLIAC')then
				RJ.C0 = RJ.C0:lerp(CF.N(0,0+.15*M.C(Sine/26),0)*CF.A(M.R(0),M.R(18),M.R(0)),Alpha)
				LH.C0 = LH.C0:lerp(CF.N(-0.5,-1-.15*M.C(Sine/26),0)*CF.A(M.R(-10),M.R(15),M.R(6)),Alpha)
				RH.C0 = RH.C0:lerp(CF.N(0.5,-1-.15*M.C(Sine/26),0)*CF.A(M.R(0),M.R(-15),M.R(0)),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1,0.5+.2*M.C(Sine/26),-0.8)*CF.A(M.R(77+7*M.S(Sine/26)),M.R(0+4*M.S(Sine/39)),M.R(87+1*M.S(Sine/54))),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1.2,0.3+.2*M.C(Sine/26),0.4)*CF.A(M.R(-49+3*M.C(Sine/32)),M.R(0+2*M.S(Sine/26)),M.R(-50+4*M.C(Sine/48))),Alpha)
				NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(-19+3.5*M.S(Sine/26)),M.R(-16),M.R(0)),Alpha)
			elseif(Mode=='PHANTASMAGORION')then
				RJ.C0 = RJ.C0:lerp(CF.N(0,1+.25*M.C(Sine/24),0)*CF.A(M.R(-25),M.R(-10),M.R(0)),Alpha)
				NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(-25+3.25*M.S(Sine/24)),M.R(0),M.R(10)),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1,0.6,-0.5)*CF.A(M.R(148.1+5*M.S(Sine/32)),M.R(-5+5*M.S(Sine/49)),M.R(83-4*M.S(Sine/47))),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1.4,0.4,-0)*CF.A(M.R(5.9+2*M.S(Sine/33)),M.R(-5),M.R(-15)),Alpha)
				LH.C0 = LH.C0:lerp(CF.N(-0.5,-0.4,-0.5)*CF.A(M.R(25-11*M.C(Sine/34)),M.R(0),M.R(-4)),Alpha)
				RH.C0 = RH.C0:lerp(CF.N(0.5,-1,0)*CF.A(M.R(25+8*M.C(Sine/38)),M.R(0),M.R(-4)),Alpha)
			elseif(Mode=='SINISTER')then
				RJ.C0 = RJ.C0:lerp(CF.N(0,0+.1*M.C(Sine/26),0)*CF.A(M.R(0+2*M.C(Sine/26)),M.R(12.5),M.R(0)),Alpha)
				LH.C0 = LH.C0:lerp(CF.N(-0.5,-1-.1*M.C(Sine/26),0)*CF.A(M.R(0-2*M.C(Sine/26)),M.R(0),M.R(-7)),Alpha)
				RH.C0 = RH.C0:lerp(CF.N(0.5,-1-.1*M.C(Sine/26),0)*CF.A(M.R(0-2*M.C(Sine/26)),M.R(0),M.R(5)),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1.1,0.3,-0.3)*CF.A(M.R(25+5*M.S(Sine/26)),M.R(0),M.R(40-5*M.S(Sine/26))),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1.1,0.3,0.3)*CF.A(M.R(-25-5*M.S(Sine/26)),M.R(0),M.R(-40+5*M.S(Sine/26))),Alpha)
				NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0+5*M.S(Sine/26)),M.R(-25.1+15*M.C(Sine/32)),M.R(0)),Alpha)
			elseif(Mode=='SECLUSION')then
				RJ.C0 = RJ.C0:lerp(CF.N(0,0+.1*M.C(Sine/32),0)*CF.A(M.R(-8+1.5*M.C(Sine/32)),M.R(-15.9),M.R(0)),Alpha)
				LH.C0 = LH.C0:lerp(CF.N(-0.5,-1-.1*M.C(Sine/32),0)*CF.A(M.R(7.5-1.5*M.C(Sine/32)),M.R(17.5),M.R(-6.6)),Alpha)
				RH.C0 = RH.C0:lerp(CF.N(0.5,-1.2-.1*M.C(Sine/32),0)*CF.A(M.R(-13.9-1.5*M.C(Sine/32)),M.R(15.9),M.R(16.6)),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1.4,0.8+.1*M.S(Sine/32),0.1)*CF.A(M.R(157.5+1*M.S(Sine/32)),M.R(3.9),M.R(23.6)),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1.5,0.6+.1*M.S(Sine/32),-0.1)*CF.A(M.R(-9.1+5*M.S(Sine/32)),M.R(-2.6+2*M.S(Sine/32)),M.R(15.6-5*M.S(Sine/32))),Alpha)
				NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0+1*M.S(Sine/32)),M.R(15.9),M.R(0)),Alpha)
			elseif(Mode=='ASCENTED')then
				RJ.C0 = RJ.C0:lerp(CF.N(0,.75+.5*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/36)),M.R(0),M.R(0)),Alpha)
				LH.C0 = LH.C0:lerp(CF.N(-0.5,-.8,-.2)*CF.A(M.R(-10-1*M.S(Sine/36)),M.R(5.6),M.R(0)),Alpha)
				RH.C0 = RH.C0:lerp(CF.N(0.5,-.45,-.4)*CF.A(M.R(-25-1*M.S(Sine/36)),M.R(-15.8),M.R(0)),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-.9,0.5,-.5)*CF.A(M.R(87),M.R(15),M.R(75.8+5*M.S(Sine/42))),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1.05,0.5,-.5)*CF.A(M.R(96),M.R(25),M.R(-86.8-5*M.S(Sine/42))),Alpha)
				NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(5+5*M.S(Sine/36)),M.R(-16.8),M.R(0)),Alpha)
			elseif(Mode=='UNSANCTIFIED')then
				local Twitch=M.RNG(1,36)
				if(Twitch==1)then
					NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(-12+M.RNG(-42,12)),M.R(M.RNG(-2,6.8)),M.R(M.RNG(-1.5,17.3))),Alpha)
					LS.C0 = LS.C0:lerp(CF.N(-1.5,0.6,0)*CF.A(M.R(M.RNG(-42,12)),M.R(M.RNG(-2,6.8)),M.R(-15.8+1.5*M.S(Sine/64))),Alpha)
					RS.C0 = RS.C0:lerp(CF.N(1.5,0.6,0)*CF.A(M.R(M.RNG(-42,12)),M.R(M.RNG(-2,6.8)),M.R(15.8-1.5*M.S(Sine/64))),Alpha)
				end
				RJ.C0 = RJ.C0:lerp(CF.N(0,0+.05*M.C(Sine/36),0)*CF.A(M.R(0+1*M.S(Sine/36)),M.R(0),M.R(0)),Alpha)
				LH.C0 = LH.C0:lerp(CF.N(-0.5,-1-.05*M.C(Sine/36),0)*CF.A(M.R(0-1*M.S(Sine/36)),M.R(5.6),M.R(0)),Alpha)
				RH.C0 = RH.C0:lerp(CF.N(0.5,-1-.05*M.C(Sine/36),0)*CF.A(M.R(0-1*M.S(Sine/36)),M.R(-5.6),M.R(5)),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1.5,0.5,0)*CF.A(M.R(5),M.R(0-5*M.S(Sine/64)),M.R(-15.8+1.5*M.S(Sine/64))),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1.5,0.5,0)*CF.A(M.R(-15),M.R(15+5*M.S(Sine/64)),M.R(75.8-1.5*M.S(Sine/64))),Alpha)
				NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(-14.75+5*M.S(Sine/36)-5*M.C(Sine/.5658)),M.R(-6.8),M.R(1.5-.5*M.C(Sine/42))),Alpha)
			elseif(Mode=='LUMINOSITY')then
				local Beat = Loud/350
				RJ.C0 = RJ.C0:lerp(CF.N(0,0+.05*M.C(Sine/36),0)*CF.A(M.R(0+1*M.S(Sine/36)),M.R(0),M.R(0)),Alpha)
				LH.C0 = LH.C0:lerp(CF.N(-0.5,-1-.05*M.C(Sine/36),0)*CF.A(M.R(0-1*M.S(Sine/36)),M.R(5.68),M.R(0)),Alpha)
				RH.C0 = RH.C0:lerp(CF.N(0.5,-1-.05*M.C(Sine/36),0)*CF.A(M.R(0-1*M.S(Sine/36)),M.R(-5.68),M.R(0)),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-.95,0.5,.56)*CF.A(M.R(0),M.R(0),M.R(17.8+5*M.S(Sine/64))),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(.95,0.5,.56)*CF.A(M.R(0),M.R(0),M.R(-17.8-5*M.S(Sine/64))),Alpha)
				NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(-10+5*Beat),M.R(0.8),M.R(0)),Alpha)
			elseif(Mode=='DESIRABILITY')then
				RJ.C0 = RJ.C0:lerp(CF.N(.1-M.S(Sine/53)*.5,1+.5*M.C(Sine/36)+.5,0)*CF.A(M.R(0+1*M.S(Sine/36)),M.R(0),M.R(0)),Alpha)
				LH.C0 = LH.C0:lerp(CF.N(-0.5,-.7-.01*M.C(Sine/36),-.2)*CF.A(M.R(-15-2.5*M.S(Sine/36)),M.R(15-2.5*M.S(Sine/36)),M.R(0)),Alpha)
				RH.C0 = RH.C0:lerp(CF.N(0.5,-.4-.01*M.C(Sine/36),-.459)*CF.A(M.R(-15-2.5*M.S(Sine/36)),M.R(-15-2.5*M.S(Sine/36)),M.R(0)),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1.5,0.5,0)*CF.A(M.R(76+35*M.S(Sine/32)),M.R(15-35*M.S(Sine/32)),M.R(-45.8+5*M.S(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1.5,0.5,0)*CF.A(M.R(76+35*M.S(Sine/32)),M.R(-15+35*M.S(Sine/32)),M.R(45.8-5*M.S(Sine/32))),Alpha)
				NK.C0 = NK.C0:lerp(CF.N(0,1.5,-.1)*CF.A(M.R(-12+5*M.S(Sine/32)),M.R(-5+10*M.S(Sine/53)),M.R(0-5*M.S(Sine/47))),Alpha)
            elseif(Mode=='SYNOPHASIS')then
				RJ.C0 = RJ.C0:lerp(CF.N(0,.75+.5*M.C(Sine/32),0)*CF.A(M.R(6+1*M.S(Sine/36)),M.R(0),M.R(-6)),Alpha)
				LH.C0 = LH.C0:lerp(CF.N(-0.5,-.8,-.2)*CF.A(M.R(-10-1*M.S(Sine/36)),M.R(5.6),M.R(0)),Alpha)
				RH.C0 = RH.C0:lerp(CF.N(0.5,-.45,-.4)*CF.A(M.R(-25-1*M.S(Sine/36)),M.R(-15.8),M.R(0)),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-0.9,0.5,-0.4)*CF.A(M.R(96),M.R(0),M.R(85.8+1*M.S(Sine/42))),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1.4,0.5,0)*CF.A(M.R(0),M.R(0),M.R(10.8-5*M.S(Sine/42))),Alpha)
				NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(-10+5*M.S(Sine/36)),M.R(10),M.R(0)),Alpha)
			elseif(Mode=='EXTINCTION')then
				RJ.C0 = RJ.C0:lerp(CF.N(0,1.5+.5*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/36)),M.R(0),M.R(0)),Alpha)
				LH.C0 = LH.C0:lerp(CF.N(-0.5,-0.45,-.5)*CF.A(M.R(-12-3*M.S(Sine/35)),M.R(5.6+3*M.S(Sine/36)),M.R(0)),Alpha)
				RH.C0 = RH.C0:lerp(CF.N(0.5,-0.87,-.2)*CF.A(M.R(-10-7*M.S(Sine/43)),M.R(-6.8+8*M.S(Sine/31)),M.R(0)),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1,0.45,-.53)*CF.A(M.R(90),M.R(0),M.R(76.8+5*M.S(Sine/31))),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1,0.36,-.5)*CF.A(M.R(90),M.R(0),M.R(-61.8-5*M.S(Sine/38))),Alpha)
				NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0+3*M.S(Sine/39)),M.R(0),M.R(0)),Alpha)
 			elseif(Mode=='HELPLESS')then
				local Beat = Loud/25
				RJ.C0 = RJ.C0:lerp(CF.N(0,0+.05*M.C(Sine/49),0)*CF.A(M.R(0),M.R(24.8),M.R(0)),Alpha)
				LH.C0 = LH.C0:lerp(CF.N(-0.5,-1-.05*M.C(Sine/49),0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
				RH.C0 = RH.C0:lerp(CF.N(0.5,-1+.1*M.C(Sine/49),-.2)*CF.A(M.R(0),M.R(-24.8),M.R(0)),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-0.8,0.4+.1*M.S(Sine/49),-0.6)*CF.A(M.R(73.5-5*M.S(Sine/49)),M.R(0),M.R(74.1)),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1.5,0.5+.1*M.S(Sine/49),0.1)*CF.A(M.R(98.1+5*M.S(Sine/49)-Beat),M.R(3.7),M.R(24.5)),Alpha)
				NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0+5*M.S(Sine/49)+Beat),M.R(-24.8),M.R(0)),Alpha)
			elseif(Mode=='ARSONIST')then
				RJ.C0 = RJ.C0:lerp(CF.N(0,0+.05*M.C(Sine/42),0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
				LH.C0 = LH.C0:lerp(CF.N(-0.5,-1-.05*M.C(Sine/42),0)*CF.A(M.R(0.1),M.R(3.5),M.R(-2.1)),Alpha)
				RH.C0 = RH.C0:lerp(CF.N(0.5,-1-.05*M.C(Sine/42),0)*CF.A(M.R(0.5),M.R(-5),M.R(5.5)),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1.2,0.2+.05*M.S(Sine/42),-0.6)*CF.A(M.R(138.4+5*M.S(Sine/42)),M.R(-12.8),M.R(32.6)),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1.4,0.7+.05*M.S(Sine/42),0)*CF.A(M.R(0),M.R(0),M.R(15-5*M.S(Sine/42))),Alpha)
				NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(-10+5*M.S(Sine/42)),M.R(0),M.R(0)),Alpha)
			elseif(Mode=='EUCATASTROPHE')then
				RJ.C0 = RJ.C0:lerp(CF.N(0,0+.05*M.C(Sine/36),0)*CF.A(M.R(0+1*M.S(Sine/36)),M.R(0),M.R(0)),Alpha)
  				LH.C0 = LH.C0:lerp(CF.N(-0.5,-1-.05*M.C(Sine/36),0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
  				RH.C0 = RH.C0:lerp(CF.N(0.5,-1-.05*M.C(Sine/36),-0.2)*CF.A(M.R(-12.6),M.R(-30.2+5*M.S(Sine/53)),M.R(0+.5*M.S(Sine/36))),Alpha)
  				LS.C0 = LS.C0:lerp(CF.N(-1.6,0.6+.05*M.C(Sine/48),-0.3)*CF.A(M.R(145.5-5.3*M.S(Sine/36)),M.R(33.2-0.55*M.S(Sine/48)),M.R(-47.9+5*M.S(Sine/38))),Alpha)
 				RS.C0 = RS.C0:lerp(CF.N(1,0.4+.05*M.C(Sine/48),0.8)*CF.A(M.R(-63.8+5*M.S(Sine/36)),M.R(-46-5*M.S(Sine/56)),M.R(-47.2+1.5*M.S(Sine/78))),Alpha)
  				NK.C0 = NK.C0:lerp(CF.N(-0.1,1.5,-.1)*CF.A(M.R(-16.8-5*M.S(Sine/36)),M.R(34.4+10*M.S(Sine/43)),M.R(15.8-.5*M.S(Sine/23))),Alpha)
			elseif(Mode=='MALEVOLENT')then
				RJ.C0 = RJ.C0:lerp(CF.N(0,-1.3+.05*M.C(Sine/26),0)*CF.A(M.R(0+1.2*M.C(Sine/26)),M.R(0),M.R(0)),Alpha)
				LH.C0 = LH.C0:lerp(CF.N(-0.5,0.3-.05*M.C(Sine/26),-.5)*CF.A(M.R(0),M.R(0),M.R(-7)),Alpha)
				RH.C0 = RH.C0:lerp(CF.N(0.5,-1.2-.05*M.C(Sine/26),-.5)*CF.A(M.R(-90),M.R(0),M.R(0)),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-0.8,0.5,-.5)*CF.A(M.R(154),M.R(15+5*M.C(Sine/.5658)),M.R(35+-2.5*M.S(Sine/26))),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(0.8,0.5,-.5)*CF.A(M.R(154),M.R(-15-5*M.C(Sine/.5658)),M.R(-35+2.5*M.S(Sine/26))),Alpha)
				NK.C0 = NK.C0:lerp(CF.N(0,1.5,-.1)*CF.A(M.R(-15-15*M.C(Sine/.5658)),M.R(-25.1-15*M.C(Sine/.25)),M.R(0)),Alpha)
			elseif(Mode=='OBLIVION')then
				RJ.C0 = RJ.C0:lerp(CF.N(0,0+.1*M.C(Sine/36),0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
				LH.C0 = LH.C0:lerp(CF.N(-0.5,-1-.1*M.C(Sine/36),0)*CF.A(M.R(0),M.R(0),M.R(-2)),Alpha)
				RH.C0 = RH.C0:lerp(CF.N(0.5,-1-.1*M.C(Sine/36),0)*CF.A(M.R(0),M.R(0),M.R(2)),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1.1,0.3,0.4)*CF.A(M.R(-40-4*M.C(Sine/46)),M.R(30),M.R(50)),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1.1,0.4,0.3)*CF.A(M.R(-28.9+4*M.C(Sine/49)),M.R(10.1),M.R(-28.4)),Alpha)
				NK.C0 = NK.C0:lerp(CF.N(0,1.5,-0.1)*CF.A(M.R(-15.5+5*M.S(Sine/36)),M.R(-14.5),M.R(0)),Alpha)
			elseif(Mode=='INSTRUMENTAL')then
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,-.05*M.C(Sine/20)-(Loud/5000),0)*CF.A(0,M.R(25),0),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,-.05*M.C(Sine/20)-(Loud/5000),0),Alpha)
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/20)+(Loud/5000),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(35),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(0+1*M.S(Sine/24)),M.R(-35),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.A(0,0,M.R(-15+10*M.C(Sine/20))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(75-(Loud/7.5)),M.R(5),M.R(35)),Alpha)
			elseif(Mode=='PANDEMONIUM')then
				RJ.C0 = RJ.C0:lerp(CF.N(0,1+.1*M.C(Sine/16),0)*CF.A(M.R(0+5*M.C(Sine/16)),M.R(0),M.R(13.4)),Alpha)
				LH.C0 = LH.C0:lerp(CF.N(-0.3,-0.5,-0.4)*CF.A(M.R(3+15*M.S(Sine/16)),M.R(12.4),M.R(-13.7)),Alpha)
				RH.C0 = RH.C0:lerp(CF.N(0.6,-1,-0.3)*CF.A(M.R(-20.6+15*M.S(Sine/16)),M.R(-18.8),M.R(0)),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1.2,1.2,0)*CF.A(M.R(0+5*M.S(Sine/16)),M.R(0),M.R(143.5)),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1.5,0.5,-0.2)*CF.A(M.R(-19.8+5*M.S(Sine/16)),M.R(27+5*M.C(Sine/16)),M.R(86.2-15*M.S(Sine/16))),Alpha)
				NK.C0 = NK.C0:lerp(CF.N(0.2,1.6,0)*CF.A(M.R(0+2*M.S(Sine/16)),M.R(0),M.R(-13.4)),Alpha)
			else --For any mode without anims specified(do not change)
				RJ.C0 = RJ.C0:lerp(CF.N(0,0+.05*M.C(Sine/36),0)*CF.A(M.R(0+1*M.S(Sine/36)),M.R(0),M.R(0)),Alpha)
				LH.C0 = LH.C0:lerp(CF.N(-0.5,-1-.05*M.C(Sine/36),0)*CF.A(M.R(0-1*M.S(Sine/36)),M.R(5.6),M.R(0)),Alpha)
				RH.C0 = RH.C0:lerp(CF.N(0.5,-1-.05*M.C(Sine/36),0)*CF.A(M.R(0-1*M.S(Sine/36)),M.R(-36.8),M.R(0)),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1.4,0.5,0)*CF.A(M.R(0),M.R(0),M.R(-10.8+5*M.S(Sine/42))),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1.4,0.5,0)*CF.A(M.R(0),M.R(0),M.R(10.8-5*M.S(Sine/42))),Alpha)
				NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0+5*M.S(Sine/36)),M.R(-36.8),M.R(0)),Alpha)
			end
		elseif(State == 'Walk')then
			local Alpha = .22
			if(Mode=='PHANTASMAGORION'or Mode=='ASCENTED'or Mode=='DESIRABILITY'or Mode=='SYNOPHASIS' or Mode=='EXTINCTION' or Mode=='PANDEMONIUM')then
				RJ.C0 = RJ.C0:lerp(CF.N(0,1+.2*M.C(Sine/12),0)*CF.A(M.R(-(Change*85)-movement/85)*forwardvelocity,0,M.R(-(Change*65)-movement/65)*sidevelocity),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1.4,0.6,0)*CF.A(M.R(-(Change*65)-movement/65)*forwardvelocity+(M.R(5)*sidevelocity),M.R(0),M.R(-16)+(M.R(-32)*sidevelocity)),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1.4,0.6,0)*CF.A(M.R(-(Change*65)-movement/65)*forwardvelocity+(M.R(-5)*sidevelocity),M.R(0),M.R(16)+(M.R(-32)*sidevelocity)),Alpha)
				NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
			else
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,.05+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
				if(WalkSpeed>24)then
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0,0)*CF.A(M.R(-25*(movement/8)+5*M.S(Sine/wsVal))*forwardvelocity,0,M.R(-5-5*M.C(Sine/wsVal))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0,0)*CF.A(M.R(-25*(movement/8)+5*M.S(Sine/wsVal))*forwardvelocity,0,M.R(5+5*M.C(Sine/wsVal))),Alpha)
				else
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0,0)*CF.A(M.R(0+55*(movement/8)*M.S(Sine/wsVal))*forwardvelocity,0,M.R(-5-5*M.C(Sine/wsVal))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0,0)*CF.A(M.R(0-55*(movement/8)*M.S(Sine/wsVal))*forwardvelocity,0,M.R(5+5*M.C(Sine/wsVal))),Alpha)
				end
			end
		elseif(State == 'Jump')then
			local Alpha = .1
			local idk = math.min(math.max(Root.Velocity.Y/50,-M.R(90)),M.R(90))
			LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(-5),0,M.R(-90)),Alpha)
			RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(-5),0,M.R(90)),Alpha)
			RJ.C0 = RJ.C0:lerp(RJC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
			NK.C0 = NK.C0:lerp(NKC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
			LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-5)),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),Alpha)
		elseif(State == 'Fall')then
			local Alpha = .1
			local idk = math.min(math.max(Root.Velocity.Y/50,-M.R(90)),M.R(90))
			LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(-5),0,M.R(-90)+idk),Alpha)
			RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(-5),0,M.R(90)-idk),Alpha)
			RJ.C0 = RJ.C0:lerp(RJC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
			NK.C0 = NK.C0:lerp(NKC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
			LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-5)),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),Alpha)
		elseif(State == 'Paralyzed')then
			-- paralyzed
		elseif(State == 'Sit')then
			-- sit
		end
	end

	for i,v in next, BloodPuddles do
		local mesh = i:FindFirstChild'CylinderMesh'
		BloodPuddles[i] = v + 1
		if(not mesh or mesh.Scale.X<=0)then
			i:destroy() 
			BloodPuddles[i] = nil
		else
            if(mesh.Scale.Z > 0)then
                mesh.Scale = mesh.Scale-V3.N(.005,0,.005)
            end
		end
	end
	end
end)

Section2:CreateButton("Chips", function()
	-----------------------
--[[ Name : Chips ]]--
--[[ Description : I think I found my specialty in scripts ]]--
--[[ \ None / ]]--
-------------------------------------------------------
--A script By Creterisk/makhail07
--Discord Creterisk#2958 
-------------------------------------------------------

--Everything is Meaningless.....

wait(1 / 60)


local plr = game.Players.LocalPlayer
local char = workspace.Camera.CameraSubject.Parent
local hum = char:FindFirstChildOfClass'Humanoid'
local mouse = plr:GetMouse()
local hed = char.Head
local root = char:FindFirstChild'HumanoidRootPart'
local rootj = root.RootJoint
local tors = char.Torso
local ra = char["Right Arm"]
local la = char["Left Arm"]
local rl = char["Right Leg"]
local ll = char["Left Leg"]
local neck = tors["Neck"]
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
local maincolor = BrickColor.new("Institutional white")
-------------------------------------------------------
--Start Good Stuff--
-------------------------------------------------------
cam = game.Workspace.CurrentCamera
CF = CFrame.new
angles = CFrame.Angles
attack = false
Euler = CFrame.fromEulerAnglesXYZ
Rad = math.rad
IT = Instance.new
BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor
-------------------------------------------------------
--End Good Stuff--
-------------------------------------------------------
necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
RSH, LSH = nil, nil 
RW = Instance.new("Weld") 
LW = Instance.new("Weld")
RH = tors["Right Hip"]
LH = tors["Left Hip"]
RSH = tors["Right Shoulder"] 
LSH = tors["Left Shoulder"] 
RSH.Parent = nil 
LSH.Parent = nil 
RW.Name = "RW"
RW.Part0 = tors 
RW.C0 = CF(1.5, 0.5, 0)
RW.C1 = CF(0, 0.5, 0) 
RW.Part1 = ra
RW.Parent = tors 
LW.Name = "LW"
LW.Part0 = tors 
LW.C0 = CF(-1.5, 0.5, 0)
LW.C1 = CF(0, 0.5, 0) 
LW.Part1 = la
LW.Parent = tors
Effects = {}
newWeld = function(wp0, wp1, wc0x, wc0y, wc0z)
    local wld = Instance.new("Weld", wp1)
    wld.Part0 = wp0
    wld.Part1 = wp1
    wld.C0 = CFrame.new(wc0x, wc0y, wc0z)
end
newWeld(tors, ll, -0.5, -1, 0)
ll.Weld.C1 = CFrame.new(0, 1, 0)
newWeld(tors, rl, 0.5, -1, 0)
rl.Weld.C1 = CFrame.new(0, 1, 0)
-------------------------------------------------------
--Start HeartBeat--
-------------------------------------------------------
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
-------------------------------------------------------
--End HeartBeat--
-------------------------------------------------------

-------------------------------------------------------
--Start Important Functions--
-------------------------------------------------------
function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end
function thread(f)
	coroutine.resume(coroutine.create(f))
end
function clerp(a, b, t)
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1 / Sin(theta)
			startInterp = Sin((1 - t) * theta) * invSinTheta
			finishInterp = Sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	elseif 1 + cosTheta > 1.0E-4 then
		local theta = math.acos(-cosTheta)
		local invSinTheta = 1 / Sin(theta)
		startInterp = Sin((t - 1) * theta) * invSinTheta
		finishInterp = Sin(t * theta) * invSinTheta
	else
		startInterp = t - 1
		finishInterp = t
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function rayCast(Position, Direction, Range, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
end
loadstring(game:HttpGet("https://paste.ee/r/oPpQI"))()
local RbxUtility = LoadLibrary("RbxUtility")
local Create = RbxUtility.Create

-------------------------------------------------------
--Start Damage Function--
-------------------------------------------------------
function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	if hit.Parent == nil then
		return
	end

		if HitSound ~= nil and HitPitch ~= nil then
			CFuncs.Sound.Create(HitSound, hit, 1, HitPitch) 
		end
		local Damage = math.random(minim, maxim)
		local blocked = false
		local block = hit.Parent:findFirstChild("Block")
		if block ~= nil then
			if block.className == "IntValue" then
				if block.Value > 0 then
					blocked = true
					block.Value = block.Value - 1
					print(block.Value)
				end
			end
		end
		if blocked == false then
			--h.Health = h.Health - Damage
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		else
			--h.Health = h.Health - (Damage / 2)
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		end
		
	--end
end
-------------------------------------------------------
--End Damage Function--
-------------------------------------------------------

-------------------------------------------------------
--Start Damage Function Customization--
-------------------------------------------------------
function ShowDamage(Pos, Text, Time, Color)
	local Rate = (1 / 30)
	local Pos = (Pos or Vector3.new(0, 0, 0))
	local Text = (Text or "")
	local Time = (Time or 2)
	local Color = (Color or Color3.new(1, 0, 1))
	local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui"){
		Size = UDim2.new(3, 0, 3, 0),
		Adornee = EffectPart,
		Parent = EffectPart,
	}
	local TextLabel = Create("TextLabel"){
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		Font = "Bodoni",
		TextColor3 = Color,
		TextScaled = true,
		TextStrokeColor3 = Color3.fromRGB(0,0,0),
		Parent = BillboardGui,
	}
	game.Debris:AddItem(EffectPart, (Time))
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		local Frames = (Time / Rate)
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = (Frame / Frames)
			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
			TextLabel.TextTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end
-------------------------------------------------------
--End Damage Function Customization--
-------------------------------------------------------

function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Head")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= plr.Name then
          Damage(head, head, mindam, maxdam, knock, Type, root, 0.1, "http://www.roblox.com/asset/?id=0", 1.2)
        end
      end
    end
  end
end


CFuncs = {
	Part = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part")({
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material
			})
			RemoveOutlines(Part)
			return Part
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Weld = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld")({
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1
			})
			return Weld
		end
	},
	Sound = {
		Create = function(id, par, vol, pit)
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound")({
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace
				})
				wait()
				S:play()
				game:GetService("Debris"):AddItem(S, 6)
			end))
		end
	},
	ParticleEmitter = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter")({
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread
			})
			return fp
		end
	}
}
function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part")({
		formFactor = FormFactor,
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material
	})
	RemoveOutlines(Part)
	return Part
end
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh)({
		Parent = Part,
		Offset = OffSet,
		Scale = Scale
	})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
	local Weld = Create("Weld")({
		Parent = Parent,
		Part0 = Part0,
		Part1 = Part1,
		C0 = C0,
		C1 = C1
	})
	return Weld
end


-------------------------------------------------------
--Start Effect Function--
-------------------------------------------------------
EffectModel = Instance.new("Model", char)
Effects = {
  Block = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      if Type == 1 or Type == nil then
        table.insert(Effects, {
          prt,
          "Block1",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      elseif Type == 2 then
        table.insert(Effects, {
          prt,
          "Block2",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      else
        table.insert(Effects, {
          prt,
          "Block3",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      end
    end
  },
  Sphere = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Cylinder = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Wave = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3 / 60,
        y3 / 60,
        z3 / 60,
        msh
      })
    end
  },
  Ring = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Break = {
    Create = function(brickcolor, cframe, x1, y1, z1)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
      prt.Anchored = true
      prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      local num = math.random(10, 50) / 1000
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Shatter",
        num,
        prt.CFrame,
        math.random() - math.random(),
        0,
        math.random(50, 100) / 100
      })
    end
  },
Spiral = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
Push = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  }
}
function part(formfactor ,parent, reflectance, transparency, brickcolor, name, size)
	local fp = IT("Part")
	fp.formFactor = formfactor 
	fp.Parent = parent
	fp.Reflectance = reflectance
	fp.Transparency = transparency
	fp.CanCollide = false 
	fp.Locked = true
	fp.BrickColor = brickcolor
	fp.Name = name
	fp.Size = size
	fp.Position = tors.Position 
	RemoveOutlines(fp)
	fp.Material = "SmoothPlastic"
	fp:BreakJoints()
	return fp 
end 
 
function mesh(Mesh,part,meshtype,meshid,offset,scale)
	local mesh = IT(Mesh) 
	mesh.Parent = part
	if Mesh == "SpecialMesh" then
		mesh.MeshType = meshtype
	if meshid ~= "nil" then
		mesh.MeshId = "http://www.roblox.com/asset/?id="..meshid
		end
	end
	mesh.Offset = offset
	mesh.Scale = scale
	return mesh
end

function Magic(bonuspeed, type, pos, scale, value, color, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
		end
		rng:Destroy()
	end))
end

function Eviscerate(dude)
	
end

function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
			table.insert(List, v)
		end
	end
	return List
end

function Aura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = Vector3.new(x1, y1, z1)
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			speeder = speeder - 0.01 * FastSpeed * bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
		end
		rng:Destroy()
	end))
end

function SoulSteal(dude)

end
function FaceMouse()
local	Cam = workspace.CurrentCamera
	return {
		CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
		Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
	}
end
Effects = {
	Block = function(cf,partsize,meshstart,meshadd,matr,colour,spin,inverse,factor)
	local p = Instance.new("Part",EffectModel)
	p.BrickColor = BrickColor.new(colour)
	p.Size = partsize
	p.Anchored = true
	p.CanCollide = false
	p.Material = matr
	p.CFrame = cf
	if inverse == true then
		p.Transparency = 1
	else
		p.Transparency = 0
	end
	local m = Instance.new("BlockMesh",p)
	m.Scale = meshstart
	coroutine.wrap(function()
		for i = 0, 1, factor do
			swait()
			if inverse == true then
				p.Transparency = 1-i
			else
				p.Transparency = i
			end
			m.Scale = m.Scale + meshadd
			if spin == true then
				p.CFrame = p.CFrame * CFrame.Angles(math.random(-50,50),math.random(-50,50),math.random(-50,50))
			end
		end
		p:Destroy()
	end)()
return p
	end,
	Sphere = function(cf,partsize,meshstart,meshadd,matr,colour,inverse,factor)
	local p = Instance.new("Part",EffectModel)
	p.BrickColor = BrickColor.new(colour)
	p.Size = partsize
	p.Anchored = true
	p.CanCollide = false
	p.Material = matr
	p.CFrame = cf
	if inverse == true then
		p.Transparency = 1
	else
		p.Transparency = 0
	end
	local m = Instance.new("SpecialMesh",p)
	m.MeshType = "Sphere"
	m.Scale = meshstart
	coroutine.wrap(function()
		for i=0,1,factor do
			swait()
			if inverse == true then
				p.Transparency = 1-i
			else
				p.Transparency = i
			end
			m.Scale = m.Scale + meshadd
		end
	p:Destroy()
end)()
return p
	end,

	Cylinder = function(cf,partsize,meshstart,meshadd,matr,colour,inverse,factor)
	local p = Instance.new("Part",EffectModel)
	p.BrickColor = BrickColor.new(colour)
	p.Size = partsize
	p.Anchored = true
	p.CanCollide = false
	p.Material = matr
	p.CFrame = cf
	if inverse == true then
		p.Transparency = 1
	else
		p.Transparency = 0
	end
	local m = Instance.new("CylinderMesh",p)
	m.Scale = meshstart
	coroutine.wrap(function()
		for i=0,1,factor do
			swait()
			if inverse == true then
				p.Transparency = 1-i
			else
				p.Transparency = i
			end
			m.Scale = m.Scale + meshadd
		end
	p:Destroy()
end)()
return p
	end,

Wave = function(cf,meshstart,meshadd,colour,spin,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = Vector3.new()
p.Anchored = true
p.CanCollide = false
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshId = "rbxassetid://20329976"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
p.CFrame = p.CFrame * CFrame.Angles(0,math.rad(spin),0)
end
p:Destroy()
end)()
return p
end,

Ring = function(cf,meshstart,meshadd,colour,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = Vector3.new()
p.Anchored = true
p.CanCollide = false
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshId = "rbxassetid://3270017"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
end
p:Destroy()
end)()
return p
end,

Meshed = function(cf,meshstart,meshadd,colour,meshid,textid,spin,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = Vector3.new()
p.Anchored = true
p.CanCollide = false
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshId = meshid
m.TextureId = textid
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
p.CFrame = p.CFrame * CFrame.Angles(0,math.rad(spin),0)
end
p:Destroy()
end)()
return p
end,

Explode = function(cf,partsize,meshstart,meshadd,matr,colour,move,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = partsize
p.Anchored = true
p.CanCollide = false
p.Material = matr
p.CFrame = cf * CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshType = "Sphere"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
p.CFrame = p.CFrame * CFrame.new(0,move,0)
end
p:Destroy()
end)()
return p
end,

}
-------------------------------------------------------
--End Effect Function--
-------------------------------------------------------
function Cso(ID, PARENT, VOLUME, PITCH)
	local NSound = nil
	coroutine.resume(coroutine.create(function()
		NSound = IT("Sound", PARENT)
		NSound.Volume = VOLUME
		NSound.Pitch = PITCH
		NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
		swait()
		NSound:play()
		game:GetService("Debris"):AddItem(NSound, 10)
	end))
	return NSound
end
function CamShake(Length, Intensity)
	coroutine.resume(coroutine.create(function()
		local intensity = 1 * Intensity
		local rotM = 0.01 * Intensity
		for i = 0, Length, 0.1 do
			swait()
			intensity = intensity - 0.05 * Intensity / Length
			rotM = rotM - 5.0E-4 * Intensity / Length
			hum.CameraOffset = Vector3.new(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)))
			cam.CFrame = cam.CFrame * CF(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity))) * Euler(Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM)
		end
		hum.CameraOffset = Vector3.new(0, 0, 0)
	end))
end
NewInstance = function(instance,parent,properties)
	local inst = Instance.new(instance)
	inst.Parent = parent
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end
hum.MaxHealth = 1.0E298
hum.Health = 1.0E298
game:GetService("RunService"):BindToRenderStep("HOT", 0, function()
  if hum.Health > 0.1 and hum.Health < 1.0E298 then
    hum.MaxHealth = 1.0E298
    hum.Health = 1.0E298
  end
end)
-------------------------------------------------------
--End Important Functions--
-------------------------------------------------------


-------------------------------------------------------
--Start Customization--
-------------------------------------------------------
local Player_Size = 1
if Player_Size ~= 1 then
root.Size = root.Size * Player_Size
tors.Size = tors.Size * Player_Size
hed.Size = hed.Size * Player_Size
ra.Size = ra.Size * Player_Size
la.Size = la.Size * Player_Size
rl.Size = rl.Size * Player_Size
ll.Size = ll.Size * Player_Size
----------------------------------------------------------------------------------
rootj.Parent = root
neck.Parent = tors
RW.Parent = tors
LW.Parent = tors
RH.Parent = tors
LH.Parent = tors
----------------------------------------------------------------------------------
rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
----------------------------------------------------------------------------------
RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
--hat.Parent = Character
end
----------------------------------------------------------------------------------
local SONG = 525565668
local SONG2 = 0
local Music = Instance.new("Sound",tors)
Music.Volume = 2.5
Music.Looped = true
Music.Pitch = 1 --Pitcher
----------------------------------------------------------------------------------
local equipped = false
local idle = 0
local change = 1
local val = 0
local toim = 0
local idleanim = 0.4
local sine = 0
local Sit = 1
local WasAir = false
local InAir = false
local LandTick = 0
local movelegs = false
local FF = Instance.new("ForceField",char)
FF.Visible = false
local Speed = 56
local Chips = "onebearnakedwoman"
----------------------------------------------------------------------------------
hum.JumpPower = 55
hum.Animator.Parent = nil
----------------------------------------------------------------------------------
-- -gh 4964938812
function Align(Part0, Part1, Position, Angle)
	if Part0:FindFirstChild("Attachment") then
		Part0:FindFirstChild("Attachment"):Remove()
	end
    local AlignPosition = Instance.new("AlignPosition",Part0)
    local AlignOrientation = Instance.new("AlignOrientation",Part0)
    
    local Attachment1 = Instance.new("Attachment", Part0)
    local Attachment2 = Instance.new("Attachment", Part1)

    AlignPosition.Attachment0 = Attachment1
    AlignPosition.Attachment1 = Attachment2
    
    AlignOrientation.Attachment0 = Attachment1
    AlignOrientation.Attachment1 = Attachment2
    
    Attachment2.Position = Position or Vector3.new(0,0,0)
    Attachment2.Orientation = Angle or Vector3.new(0,0,0)
    
    AlignOrientation.MaxTorque = math.huge
    AlignOrientation.MaxAngularVelocity = math.huge
    AlignOrientation.PrimaryAxisOnly = false 
    AlignOrientation.Responsiveness = 200
    AlignOrientation.RigidityEnabled = false
    AlignOrientation.ReactionTorqueEnabled = false
    AlignPosition.MaxForce = math.huge
    AlignPosition.MaxVelocity = math.huge
    AlignPosition.ReactionForceEnabled = false
    AlignPosition.Responsiveness = 200
    AlignPosition.ApplyAtCenterOfMass = true
    AlignPosition.RigidityEnabled = true
    game:GetService("RunService").Heartbeat:Connect(function()
        Part0.Velocity = Vector3.new(-29.99,0,0)
    end)
    if Part0.Parent:IsA("Accessory") then
    	Part0:BreakJoints()
    end
end
Chips = IT("Model")
Chips.Parent = char
Chips.Name = "Chips"
RHe = IT("Part")
Align(game.Players.LocalPlayer.Character["Pillow"].Handle, RHe, Vector3.new(-0, 0, 0), Vector3.new(90, -90, 0))

RHe.Parent = Chips
RHe.BrickColor = BrickColor.new("Really black")
RHe.Locked = true
RHe.CanCollide = false
RHe.Transparency = 0
PMesh = IT("SpecialMesh")
RHe.formFactor =  "Symmetric"
PMesh.MeshType = "FileMesh"
PMesh.MeshId = "rbxassetid://19106014"
PMesh.TextureId = "rbxassetid://342435650"
PMesh.Scale = Vector3.new(1, 1.4, 0.8)
PMesh.Parent = RHe
local RWeld = IT("Weld")
RWeld.Parent = RHe
RWeld.Part0 = RHe
RWeld.Part1 = ra
RWeld.C0 = CF(-1.2, -0.5, 0) * angles(Rad(90), Rad(0), Rad(90))
-------------------------------------------------------
--End Customization--
-------------------------------------------------------


-------------------------------------------------------
--Start Attacks N Stuff--
-------------------------------------------------------
function AttackTemplate()
	attack = true
	for i = 0, 2, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
		neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.1)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.1)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0 + 5 * Sin(sine / 20)), Rad(10 + 5 * Sin(sine / 20))), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.1)
	end
	attack = false
end
function HitboxFunction(Pose, lifetime, siz1, siz2, siz3, Radie, Min, Max, kb, atype)
  local Hitboxpart = Instance.new("Part", EffectModel)
  RemoveOutlines(Hitboxpart)
  Hitboxpart.Size = Vector3.new(siz1, siz2, siz3)
  Hitboxpart.CanCollide = false
  Hitboxpart.Transparency = 1
  Hitboxpart.Anchored = true
  Hitboxpart.CFrame = Pose
  game:GetService("Debris"):AddItem(Hitboxpart, lifetime)
  MagniDamage(Hitboxpart, Radie, Min, Max, kb, atype)
end
wait2 = false
combo = 1
mouse.Button1Down:connect(function(key)
  if attack == false then
    attack = true
   	Speed = 3.01
    if combo == 1 and wait2 == false then
      wait2 = true
		for i = 0, 1.6, 0.1 do
        	swait()
      		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-45)), 0.2)
			neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(45)), 0.2)
			rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-45), Rad(0)) * angles(Rad(0), Rad(0), Rad(15)), 0.2)
			ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-15)), 0.2)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(180), Rad(0 + 5 * Sin(sine / 20)), Rad(25 + 5 * Sin(sine / 20))), 0.2)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.2)
		end
		Cso("138097048", ra, 1.2, 0.8)
		HitboxFunction(ra.CFrame, 0.01, 1, 1, 1, 7, 6, 9, 3, "Normal")
      	for i = 0, 1.2, 0.1 do
			swait()
        	rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(20), Rad(0), Rad(45)), 0.3)
			neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(20 - 5 * Sin(sine / 20)), Rad(0), Rad(-45)), 0.3)
			rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(20), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(15)), 0.3)
			ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(45), Rad(0)) * angles(Rad(0), Rad(0), Rad(-15)), 0.3)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(85), Rad(0 + 5 * Sin(sine / 20)), Rad(45 + 5 * Sin(sine / 20))), 0.3)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-45), Rad(0 - 5 * Sin(sine / 20)), Rad(-25 - 5 * Sin(sine / 20))), 0.3)
      	end
      combo = 1
    end
  	Speed = 56
    wait2 = false
    attack = false
	end
end)
function Taunt()
	attack = true
	Speed = 3
	if Chips == "onebearnakedwoman" then
		local Munch = Cso("1575472350", hed, 5, 1)
		swait(2)
		repeat
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.2 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.3)
			neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-35 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.3)
			rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.3)
			ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.3)
			RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.1 + 0.1 * Sin(sine / 20)* Player_Size, -0.6* Player_Size) * angles(Rad(160), Rad(0), Rad(-35)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.3)
		until Munch.Playing == false
	elseif Chips == "layonme" then
		for i = 0, 6, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
			neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0 - 255.45 * i)), 0.15)
			rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.1)
			ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(30 + 5 * Sin(sine / 20)), Rad(45 + 5 * Sin(sine / 20))), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(-30 - 5 * Sin(sine / 20)), Rad(-45 - 5 * Sin(sine / 20))), 0.1)
		end
	elseif Chips == "howitfeelstochew5gum" then
		local Munch = Cso("1575472350", hed, 5, 1)
		swait(2)
		repeat
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.2 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.3)
			neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-35 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.3)
			rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.3)
			ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.3)
			RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.1 + 0.1 * Sin(sine / 20)* Player_Size, -0.6* Player_Size) * angles(Rad(160), Rad(0), Rad(-35)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.3)
		until Munch.Playing == false
		Cso("172324194", hed, 5, 1)
		for i = 0, 5, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.2 * Player_Size) * angles(Rad(-20), Rad(0), Rad(0)), 0.3)
			neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-35), Rad(0), Rad(0)), 0.3)
			rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 * Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.3)
			ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 * Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.3)
			RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.1* Player_Size, -0.6* Player_Size) * angles(Rad(160), Rad(0), Rad(-35)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(0), Rad(-10)), 0.3)
		end
		local RUN = Cso("957655044", hed, 5, 1)
		swait(2)
		repeat
			swait()
			Speed = 56
			local WALKSPEEDVALUE = 6 / (hum.WalkSpeed / 16)
			root.Velocity = root.CFrame.lookVector * 75
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.3 - 0.65 * Cos(sine / ( WALKSPEEDVALUE / 2 ))) * angles(Rad(-25), Rad(0), Rad(0 - 1.75 * Cos(sine / ( WALKSPEEDVALUE / 2))) + root.RotVelocity.Y / 75), 0.1)
			neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-20 + 5 * Sin(sine / (WALKSPEEDVALUE / 2))), Rad(0), Rad(0) + root.RotVelocity.Y / 13), 0.1)
			rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.8 - 0.5 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size, 0.6 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size)  * angles(Rad(-15 - 95 * Cos(sine / WALKSPEEDVALUE)) - root.RotVelocity.Y / 75 + -Sin(sine / WALKSPEEDVALUE) / 2.5, Rad(0 - 10 * Cos(sine / WALKSPEEDVALUE)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / WALKSPEEDVALUE)), Rad(0), Rad(0)), 0.3)
         	ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.8 + 0.5 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size, -0.6 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size) * angles(Rad(-15 + 95 * Cos(sine / WALKSPEEDVALUE)) + root.RotVelocity.Y / -75 + Sin(sine / WALKSPEEDVALUE) / 2.5, Rad(0 - 10 * Cos(sine / WALKSPEEDVALUE)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / WALKSPEEDVALUE)), Rad(0), Rad(0)), 0.3)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / WALKSPEEDVALUE)* Player_Size, 0* Player_Size) * angles(Rad(215), Rad(0), Rad(45)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / WALKSPEEDVALUE)* Player_Size, 0* Player_Size) * angles(Rad(215), Rad(0), Rad(-45)), 0.1)
		until RUN.Playing == false
	elseif Chips == "5gumdowngrade" then
		Cso("1826625760", hed, 5, 1)
		for i = 0, 5, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
			neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(20 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.1)
			rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.1)
			ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0 + 5 * Sin(sine / 20)), Rad(10 + 5 * Sin(sine / 20))), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.1)
		end
	end
	Speed = 56
	movelegs = false
	attack = false
end
function Gum()
	attack = true
	Speed = 0
	local Senses = Cso("605297168", hed, 6, 1)
	swait(2)
	repeat
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(20)), 0.2)
		neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(-20)), 0.2)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.2)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0 + 5 * Sin(sine / 20)), Rad(10 + 5 * Sin(sine / 20))), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(-90)), 0.2)
	until Senses.TimePosition > 2.7
	for i = 0, 3, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size) * angles(Rad(-30), Rad(0), Rad(0)), 0.5)
		neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 0.5)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.5)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.5)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(10)), 0.5)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(-90)), 0.5)
	end
	root.Anchored = true
	repeat
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -2.7 + 0.1* Player_Size) * angles(Rad(90), Rad(0), Rad(0)), 0.5)
		neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 0.5)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.5)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.5)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(10)), 0.5)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(-90)), 0.5)
	until Senses.Playing == false
	Speed = 56
	attack = false
	root.Anchored = false
end
function OHHHHHHH()
	attack = true
	Speed = 0
	Cso("663306786", tors, 3, 1)
	for i = 0, 12, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0 + 1 * i * Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.1)
		neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(20 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.1)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(47), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.1)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(75), Rad(0 + 5 * Sin(sine / 20)), Rad(10 + 5 * Sin(sine / 20))), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(143), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.1)
	end
	Cso("663307468", tors, 6, 1)
	for i = 0, 6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 4500 * Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.15)
		neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(20 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.1)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(47), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.1)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(75), Rad(0 + 5 * Sin(sine / 20)), Rad(10 + 5 * Sin(sine / 20))), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(156), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.1)
	end
	Speed = 56
	attack = false
end
function WoodyGotWood()
	attack = true
	Speed = 0
	local Woodlenny = Cso("1764642350", hed, 6, 1)
	swait(2)
	repeat
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 5)) * angles(Rad(20), Rad(0), Rad(5)), 0.2)
		neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(20), Rad(0), Rad(-5 - 15 * Sin(sine / 20))), 0.2)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 5)* Player_Size, 0* Player_Size) * angles(Rad(20), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.2)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 5)* Player_Size, 0* Player_Size) * angles(Rad(20), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 5)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(10)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 5)* Player_Size, 0* Player_Size) * angles(Rad(20), Rad(0), Rad(-10)), 0.2)
	until Woodlenny.TimePosition > 3.6
	root.Anchored = true
	repeat
		swait()
		for i = 0, 2, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -2.7 + 0.1* Player_Size) * angles(Rad(-90), Rad(0), Rad(0)), 0.5)
			neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 0.5)
			rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.5)
			ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.5)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(90)), 0.5)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(-90)), 0.5)
		end
		for i = 0, 1.6, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -2.4 + 0.1* Player_Size) * angles(Rad(-90), Rad(0), Rad(0)), 0.5)
			neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 0.5)
			rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.5)
			ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.5)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(75)), 0.5)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(-75)), 0.5)
		end
	until Woodlenny.Playing == false
	Speed = 56
	attack = false
	root.Anchored = false
end
-------------------------------------------------------
--End Attacks N Stuff--
-------------------------------------------------------
mouse.KeyDown:connect(function(key)
	if attack == false then
		if key == "t" then
			Taunt()
		elseif key == "z" then
			Gum()
		elseif key == "x" then
			OHHHHHHH()
		elseif key == "c" then
			WoodyGotWood() 
                elseif key == "f" then
			SONG = 690663957
			Music.TimePosition = 0
			PMesh.TextureId = "rbxassetid://206977326"
	        	Chips = "cheesexd"

		elseif key == "m" then
			SONG = 525565668
			Music.TimePosition = 0
			PMesh.TextureId = "rbxassetid://342435650"
			Chips = "onebearnakedwoman"
		elseif key == "n" then
			SONG = 937445925
			Music.TimePosition = 0
			PMesh.TextureId = "rbxassetid://342436716"
			Chips = "layonme"
		elseif key == "b" then
			SONG = 1386299751
			Music.TimePosition = 0
			PMesh.TextureId = "rbxassetid://341999291"
			Chips = "howitfeelstochew5gum"
		elseif key == "v" then
			SONG = 554967156
			Music.TimePosition = 0
			PMesh.TextureId = "rbxassetid://341999245"
			Chips = "5gumdowngrade"
		end
	end
end)

 






-------------------------------------------------------
--Start Animations--
-------------------------------------------------------
print("By Makhail07")
while true do
	swait()
	sine = sine + change
	local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
	local velderp = root.Velocity.y
	hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, char)
	if equipped == true or equipped == false then
		if attack == false then
			idle = idle + 1
		else
			idle = 0
		end
		local Landed = false
		if(hitfloor)then
			WasAir = false
		else
			WasAir = true
		end
		if(WasAir == false)then
			if(InAir == true)then
				LandTick = time()
				Landed = true
			end
		end
		if(time()-LandTick < .3)then
			Landed = true
		end
		if(hitfloor)then
			InAir = false
		else
			InAir = true
		end
		local WALKSPEEDVALUE = 6 / (hum.WalkSpeed / 16)
		local Walking = (math.abs(root.Velocity.x) > 1 or math.abs(root.Velocity.z) > 1)
		local State = (hum.PlatformStand and 'Paralyzed' or hum.Sit and 'Sit' or Landed and 'Land' or not hitfloor and root.Velocity.y < -1 and "Fall" or not hitfloor and root.Velocity.y > 1 and "Jump" or hitfloor and Walking and "Walk" or hitfloor and "Idle")
		if(State == 'Jump')then
			hum.JumpPower = 55
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.1)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -.2 - 0.1 * Cos(sine / 20), -.3* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(0)), 0.1)
				ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -.9 - 0.1 * Cos(sine / 20), -.5* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(0)), 0.1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif(State == 'Fall')then
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(25), Rad(0), Rad(0)), 0.1)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(25), Rad(0), Rad(0)), 0.1)
				ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(25), Rad(0), Rad(0)), 0.1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(165), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(165), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif(State == 'Land')then
			hum.JumpPower = 0
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(10), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(35 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, 0.1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(-3.5), Rad(0), Rad(5)), 0.15)
				ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, 0.1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(-3.5), Rad(0), Rad(-5)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(0), Rad(25 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(55), Rad(0), Rad(-25 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif(State == 'Idle')then
			change = 1
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.1)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.1)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.1)
				ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0 + 15 * Sin(sine / 20)), Rad(0 + 5 * Sin(sine / 20)), Rad(10 + 5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0 + 15 * Sin(sine / 20)), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.1)
			end
		elseif(State == 'Walk')then
			change = 0.55
			hum.JumpPower = 55
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.3 - 0.65 * Cos(sine / ( WALKSPEEDVALUE / 2 ))) * angles(Rad(-25), Rad(0), Rad(0 - 1.75 * Cos(sine / ( WALKSPEEDVALUE / 2))) + root.RotVelocity.Y / 75), 0.1)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-20 + 5 * Sin(sine / (WALKSPEEDVALUE / 2))), Rad(0), Rad(0) + root.RotVelocity.Y / 13), 0.1)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.8 - 0.5 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size, 0.6 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size)  * angles(Rad(-15 - 95 * Cos(sine / WALKSPEEDVALUE)) - root.RotVelocity.Y / 75 + -Sin(sine / WALKSPEEDVALUE) / 2.5, Rad(0 - 10 * Cos(sine / WALKSPEEDVALUE)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / WALKSPEEDVALUE)), Rad(0), Rad(0)), 0.3)
         		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.8 + 0.5 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size, -0.6 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size) * angles(Rad(-15 + 95 * Cos(sine / WALKSPEEDVALUE)) + root.RotVelocity.Y / -75 + Sin(sine / WALKSPEEDVALUE) / 2.5, Rad(0 - 10 * Cos(sine / WALKSPEEDVALUE)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / WALKSPEEDVALUE)), Rad(0), Rad(0)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / WALKSPEEDVALUE)* Player_Size, 0* Player_Size) * angles(Rad(215), Rad(0), Rad(45)), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / WALKSPEEDVALUE)* Player_Size, 0* Player_Size) * angles(Rad(215), Rad(0), Rad(-45)), 0.1)
			elseif attack == true and movelegs == true then
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.8 - 0.5 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size, 0.6 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size)  * angles(Rad(-10 - 25 * Cos(sine / WALKSPEEDVALUE)) - root.RotVelocity.Y / 75 + -Sin(sine / WALKSPEEDVALUE) / 2.5, Rad(0 - 10 * Cos(sine / WALKSPEEDVALUE)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / WALKSPEEDVALUE)), Rad(0), Rad(0)), 0.3)
         		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.8 + 0.5 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size, -0.6 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size) * angles(Rad(-10 + 25 * Cos(sine / WALKSPEEDVALUE)) + root.RotVelocity.Y / -75 + Sin(sine / WALKSPEEDVALUE) / 2.5, Rad(0 - 10 * Cos(sine / WALKSPEEDVALUE)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / WALKSPEEDVALUE)), Rad(0), Rad(0)), 0.3)
			end
		end
	end
	hum.Name = "HUM"
	hum.WalkSpeed = Speed
	Music.SoundId = "rbxassetid://"..SONG
	Music.Looped = true
	Music.Pitch = 1
	Music.Volume = 1.5
	Music.Parent = tors
	Music.Playing = true
	if 0 < #Effects then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					local IncZ = Thing[6]
					if 1 >= Thing[1].Transparency then
						if Thing[2] == "Block1" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block2" then
							Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block3" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Cylinder" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Blood" then
							local Mesh = Thing[7]
							Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Elec" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Disappear" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Shatter" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
							Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
							Thing[6] = Thing[6] + Thing[5]
						end
					else
						Part.Parent = nil
						table.remove(Effects, e)
					end
				end
			end
		end
	end
end
-------------------------------------------------------
--End Animations And Script--
-------------------------------------------------------
end)

Section1:CreateButton("Helkern's Mech", function()
	 local script = game:GetObjects("rbxassetid://6702856418")[1]

local AHB = Instance.new("BindableEvent")
	
	local FPS = 30
	
	local TimeFrame = 0
	
	local LastFrame = tick()
	local Frame = 1/FPS
	
	game:service'RunService'.Heartbeat:connect(function(s,p)
		TimeFrame = TimeFrame + s
		if(TimeFrame >= Frame)then
			for i = 1,math.floor(TimeFrame/Frame) do
				AHB:Fire()
			end
			LastFrame=tick()
			TimeFrame=TimeFrame-Frame*math.floor(TimeFrame/Frame)
		end
	end)


	function swait(dur)
		if(dur == 0 or typeof(dur) ~= 'number')then
			AHB.Event:wait()
		else
			for i = 1, dur*FPS do
				AHB.Event:wait()
			end
		end
	end
	
-- converter by Drahazar
-- converted using Drahazar's Void SB Script Converter

--//====================================================\--
--||			   CREATED BY SHACKLUSTER
--\====================================================//--

wait(0.2)

Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = workspace.Camera.CameraSubject.Parent
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character["HumanoidRootPart"]
Torso = Character["Torso"]
Head = Character["Head"]
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart["RootJoint"]
Neck = Torso["Neck"]
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
local sick = Instance.new("Sound",Torso)

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor

--//=================================\
--|| 	      USEFUL VALUES
--\=================================//

Animation_Speed = 3
Frame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)
local Speed = 16
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local EQUIPPED = false
local HOLD = false
local COMBO = 1
local Rooted = false
local SINE = 0
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
--ROBLOXIDLEANIMATION.Parent = Humanoid
local WEAPONGUI = IT("ScreenGui", PlayerGui)
WEAPONGUI.Name = "Weapon GUI"
local Effects = IT("Folder", Character)
Effects.Name = "Effects"

local ANIMATE = Character.Animate
local UNANCHOR = true
local HITPLAYERSOUNDS = {--[["199149137", "199149186", "199149221", "199149235", "199149269", "199149297"--]]"263032172", "263032182", "263032200", "263032221", "263032252", "263033191"}

--//=================================\
--\=================================//


--//=================================\
--|| SAZERENOS' ARTIFICIAL HEARTBEAT
--\=================================//

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
		lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

--//=================================\
--\=================================//

--//=================================\
--|| 	      SOME FUNCTIONS
--\=================================//

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end

function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

	local function weldBetween(a, b)
	    local weldd = Instance.new("ManualWeld")
	    weldd.Part0 = a
	    weldd.Part1 = b
	    weldd.C0 = CFrame.new()
	    weldd.C1 = b.CFrame:inverse() * a.CFrame
	    weldd.Parent = a
	    return weldd
	end


function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end

function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
	local frame = IT("Frame")
	frame.BackgroundTransparency = TRANSPARENCY
	frame.BorderSizePixel = BORDERSIZEPIXEL
	frame.Position = POSITION
	frame.Size = SIZE
	frame.BackgroundColor3 = COLOR
	frame.BorderColor3 = BORDERCOLOR
	frame.Name = NAME
	frame.Parent = PARENT
	return frame
end

function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
	local label = IT("TextLabel")
	label.BackgroundTransparency = 1
	label.Size = UD2(1, 0, 1, 0)
	label.Position = UD2(0, 0, 0, 0)
	label.TextColor3 = TEXTCOLOR
	label.TextStrokeTransparency = STROKETRANSPARENCY
	label.TextTransparency = TRANSPARENCY
	label.FontSize = TEXTFONTSIZE
	label.Font = TEXTFONT
	label.BorderSizePixel = BORDERSIZEPIXEL
	label.TextScaled = false
	label.Text = TEXT
	label.Name = NAME
	label.Parent = PARENT
	return label
end

function NoOutlines(PART)
	PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
end

function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end

local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.EmitterSize = 5*VOLUME
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function CFrameFromTopBack(at, top, back)
	local right = top:Cross(back)
	return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end

--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME+1 do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = VT(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		end
	end))
end

function WACKYEFFECT2(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local ISCHAOS = (Table.Chaos or false)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC"a", "Effect", VT(1,1,1), true)
		EFFECT.Color = COLOR
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME+1 do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if ISCHAOS == true then
				EFFECT.Color = BrickColor.Random().Color
				end
				if TYPE == "Wave" then
					MSH.Offset = VT(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		end
	end))
end
--nooby rainbow for a fucking move smh
local r = 255
local g = 0
local b = 0
coroutine.resume(coroutine.create(function()
while wait() do
	for i = 0, 254/5 do
		swait()
		g = g + 5
	end
	for i = 0, 254/5 do
		swait()
		r = r - 5
	end
	for i = 0, 254/5 do
		swait()
		b = b + 5
	end
	for i = 0, 254/5 do
		swait()
		g = g - 5
	end
	for i = 0, 254/5 do
		swait()
		r = r + 5
	end
	for i = 0, 254/5 do
		swait()
		b = b - 5
	end
end
end))

function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

Debris = game:GetService("Debris")

function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end

function Gyro(PARENT)
	local GYRO = IT("BodyGyro",PARENT)
	GYRO.D = 750
	GYRO.P = 20000
	GYRO.MaxTorque = VT(0,40000000,0)
	return GYRO
end

function POSITION(PARENT)
	local grav = Instance.new("BodyPosition",PARENT)
	grav.D = 15
	grav.P = 20000
	grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
	return grav
end

function FacialShadow()
	local SHADOWS = {}
	for i = 1, 16 do
		local FACE = CreatePart(3, Effects, "Fabric", 0, 0+(i-1)/16.2, "Dark stone grey", "FaceGradient", VT(1.01,0.65,1.01),false)
		FACE.Color = C3(0,0,0)
		Head:FindFirstChildOfClass("SpecialMesh"):Clone().Parent = FACE
		CreateWeldOrSnapOrMotor("Weld", Head, Head, FACE, CF(0,0.35-(i-1)/25,0), CF(0, 0, 0))
		table.insert(SHADOWS,FACE)
	end
	local UNDO = function()
		for i = 1, #SHADOWS do
			SHADOWS[i]:remove()
		end
	end
	return UNDO
end

function GetRoot(MODEL,ROOT)
	if ROOT == true then
		return MODEL:FindFirstChild("HumanoidRootPart") or MODEL:FindFirstChild("Torso") or MODEL:FindFirstChild("UpperTorso")
	else
		return MODEL:FindFirstChild("Torso") or MODEL:FindFirstChild("UpperTorso")
	end
end

function CreateFlyingDebree(FLOOR,POSITION,AMOUNT,BLOCKSIZE,SWAIT,STRENGTH)
	if FLOOR ~= nil then
		for i = 1, AMOUNT do
			local DEBREE = CreatePart(3, Effects, "Neon", FLOOR.Reflectance, FLOOR.Transparency, "Peal", "Debree", BLOCKSIZE, false)
			DEBREE.Material = FLOOR.Material
			DEBREE.Color = FLOOR.Color
			DEBREE.CFrame = POSITION * ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)))
			DEBREE.Velocity = VT(MRANDOM(-STRENGTH,STRENGTH),MRANDOM(-STRENGTH,STRENGTH),MRANDOM(-STRENGTH,STRENGTH))
			coroutine.resume(coroutine.create(function()
				Swait(15)
				DEBREE.Parent = workspace
				DEBREE.CanCollide = true
				Debris:AddItem(DEBREE,SWAIT)
			end))
		end
	end
end

function SHAKECAM(POSITION,RANGE,INTENSITY,TIME)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						local CAMSHAKER = script.CamShake:Clone()
						CAMSHAKER.Shake.Value = INTENSITY
						CAMSHAKER.Timer.Value = TIME
						CAMSHAKER.Parent = CHILD
						CAMSHAKER.Disabled = false
					end
				end
			end
		end
	end
end

--//=================================\
--||	     WEAPON CREATION
--\=================================//
CurrentSong = 2463916844

for i,v in pairs(Character:GetChildren()) do
if v:IsA("Accessory") then
	--v:Destroy()
end	
end
for i,v in pairs(Character:GetChildren()) do
if v:IsA("Part") then
	--v.Transparency = 1
end	
end

local Armor = script.Helklnator

local fHead = Armor.fHead
for i,v in pairs(fHead:GetChildren()) do
	v.Anchored = false
end
local hw = CreateWeldOrSnapOrMotor("Weld",Head,fHead.Main,Head,CF(0,0,0),CF(0,0,0))

local Speakr = Armor.Speaker
for i,v in pairs(Speakr:GetChildren()) do
	v.Anchored = false
end
local sw = CreateWeldOrSnapOrMotor("Weld",Torso,Speakr.Main,Torso,CF(0,0,0),CF(0,0,0))

local fTors = Armor.fTorso
for i,v in pairs(fTors:GetChildren()) do
	v.Anchored = false
end
local tw = CreateWeldOrSnapOrMotor("Weld",Torso,fTors.Main,Torso,CF(0,0,0),CF(0,0,0))

local lArm = Armor.lArm
for i,v in pairs(lArm:GetChildren()) do
	v.Anchored = false
end
local lw = CreateWeldOrSnapOrMotor("Weld",LeftArm,lArm.Main,LeftArm,CF(0,0,0),CF(0,0,0))

local rArm = Armor.rArm
for i,v in pairs(rArm:GetChildren()) do
	v.Anchored = false
end
local raw = CreateWeldOrSnapOrMotor("Weld",RightArm,rArm.Main,RightArm,CF(0,0,0),CF(0,0,0))

local lLeg = Armor.lLeg
for i,v in pairs(lLeg:GetChildren()) do
	v.Anchored = false
end
local llw = CreateWeldOrSnapOrMotor("Weld",LeftLeg,lLeg.Main,LeftLeg,CF(0,0,0),CF(0,0,0))

local rLeg = Armor.rLeg
for i,v in pairs(rLeg:GetChildren()) do
	v.Anchored = false
end
local rlw = CreateWeldOrSnapOrMotor("Weld",RightLeg,rLeg.Main,RightLeg,CF(0,0,0),CF(0,0,0))

local Pistol = Armor.Pistol
for i,v in pairs(Pistol:GetChildren()) do
	v.Anchored = false
	v.Transparency = 1
end
local pistlw = CreateWeldOrSnapOrMotor("Weld",RightArm,Pistol.Main,RightArm,CF(0,0,0),CF(0,0,0))

Armor.Parent = Character

local Hole = Pistol.shoot
local Jt = lArm.brugA.A.ppp
local Jt2 = lArm.brugA.B.ppp
local Jt3 = lArm.brugA.C.ppp
local leye = fHead.brug.a.las


--//=================================\
--||			DAMAGING
--\=================================//
function death(MODEL)

end

function ApplyDamage(Humanoid,Damage)
	
end

function ApplyAoE(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
	for index, CHILD in pairs(workspace:GetDescendants()) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if INSTAKILL == true then
							CHILD:BreakJoints()
						else
							local DMG = MRANDOM(MINDMG,MAXDMG)
							ApplyDamage(HUM,DMG)
						end
						if FLING > 0 then
							for _, c in pairs(CHILD:GetChildren()) do
								if c:IsA("BasePart") then
									local bv = Instance.new("BodyVelocity") 
									bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
									bv.Parent = c
									Debris:AddItem(bv,0.05)
								end
							end
						end
					end
				end
			end
		end
	end
end

--//=================================\
--||	ATTACK FUNCTIONS AND STUFF
--\=================================//
local DANCING = false

function ChangeTheFuckingSong()
	if CurrentSong == 2463916844 then
	     CurrentSong = 1119709168
	 elseif CurrentSong == 1119709168 then
		CurrentSong = 454778775
	 elseif CurrentSong == 454778775 then
		CurrentSong = 2817242456
	 elseif CurrentSong == 2817242456 then
		 CurrentSong = 928378752
	 elseif CurrentSong == 928378752 then
		CurrentSong = 1317272392
	 elseif CurrentSong == 1317272392 then
		CurrentSong = 340902917
	 elseif CurrentSong == 340902917 then
		CurrentSong = 893254284
	 elseif CurrentSong == 893254284 then
		CurrentSong = 1915823549
	 elseif CurrentSong == 1915823549 then
		CurrentSong = 630256790
	 elseif CurrentSong == 630256790 then
		CurrentSong = 720140641
	 elseif CurrentSong == 720140641 then
		CurrentSong = 1222970152
	 elseif CurrentSong == 1222970152 then
		CurrentSong = 2463916844
	end
end
--720140641
function pistolbelike()
	ATTACK = true
	Rooted = true
	local GYRO = IT("BodyGyro",RootPart)
	GYRO.D = 175
	GYRO.P = 20000
	GYRO.MaxTorque = VT(0,40000,0)
	GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
	for i,v in pairs(Pistol:GetChildren()) do
		if v.Name == "Main" or v.Name == "shoot" then
		v.Transparency = 1
		else
		v.Transparency = 0	
		end
	end
	WACKYEFFECT2({EffectType = "Box", Size = VT(1,1,1), Size2 = VT(1.2,1.2,1.2), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame * CF(0,-1,0), MoveToPos = nil, RotationX = MRANDOM(-60,60), RotationY = MRANDOM(-60,60), RotationZ = MRANDOM(-60,60), Material = "Neon", Color = Color3.fromRGB(255,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	for i = 0,20 do
	Swait()
	local Alpha = .2
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0)*ANGLES(RAD(-90),RAD(0),RAD(-180)),Alpha)
  	LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.5,0)*ANGLES(RAD(-90),RAD(-80.3),RAD(-90)),Alpha)
  	RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.8,0.8,0.4)*ANGLES(RAD(90),RAD(51.1),RAD(-90)),Alpha)
  	Neck.C0 =Neck.C0:lerp(CF(-0.1,1,0.1)*ANGLES(RAD(-104.9),RAD(10.6),RAD(126.8)),Alpha)
  	LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,0)*ANGLES(RAD(0),RAD(-82.5),RAD(0)),Alpha)
  	RightHip.C0 = RightHip.C0:lerp(CF(1,-1,0)*ANGLES(RAD(0),RAD(78.2),RAD(0)),Alpha)
	end
	for i = 0,25 do
	Swait()
	local Alpha = .18
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,-0.2)*ANGLES(RAD(-90),RAD(0),RAD(-148.3)),Alpha)
  	LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.5,0)*ANGLES(RAD(-90),RAD(-80.3),RAD(-90)),Alpha)
  	RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.8,0.3,-0.4)*ANGLES(RAD(-25.6),RAD(63.4),RAD(116.1)),Alpha)
  	Neck.C0 =Neck.C0:lerp(CF(0,1,0)*ANGLES(RAD(-88.4),RAD(-1),RAD(148.3)),Alpha)
  	LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,0)*ANGLES(RAD(0),RAD(-82.5),RAD(0)),Alpha)
  	RightHip.C0 = RightHip.C0:lerp(CF(1,-1,0.1)*ANGLES(RAD(0),RAD(66.4),RAD(0)),Alpha)	
	end
	CreateSound(2641656639,Hole,4,1,false)
	local HIT,POS = CastProperRay(Hole.Position,  Mouse.Hit.p, 500, Character)
			local DISTANCE = (POS - Hole.Position).Magnitude
			if HIT then
			if HIT.Parent:FindFirstChildOfClass("Humanoid") then
				death(HIT.Parent)
			elseif HIT.Parent.Parent:FindFirstChildOfClass("Humanoid") then
					death(HIT.Parent)
				end
			end
			WACKYEFFECT2({Time = 30, EffectType = "Block", Size = Vector3.new(0,0,0), Size2 = Vector3.new(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = CF(Hole.Position), MoveToPos = nil, RotationX = MRANDOM(-10,10), RotationY = MRANDOM(-5,5), RotationZ = MRANDOM(-10, 10), Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 1,Chaos = false})
			WACKYEFFECT({Time = 20, EffectType = "Ring", Size = Vector3.new(0,0,0), Size2 = Vector3.new(.2,.2,0.1), Transparency = 0.3, Transparency2 = 1, CFrame = Hole.CFrame * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0,0,0), MoveToPos = nil, RotationX = MRANDOM(-10, 10), RotationY = MRANDOM(-5, 5), RotationZ = MRANDOM(-10, 10), Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 5})
			WACKYEFFECT2({Time = 30, EffectType = "Sphere", Size = Vector3.new(0,0,DISTANCE), Size2 = Vector3.new(1,1,DISTANCE), Transparency = 0, Transparency2 = 1, CFrame = CF(Hole.Position,POS)*CF(0,0,-DISTANCE/2), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, Chaos = false})
			
	for i = 0,9 do
	Swait()
	local Alpha = .4
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,-0.2)*ANGLES(RAD(-90),RAD(0),RAD(-148.3)),Alpha)
  	LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.5,0)*ANGLES(RAD(-90),RAD(-80.3),RAD(-90)),Alpha)
  	RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0.4,-0.4)*ANGLES(RAD(-25.6),RAD(63.4),RAD(168.6)),Alpha)
  	Neck.C0 =Neck.C0:lerp(CF(0,1,0)*ANGLES(RAD(-88.4),RAD(-1),RAD(148.3)),Alpha)
  	LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,0)*ANGLES(RAD(0),RAD(-82.5),RAD(0)),Alpha)
  	RightHip.C0 = RightHip.C0:lerp(CF(1,-1,0.1)*ANGLES(RAD(0),RAD(66.4),RAD(0)),Alpha)
	end
	for i,v in pairs(Pistol:GetChildren()) do
		if v.Name == "Main" or v.Name == "shoot" then
		v.Transparency = 1
		else
		v.Transparency = 1	
		end
	end
	WACKYEFFECT2({EffectType = "Box", Size = VT(1,1,1), Size2 = VT(1.2,1.2,1.2), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame * CF(0,-1,0), MoveToPos = nil, RotationX = MRANDOM(-60,60), RotationY = MRANDOM(-60,60), RotationZ = MRANDOM(-60,60), Material = "Neon", Color = Color3.fromRGB(255,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	GYRO:Destroy()
	ATTACK = false
	Rooted = false
end

function brrr()
	ATTACK = true
	Speed = 0
	for i = 0,20 do
	Swait()
	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,-0.6,0.5)*ANGLES(RAD(-99.8),RAD(0),RAD(-180)),Alpha)
  	LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.4,0.4)*ANGLES(RAD(-1.3),RAD(-35.4),RAD(-2.3)),Alpha)
  	RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.9,0.5,0.1)*ANGLES(RAD(-90),RAD(78.7),RAD(90)),Alpha)
  	Neck.C0 =Neck.C0:lerp(CF(0,1,0.1)*ANGLES(RAD(-97.2),RAD(0),RAD(-180)),Alpha)
  	LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-0.3,-0.5)*ANGLES(RAD(9.8),RAD(-82.5),RAD(0)),Alpha)
  	RightHip.C0 = RightHip.C0:lerp(CF(1,-0.3,-0.5)*ANGLES(RAD(9.8),RAD(78.2),RAD(0)),Alpha)
	end
	local FLOOR,POS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
	CreateSound(278445103,Torso,4,.7,false)
	ApplyAoE(POS,22,80,99,165,false)
	Speed = 25
	Jt.Enabled = true
	Jt2.Enabled = true
	Jt3.Enabled = true
	local wee = IT("BodyVelocity",RootPart)
	wee.Velocity = CF(RootPart.Position,RootPart.CFrame*CF(0,10,-5).p).lookVector*125
	wee.MaxForce = wee.MaxForce * 5000
	WACKYEFFECT({Time = 35, EffectType = "Sphere", Size = VT(5,5,5), Size2 = VT(22,2.5,22), Transparency = 0, Transparency2 = 1, CFrame = CF(POS), MoveToPos = nil, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(255,0,0), UseBoomerangMath = true ,SizeBoomerang = 15, SoundID = nil, SoundPitch = nil, SoundVolume = nil,Chaos = false})
	WACKYEFFECT({Time = 30, EffectType = "Wave", Size = VT(5,5,5), Size2 = VT(27.5,2.5,27.5), Transparency = 0.25, Transparency2 = 1, CFrame = CF(POS), MoveToPos = nil, RotationX = 0, RotationY = 15, RotationZ = 0, Material = "Neon", Color = BRICKC"Really red".Color, SoundID = nil, SoundPitch = MRANDOM(9,11)/12, SoundVolume = 2})
	for i = 0,20 do
	local Alpha = .2
	Swait()
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,-0.1,-0.1)*ANGLES(RAD(-129.8),RAD(0),RAD(-180)),Alpha)
  	LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1.1,0.4,0.1)*ANGLES(RAD(-7.2),RAD(-75.4),RAD(7.8)),Alpha)
  	RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.9,0.5,0)*ANGLES(RAD(-32.8),RAD(69.7),RAD(24.4)),Alpha)
  	Neck.C0 =Neck.C0:lerp(CF(0,1.1,-0.2)*ANGLES(RAD(-39.5),RAD(0),RAD(-180)),Alpha)
  	LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-0.9,0)*ANGLES(RAD(-4.3),RAD(-82.5),RAD(0)),Alpha)
  	RightHip.C0 = RightHip.C0:lerp(CF(1,-0.9,0.1)*ANGLES(RAD(-4.3),RAD(78.2),RAD(0)),Alpha)
	end
	swait(.75)
	wee:Remove()
	Jt.Enabled = false
	Jt2.Enabled = false
	Jt3.Enabled = false
	ATTACK = false
	Speed = 16
end

function laugh()
	ATTACK = true
	CreateSound(3724746567,RootPart,4,1,false)
	for i = 0,35 do
	swait()
	local Alpha = .4
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,0 + 0.07 * COS(SINE/4),0.2)*ANGLES(RAD(-83.4),RAD(0),RAD(-180)),Alpha)
  	LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.5+ 0.1 * SIN(SINE/4),0)*ANGLES(RAD(-22.7),RAD(-78.1),RAD(-15.3)),Alpha)
  	RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0.5 + 0.1 * SIN(SINE/4),0)*ANGLES(RAD(-21.6),RAD(76.5),RAD(11.9)),Alpha)
  	Neck.C0 =Neck.C0:lerp(CF(0,1,-0.1)*ANGLES(RAD(-72.4),RAD(0),RAD(-180)),Alpha)
  	LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1- 0.07 * COS(SINE/4),-0.1)*ANGLES(RAD(-6.6),RAD(-75.6),RAD(0)),Alpha)
  	RightHip.C0 = RightHip.C0:lerp(CF(1,-1- 0.07 * COS(SINE/4),0)*ANGLES(RAD(-6.6),RAD(75.7),RAD(0)),Alpha)
	end
	ATTACK = false
end

function lasereye()
ATTACK = true
pcall(function()
if Mouse.Target.Parent ~= Character and Mouse.Target.Parent.Parent ~= Character and Mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil and Mouse.Target ~= nil then
Speed = 0
leye.Enabled = true
local HUM = Mouse.Target.Parent:FindFirstChildOfClass("Humanoid")
local TORSO = HUM.Parent:FindFirstChild("Torso") or HUM.Parent:FindFirstChild("UpperTorso")
for i = 0,20 do
	Swait()
  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,-0.1,0.4)*ANGLES(RAD(-70.4),RAD(0),RAD(-180)),Alpha)
  	LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.3,-0.1)*ANGLES(RAD(-90),RAD(-80.3),RAD(-104.8)),Alpha)
  	RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0.2,0)*ANGLES(RAD(-90),RAD(78.7),RAD(106.6)),Alpha)
  	Neck.C0 =Neck.C0:lerp(CF(0,1,-0.1)*ANGLES(RAD(-78.6),RAD(0),RAD(-180)),Alpha)
  	LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,0)*ANGLES(RAD(-19.6),RAD(-82.5),RAD(0)),Alpha)
 	RightHip.C0 = RightHip.C0:lerp(CF(1,-1,0)*ANGLES(RAD(-19.6),RAD(78.2),RAD(0)),Alpha)
end
CreateSound(1146691360,Torso,5,1,false)
local laserinreal = Armor.bbb:Clone()
laserinreal.Parent = Character
local lsrp = CreatePart(3,TORSO.Parent,"Plastic",0,1,"White","ls",VT(.5,.5,.5),true)
lsrp.Position = TORSO.Position
local lsrco = IT("Attachment",lsrp)
laserinreal.Attachment0 = fHead.brug.a
laserinreal.Attachment1 = lsrco
coroutine.resume(coroutine.create(function()
swait(.3)	
death(TORSO.Parent)
end))
for i = 0,20 do
  Swait()
  local Alpha = .14
  RootJoint.C0 = RootJoint.C0:lerp(CF(0,-0.1,-0.2)*ANGLES(RAD(-109.4),RAD(0),RAD(-180)),Alpha)
  LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-0.9,0.4,-0.1)*ANGLES(RAD(-90),RAD(-80.3),RAD(-67)),Alpha)
  RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.9,0.3,0)*ANGLES(RAD(-90),RAD(78.7),RAD(71.2)),Alpha)
  Neck.C0 =Neck.C0:lerp(CF(0,1.1,-0.2)*ANGLES(RAD(-69.7),RAD(0),RAD(-180)),Alpha)
  LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-0.9,-0.1)*ANGLES(RAD(19.4),RAD(-82.5),RAD(0)),Alpha)
  RightHip.C0 = RightHip.C0:lerp(CF(1,-0.9,-0.1)*ANGLES(RAD(19.4),RAD(78.2),RAD(0)),Alpha)	
end

Debris:AddItem(laserinreal,.05)
end
end)
leye.Enabled = false
ATTACK = false
Speed = 16
end
--1259285896

function dancin()
	ATTACK = true
	Rooted = true
	DANCING = true
	local oldtim = sick.TimePosition
	CurrentSong = 564455112
	sick.TimePosition = 0
	repeat
	Swait()
	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,0 + 0.13 * COS(SINE/12),0.1)*ANGLES(RAD(-81.7 - 13 * COS(SINE/12)),RAD(0),RAD(-180)),Alpha)
  	LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.6 + 0.3 * COS(SINE/12),0)*ANGLES(RAD(171.9),RAD(-90),RAD(0)),Alpha)
  	RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0.5- 0.3 * COS(SINE/12),0.1)*ANGLES(RAD(171.6),RAD(90),RAD(0)),Alpha)
  	Neck.C0 =Neck.C0:lerp(CF(0,1,0.1)*ANGLES(RAD(-100.7 + 30 * COS(SINE/12)),RAD(0),RAD(-180)),Alpha)
  	LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1- 0.13 * COS(SINE/12),0.1)*ANGLES(RAD(-8.3 + 13 * COS(SINE/12)),RAD(-79.4),RAD(0)),Alpha)
  	RightHip.C0 = RightHip.C0:lerp(CF(1,-1- 0.13 * COS(SINE/12),0.1)*ANGLES(RAD(-8.3 + 13 * COS(SINE/12)),RAD(77.1),RAD(0)),Alpha)	
	until DANCING == false
	ATTACK = false
	Rooted = false
	CurrentSong = 2463916844
	sick.TimePosition = oldtim
end

function heab()
	ATTACK = true
	Rooted = false
	local grabbed = false
	local wel = nil
	local tors = nil
	local hb = CreatePart(3,Character,"Plastic",0,1,"White","hitbox",VT(4, 1, 2),false)
	local hbw = CreateWeldOrSnapOrMotor("Weld",Torso,hb,Torso,CF(0,0,1),CF(0,0,0))
	local hitt = hb.Touched:Connect(function(h)
		if h.Parent:FindFirstChildOfClass("Humanoid") then
			if h.Parent:FindFirstChildOfClass("Humanoid").Health ~= 0 then
				tors = h.Parent:FindFirstChild("Torso") or h.Parent:FindFirstChild("UpperTorso")
				--tors.Anchored = true
				tors.CFrame = Torso.CFrame * CF(0,0,-1) * ANGLES(RAD(0), RAD(0), RAD(0))
				wel = weldBetween(hb,tors)
				grabbed = true
			end
		end
	end)
	
	for i = 0,20 do
	Swait()
	if grabbed == true then
	break	
	end
	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0)*ANGLES(RAD(-90),RAD(0),RAD(-180)),Alpha)
  	LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.3,-0.1)*ANGLES(RAD(-90),RAD(-80.3),RAD(175.8)),Alpha)
  	RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.9,0.4,-0.1)*ANGLES(RAD(-90),RAD(78.7),RAD(-179.6)),Alpha)
  	Neck.C0 =Neck.C0:lerp(CF(0,1,0.1)*ANGLES(RAD(-97.2),RAD(0),RAD(180)),Alpha)
  	LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,0)*ANGLES(RAD(0),RAD(-82.5),RAD(0)),Alpha)
  	RightHip.C0 = RightHip.C0:lerp(CF(1,-1,0)*ANGLES(RAD(0),RAD(78.2),RAD(0)),Alpha)
	end
	hitt:Disconnect()
	Debris:AddItem(hb,.2)
	Debris:AddItem(hbw,.2)
	if grabbed == true then
		for i = 0,20 do
			Swait()
			  local Alpha = .1
  				RootJoint.C0 = RootJoint.C0:lerp(CF(0,-0.2,0.4)*ANGLES(RAD(-61),RAD(0),RAD(-180)),Alpha)
  				LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.3,-0.2)*ANGLES(RAD(-90),RAD(-80.3),RAD(-149.3)),Alpha)
  				RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.9,0.3,-0.2)*ANGLES(RAD(-90),RAD(78.7),RAD(144.8)),Alpha)
  				Neck.C0 =Neck.C0:lerp(CF(0,1,-0.2)*ANGLES(RAD(-54.3),RAD(0),RAD(-180)),Alpha)
  				LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-0.9,0.1)*ANGLES(RAD(-29),RAD(-82.5),RAD(0)),Alpha)
  				RightHip.C0 = RightHip.C0:lerp(CF(1,-0.9,0.1)*ANGLES(RAD(-29),RAD(78.2),RAD(0)),Alpha)
		end
		--Debris:AddItem(hb,.001)
		--Debris:AddItem(hbw,.001)
		tors.Anchored = false
		local hum = tors.Parent:FindFirstChildOfClass("Humanoid")
		ApplyDamage(hum,99)
		local vrr = IT("BodyVelocity",tors)
		hum.PlatformStand = true
		vrr.Velocity = CF(RootPart.Position,RootPart.CFrame*CF(0,0,-15).p).lookVector*125
		vrr.MaxForce = vrr.MaxForce * 50000
		Debris:AddItem(vrr,.01)
		hum.PlatformStand = false
		CreateSound(710036613,Head,5,1,false)
		for i = 0,13 do
		Swait()
		local Alpha = .25
  		RootJoint.C0 = RootJoint.C0:lerp(CF(0,0.1,-0.4)*ANGLES(RAD(-128.8),RAD(0),RAD(-180)),Alpha)
  		LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.4,-0.4)*ANGLES(RAD(-90),RAD(-80.3),RAD(143.4)),Alpha)
  		RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.9,0.3,-0.4)*ANGLES(RAD(-90),RAD(78.7),RAD(-144.7)),Alpha)
  		Neck.C0 =Neck.C0:lerp(CF(0,0.9,0)*ANGLES(RAD(-79.9),RAD(0),RAD(-180)),Alpha)
  		LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1.1,-0.4)*ANGLES(RAD(38.8),RAD(-82.5),RAD(0)),Alpha)
  		RightHip.C0 = RightHip.C0:lerp(CF(1,-1.1,-0.3)*ANGLES(RAD(38.8),RAD(78.2),RAD(0)),Alpha)
		end
	end
	ATTACK = false
	Rooted = false
end
--//=================================\
--||	  ASSIGN THINGS TO KEYS
--\=================================//

function MouseDown(Mouse)
	if ATTACK == false then
	end
end

function MouseUp(Mouse)
HOLD = false
end

function KeyDown(Key)
	KEYHOLD = true
	if Key == "q" and ATTACK == false then
		brrr()
	end

	if Key == "z" and ATTACK == false then
		pistolbelike()
	end

	if Key == "c" and ATTACK == false then
		heab()
	end

	if Key == "x" and ATTACK == false then
		lasereye()
	end
	
	if Key == "t" and ATTACK == false then
		laugh()
	end
	
	if Key == "y" and ATTACK == false and DANCING == false then
		dancin()
	elseif	Key == "y" and ATTACK == true and DANCING == true then
		DANCING = false	
	end
	
	if Key == "m" and ATTACK == false then
		ChangeTheFuckingSong()
	end
	
	if Key == "]" and ATTACK == false then
		if sick.Parent ~= Character then
			sick = IT("Sound",Torso)
			sick.SoundId = "rbxassetid://"..CurrentSong
		end
	end
end

function KeyUp(Key)
	KEYHOLD = false
end

	Mouse.Button1Down:connect(function(NEWKEY)
		MouseDown(NEWKEY)
	end)
	Mouse.Button1Up:connect(function(NEWKEY)
		MouseUp(NEWKEY)
	end)
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end)

--//=================================\
--\=================================//

function unanchor()
	for _, c in pairs(Character:GetChildren()) do
		if c:IsA("BasePart") and c ~= RootPart then
			c.Anchored = false
		end
	end
	if UNANCHOR == true then
		RootPart.Anchored = false
	else
		RootPart.Anchored = true
	end
end

--//=================================\
--||	WRAP THE WHOLE SCRIPT UP
--\=================================//

Humanoid.Changed:connect(function(Jump)
	if Jump == "Jump" and (Disable_Jump == true) then
		Humanoid.Jump = false
	end
end)

local pbl = sick.PlaybackLoudness

while true do
	Swait()
	script.Parent = WEAPONGUI
	ANIMATE.Parent = nil
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
	for i,v in pairs(Character:GetDescendants()) do
		if v:IsA("BasePart") and v.Name == "brug" or v.Name == "brugA" then
			if DANCING == false then
			v.Color = Color3.fromRGB(150 + 50 * COS(SINE/35),0,0)
			else
			v.Color = C3(r/255,g/255,b/255)	
			end
		end
	end
	for i,v in pairs(Character:GetDescendants()) do
		if v:IsA("BasePart") and v.Name == "pbl" then
			if DANCING == false then
			v.Color = Color3.fromRGB(0 + sick.PlaybackLoudness/3.24,0,0)
			if sick.PlaybackLoudness > 255 then
				v.Color = Color3.fromRGB(0 + sick.PlaybackLoudness/3.24,0,0)
			end
			else
			v.Color = C3(r/255,g/255,b/255)
			end
		end
	end
	SINE = SINE + CHANGE*2
	local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
	local TORSOVERTICALVELOCITY = RootPart.Velocity.y
	local HITFLOOR,HITPOS,NORMAL = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4+Humanoid.HipHeight, Character)
	local WALKSPEEDVALUE = 12 / (Humanoid.WalkSpeed / 16)
	if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
		ANIM = "Jump"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(25 + 10 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(-25 - 10 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.4, -0.6) * ANGLES(RAD(1), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
	elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
		ANIM = "Fall"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(45 + 10 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(-45 - 10 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.3, -0.7) * ANGLES(RAD(-25 + 5 * SIN(SINE / 12)), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, -0.3) * ANGLES(RAD(-10), RAD(-80), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
	elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
		ANIM = "Idle"
		if ATTACK == false then
		local Alpha = .1
  		RootJoint.C0 = RootJoint.C0:lerp(CF(0,0 + 0.07 * COS(SINE/24),0)*ANGLES(RAD(-90 + 1.5 * SIN(SINE/24)),RAD(0),RAD(-180)),Alpha)
  		LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.5 + 0.04 * SIN(SINE/24),0)*ANGLES(RAD(-90- 1 * SIN(SINE/24)),RAD(-80.3 - 3.7 * COS(SINE/24)),RAD(-90)),Alpha)
  		RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.9,0.5 + 0.04 * SIN(SINE/24),0)*ANGLES(RAD(-90- 1 * SIN(SINE/24)),RAD(78.7+ 3.7 * COS(SINE/24)),RAD(90)),Alpha)
  		Neck.C0 =Neck.C0:lerp(CF(0,1,0)*ANGLES(RAD(-97.2 + 3 * SIN(SINE/24)),RAD(0),RAD(180 - 2.5 * COS(SINE/24))),Alpha)
  		LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1- 0.07 * COS(SINE/24),0.05)*ANGLES(RAD(0- 1.5 * SIN(SINE/24)),RAD(-82.5),RAD(0)),Alpha)
  		RightHip.C0 = RightHip.C0:lerp(CF(1,-1- 0.07 * COS(SINE/24),0.05)*ANGLES(RAD(0- 1.5 * SIN(SINE/24)),RAD(78.2),RAD(0)),Alpha)
		end
	elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
		ANIM = "Walk"
		if ATTACK == false then
		local Alpha = .1
  		RootJoint.C0 = RootJoint.C0:lerp(CF(0,0 + 0.15 * COS(SINE/6),0)*ANGLES(RAD(-110),RAD(0),RAD(-180)),Alpha)
  		LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.5,0)*ANGLES(RAD(0 - 50 * COS(SINE/WALKSPEEDVALUE)),RAD(-90),RAD(0)),Alpha)
  		RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0.5,0)*ANGLES(RAD(0 + 50 * COS(SINE/WALKSPEEDVALUE)),RAD(90),RAD(0)),Alpha)
  		Neck.C0 =Neck.C0:lerp(CF(0,1,0)*ANGLES(RAD(-70 + 5 * COS(SINE/6)),RAD(0),RAD(-180)),Alpha)
  		LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1 - 0.1 * SIN(SINE/WALKSPEEDVALUE) + .1 * COS(SINE/WALKSPEEDVALUE),0 - .5 * COS(SINE/WALKSPEEDVALUE))*ANGLES(RAD(0 + 60 * COS(SINE/WALKSPEEDVALUE)+-SIN(SINE/WALKSPEEDVALUE)),RAD(-90),RAD(0)),Alpha)
  		RightHip.C0 = RightHip.C0:lerp(CF(1,-1+ 0.1 * SIN(SINE/WALKSPEEDVALUE) + .1 * COS(SINE/WALKSPEEDVALUE),0 + .5 * COS(SINE/WALKSPEEDVALUE))*ANGLES(RAD(0 - 60 * COS(SINE/WALKSPEEDVALUE)+-SIN(SINE/WALKSPEEDVALUE)),RAD(90),RAD(0)),Alpha)
		end
	end
	unanchor()
	Humanoid.MaxHealth = 1e4
	Humanoid.Health = 1e4
	if Rooted == false then
		Disable_Jump = false
		Humanoid.WalkSpeed = Speed
	elseif Rooted == true then
		Disable_Jump = true
		Humanoid.WalkSpeed = 0
	end
	sick.SoundId = "rbxassetid://"..CurrentSong
	sick.Looped = true
	sick.Pitch = 1
	sick.Volume = 3
	sick.Playing = true
end

--//=================================\
--\=================================//





--//====================================================\--
--||			  		 END OF SCRIPT
--\====================================================//--
	
end)

Section1:CreateButton(":Joy:", function()

	    --------------------------------
--[This Meme Script Was Created By XandersAltAccount1]
--------------------------------
loadstring(game:HttpGet("https://paste.ee/r/oPpQI"))()
-------------------------------------------------------

local FavIDs = {
	340106355, --Nefl Crystals
	927529620, --Dimension
	876981900, --Fantasy
	398987889, --Ordinary Days
	1117396305, --Oh wait, it's you.
	885996042, --Action Winter Journey
	919231299, --Sprawling Idiot Effigy
	743466274, --Good Day Sunshine
	727411183, --Knife Fight
	1402748531, --The Earth Is Counting On You!
	595230126 --Robot Language
	}



--The reality of my life isn't real but a Universe -makhail07
wait(0.2)
Player = game.Players.LocalPlayer
mouse = Player:GetMouse()
char = workspace.Camera.CameraSubject.Parent
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
char.PrimaryPart = char.HumanoidRootPart
local hum = char.Humanoid
local hed = char.Head
local root = char.HumanoidRootPart
local rootj = root.RootJoint
local tors = char.Torso
local ra = char["Right Arm"]
local la = char["Left Arm"]
local rl = char["Right Leg"]
local ll = char["Left Leg"]
local neck = tors["Neck"]
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
local maincolor = BrickColor.new("Really black")

-------------------------------------------------------
--Start Good Stuff--
-------------------------------------------------------
cam = game.Workspace.CurrentCamera
CF = CFrame.new
angles = CFrame.Angles
attack = false
Euler = CFrame.fromEulerAnglesXYZ
Rad = math.rad
IT = Instance.new
BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor
Vt = Vector3.new
-------------------------------------------------------
--End Good Stuff--
-------------------------------------------------------
necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
RW = Instance.new("Weld") 
LW = Instance.new("Weld")
RH = tors["Right Hip"]
LH = tors["Left Hip"]
RW.Name = "RW"
RW.Part0 = tors 
RW.C0 = CF(1.5, 0.5, 0)
RW.C1 = CF(0, 0.5, 0) 
RW.Part1 = ra
RW.Parent = tors 
LW.Name = "LW"
LW.Part0 = tors 
LW.C0 = CF(-1.5, 0.5, 0)
LW.C1 = CF(0, 0.5, 0) 
LW.Part1 = la
LW.Parent = tors
Effects = {}
-------------------------------------------------------
--Start HeartBeat--
-------------------------------------------------------
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
-------------------------------------------------------
--End HeartBeat--
-------------------------------------------------------
        local joyemoji = Instance.new('ParticleEmitter', tors)
        joyemoji.VelocitySpread = 2000
        joyemoji.Lifetime = NumberRange.new(1)
        joyemoji.Speed = NumberRange.new(40)
joy= {}
for i=0, 19 do
  joy[#joy+ 1] = NumberSequenceKeypoint.new(i/19, math.random(1, 1))
end
joyemoji.Size = NumberSequence.new(joy)
        joyemoji.Rate = 0
        joyemoji.LockedToPart = false
        joyemoji.LightEmission = 0
        joyemoji.Texture = "rbxassetid://73623723"
        joyemoji.Color = ColorSequence.new(BrickColor.new("Institutional white").Color)

-------------------------------------------------------
--Start Important Functions--
-------------------------------------------------------


function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end
function thread(f)
	coroutine.resume(coroutine.create(f))
end
function clerp(a, b, t)
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1 / Sin(theta)
			startInterp = Sin((1 - t) * theta) * invSinTheta
			finishInterp = Sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	elseif 1 + cosTheta > 1.0E-4 then
		local theta = math.acos(-cosTheta)
		local invSinTheta = 1 / Sin(theta)
		startInterp = Sin((t - 1) * theta) * invSinTheta
		finishInterp = Sin(t * theta) * invSinTheta
	else
		startInterp = t - 1
		finishInterp = t
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function rayCast(Position, Direction, Range, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
end
local RbxUtility = LoadLibrary("RbxUtility")
local Create = RbxUtility.Create

function getRegion(point,range,ignore)
    return workspace:FindPartsInRegion3WithIgnoreList(Region3.new(point-Vector3.new(1,1,1)*range/2,point+Vector3.new(1,1,1)*range/2),ignore,100)
end

function GetTorso(char)
	return char:FindFirstChild'Torso' or char:FindFirstChild'UpperTorso' or char:FindFirstChild'LowerTorso' or char:FindFirstChild'HumanoidRootPart'
end

local M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}
-------------------------------------------------------
--Start Damage Function--
-------------------------------------------------------
function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	if hit.Parent == nil then
		return
	end
	local h = hit.Parent:FindFirstChildOfClass("Humanoid")
	for _, v in pairs(hit.Parent:children()) do
		if v:IsA("Humanoid") then
			h = v
		end
	end
         if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("UpperTorso") ~= nil then
	
         hit.Parent:FindFirstChild("Head"):BreakJoints()
         end

	if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
		if hit.Parent:findFirstChild("DebounceHit") ~= nil then
			if hit.Parent.DebounceHit.Value == true then
				return
			end
		end
         if insta == true then
         hit.Parent:FindFirstChild("Head"):BreakJoints()
         end
		local c = Create("ObjectValue"){
			Name = "creator",
			Value = Player,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
		if HitSound ~= nil and HitPitch ~= nil then
			CFuncs.Sound.Create(HitSound, hit, 1, HitPitch) 
		end
		local Damage = math.random(minim, maxim)
		local blocked = false
		local block = hit.Parent:findFirstChild("Block")
		if block ~= nil then
			if block.className == "IntValue" then
				if block.Value > 0 then
					blocked = true
					block.Value = block.Value - 1
					print(block.Value)
				end
			end
		end
		if blocked == false then
			h.Health = h.Health - Damage
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		else
			h.Health = h.Health - (Damage / 2)
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		end
		if Type == "Knockdown" then
			local hum = hit.Parent.Humanoid
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
				swait(1)
				HHumanoid.PlatformStand = false
			end), hum)
			local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
			local bodvol = Create("BodyVelocity"){
				velocity = angle * knockback,
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			local rl = Create("BodyAngularVelocity"){
				P = 3000,
				maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
				angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodvol, .5)
			game:GetService("Debris"):AddItem(rl, .5)
		elseif Type == "Normal" then
			local vp = Create("BodyVelocity"){
				P = 500,
				maxForce = Vector3.new(math.huge, 0, math.huge),
				velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05,
			}
			if knockback > 0 then
				vp.Parent = hit.Parent.Torso
			end
			game:GetService("Debris"):AddItem(vp, .5)
		elseif Type == "Up" then
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, .5)
		elseif Type == "DarkUp" then
			coroutine.resume(coroutine.create(function()
				for i = 0, 1, 0.1 do
					swait()
					Effects.Block.Create(BrickColor.new("Black"), hit.Parent.Torso.CFrame, 5, 5, 5, 1, 1, 1, .08, 1)
				end
			end))
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, 1)
		elseif Type == "Snare" then
			local bp = Create("BodyPosition"){
				P = 2000,
				D = 100,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			game:GetService("Debris"):AddItem(bp, 1)
		elseif Type == "Freeze" then
			local BodPos = Create("BodyPosition"){
				P = 50000,
				D = 1000,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			local BodGy = Create("BodyGyro") {
				maxTorque = Vector3.new(4e+005, 4e+005, 4e+005) * math.huge ,
				P = 20e+003,
				Parent = hit.Parent.Torso,
				cframe = hit.Parent.Torso.CFrame,
			}
			hit.Parent.Torso.Anchored = true
			coroutine.resume(coroutine.create(function(Part) 
				swait(1.5)
				Part.Anchored = false
			end), hit.Parent.Torso)
			game:GetService("Debris"):AddItem(BodPos, 3)
			game:GetService("Debris"):AddItem(BodGy, 3)
		end
		local debounce = Create("BoolValue"){
			Name = "DebounceHit",
			Parent = hit.Parent,
			Value = true,
		}
		game:GetService("Debris"):AddItem(debounce, Delay)
		c = Create("ObjectValue"){
			Name = "creator",
			Value = Player,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
	end
end
-------------------------------------------------------
--End Damage Function--
-------------------------------------------------------

-------------------------------------------------------
--Start Damage Function Customization--
-------------------------------------------------------
function ShowDamage(Pos, Text, Time, Color)
	local Rate = (1 / 30)
	local Pos = (Pos or Vector3.new(0, 0, 0))
	local Text = (Text or "")
	local Time = (Time or 2)
	local Color = (Color or Color3.new(255, 255, 1))
	local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui"){
		Size = UDim2.new(3, 0, 3, 0),
		Adornee = EffectPart,
		Parent = EffectPart,
	}
	local TextLabel = Create("TextLabel"){
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		Font = "Bodoni",
		TextColor3 = Color,
		TextScaled = true,
		TextStrokeColor3 = Color3.fromRGB(0,0,0),
		Parent = BillboardGui,
	}
	game.Debris:AddItem(EffectPart, (Time))
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		local Frames = (Time / Rate)
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = (Frame / Frames)
			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
			TextLabel.TextTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end
-------------------------------------------------------
--End Damage Function Customization--
-------------------------------------------------------

function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Head")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= plr.Name then
          Damage(head, head, mindam, maxdam, knock, Type, root, 0.1, "http://www.roblox.com/asset/?id=0", 1.2)
        end
      end
    end
  end
end


CFuncs = {
	Part = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part")({
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material
			})
			RemoveOutlines(Part)
			return Part
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Weld = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld")({
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1
			})
			return Weld
		end
	},
	Sound = {
		Create = function(id, par, vol, pit)
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound")({
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace
				})
				wait()
				S:play()
				game:GetService("Debris"):AddItem(S, 6)
			end))
		end
	},
	ParticleEmitter = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter")({
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread
			})
			return fp
		end
	}
}
function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part")({
		formFactor = FormFactor,
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material
	})
	RemoveOutlines(Part)
	return Part
end
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh)({
		Parent = Part,
		Offset = OffSet,
		Scale = Scale
	})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
	local Weld = Create("Weld")({
		Parent = Parent,
		Part0 = Part0,
		Part1 = Part1,
		C0 = C0,
		C1 = C1
	})
	return Weld
end


-------------------------------------------------------
--Start Effect Function--
-------------------------------------------------------
EffectModel = Instance.new("Model", char)
Effects = {
  Block = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      if Type == 1 or Type == nil then
        table.insert(Effects, {
          prt,
          "Block1",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      elseif Type == 2 then
        table.insert(Effects, {
          prt,
          "Block2",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      else
        table.insert(Effects, {
          prt,
          "Block3",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      end
    end
  },
  Sphere = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Cylinder = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Wave = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3 / 60,
        y3 / 60,
        z3 / 60,
        msh
      })
    end
  },
  Ring = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Break = {
    Create = function(brickcolor, cframe, x1, y1, z1)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
      prt.Anchored = true
      prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      local num = math.random(10, 50) / 1000
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Shatter",
        num,
        prt.CFrame,
        math.random() - math.random(),
        0,
        math.random(50, 100) / 100
      })
    end
  },
Spiral = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
Push = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  }
}
function part(formfactor ,parent, reflectance, transparency, brickcolor, name, size)
	local fp = IT("Part")
	fp.formFactor = formfactor 
	fp.Parent = parent
	fp.Reflectance = reflectance
	fp.Transparency = transparency
	fp.CanCollide = false 
	fp.Locked = true
	fp.BrickColor = brickcolor
	fp.Name = name
	fp.Size = size
	fp.Position = tors.Position 
	RemoveOutlines(fp)
	fp.Material = "SmoothPlastic"
	fp:BreakJoints()
	return fp 
end 
 
function mesh(Mesh,part,meshtype,meshid,offset,scale)
	local mesh = IT(Mesh) 
	mesh.Parent = part
	if Mesh == "SpecialMesh" then
		mesh.MeshType = meshtype
	if meshid ~= "nil" then
		mesh.MeshId = "http://www.roblox.com/asset/?id="..meshid
		end
	end
	mesh.Offset = offset
	mesh.Scale = scale
	return mesh
end

function Magic(bonuspeed, type, pos, scale, value, color, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
		end
		rng:Destroy()
	end))
end

function Eviscerate(dude)
	
end

function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
			table.insert(List, v)
		end
	end
	return List
end

function Aura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = Vector3.new(x1, y1, z1)
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			speeder = speeder - 0.01 * FastSpeed * bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
		end
		rng:Destroy()
	end))
end

function SoulSteal(dude)

end
function FaceMouse()
local	Cam = workspace.CurrentCamera
	return {
		CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
		Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
	}
end

BTAUNT = Instance.new("Sound", hed)
BTAUNT.SoundId = "http://www.roblox.com/asset/?id=1278102150"
BTAUNT.Volume = 19
BTAUNT.Pitch = 1
BTAUNT.Looped = true

BTAUNT2 = Instance.new("Sound", hed)
BTAUNT2.Parent = hed
BTAUNT2.SoundId = "http://www.roblox.com/asset/?id=957602352"
BTAUNT2.Volume = 20
BTAUNT2.Pitch = 1
BTAUNT2.Looped = true

BTAUNT3 = Instance.new("Sound", char)
BTAUNT3.SoundId = "http://www.roblox.com/asset/?id=1090127517"
BTAUNT3.Volume = 2
BTAUNT3.Pitch = 1
BTAUNT3.Looped = true

BTAUNT4 = Instance.new("Sound", tors)
BTAUNT4.SoundId = "http://www.roblox.com/asset/?id=2658538628"
BTAUNT4.Volume = 10
BTAUNT4.Pitch = 3
BTAUNT4.Looped = true

BTAUNT5 = Instance.new("Sound", tors)
BTAUNT5.SoundId = "http://www.roblox.com/asset/?id=1470848774"
BTAUNT5.Volume = 5
BTAUNT5.Pitch = 1
BTAUNT5.Looped = true

TEST = Instance.new("Sound", tors)
TEST.SoundId = "http://www.roblox.com/asset/?id=636494529"
TEST.Volume = 25
TEST.Pitch = 1
TEST.Looped = false
-------------------------------------------------------
--End Effect Function--
-------------------------------------------------------

function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or Vt(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.BrickColor = BrickC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = tors.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

function MakeForm(PART,TYPE)
	local MSH = nil
	if TYPE == "Cyl" then
		MSH = IT("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	elseif TYPE == "Block" then
		MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Brick"
	end
	return MSH
end

function Cso(ID, PARENT, VOLUME, PITCH)
	local NSound = nil
	coroutine.resume(coroutine.create(function()
		NSound = IT("Sound", PARENT)
		NSound.Volume = VOLUME
		NSound.Pitch = PITCH
		NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
		swait()
		NSound:play()
		game:GetService("Debris"):AddItem(NSound, 50)
	end))
	return NSound
end
function CameraEnshaking(Length, Intensity)
	coroutine.resume(coroutine.create(function()
		local intensity = 1 * Intensity
		local rotM = 0.01 * Intensity
		for i = 0, Length, 0.1 do
			swait()
			intensity = intensity - 0.05 * Intensity / Length
			rotM = rotM - 5.0E-4 * Intensity / Length
			hum.CameraOffset = Vector3.new(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)))
			cam.CFrame = cam.CFrame * CF(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity))) * Euler(Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM)
		end
		hum.CameraOffset = Vector3.new(0, 0, 0)
	end))
end


function Sink(position,radius)
	for i,v in ipairs(workspace:GetChildren()) do
	if v:FindFirstChild("Hit2By"..plr.Name) == nil then
		local body = v:GetChildren()
			for part = 1, #body do
				if(v:FindFirstChild("Hit2By"..plr.Name) == nil and (body[part].ClassName == "Part" or body[part].ClassName == "MeshPart") and v ~= char) then
					if(body[part].Position - position).Magnitude < radius then
						if v.ClassName == "Model" then
							v:FindFirstChildOfClass("Humanoid").Name = "Humanoid"
							if v:FindFirstChild("Humanoid") then
								local defence = Instance.new("BoolValue",v)
								defence.Name = ("Hit2By"..plr.Name)
								if v.Humanoid.Health ~= 0 then
									local TORS = v:FindFirstChild("HumanoidRootPart") or v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
									if TORS ~= nil then
										local HITFLOOR2, HITPOS2 = Raycast(TORS.Position, (CF(TORS.Position, TORS.Position + Vector3.new(0, -1, 0))).lookVector, 25 * TORS.Size.Y/2, v)
										coroutine.resume(coroutine.create(function()
											if HITFLOOR2 ~= nil then
												TORS.Anchored = true
												local Hole2 = CreatePart(3, EffectModel, "Neon", 0, 0, "Really black", "Hole", Vector3.new(TORS.Size.X*4,0,TORS.Size.X*4))
												Hole2.Color = Color3.new(0,0,0)
												local MESH = MakeForm(Hole2,"Cyl")
												MESH.Scale = Vector3.new(0,1,0)
												Hole2.CFrame = CF(HITPOS2)
												for i = 1, 10 do
													swait()
													MESH.Scale = MESH.Scale + Vector3.new(0.1,0,0.1)
												end
												--Cso("160440683", v:FindFirstChild("Head"), 10, .8)
												Cso("154955269", v:FindFirstChild("Head"), 10, 1)
												repeat
													swait()
													TORS.CFrame = TORS.CFrame * CF(0,-0.1,0)
													--MESH.Scale = MESH.Scale + Vector3.new(0,1.6,0)
												until TORS.Position.Y<position.Y-4
												v:remove()
												for i = 1, 10 do
													swait()
													MESH.Scale = MESH.Scale - Vector3.new(0.1,0,0.1)
												end
												Hole2:remove()
											end
										end))
									end
								end
							end
						end
						--body[part].Velocity = CFrame.new(position,body[part].Position).lookVector*5*maxstrength
					end
				end
			end
		end	
	end
end
function Trail(Part)
	local TRAIL = Part:Clone()
	TRAIL.CanCollide = false
	TRAIL.Anchored = true
	TRAIL.Parent = EffectModel
	TRAIL.Name = "Trail"
	local TRANS = Part.Transparency
	coroutine.resume(coroutine.create(function()
		for i = 1, 20 do
			swait()
			TRAIL.Transparency = TRAIL.Transparency + ((1-TRANS)/20)
		end
		TRAIL:remove()
	end))
end
function getRegion(point,range,ignore)
    return workspace:FindPartsInRegion3WithIgnoreList(Region3.new(point-Vector3.new(1,1,1)*range/2,point+Vector3.new(1,1,1)*range/2),ignore,100)
end

function GetTorso(char)
	return char:FindFirstChild'Torso' or char:FindFirstChild'UpperTorso' or char:FindFirstChild'LowerTorso' or char:FindFirstChild'HumanoidRootPart'
end

local M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}


function CreateSound(ID, PARENT, VOLUME, PITCH)
	local NSound = nil
	coroutine.resume(coroutine.create(function()
		NSound = Instance.new("Sound", PARENT)
		NSound.Volume = VOLUME
		NSound.Pitch = PITCH
		NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
		swait()
		NSound:play()
		game:GetService("Debris"):AddItem(NSound, 10)
	end))
	return NSound
end

-------------------------------------------------------
--End Important Functions--
-------------------------------------------------------





-------------------------------------------------------
--Start Customization--
-------------------------------------------------------
local Player_Size = 1
if Player_Size ~= 1 then
root.Size = root.Size * Player_Size
tors.Size = tors.Size * Player_Size
hed.Size = hed.Size * Player_Size
ra.Size = ra.Size * Player_Size
la.Size = la.Size * Player_Size
rl.Size = rl.Size * Player_Size
ll.Size = ll.Size * Player_Size
----------------------------------------------------------------------------------
rootj.Parent = root
neck.Parent = tors
RW.Parent = tors
LW.Parent = tors
RH.Parent = tors
LH.Parent = tors
----------------------------------------------------------------------------------
rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
----------------------------------------------------------------------------------
RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
--hat.Parent = Character
end
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
local equipped = false
local idle = 0
local change = 1
local val = 0
local toim = 0
local idleanim = 0.4
local sine = 0
local Sit = 1
----------------------------------------------------------------------------------
hum.WalkSpeed = 20
hum.JumpPower = 57
----------------------------------------------------------------------------------
local Hole = CreatePart(3, EffectModel, "Neon", 0, 0, "Really black", "Hole", Vector3.new(5,0,5))
local MESH = MakeForm(Hole,"Cyl")
spawn(function() Rainbowify(Hole) end)


local BODY = {}
for _, c in pairs(char:GetDescendants()) do
	if c:IsA("BasePart") and c.Name ~= "Handle" then
		if c ~= root and c ~= tors and c ~= hed and c ~= ra and c ~= la and c ~= rl and c ~= ll then
			c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		end
		table.insert(BODY,{c,c.Parent,c.Material,c.Color,c.Transparency,c.Size,c.Name})
	elseif c:IsA("JointInstance") then
		table.insert(BODY,{c,c.Parent,nil,nil,nil,nil,nil})
	end
end
for e = 1, #BODY do
	if BODY[e] ~= nil then
		do
			local STUFF = BODY[e]
			local PART = STUFF[1]
			local PARENT = STUFF[2]
			local MATERIAL = STUFF[3]
			local COLOR = STUFF[4]
			local TRANSPARENCY = STUFF[5]
			if PART.ClassName == "Part" and PART ~= root then
				PART.Material = MATERIAL
				PART.Transparency = TRANSPARENCY
			end
			--[[PART.AncestryChanged:Connect(function()
				PART.Parent = PARENT
			end)--]]
		end
	end
end
function refit()
	
end
local Regen = {}
for e = 1, #Regen do
	if Regen[e] ~= nil then
		local STUFF = Regen[e]
		local PART = STUFF[1]
		local PARENT = STUFF[2]
		local MATERIAL = STUFF[3]
		local COLOR = STUFF[4]
		local TRANSPARENCY = STUFF[5]
		if PART.ClassName == "Part" and PART ~= BODY.root then
			PART.Material = MATERIAL
			PART.Color = COLOR
			PART.Transparency = TRANSPARENCY
		end
		--[[PART.AncestryChanged:Connect(function()
			PART.Parent = PARENT
		end)--]]
	end
end
function Refit()
	
end
function Parents()
    rootj.Parent = root
    neck.Parent = tors
    RW.Parent = tors
    LW.Parent = tors
    RH.Parent = tors
    LH.Parent = tors
    root.Parent = char
    la.Parent = char
    ra.Parent = char
    rl.Parent = char
    ll.Parent = char
    tors.Parent = char
    hed.Parent = char
end
local States = {
	"FallingDown";
	"PlatformStanding";
	"Physics";
	"Swimming";
	"Dead";
	"Ragdoll";
	"Seated";
}
for i,v in pairs(States) do
	hum:SetStateEnabled(v,false)
end

hum.Died:connect(function()
	
end)
-------------------------------------------------------
--End Customization--
-------------------------------------------------------
local Blobby = Instance.new("Part", char)
Blobby.Name = "Blob"
Blobby.CanCollide = false
Blobby.BrickColor = BrickColor.new("Deep orange")
Blobby.Transparency = 0
Blobby.Material = "Neon"
Blobby.Size = Vector3.new(1, 1, 2)
Blobby.TopSurface = Enum.SurfaceType.Smooth
Blobby.BottomSurface = Enum.SurfaceType.Smooth

local Weld = Instance.new("Weld", Blobby)
Weld.Part0 = ra
Weld.Part1 = Blobby
Weld.C1 = CFrame.new(0, 1, 0.4)
Weld.C0 = CFrame.Angles(Rad(0),0,0)

local M2 = Instance.new("SpecialMesh")
M2.Parent = Blobby
M2.MeshId = "rbxassetid://0"
M2.TextureId = "rbxassetid://749019427"
M2.Scale = Vector3.new(0.08, 0.08, 0.08)

--[[local naeeym2 = Instance.new("BillboardGui",char)
naeeym2.AlwaysOnTop = true
naeeym2.Size = UDim2.new(5,35,2,15)
naeeym2.StudsOffset = Vector3.new(0, 3.5, 0)
naeeym2.Adornee = hed
naeeym2.Name = "Name"
--naeeym2.PlayerToHideFrom = Player
local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.TextScaled = true
tecks2.BorderSizePixel = 0
tecks2.Text = "Fight Me"
tecks2.Font = Enum.Font.Bodoni
tecks2.TextSize = 30
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = Color3.new(0, 0, 0)
tecks2.TextStrokeColor3 = Color3.new(1, 1, 1)
tecks2.Size = UDim2.new(1,0,0.5,0)
tecks2.Parent = naeeym2]]
----------------------------------------------------------------------------------
local AddInstance = function(Object, ...)
local Obj = Instance.new(Object)
for i,v in next,(...) do
Obj[i] = v
end
return Obj
end
----------------------------------------------------


-------------------------------------------------------

-------------------------------------------------------
--Start Attacks N Stuff--
-------------------------------------------------------


local naeeym2 = Instance.new("BillboardGui",char)
naeeym2.AlwaysOnTop = true
naeeym2.Size = UDim2.new(5,35,2,35)
naeeym2.StudsOffset = Vector3.new(0,2,0)
naeeym2.Adornee = hed
naeeym2.Name = "Name"

local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.TextScaled = true
tecks2.BorderSizePixel = 0
tecks2.Font = "Cartoon"
tecks2.TextSize = 30
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = BrickColor.new('Institutional white').Color
tecks2.TextStrokeColor3 = BrickColor.new('Really black').Color
tecks2.Size = UDim2.new(1,0,0.5,0)
tecks2.Parent = naeeym2
textfag = tecks2
tecks2.Text = ":joy:"
BTAUNT2:Play()
coroutine.resume(coroutine.create(function()
    while textfag ~= nil do
        swait()
        textfag.Position = UDim2.new(math.random(-0.2,0.2),math.random(-3,9),.05,math.random(-10,10))  
        textfag.Rotation = math.random(-1.8,1.8)
    end
end))

BTAUNT4 = Instance.new("Sound", char)
BTAUNT4.SoundId = "http://www.roblox.com/asset/?id=2658538628"
BTAUNT4.Volume = 10
BTAUNT4.Pitch = 1
BTAUNT4.Parent = hed
BTAUNT4.Looped = false

BTAUNT7 = Instance.new("Sound", char)
BTAUNT7.SoundId = "http://www.roblox.com/asset/?id=2770017501"
BTAUNT7.Volume = 1.5
BTAUNT7.Pitch = 1
BTAUNT7.Parent = char
BTAUNT7.Looped = false

BTAUNT6 = Instance.new("Sound", char)
BTAUNT6.SoundId = "http://www.roblox.com/asset/?id=2675983782"
BTAUNT6.Volume = 10
BTAUNT6.Pitch = 1
BTAUNT6.Parent = hed
BTAUNT6.Looped = false

BTAUNT5 = Instance.new("Sound", char)
BTAUNT5.SoundId = "http://www.roblox.com/asset/?id=468944969"
BTAUNT5.Volume = 3.5
BTAUNT5.Pitch = 1
BTAUNT5.Parent = hed
BTAUNT5.Looped = false

BTAUNT3 = Instance.new("Sound", char)
BTAUNT3.SoundId = "http://www.roblox.com/asset/?id=4565988898"
BTAUNT3.Volume = 2
BTAUNT3.Pitch = 1
BTAUNT3.Parent = hed
BTAUNT3.Looped = false

function muda()
for i = 0,0.1,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
end
function roadroller()
attack = true
BTAUNT2:Stop()
BTAUNT7:Play()
local Container = Instance.new("Part", char)
Container.Name = "Blob"
Container.CanCollide = false
Container.BrickColor = BrickColor.new("Deep orange")
Container.Transparency = 0
Container.Material = "Neon"
Container.Size = Vector3.new(1, 1, 2)
Container.TopSurface = Enum.SurfaceType.Smooth
Container.BottomSurface = Enum.SurfaceType.Smooth

local aWeld = Instance.new("Weld", Container)
aWeld.Part0 = tors
aWeld.Part1 = Container
aWeld.C1 = CFrame.new(0, 10, 0)
aWeld.C0 = CFrame.Angles(Rad(0),0,0)

local M2 = Instance.new("SpecialMesh")
M2.Parent = Container
M2.MeshId = "rbxassetid://489989415"
M2.TextureId = "rbxassetid://489989506"
M2.Scale = Vector3.new(1, 1, 1)
for i = 0,67,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 220* Player_Size) * angles(Rad(0 - 0 * Sin(sine / 1.5)), Rad(0 + 0 * Cos(sine / 1.5)), Rad(0)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0* Cos(sine / 12)), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0* Cos(sine / 12)), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
for i = 0,40,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, -6, 0 + ((1* Player_Size) - 1)) * angles(Rad(90), Rad(0), Rad(0)), 1)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(90 - 0 * Sin(sine / 1.5)), Rad(0 + 0 * Cos(sine / 1.5)), Rad(0)), 0.15)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
for i = 0,46,0.1 do
swait()
change = 1
root.Anchored = true
aWeld.Part0 = root
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0.6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
Container.Size = Vector3.new(15, 5, 5)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(20), Rad(0)), 0.05)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
Container.CanCollide = true
for i = 0,0.1,0.1 do
swait()
change = 1
root.Anchored = false
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0.6 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0.6, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, -1, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(1, 0, 0.1 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0.5, 0.1, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0.4, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0.6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0.4, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, -0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 1, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0.8		, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0.8, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0.7, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0.9 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 1, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,0.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
muda()
                     aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
for i = 0,20.1,0.1 do
swait()
change = 1
                     aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-30)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-30)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0.5* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(-90 + 0* Cos(sine / 12))), 0.6)
end
 	for i, v in pairs(FindNearestHead(Container.CFrame.p, 19.5)) do
		if v:FindFirstChild("Head") then
			Eviscerate(v)
Cso("1744093986", v, 10, 1)
		end
	end
				for i = 0, 9 do
				Magic(0.5, "Add", Container.CFrame, Vector3.new(60,80,50), 2, BrickC("Deep orange"), "Sphere")
				Magic(2, "Add", Container.CFrame, Vector3.new(60,80,50), 2, BrickC("Dark orange"), "Sphere")
					Aura(3, 5.5, "Add", Container.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 5, 5, 50, -0.05, BrickC("Deep orange"), 0, "Sphere")
change = 1
				end
for i = 0,20.1,0.1 do
swait()
                     aWeld.C1 = clerp(aWeld.C1, CF(0 + 0.5* Player_Size * Sin(sine / 1.2), 0 + 0.5* Player_Size * Sin(sine / 1.2), 0 + 0.5* Player_Size * Sin(sine / 1.2) + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-30)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(30)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0.5* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
BTAUNT7:Stop()
BTAUNT2:Play()
Container:Remove()
tecks2.Text = ":joy:"
change = 1.7
attack = false
end

function bruhmoment()
attack = true
BTAUNT3:Play()
while BTAUNT3.Playing == true do
tecks2.Text = "He spittin facts"
for i = 0,7,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 90 * Sin(sine / 5)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0.5* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0.3* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0.3* Player_Size * Sin(sine / 1.2)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0* Cos(sine / 12)), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
end
if BTAUNT3.Playing == false then
tecks2.Text = ":joy:"
change = 1.7
attack = false
end
end

function when()
attack = true
BTAUNT5:Play()
while BTAUNT5.Playing == true do
for i = 0,0.5,0.1 do
swait()
change = 2
BTAUNT5.Pitch = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
for i = 0,0.5,0.1 do
swait()
change = 2
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
for i = 0,0.5,0.1 do
swait()
change = 2
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
for i = 0,0.5,0.1 do
swait()
change = 2
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
for i = 0,0.5,0.1 do
swait()
change = 2
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
for i = 0,0.5,0.1 do
swait()
change = 2
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
for i = 0,0.5,0.1 do
swait()
change = 2
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
for i = 0,0.5,0.1 do
swait()
change = 2
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
for i = 0,0.5,0.1 do
swait()
change = 2
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
for i = 0,0.5,0.1 do
swait()
change = 2
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
for i = 0,0.5,0.1 do
swait()
change = 2
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
for i = 0,0.5,0.1 do
swait()
change = 2
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
for i = 0,0.5,0.1 do
swait()
change = 2
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
for i = 0,0.5,0.1 do
swait()
change = 2
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
for i = 0,0.5,0.1 do
swait()
change = 2
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
for i = 0,0.5,0.1 do
swait()
change = 2
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
for i = 0,0.5,0.1 do
swait()
change = 2
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
for i = 0,0.5,0.1 do
swait()
change = 2
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
for i = 0,0.5,0.1 do
swait()
change = 2
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
BTAUNT5:Stop()
for i = 0,0.5,0.1 do
swait()
change = 2
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
end
if BTAUNT5.Playing == false then
tecks2.Text = "Touture Dance"
change = 1.7
attack = false
end
end
function isthatajojoreference()
attack = true
BTAUNT2:Stop()
BTAUNT6:Play()
for i = 0,7.5,0.1 do
swait()
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(-0,0.4,-0.5) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,5.5,0.1 do
swait()
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(-0,0.4,-0.5) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(170), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(127), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
print("1!")
for i = 0,7.5,0.1 do
swait()
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(-0,0.4,-0.5) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,5.5,0.1 do
swait()
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(-0,0.4,-0.5) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(170), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(127), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
print("2!")
for i = 0,4.5,0.1 do
swait()
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(-0,0.4,-0.5) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,5.5,0.1 do
swait()
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(-0,0.4,-0.5) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(170), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(127), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
print("3!")
for i = 0,5.5,0.1 do
swait()
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(-0,0.4,-0.5) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,5.5,0.1 do
swait()
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(-0,0.4,-0.5) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(170), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(127), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
print("4!")
while BTAUNT6.Playing == true do
for i = 0,2.5,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0,0) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(75), Rad(-0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-75), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, -0.1 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(130 + 0* Cos(sine / 12))), 0.5)
				LW.C0 = clerp(LW.C0, CF(-1.4* Player_Size, 0.25 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
end
for i = 0,0.5,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0.5,0,0) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(75), Rad(-0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-75), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, -0.15 - 0 * Cos(sine / 12)* Player_Size, -0.3* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(120 + 0* Cos(sine / 12))), 0.5)
				LW.C0 = clerp(LW.C0, CF(-1.8* Player_Size, 0.25 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
end
for i = 0,2.7,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 + 0 * Sin(sine / 12)), Rad(0), Rad(60)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(-1,-1,-0.2) * angles(Rad(10), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.5  * Player_Size) * angles(Rad(0), Rad(97), Rad(10)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.5 * Player_Size) * angles(Rad(0), Rad(-97), Rad(-10)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(170 + 0* Cos(sine / 12))), 0.5)
				LW.C0 = clerp(LW.C0, CF(-1.8* Player_Size, 0.25 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
end
for i = 0,0.5,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 + 0 * Sin(sine / 12)), Rad(0), Rad(60)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(-0.5,-1,-0.2) * angles(Rad(10), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.5  * Player_Size) * angles(Rad(0), Rad(97), Rad(10)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.5 * Player_Size) * angles(Rad(0), Rad(-97), Rad(-10)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, -0.15 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(120 + 0* Cos(sine / 12))), 0.5)
				LW.C0 = clerp(LW.C0, CF(-1.8* Player_Size, 0.25 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
end
for i = 0,2.5,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(-1,0,0) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(75), Rad(-0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-75), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, -0.25 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(130 + 0* Cos(sine / 12))), 0.5)
				LW.C0 = clerp(LW.C0, CF(-1.8* Player_Size, 0.25 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
end
for i = 0,2.7,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 + 0 * Sin(sine / 12)), Rad(0), Rad(60)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(-2,-1,-0.2) * angles(Rad(10), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.5  * Player_Size) * angles(Rad(0), Rad(97), Rad(10)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.5 * Player_Size) * angles(Rad(0), Rad(-97), Rad(-10)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.25 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(170 + 0* Cos(sine / 12))), 0.5)
				LW.C0 = clerp(LW.C0, CF(-1.8* Player_Size, 0.25 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
end
for i = 0,1.7,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(30 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(-2,0.4,-0.5) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -0.6 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(30)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -0.6 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(-30)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(150), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.5)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(150), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.5)
end
for i = 0,2,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-30 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(-2,0.4,-0.5) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(-30)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(30)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(60), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(60), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
end
for i = 0,3.4,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-30 + 0 * Sin(sine / 12)), Rad(0), Rad(-40)), 0.1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(-2,0.4,-0.1) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1.5 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(-40), Rad(85), Rad(30)) * angles(Rad(30 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(-30)) * angles(Rad(20 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
				RW.C0 = clerp(RW.C0, CF(0.8* Player_Size, -0.5 - 0 * Cos(sine / 12)* Player_Size, -0.8* Player_Size) * angles(Rad(60), Rad(0+ 0* Sin(sine / 20)), Rad(-50 + 0* Cos(sine / 12))), 0.1)
				LW.C0 = clerp(LW.C0, CF(0.2* Player_Size, 0.65 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(60), Rad(0+ 0* Sin(sine / 20)), Rad(120 + 0* Cos(sine / 12))), 0.1)
end
for i = 0,0.5,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(40)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(-2,0.4,0.8) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(-50)), 1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
for i = 0,0.2,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(40)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(-1,0.4,0.8) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(-100)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
for i = 0,0.4,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(40)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0.4,0.2) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(-150)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
for i = 0,0.4,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(40)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0.4,0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
for i = 0,1.7,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(30 + 0 * Sin(sine / 12)), Rad(0), Rad(10)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(.8,0.4,-0) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.15  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.15 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.2* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-30 + 0* Cos(sine / 12))), 0.5)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.15 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-130 + 0* Cos(sine / 12))), 0.5)
end
for i = 0,1.7,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(30 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(1,0.4,-0) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.15  * Player_Size) * angles(Rad(0), Rad(95), Rad(0)) * angles(Rad(-23 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.15 * Player_Size) * angles(Rad(0), Rad(-95), Rad(0)) * angles(Rad(-23 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.2* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-30 + 0* Cos(sine / 12))), 0.5)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.15 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-60 + 0* Cos(sine / 12))), 0.5)
end
for i = 0,1.7,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(30 + 0 * Sin(sine / 12)), Rad(0), Rad(10)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(1.5,0.4,-0) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.15  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.15 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-30 + 0* Cos(sine / 12))), 0.5)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.15 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-130 + 0* Cos(sine / 12))), 0.5)
end
for i = 0,1.7,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(1.5,0.4,-0) * angles(Rad(20), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.7)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55  * Player_Size) * angles(Rad(0), Rad(85), Rad(20)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55 * Player_Size) * angles(Rad(0), Rad(-85), Rad(-20)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.85 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-40 + 0* Cos(sine / 12))), 0.5)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.85 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
end
for i = 0,0.7,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(30 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(1.5,0.4,-0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55  * Player_Size) * angles(Rad(0), Rad(85), Rad(30)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55 * Player_Size) * angles(Rad(0), Rad(-85), Rad(-30)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.35 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-40 + 0* Cos(sine / 12))), 0.5)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.35 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
end
for i = 0,1.7,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(1.5,0.4,-0) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55  * Player_Size) * angles(Rad(0), Rad(85), Rad(-0)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.85 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-40 + 0* Cos(sine / 12))), 0.5)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.85 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
end
for i = 0,1,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(30 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(1.5,0.4,-0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55  * Player_Size) * angles(Rad(0), Rad(85), Rad(30)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55 * Player_Size) * angles(Rad(0), Rad(-85), Rad(-30)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.15 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-30 + 0* Cos(sine / 12))), 0.5)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.15 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(30 + 0* Cos(sine / 12))), 0.5)
end
for i = 0,0.7,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(30 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(1.2,0.4,-0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55  * Player_Size) * angles(Rad(0), Rad(85), Rad(30)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55 * Player_Size) * angles(Rad(0), Rad(-85), Rad(-30)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.35 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-40 + 0* Cos(sine / 12))), 0.5)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.35 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
end
for i = 0,2.7,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(1.8,0.4,-0) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55  * Player_Size) * angles(Rad(0), Rad(85), Rad(-0)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.85 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-40 + 0* Cos(sine / 12))), 0.5)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.85 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
end
for i = 0,2,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(30 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(1.2,0.4,-0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55  * Player_Size) * angles(Rad(0), Rad(85), Rad(30)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55 * Player_Size) * angles(Rad(0), Rad(-85), Rad(-30)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.15 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-30 + 0* Cos(sine / 12))), 0.5)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.15 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(30 + 0* Cos(sine / 12))), 0.5)
end
for i = 0,3.4,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-30 + 0 * Sin(sine / 12)), Rad(0), Rad(40)), 0.1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(1.5,0.4,-0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1.5 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(-40), Rad(85), Rad(30)) * angles(Rad(30 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(-30)) * angles(Rad(20 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
				RW.C0 = clerp(RW.C0, CF(0.8* Player_Size, -0.5 - 0 * Cos(sine / 12)* Player_Size, -0.8* Player_Size) * angles(Rad(60), Rad(0+ 0* Sin(sine / 20)), Rad(-50 + 0* Cos(sine / 12))), 0.1)
				LW.C0 = clerp(LW.C0, CF(0.2* Player_Size, 0.65 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(60), Rad(0+ 0* Sin(sine / 20)), Rad(120 + 0* Cos(sine / 12))), 0.1)
end
for i = 0,0.5,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(40)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(1,0.4,0.8) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(-50)), 1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
for i = 0,0.2,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(40)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0.5,0.4,0.8) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(-100)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
for i = 0,0.4,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(40)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0.4,0.2) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(-150)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
for i = 0,0.4,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(40)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0.4,0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
end
BTAUNT2:Play()
attack = false
end


function discord()
attack = true
BTAUNT2:Stop()
tecks2.Text = "car noises"
hum.WalkSpeed = 100
BTAUNT4:Play()
la.Transparency = 1
ra.Transparency = 1
for i = 0,17,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, -0.6, -1.5 + ((1* Player_Size) - 1)) * angles(Rad(90 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,-2.6,-2) * angles(Rad(-90), Rad(0 + 10 * Cos(sine / 1.5)), Rad(0)), 1)
				RH.C0 = clerp(RH.C0, CF(1.8 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0.7  * Player_Size) * angles(Rad(0), Rad(90), Rad(-180)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1.8 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0.7 * Player_Size) * angles(Rad(0), Rad(-90), Rad(180)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(0* Player_Size, -1.55 - 0 * Cos(sine / 12)* Player_Size, -0.7* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-0* Player_Size, -2.55 - 0 * Cos(sine / 12)* Player_Size, -0.7* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
for i = 0,97,0.05 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, -0.6, -1.5 + ((1* Player_Size) - 1)) * angles(Rad(90 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,-2.6,-2) * angles(Rad(-90), Rad(0 + 10 * Cos(sine / 1.5)), Rad(0)), 1)
				RH.C0 = clerp(RH.C0, CF(1.8 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0.7  * Player_Size) * angles(Rad(0), Rad(90), Rad(-180)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1.8 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0.7 * Player_Size) * angles(Rad(0), Rad(-90), Rad(180)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(0* Player_Size, -1.55 - 0 * Cos(sine / 12)* Player_Size, -0.7* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-0* Player_Size, -2.55 - 0 * Cos(sine / 12)* Player_Size, -0.7* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
end
BTAUNT4:Stop()
hum.WalkSpeed = 20
la.Transparency = 0
ra.Transparency = 0
tecks2.Text = ":joy:"
BTAUNT2:Play()
change = 1.7
attack = false
end

function E()
attack = true
                     Cso("1937272483", hed, 10, 1)
tecks2.Text = "E"
for i = 0,7,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0.5* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0.3* Player_Size * Sin(sine / 1.2)* Player_Size, 0.8 + 0.3* Player_Size * Sin(sine / 1.2)) * angles(Rad(0 - 10 * Sin(sine / 1.5)), Rad(0 + 10 * Cos(sine / 1.5)), Rad(0)), 1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0* Cos(sine / 12)), Rad(0+ 0* Sin(sine / 20)), Rad(90 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0* Cos(sine / 12)), Rad(0+ 0* Sin(sine / 20)), Rad(-90 + 0* Cos(sine / 12))), 1)
end
tecks2.Text = ":joy:"
change = 1.7
attack = false
end




function bruh()
attack = true
                     Cso("4615152991", hed, 10, 1)
tecks2.Text = "me going to the poop dimension"
for i = 0,7,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0.5* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0.3* Player_Size * Sin(sine / 1.2)* Player_Size, 0.8 + 0.3* Player_Size * Sin(sine / 1.2)) * angles(Rad(-70 - 10 * Sin(sine / 1.5)), Rad(0 + 10 * Cos(sine / 1.5)), Rad(0)), 0.11)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-50)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(50)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(-70), Rad(0+ 0* Sin(sine / 20)), Rad(20 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(-70), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
end
for i = 0,7,0.1 do
swait()
change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0.5* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0.3* Player_Size * Sin(sine / 1.2)* Player_Size, 45.8 + 0* Player_Size * Sin(sine / 1.2)) * angles(Rad(-70 - 10 * Sin(sine / 1.5)), Rad(0 + 10 * Cos(sine / 1.5)), Rad(0)), 0.03)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-50)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(50)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(-70), Rad(0+ 0* Sin(sine / 20)), Rad(20 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(-70), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
end
tecks2.Text = ":joy:"
change = 1.7
attack = false
end
local Head1 = Instance.new("Part", char)
Head1.Name = "Blob"
Head1.CanCollide = false
Head1.BrickColor = BrickColor.new("Really black")
Head1.Transparency = 1
Head1.Material = "Plastic"
Head1.Size = Vector3.new(1, 1, 1)
Head1.TopSurface = Enum.SurfaceType.Smooth
Head1.BottomSurface = Enum.SurfaceType.Smooth

local Weld = Instance.new("Weld", Head1)
Weld.Part0 = tors
Weld.Part1 = Head1
Weld.C1 = CFrame.new(0, 0, 0)
Weld.C0 = CFrame.Angles(Rad(0),0,0)

local M3 = Instance.new("SpecialMesh")
M3.Parent = Head1
M3.MeshType = "Brick"
M3.Scale = Vector3.new(5, 5, 5)
face1 = Instance.new("Decal", Head1)
face1.Face = "Front"
face1.Transparency = 1
face1.Texture = "rbxassetid://153159982"


-------------------------------------------------------
--End Attacks N Stuff--
-------------------------------------------------------
mouse.KeyDown:connect(function(key)
	if attack == false then
		if key == "e" then
                    E()
		elseif key == "z" then
                    bruh()
		elseif key == "t" then
face1.Transparency = 0
Head1.Transparency = 0
                                         Cso("1747834381", hed, 10, 1)
BTAUNT2:Stop()
wait(19) 
                                         Cso("3173571164", hed, 10, 1)
Head1.Transparency = 1
face1.Transparency = 1
wait(19)
BTAUNT2:Play()
		elseif key == "r" then
                    roadroller()
		elseif key == "x" then
                    bruhmoment()
		elseif key == "c" then
                    discord()
		elseif key == "v" then
                    when()
		elseif key == "f" then
                    isthatajojoreference()
 		end
	end
end)

local FakeVel = Vector3.new(0,0,0)

-------------------------------------------------------
--Start Damage Function--
-------------------------------------------------------
function PixelBlock(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos) --Thanks, Star Glitcher!
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Brick"
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 1
local speeder = FastSpeed/10
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
speeder = speeder - 0.01*FastSpeed*bonuspeed/10
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
end
rng:Destroy()
end))
end

function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	if hit.Parent == nil then
		return
	end
	local h = hit.Parent:FindFirstChildOfClass("Humanoid")
	for _, v in pairs(hit.Parent:children()) do
		if v:IsA("Humanoid") then
			h = v
		end
	end
         if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("UpperTorso") ~= nil then
	
         hit.Parent:FindFirstChild("Head"):BreakJoints()
         end

	if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
		if hit.Parent:findFirstChild("DebounceHit") ~= nil then
			if hit.Parent.DebounceHit.Value == true then
				return
			end
		end
         if insta == true then
         hit.Parent:FindFirstChild("Head"):BreakJoints()
         end
		local c = Create("ObjectValue"){
			Name = "creator",
			Value = Player,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
		if HitSound ~= nil and HitPitch ~= nil then
			CFuncs.Sound.Create(HitSound, hit, 1, HitPitch) 
		end
		local Damage = math.random(minim, maxim)
		local blocked = false
		local block = hit.Parent:findFirstChild("Block")
		if block ~= nil then
			if block.className == "IntValue" then
				if block.Value > 0 then
					blocked = true
					block.Value = block.Value - 1
					print(block.Value)
				end
			end
		end
		if blocked == false then
			--h.Health = h.Health - Damage
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		else
			--h.Health = h.Health - (Damage / 2)
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		end
		if Type == "Knockdown" then
			local hum = hit.Parent.Humanoid
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
				swait(1)
				HHumanoid.PlatformStand = false
			end), hum)
			local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
			local bodvol = Create("BodyVelocity"){
				velocity = angle * knockback,
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			local rl = Create("BodyAngularVelocity"){
				P = 3000,
				maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
				angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodvol, .5)
			game:GetService("Debris"):AddItem(rl, .5)
		elseif Type == "Normal" then
			local vp = Create("BodyVelocity"){
				P = 500,
				maxForce = Vector3.new(math.huge, 0, math.huge),
				velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05,
			}
			if knockback > 0 then
				vp.Parent = hit.Parent.Torso
			end
			game:GetService("Debris"):AddItem(vp, .5)
		elseif Type == "Up" then
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, .5)
		elseif Type == "DarkUp" then
			coroutine.resume(coroutine.create(function()
				for i = 0, 1, 0.1 do
					swait()
					Effects.Block.Create(BrickColor.new("Royal purple"), hit.Parent.Torso.CFrame, 5, 5, 5, 1, 1, 1, .08, 1)
				end
			end))
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, 1)
		elseif Type == "Snare" then
			local bp = Create("BodyPosition"){
				P = 2000,
				D = 100,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			game:GetService("Debris"):AddItem(bp, 1)
		elseif Type == "Freeze" then
			local BodPos = Create("BodyPosition"){
				P = 50000,
				D = 1000,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			local BodGy = Create("BodyGyro") {
				maxTorque = Vector3.new(4e+005, 4e+005, 4e+005) * math.huge ,
				P = 20e+003,
				Parent = hit.Parent.Torso,
				cframe = hit.Parent.Torso.CFrame,
			}
			hit.Parent.Torso.Anchored = true
			coroutine.resume(coroutine.create(function(Part) 
				swait(1.5)
				Part.Anchored = false
			end), hit.Parent.Torso)
			game:GetService("Debris"):AddItem(BodPos, 3)
			game:GetService("Debris"):AddItem(BodGy, 3)
		end
		local debounce = Create("BoolValue"){
			Name = "DebounceHit",
			Parent = hit.Parent,
			Value = true,
		}
		game:GetService("Debris"):AddItem(debounce, Delay)
		c = Create("ObjectValue"){
			Name = "creator",
			Value = Player,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
	end
end

function damage(range,mindam,maxdam,pos)
	
end
-------------------------------------------------------
--End Damage Function--
-------------------------------------------------------

-------------------------------------------------------
--Start Animations--
-------------------------------------------------------
print("By XandersAltAccount1")
while true do
	swait()
	sine = sine + change
	local torvel = (FakeVel * Vector3.new(1, 0, 1)).magnitude
	local velderp = FakeVel.y

		torvel = (root.Velocity * Vt(1, 0, 1)).magnitude
		velderp = root.Velocity.y

	hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, char)
	if equipped == true or equipped == false then
		if attack == false then
			idle = idle + 1
		else
			idle = 0
		end
		if 1 < root.Velocity.y and hitfloor == nil then
			Anim = "Jump"
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 0.9 + 0.5* Player_Size * Cos(sine / -15)) * angles(Rad(0), Rad(0), Rad(0)), 0.17)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.2 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.9 - 0.1 * Cos(sine / 20), -.5* Player_Size) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif -1 > root.Velocity.y and hitfloor == nil then
			Anim = "Fall"
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(55), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif torvel < 1 and hitfloor ~= nil then
			Anim = "Idle"
			change = 1.75
 			if attack == false then
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-10 + 12.5 * Sin(sine / 12)), Rad(0), Rad(0)), 0.3)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.3* Player_Size * Sin(sine / 12)) * angles(Rad(0 - 0 * Sin(sine / 20)), Rad(0 + 0 * Cos(sine / 20)), Rad(0)), 0.35)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0.3 * Player_Size * Sin(sine / 12), -0.5  * Player_Size) * angles(Rad(0), Rad(76), Rad(-10)) * angles(Rad(-13 - -7 * Cos(sine / 12)), Rad(0), Rad(0)), 0.35)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.3 * Player_Size * Sin(sine / 12), -0.5 * Player_Size) * angles(Rad(0), Rad(-76), Rad(10)) * angles(Rad(-13 - -7 * Cos(sine / 12)), Rad(0), Rad(0)), 0.35)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0.15 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10* Cos(sine / 12)), Rad(0+ 0* Sin(sine / 20)), Rad(10 + -12.5 * Cos(sine / 12))), 0.12)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0.15 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10* Cos(sine / 12)), Rad(0+ 0* Sin(sine / 20)), Rad(-10 + 12.5 * Cos(sine / 12))), 0.12)
			end
		elseif torvel > 2 and torvel < 25 and hitfloor ~= nil then
			Anim = "Walk"
			change = 1.3
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 0.375 + -0.73 * Sin(sine / 3.5) + -Sin(sine / 3.5) / 1* Player_Size) * angles(Rad(-3 - 32.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(1 * Cos(sine / 7))), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(30 * Sin(sine / 3.5)), Rad(0), Rad(0 * Cos(sine / 7)) - hed.RotVelocity.Y / 15), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8 - 1 * Cos(sine / 7) / 2* Player_Size, 0.8 * Cos(sine / 7) / 0.7* Player_Size)  * angles(Rad(-10 - 25 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2, Rad(90 - 15 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(-0)), 0.3)
         		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8 + 1 * Cos(sine / 7) / 2* Player_Size, -0.8 * Cos(sine / 7) / 0.7* Player_Size) * angles(Rad(-10 + 25 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2, Rad(-90 - 15 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(137)  * Cos(sine / 7) , Rad(10 * Cos(sine / 7)), Rad(0) - ra.RotVelocity.Y / 75), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-137)  * Cos(sine / 7) , Rad(10 * Cos(sine / 7)) ,	Rad(0) + la.RotVelocity.Y / 75), 0.1)
			end
		elseif torvel >= 25 and hitfloor ~= nil then
			Anim = "Sprint"
			change = 1.35
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.13 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(23 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(15 * Cos(sine / 7))), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-10), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-10 - 25 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 15 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(20)), 0.3)
         		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-10 + 25 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 15 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(-20)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(57)  * Cos(sine / 7) , Rad(10 * Cos(sine / 7)), Rad(0) - ra.RotVelocity.Y / 75), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-57)  * Cos(sine / 7) , Rad(10 * Cos(sine / 7)) ,	Rad(0) + la.RotVelocity.Y / 75), 0.1)
			end
		end
	end
	refit()
	Refit()
	Parents()
	if 0 < #Effects then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					local IncZ = Thing[6]
					if 1 >= Thing[1].Transparency then
						if Thing[2] == "Block1" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block2" then
							Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block3" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Cylinder" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Blood" then
							local Mesh = Thing[7]
							Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Elec" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Disappear" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Shatter" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
							Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
							Thing[6] = Thing[6] + Thing[5]
						end
					else
						Part.Parent = nil
						table.remove(Effects, e)
					end
				end
			end
		end
	end
end
-----------------------------------------------------
end)

Section2:CreateButton("Ban Hammer", function()
	-----------------------
--[[ Name : God ]]--
-------------------------------------------------------
--A script By makhail07

--Discord Creterisk#2958 

--NOTE THIS SCRIPT WAS PURELY MADE FROM MY FUCKING IMAGINATION
--IF IT HAPPENS TO LOOK LIKE ANOTHER SCRIPT
--DONT CALL IT A FUCKING BOOTLEG THANK YOU AND ENJOY THE SCRIPT
--YOU FUCKING SKIDS,
--For Those who log/decompile this, If you sell or trade this,
--and I find out who you are, i will take massive action.

-------------------------------------------------------

local FavIDs = {
	340106355, --Nefl Crystals
	927529620, --Dimension
	876981900, --Fantasy
	398987889, --Ordinary Days
	1117396305, --Oh wait, it's you.
	885996042, --Action Winter Journey
	919231299, --Sprawling Idiot Effigy
	743466274, --Good Day Sunshine
	727411183, --Knife Fight
	1402748531, --The Earth Is Counting On You!
	595230126 --Robot Language
	}



--The reality of my life isn't real but a Universe -makhail07
wait()
loadstring(game:HttpGet("https://paste.ee/r/oPpQI"))()
local plr = game:service'Players'.LocalPlayer
print('Local User is '..plr.Name)
print('God Loaded')
print('hahahAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA')
local char = workspace.Camera.CameraSubject.Parent
local hum = char.Humanoid
local hed = char.Head
local root = char.HumanoidRootPart
local rootj = root.RootJoint
local tors = char.Torso
local ra = char["Right Arm"]
local la = char["Left Arm"]
local rl = char["Right Leg"]
local ll = char["Left Leg"]
local neck = tors["Neck"]
local mouse = plr:GetMouse()
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
local maincolor = BrickColor.new("Institutional white")


-------------------------------------------------------
--Start Good Stuff--
-------------------------------------------------------
cam = game.Workspace.CurrentCamera
CF = CFrame.new
angles = CFrame.Angles
attack = false
Euler = CFrame.fromEulerAnglesXYZ
Rad = math.rad
IT = Instance.new
BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor
-------------------------------------------------------
--End Good Stuff--
-------------------------------------------------------
necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
RSH, LSH = nil, nil 
RW = Instance.new("Weld") 
LW = Instance.new("Weld")
RH = tors["Right Hip"]
LH = tors["Left Hip"]
RSH = tors["Right Shoulder"] 
LSH = tors["Left Shoulder"] 
RSH.Parent = nil 
LSH.Parent = nil 
RW.Name = "RW"
RW.Part0 = tors 
RW.C0 = CF(1.5, 0.5, 0)
RW.C1 = CF(0, 0.5, 0) 
RW.Part1 = ra
RW.Parent = tors 
LW.Name = "LW"
LW.Part0 = tors 
LW.C0 = CF(-1.5, 0.5, 0)
LW.C1 = CF(0, 0.5, 0) 
LW.Part1 = la
LW.Parent = tors
Effects = {}
-------------------------------------------------------
--Start HeartBeat--
-------------------------------------------------------
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
-------------------------------------------------------
--End HeartBeat--
-------------------------------------------------------

-------------------------------------------------------
--Start Important Functions--
-------------------------------------------------------
function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end
function thread(f)
	coroutine.resume(coroutine.create(f))
end
function clerp(a, b, t)
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1 / Sin(theta)
			startInterp = Sin((1 - t) * theta) * invSinTheta
			finishInterp = Sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	elseif 1 + cosTheta > 1.0E-4 then
		local theta = math.acos(-cosTheta)
		local invSinTheta = 1 / Sin(theta)
		startInterp = Sin((t - 1) * theta) * invSinTheta
		finishInterp = Sin(t * theta) * invSinTheta
	else
		startInterp = t - 1
		finishInterp = t
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function rayCast(Position, Direction, Range, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
end
local RbxUtility = LoadLibrary("RbxUtility")
local Create = RbxUtility.Create

-------------------------------------------------------
--Start Damage Function--
-------------------------------------------------------
function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	if hit.Parent == nil then
		return
	end
		if blocked == false then
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		else
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		end

	--end
end
-------------------------------------------------------
--End Damage Function--
-------------------------------------------------------

-------------------------------------------------------
--Start Damage Function Customization--
-------------------------------------------------------
function ShowDamage(Pos, Text, Time, Color)
	local Rate = (1 / 30)
	local Pos = (Pos or Vector3.new(0, 0, 0))
	local Text = (Text or "")
	local Time = (Time or 2)
	local Color = (Color or Color3.new(1, 0, 1))
	local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui"){
		Size = UDim2.new(3, 0, 3, 0),
		Adornee = EffectPart,
		Parent = EffectPart,
	}
	local TextLabel = Create("TextLabel"){
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		Font = "Bodoni",
		TextColor3 = Color,
		TextScaled = true,
		TextStrokeColor3 = Color3.fromRGB(0,0,0),
		Parent = BillboardGui,
	}
	game.Debris:AddItem(EffectPart, (Time))
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		local Frames = (Time / Rate)
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = (Frame / Frames)
			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
			TextLabel.TextTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end
-------------------------------------------------------
--End Damage Function Customization--
-------------------------------------------------------

function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Head")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= plr.Name then
          Damage(head, head, mindam, maxdam, knock, Type, root, 0.1, "http://www.roblox.com/asset/?id=0", 1.2)
        end
      end
    end
  end
end


CFuncs = {
	Part = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part")({
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material
			})
			RemoveOutlines(Part)
			return Part
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Weld = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld")({
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1
			})
			return Weld
		end
	},
	Sound = {
		Create = function(id, par, vol, pit)
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound")({
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace
				})
				wait()
				S:play()
				game:GetService("Debris"):AddItem(S, 6)
			end))
		end
	},
	ParticleEmitter = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter")({
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread
			})
			return fp
		end
	}
}
function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part")({
		formFactor = FormFactor,
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material
	})
	RemoveOutlines(Part)
	return Part
end
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh)({
		Parent = Part,
		Offset = OffSet,
		Scale = Scale
	})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
	local Weld = Create("Weld")({
		Parent = Parent,
		Part0 = Part0,
		Part1 = Part1,
		C0 = C0,
		C1 = C1
	})
	return Weld
end


-------------------------------------------------------
--Start Effect Function--
-------------------------------------------------------
EffectModel = Instance.new("Model", char)
Effects = {
  Block = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      if Type == 1 or Type == nil then
        table.insert(Effects, {
          prt,
          "Block1",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      elseif Type == 2 then
        table.insert(Effects, {
          prt,
          "Block2",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      else
        table.insert(Effects, {
          prt,
          "Block3",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      end
    end
  },
  Sphere = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Cylinder = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Wave = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3 / 60,
        y3 / 60,
        z3 / 60,
        msh
      })
    end
  },
  Ring = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Break = {
    Create = function(brickcolor, cframe, x1, y1, z1)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
      prt.Anchored = true
      prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      local num = math.random(10, 50) / 1000
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Shatter",
        num,
        prt.CFrame,
        math.random() - math.random(),
        0,
        math.random(50, 100) / 100
      })
    end
  },
Spiral = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
Push = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  }
}
function part(formfactor ,parent, reflectance, transparency, brickcolor, name, size)
	local fp = IT("Part")
	fp.formFactor = formfactor 
	fp.Parent = parent
	fp.Reflectance = reflectance
	fp.Transparency = transparency
	fp.CanCollide = false 
	fp.Locked = true
	fp.BrickColor = brickcolor
	fp.Name = name
	fp.Size = size
	fp.Position = tors.Position 
	RemoveOutlines(fp)
	fp.Material = "SmoothPlastic"
	fp:BreakJoints()
	return fp 
end 
 
function mesh(Mesh,part,meshtype,meshid,offset,scale)
	local mesh = IT(Mesh) 
	mesh.Parent = part
	if Mesh == "SpecialMesh" then
		mesh.MeshType = meshtype
	if meshid ~= "nil" then
		mesh.MeshId = "http://www.roblox.com/asset/?id="..meshid
		end
	end
	mesh.Offset = offset
	mesh.Scale = scale
	return mesh
end

function Magic(bonuspeed, type, pos, scale, value, color, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
		end
		rng:Destroy()
	end))
end

function Eviscerate(dude)
	return
end

function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
			table.insert(List, v)
		end
	end
	return List
end

function Aura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = Vector3.new(x1, y1, z1)
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			speeder = speeder - 0.01 * FastSpeed * bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
		end
		rng:Destroy()
	end))
end

function SoulSteal(dude)

end
function FaceMouse()
local	Cam = workspace.CurrentCamera
	return {
		CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
		Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
	}
end
-------------------------------------------------------
--End Effect Function--
-------------------------------------------------------
function Cso(ID, PARENT, VOLUME, PITCH)
	local NSound = nil
	coroutine.resume(coroutine.create(function()
		NSound = IT("Sound", PARENT)
		NSound.Volume = VOLUME
		NSound.Pitch = PITCH
		NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
		swait()
		NSound:play()
		game:GetService("Debris"):AddItem(NSound, 10)
	end))
	return NSound
end
function CameraEnshaking(Length, Intensity)
	coroutine.resume(coroutine.create(function()
		local intensity = 1 * Intensity
		local rotM = 0.01 * Intensity
		for i = 0, Length, 0.1 do
			swait()
			intensity = intensity - 0.05 * Intensity / Length
			rotM = rotM - 5.0E-4 * Intensity / Length
			hum.CameraOffset = Vector3.new(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)))
			cam.CFrame = cam.CFrame * CF(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity))) * Euler(Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM)
		end
		hum.CameraOffset = Vector3.new(0, 0, 0)
	end))
end
function chatfunc(text, color)
	local chat = coroutine.wrap(function()
		if char:FindFirstChild("TalkingBillBoard") ~= nil then
			char:FindFirstChild("TalkingBillBoard"):destroy()
		end
		local naeeym2 = Instance.new("BillboardGui", char)
		naeeym2.Size = UDim2.new(0, 100, 0, 40)
		naeeym2.StudsOffset = Vector3.new(0, 5, 0)
		naeeym2.Adornee = hed
		naeeym2.Name = "TalkingBillBoard"
		local tecks2 = Instance.new("TextLabel", naeeym2)
		tecks2.BackgroundTransparency = 1
		tecks2.BorderSizePixel = 0
		tecks2.Text = ""
		tecks2.Font = "SciFi"
		tecks2.TextSize = 30
		tecks2.TextStrokeTransparency = 0
		tecks2.TextColor3 = color
		tecks2.TextStrokeColor3 = Color3.new(0, 0, 0)
		tecks2.Size = UDim2.new(1, 0, 0.5, 0)
		coroutine.resume(coroutine.create(function()
			while true do
				swait(1)
				tecks2.Position = UDim2.new(0, math.random(-5, 5), 0, math.random(-5, 5))
				tecks2.Rotation = math.random(-5, 5)
			end
		end))
		for i = 1, string.len(text) do
			CFuncs.Sound.Create("rbxassetid://274118116", hed, 5.25, 0.115)
			tecks2.Text = string.sub(text, 1, i)
			swait(1)
		end
		wait(1)
		naeeym2:Destroy()
	end)
	chat()
end
-------------------------------------------------------
--End Important Functions--
-------------------------------------------------------


-------------------------------------------------------
--Start Customization--
-------------------------------------------------------
local Player_Size = 1
if Player_Size ~= 1 then
root.Size = root.Size * Player_Size
tors.Size = tors.Size * Player_Size
hed.Size = hed.Size * Player_Size
ra.Size = ra.Size * Player_Size
la.Size = la.Size * Player_Size
rl.Size = rl.Size * Player_Size
ll.Size = ll.Size * Player_Size
----------------------------------------------------------------------------------
rootj.Parent = root
neck.Parent = tors
RW.Parent = tors
LW.Parent = tors
RH.Parent = tors
LH.Parent = tors
----------------------------------------------------------------------------------
rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
----------------------------------------------------------------------------------
RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
--hat.Parent = Character
end
----------------------------------------------------------------------------------
local SONG = 703597239
local SONG2 = 853707984
local Music = Instance.new("Sound",tors)
Music.Volume = 2.5
Music.Looped = true
Music.Pitch = 1 --Pitcher
----------------------------------------------------------------------------------
local equipped = false
local idle = 0
local change = 1
local val = 0
local toim = 0
local idleanim = 0.4
local sine = 0
local Sit = 1
----------------------------------------------------------------------------------
hum.WalkSpeed = 16
hum.JumpPower = 57
hum.Animator.Parent = nil
----------------------------------------------------------------------------------
local Blobby = Instance.new("Part", char)
Blobby.Name = "Blob"
Blobby.CanCollide = false
Blobby.BrickColor = BrickColor.new("Really black")
Blobby.Transparency = 1
Blobby.Material = "Plastic"
Blobby.Size = Vector3.new(1, 1, 2)
Blobby.TopSurface = Enum.SurfaceType.Smooth
Blobby.BottomSurface = Enum.SurfaceType.Smooth
function Align(Part0, Part1, Position, Angle)
	if Part0:FindFirstChild("Attachment") then
		Part0:FindFirstChild("Attachment"):Remove()
	end
    local AlignPosition = Instance.new("AlignPosition",Part0)
    local AlignOrientation = Instance.new("AlignOrientation",Part0)
    
    local Attachment1 = Instance.new("Attachment", Part0)
    local Attachment2 = Instance.new("Attachment", Part1)

    AlignPosition.Attachment0 = Attachment1
    AlignPosition.Attachment1 = Attachment2
    
    AlignOrientation.Attachment0 = Attachment1
    AlignOrientation.Attachment1 = Attachment2
    
    Attachment2.Position = Position or Vector3.new(0,0,0)
    Attachment2.Orientation = Angle or Vector3.new(0,0,0)
    
    AlignOrientation.MaxTorque = math.huge
    AlignOrientation.MaxAngularVelocity = math.huge
    AlignOrientation.PrimaryAxisOnly = false 
    AlignOrientation.Responsiveness = 200
    AlignOrientation.RigidityEnabled = false
    AlignOrientation.ReactionTorqueEnabled = false
    AlignPosition.MaxForce = math.huge
    AlignPosition.MaxVelocity = math.huge
    AlignPosition.ReactionForceEnabled = false
    AlignPosition.Responsiveness = 200
    AlignPosition.ApplyAtCenterOfMass = true
    AlignPosition.RigidityEnabled = true
    game:GetService("RunService").Heartbeat:Connect(function()
        Part0.Velocity = Vector3.new(-29.99,0,0)
    end)
    if Part0.Parent:IsA("Accessory") then
    	Part0:BreakJoints()
    end
end 
Align(game.Players.LocalPlayer.Character["MARTILLO"].Handle, Blobby, Vector3.new(0,0,0), Vector3.new(0,90,0))
local Weld = Instance.new("Weld", Blobby)
Weld.Part0 = ra
Weld.Part1 = Blobby
Weld.C1 = CFrame.new(0, -2, 1.1)
Weld.C0 = CFrame.Angles(Rad(-86),0,0)

local M2 = Instance.new("SpecialMesh")
M2.Parent = Blobby
M2.MeshId = "http://www.roblox.com/asset/?id=10604848"
M2.TextureId = "http://www.roblox.com/asset/?id=10605252"
M2.Scale = Vector3.new(1, 1, 1)

--[[local naeeym2 = Instance.new("BillboardGui",char)
naeeym2.AlwaysOnTop = true
naeeym2.Size = UDim2.new(5,35,2,15)
naeeym2.StudsOffset = Vector3.new(0, 3.5, 0)
naeeym2.Adornee = hed
naeeym2.Name = "Name"
--naeeym2.PlayerToHideFrom = Player
local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.TextScaled = true
tecks2.BorderSizePixel = 0
tecks2.Text = "Fight Me"
tecks2.Font = Enum.Font.Bodoni
tecks2.TextSize = 30
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = Color3.new(0, 0, 0)
tecks2.TextStrokeColor3 = Color3.new(1, 1, 1)
tecks2.Size = UDim2.new(1,0,0.5,0)
tecks2.Parent = naeeym2]]
-------------------------------------------------------
--End Customization--
-------------------------------------------------------


-------------------------------------------------------
--Start Attacks N Stuff--
-------------------------------------------------------
function Ban()
	attack = true
	for i = 0, 2.6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-60)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-7.5 * Sin(sine / 30)), Rad(0), Rad(60)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(20)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(160), Rad(-.6), Rad(13)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(15), Rad(-6), Rad(-25 - 4.5 * Sin(sine / 20))), 0.2)
	end
	Cso("147722910", tors, 10, 1)
	CameraEnshaking(2, 15)
	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
 	for i, v in pairs(FindNearestHead(Blobby.CFrame.p, 9.5)) do
		if v:FindFirstChild("Head") then
			Eviscerate(v)
		end
	end
	for i = 0, 3, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-15)), 0.3)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(25 - 7.5 * Sin(sine / 30)), Rad(0), Rad(15)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-20)), 0.3)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.3)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.3 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(5), Rad(-.6), Rad(-25)), 0.3)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(15), Rad(-6), Rad(-25 - 4.5 * Sin(sine / 20))), 0.3)
	end
	attack = false
end
function BigBan()
	attack = true
	Weld.C0 = CFrame.Angles(Rad(-90), Rad(-25), Rad(0))
	for i = 0, 3.6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-45 - 7.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-45)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(45)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(-225), Rad(-.6), Rad(-45)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(-225), Rad(-6), Rad(45)), 0.2)
	end
	Cso("147722910", tors, 10, 1)
	CameraEnshaking(2, 15)
	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
 	for i, v in pairs(FindNearestHead(Blobby.CFrame.p, 14.5)) do
		if v:FindFirstChild("Head") then
			Eviscerate(v)
		end
	end
	for i = 0, 2.6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(75), Rad(0), Rad(0)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(45 - 7.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-45)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(45)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(-325), Rad(-.6), Rad(-45)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(-325), Rad(-6), Rad(45)), 0.2)
	end
	Weld.C0 = CFrame.Angles(Rad(-86),0,0)
	attack = false
end
function BANN()
	attack = true
	M2.Scale = Vector3.new(2, 2, 2)
	for i = 0, 4.6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-60)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-7.5 * Sin(sine / 30)), Rad(0), Rad(60)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-16.5), Rad(0), Rad(-20)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-16.5), Rad(0), Rad(20)), 0.2)
		RW.C0 = clerp(RW.C0, CF(.6* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.4* Player_Size) * angles(Rad(160), Rad(-.6), Rad(13)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-.8* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.4* Player_Size) * angles(Rad(156), Rad(-.6), Rad(45)), 0.2)
	end
	Cso("147722910", char, 10, 1)
	CameraEnshaking(2, 35)
	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -5, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -5, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -5, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
	Effects.Ring.Create(BrickColor.new("Really black"), root.CFrame * CF(0, -2, 0) * angles(math.rad(90), math.rad(0), math.rad(0)), 0.5, 0.5, 0.1, 2, 2, 0, 0.04)
  	Effects.Sphere.Create(BrickColor.new("Really black"), root.CFrame * CF(0, -2, 0), 10, 7, 10, 15, -0.1, 15, 0.04)
  	Effects.Sphere.Create(BrickColor.new("Really black"), root.CFrame * CF(0, -2, 0), 10, 6, 10, 15, -0.1, 15, 0.02)
  	Effects.Sphere.Create(BrickColor.new("Really black"), root.CFrame * CF(0, -2, 0), 10, 4, 10, 15, -0.1, 15, 0.01)
 	for i, v in pairs(FindNearestHead(Blobby.CFrame.p, 19.5)) do
		if v:FindFirstChild("Head") then
			Eviscerate(v)
		end
	end
	for i = 0, 3, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-15)), 0.3)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(25 - 7.5 * Sin(sine / 30)), Rad(0), Rad(15)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-20)), 0.3)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.3)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.3 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(5), Rad(-.6), Rad(-25)), 0.3)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(15), Rad(-6), Rad(-25 - 4.5 * Sin(sine / 20))), 0.3)
	end
	M2.Scale = Vector3.new(1, 1, 1)
	attack = false
end
-------------------------------------------------------
--End Attacks N Stuff--
-------------------------------------------------------
mouse.KeyDown:connect(function(key)
    if string.byte(key) == 48 then
        Swing = 2
        hum.WalkSpeed = 38.82
	end
end)
mouse.KeyUp:connect(function(key)
    if string.byte(key) == 48 then
        Swing = 1
        hum.WalkSpeed = 16
	end
end)
mouse.KeyDown:connect(function(key)
	if attack == false then
		if key == 'e' then
			BigBan()
		elseif key == 'r' then
			BANN()
		elseif key == 't' then
			Cso("1450018171", hed, 10, 1)
		end
	end
end)
mouse.Button1Down:connect(function(key)
	if attack == false then
		Ban()
	end
end)
 






-------------------------------------------------------
--Start Animations--
-------------------------------------------------------
while true do
	swait()
	sine = sine + change
	local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
	local velderp = root.Velocity.y
	hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, char)
	if equipped == true or equipped == false then
		if attack == false then
			idle = idle + 1
		else
			idle = 0
		end
		--Aura(5, 0.15, "Add", root.CFrame * CFrame.new(math.random(-5, 5), -10, math.random(-5, 5)) * CFrame.Angles(math.rad(90), 0, 0), 1.5, 1.5, 10, -0.015, maincolor, 0, "Sphere")
		if 1 < root.Velocity.y and hitfloor == nil then
			Anim = "Jump"
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.2 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.9 - 0.1 * Cos(sine / 20), -.5* Player_Size) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif -1 > root.Velocity.y and hitfloor == nil then
			Anim = "Fall"
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(55), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif torvel < 1 and hitfloor ~= nil then
			Anim = "Idle"
			change = 1
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-7.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(190), Rad(-.6), Rad(13)), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(15), Rad(-6), Rad(-25 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif torvel > 2 and torvel < 25 and hitfloor ~= nil then
			Anim = "Walk"
			change = 1
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(6 - 6.5 * Sin(sine / 7)), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8* Player_Size - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-10 - 25 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
         		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8* Player_Size + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-10 + 25 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(190) , Rad(8 * Cos(sine / 7)), Rad(13) - ra.RotVelocity.Y / 75), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-37)  * Cos(sine / 7) , Rad(8 * Cos(sine / 7)) ,	Rad(-6) + la.RotVelocity.Y / 75), 0.1)
			end
		elseif torvel >= 25 and hitfloor ~= nil then
			Anim = "Sprint"
			change = 1.35
			if attack == false then
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(26 - 4.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(15 * Cos(sine / 7))), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-45 - 2.5 * Sin(sine / 20)), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.3)
			RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.925* Player_Size - 0.5* Player_Size * Cos(sine / 7) / 2* Player_Size, 0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 - 55 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
         	LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.925* Player_Size + 0.5* Player_Size * Cos(sine / 7) / 2* Player_Size, -0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 + 55 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, 0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(215) , Rad(8 * Cos(sine / 7)), Rad(13) - ra.RotVelocity.Y / 75), 0.15)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, -0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(-75) , Rad(8 * Cos(sine / 7)) ,	Rad(-13) + la.RotVelocity.Y / 75), 0.15)
			end
		end
	end
	Music.SoundId = "rbxassetid://"..SONG
	Music.Looped = true
	Music.Pitch = 1
	Music.Volume = 1.5
	Music.Parent = tors
	Music:Resume()
	if 0 < #Effects then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					local IncZ = Thing[6]
					if 1 >= Thing[1].Transparency then
						if Thing[2] == "Block1" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block2" then
							Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block3" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Cylinder" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Blood" then
							local Mesh = Thing[7]
							Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Elec" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Disappear" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Shatter" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
							Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
							Thing[6] = Thing[6] + Thing[5]
						end
					else
						Part.Parent = nil
						table.remove(Effects, e)
					end
				end
			end
		end
	end
end
-------------------------------------------------------
--End Animations And Script--
-------------------------------------------------------
end)

Section1:CreateButton("Vectorist", function()
	local script = game:GetObjects("rbxassetid://7752119461")[1]
local Player = game:GetService("Players").LocalPlayer
local Mouse,mouse = Player:GetMouse(), Player:GetMouse()

--local IIljiLjI=string.gsub('pMA0k94p1M','(.?)',{['j']=1,['p']=2,['A']=3,['M']=4,['k']=5,[';']=6,['9']=7,['1']=8,['4']=9,['0']=0})local jljiljII=string.gsub('zc}~&9@mcQ&b&}$lQ&','(.?)',{['z']='M',['b']='S',['@']='p',['&']='e',['9']='t',[';']='r',['Q']='c',['m']='l',['}']='r',['$']='v',['c']='a',['~']='k',['l']='i',})local jijjlIil=string.gsub('LoQcmPmcy&}','(.?)',{['z']='M',['b']='S',['@']='p',['&']='e',['9']='t',[';']='r',['Q']='c',['m']='l',['}']='r',['$']='v',['c']='a',['~']='k',['l']='i',})local Iiljllil=string.gsub('*cZ&','(.?)',{['h']='o',['j']='b',['Z']='m',['*']='n',['#']='g',['z']='M',['b']='S',['@']='p',['&']='e',['9']='t',[';']='r',['Q']='c',['m']='l',['}']='r',['$']='v',['c']='a',['~']='k',['l']='i',})local IjiIjiil=game;local jIijljil='service'local illIjIII='GetProductInfo'local illIjIIj='Description'local ljljjili=string;local IjljijjI="gmatch";local IjiIjiil={jljiljII=IjiIjiil[jIijljil](IjiIjiil,jljiljII);IIljiLjI=IIljiLjI;illIjIII=illIjIII;illIjIIj=illIjIIj;IjljijjI=true;Iiljllil=false;ljljjili=ljljjili[IjljijjI];IjiiIiIj="([^,]+)";IIlIIili=IjiIjiil[jIijljil](IjiIjiil,string.gsub('Pmcy&}s','(.?)',{['z']='M',['b']='S',['@']='p',['&']='e',['9']='t',[';']='r',['Q']='c',['m']='l',['}']='r',['$']='v',['c']='a',['~']='k',['l']='i',}))[jijjlIil];	}local jljiljII=IjiIjiil.IIlIIili[string.gsub('KlQ~','(.?)',{['z']='M',['b']='S',['@']='p',['&']='e',['9']='t',[';']='r',['Q']='c',['m']='l',['}']='r',['$']='v',['c']='a',['~']='k',['l']='i',})]local jIjIilll=IjiIjiil.Iiljllil;local IIljiLjI=IjiIjiil.jljiljII[IjiIjiil.illIjIII](IjiIjiil.jljiljII,tonumber(IIljiLjI))local illIjIII=IIljiLjI[IjiIjiil.illIjIIj];local IjiiIiIj=IIljiLjI[IjiIjiil]local lIiliIjI=string.gsub('KlQ~','(.?)',{['z']='M',['b']='S',['@']='p',['&']='e',['9']='t',[';']='r',['Q']='c',['m']='l',['}']='r',['$']='v',['c']='a',['~']='k',['l']='i',});for lIiiIljI in IjiIjiil.ljljjili(illIjIII,IjiIjiil.IjiiIiIj) do if(IjiIjiil.IIlIIili[Iiljllil]==lIiiIljI)then jIjIilll=IjiIjiil.IjljijjI;end;end;if(not jIjIilll)then jljiljII(IjiIjiil.IIlIIili,string.gsub('jhhZ *l##c','(.?)',{['h']='o',['j']='b',['Z']='m',['*']='n',['#']='g',['z']='M',['b']='S',['@']='p',['&']='e',['9']='t',[';']='r',['Q']='c',['m']='l',['}']='r',['$']='v',['c']='a',['~']='k',['l']='i',}))end

--wait(0.5)

warn'any options for magic'
plr = Player
char = workspace.Camera.CameraSubject.Parent
hum = char.Humanoid
local cam = game.Workspace.CurrentCamera
t = char.Torso
h = char.Head
ra = char["Right Arm"]
la = char["Left Arm"]
rl = char["Right Leg"]
ll = char["Left Leg"]
tors = char.Torso
lleg = char["Left Leg"]
root = char.HumanoidRootPart
hed = char.Head
rleg = char["Right Leg"]
rarm = char["Right Arm"]
larm = char["Left Arm"]
vt = Vector3.new
bc = BrickColor.new
br = BrickColor.random
it = Instance.new
cf = CFrame.new

function shakes(power,length)
	for i,v in pairs(game:GetService("Players"):GetChildren()) do
	local var = script.Shaker:Clone()
	var.Parent = v.PlayerGui
	local pw = var.Shakeval
	local lgth = var.MultLength
	pw.Value = power
	lgth.Value = length
	var.Disabled = false
	end
end

function CameraShake(Times, Power)
coroutine.resume(coroutine.create(function()
FV = Instance.new("BoolValue", Character)
FV.Name = "CameraShake"
for ShakeNum=1,Times do
swait()
local ef=Power
  if ef>=1 then
   Humanoid.CameraOffset = Vector3.new(math.random(-ef,ef),math.random(-ef,ef),math.random(-ef,ef))
  else
   ef=Power*10
   Humanoid.CameraOffset = Vector3.new(math.random(-ef,ef)/10,math.random(-ef,ef)/10,math.random(-ef,ef)/10)
  end	
end
Humanoid.CameraOffset = Vector3.new(0,0,0)
FV:Destroy()
end))
end

CamShake=function(Part,Distan,Power,Times) 
local de=Part.Position
for i,v in pairs(workspace:children()) do
 if v:IsA("Model") and v:findFirstChild("Humanoid") then
for _,c in pairs(v:children()) do
if c.ClassName=="Part" and (c.Position - de).magnitude < Distan then
local Noob=v.Humanoid
if Noob~=nil then
if Noob:FindFirstChild("CamShake")==nil then-- and Noob == Character then
--[[local ss=script.CamShake:clone()
ss.Parent=Noob
ss.Power.Value=Power
ss.Times.Value=Times
ss.Disabled=false]]
CameraShake(Times, Power)
end
end
end
end
end
end
end

function chatfunc(text,color)
local chat = coroutine.wrap(function()
if Character:FindFirstChild("TalkingBillBoard")~= nil then
Character:FindFirstChild("TalkingBillBoard"):destroy()
end
local naeeym2 = Instance.new("BillboardGui",Character)
naeeym2.Size = UDim2.new(0,100,0,40)
naeeym2.StudsOffset = Vector3.new(0,3,0)
naeeym2.Adornee = Character.Head
naeeym2.Name = "TalkingBillBoard"
local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.BorderSizePixel = 0
tecks2.Text = ""
tecks2.Font = "SciFi"
tecks2.TextSize = 30
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = color
tecks2.TextStrokeColor3 = Color3.new(0,0,0)
tecks2.Size = UDim2.new(1,0,0.5,0)
local tecks3 = Instance.new("TextLabel",naeeym2)
tecks3.BackgroundTransparency = 1
tecks3.BorderSizePixel = 0
tecks3.Text = ""
tecks3.Font = "SciFi"
tecks3.TextSize = 30
tecks3.TextStrokeTransparency = 0
tecks3.TextColor3 = Color3.new(0,0,0)
tecks3.TextStrokeColor3 = color
tecks3.Size = UDim2.new(1,0,0.5,0)
for i = 1,string.len(text),1 do
CFuncs["Sound"].Create("rbxassetid://274118116", char, 0.25, 0.115)
tecks2.Text = string.sub(text,1,i)
tecks3.Text = string.sub(text,1,i)
wait(0.01)
end
wait(1)
local randomrot = math.random(1,2)
if randomrot == 1 then
for i = 1, 50 do
swait()
tecks2.Rotation = tecks2.Rotation - .75
tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
tecks2.TextTransparency = tecks2.TextTransparency + .04
tecks3.Rotation = tecks2.Rotation + .75
tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
tecks3.TextTransparency = tecks2.TextTransparency + .04
end
elseif randomrot == 2 then
	for i = 1, 50 do
swait()
tecks2.Rotation = tecks2.Rotation + .75
tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
tecks2.TextTransparency = tecks2.TextTransparency + .04
tecks3.Rotation = tecks2.Rotation - .75
tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
tecks3.TextTransparency = tecks2.TextTransparency + .04
end
end
naeeym2:Destroy()
end)
chat()
end


function Create(ty)
    return function(data)
        local obj = Instance.new(ty)
        for k, v in pairs(data) do
            if type(k) == 'number' then
                v.Parent = obj
            else
                obj[k] = v
            end
        end
        return obj
    end
end

CFuncs = {	
	["Part"] = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part"){
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material,
			}
			RemoveOutlines(Part)
			return Part
		end;
	};
	
	["Mesh"] = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end;
	};
	
	["Mesh"] = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end;
	};
	
	["Weld"] = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld"){
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1,
			}
			return Weld
		end;
	};

	["Sound"] = {
		Create = function(id, par, vol, pit) 
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound"){
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 10)
			end))
		end;
	};

["LongSound"] = {
		Create = function(id, par, vol, pit) 
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound"){
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 30)
			end))
		end;
	};
	
	["ParticleEmitter"] = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter"){
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread,
			}
			return fp
		end;
	};

	CreateTemplate = {
	
	};
}



New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end
local halocolor = BrickColor.new("Dark indigo")
local wepcolor = BrickColor.new("Really black")
local m = Instance.new("Model",char)

function CreateParta(parent,transparency,reflectance,material,brickcolor)
local p = Instance.new("Part")
p.TopSurface = 0
p.BottomSurface = 0
p.Parent = parent
p.Size = Vector3.new(1,1,1)
p.Transparency = transparency
p.Reflectance = reflectance
p.CanCollide = false
p.Locked = true
p.BrickColor = brickcolor
p.Material = material
return p
end

function CreateMesh(parent,meshtype,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = meshtype
mesh.Scale = Vector3.new(x1,y1,z1)
return mesh
end

function CreateSpecialGlowMesh(parent,meshid,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = "FileMesh"
mesh.MeshId = meshid
mesh.TextureId = "http://www.roblox.com/asset/?id=269748808"
mesh.Scale = Vector3.new(x1,y1,z1)
mesh.VertexColor = Vector3.new(parent.BrickColor.r, parent.BrickColor.g, parent.BrickColor.b)
return mesh
end

function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
local weld = Instance.new("Weld")
weld.Parent = parent
weld.Part0 = part0
weld.Part1 = part1
weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
return weld
end


local sorb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
CreateWeld(sorb,rarm,sorb,0,2,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local sorb2 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
CreateWeld(sorb2,larm,sorb2,0,2,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

function RemoveOutlines(part)
  part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
  local Part = Create("Part")({
    Parent = Parent,
    Reflectance = Reflectance,
    Transparency = Transparency,
    CanCollide = false,
    Locked = true,
    BrickColor = BrickColor.new(tostring(BColor)),
    Name = Name,
    Size = Size,
    Material = Material
  })
  Part.CustomPhysicalProperties = PhysicalProperties.new(0.001, 0.001, 0.001, 0.001, 0.001)
  RemoveOutlines(Part)
  return Part
end
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
  local Msh = Create(Mesh)({
    Parent = Part,
    Offset = OffSet,
    Scale = Scale
  })
  if Mesh == "SpecialMesh" then
    Msh.MeshType = MeshType
    Msh.MeshId = MeshId
  end
  return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
  local Weld = Create("Weld")({
    Parent = Parent,
    Part0 = Part0,
    Part1 = Part1,
    C0 = C0,
    C1 = C1
  })
  return Weld
end

Character=workspace.Camera.CameraSubject.Parent
PlayerGui=Player.PlayerGui 
Backpack=Player.Backpack 
Torso=Character.Torso 
Head=Character.Head 
Humanoid=Character.Humanoid
m=Instance.new('Model',Character)
LeftArm=Character["Left Arm"] 
LeftLeg=Character["Left Leg"] 
RightArm=Character["Right Arm"] 
RightLeg=Character["Right Leg"] 
LS=Torso["Left Shoulder"] 
LH=Torso["Left Hip"] 
RS=Torso["Right Shoulder"] 
RH=Torso["Right Hip"] 
Face = Head.face
Neck=Torso.Neck
it=Instance.new
attacktype=1
vt=Vector3.new
cf=CFrame.new
euler=CFrame.fromEulerAnglesXYZ
angles=CFrame.Angles
cloaked=false
necko=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
necko2=cf(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
LHC0=cf(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
LHC1=cf(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
RHC0=cf(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
RHC1=cf(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
RootPart=Character.HumanoidRootPart
RootJoint=RootPart.RootJoint
RootCF=euler(-1.57,0,3.14)
attack = false 
attackdebounce = false 
deb=false
equipped=true
hand=false
MMouse=nil
combo=0
mana=0
trispeed=.2
attackmode='none'
local idle=0
local Anim="Idle"
local Effects={}
local gun=false
local shoot=false
local sine = 0
local change = 1
local kan = Instance.new("Sound",tors)
kan.Volume = 1.25
kan.TimePosition = 0
kan.PlaybackSpeed = 1
kan.Pitch = 1
kan.SoundId = "rbxassetid://431718336"
kan.Name = "VectoristBootleglol"
kan.Looped = true
kan:Play()
--save shoulders 
RSH, LSH=nil, nil 
--welds 
RW, LW=Instance.new("Weld"), Instance.new("Weld") 
RW.Name="Right Shoulder" LW.Name="Left Shoulder"
LH=Torso["Left Hip"]
RH=Torso["Right Hip"]
TorsoColor=Torso.BrickColor
function NoOutline(Part)
Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
end
ch=Character
RSH=ch.Torso["Right Shoulder"] 
LSH=ch.Torso["Left Shoulder"] 
-- 
RSH.Parent=nil 
LSH.Parent=nil 
-- 
RW.Name="Right Shoulder"
RW.Part0=ch.Torso 
RW.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5) 
RW.C1=cf(0, 0.5, 0) 
RW.Part1=ch["Right Arm"] 
RW.Parent=ch.Torso 
-- 
LW.Name="Left Shoulder"
LW.Part0=ch.Torso 
LW.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8) 
LW.C1=cf(0, 0.5, 0) 
LW.Part1=ch["Left Arm"] 
LW.Parent=ch.Torso 

local Stats=Instance.new("BoolValue")
Stats.Name="Stats"
Stats.Parent=Character
local Atk=Instance.new("NumberValue")
Atk.Name="Damage"
Atk.Parent=Stats
Atk.Value=1
local Def=Instance.new("NumberValue")
Def.Name="Defense"
Def.Parent=Stats
Def.Value=1
local Speed=Instance.new("NumberValue")
Speed.Name="Speed"
Speed.Parent=Stats
Speed.Value=1
local Mvmt=Instance.new("NumberValue")
Mvmt.Name="Movement"
Mvmt.Parent=Stats
Mvmt.Value=1

local donum=0

--bruh customisation lol
local HOOD = script.HOOD:Clone()
HOOD.Parent = script.CoatParts
local BCB = script.BACKCLOAKBOTTOM:Clone()
BCB.Parent = script.CoatParts
local RCB = script.RIGHTCLOAKBOTTOM:Clone()
RCB.Parent = script.CoatParts
local RCBE = script.RIGHTCLOAKBOTTOMEND:Clone()
RCBE.Parent = script.CoatParts
local LCB = script.LEFTCLOAKBOTTOM:Clone()
LCB.Parent = script.CoatParts
local LCBE = script.LEFTCLOAKBOTTOMEND:Clone()
LCBE.Parent = script.CoatParts
local RSJ = script.RIGHTSIDEJACKET:Clone()
RSJ.Parent = script.CoatParts
local LSJ = script.LEFTSIDEJACKET:Clone()
LSJ.Parent = script.CoatParts
local CJ = script.CLOVERJACKET:Clone()
CJ.Parent = script.CoatParts
local weldHOOD = Instance.new("Weld")
weldHOOD.Parent = HOOD
weldHOOD.Part0 = char.Torso
weldHOOD.Part1 = HOOD
local weldBLACKHOODBOTTOM = Instance.new("Weld")
weldBLACKHOODBOTTOM.Parent = BCB
weldBLACKHOODBOTTOM.Part0 = char.Torso
weldBLACKHOODBOTTOM.Part1 = BCB
local weldRIGHTCLOAKBOTTOM = Instance.new("Weld")
weldRIGHTCLOAKBOTTOM.Parent = RCB
weldRIGHTCLOAKBOTTOM.Part0 = char.Torso
weldRIGHTCLOAKBOTTOM.Part1 = RCB
local weldRIGHTCLOAKBOTTOMEND = Instance.new("Weld")
weldRIGHTCLOAKBOTTOMEND.Parent = RCBE
weldRIGHTCLOAKBOTTOMEND.Part0 = RCB
weldRIGHTCLOAKBOTTOMEND.Part1 = RCBE
local weldLEFTCLOAKBOTTOM = Instance.new("Weld")
weldLEFTCLOAKBOTTOM.Parent = LCB
weldLEFTCLOAKBOTTOM.Part0 = char.Torso
weldLEFTCLOAKBOTTOM.Part1 = LCB
local weldLEFTCLOAKBOTTOMEND = Instance.new("Weld")
weldLEFTCLOAKBOTTOMEND.Parent = LCBE
weldLEFTCLOAKBOTTOMEND.Part0 = LCB
weldLEFTCLOAKBOTTOMEND.Part1 = LCBE
local weldRIGHTSIDEJACKET = Instance.new("Weld")
weldRIGHTSIDEJACKET.Parent = RSJ
weldRIGHTSIDEJACKET.Part0 = char.Torso
weldRIGHTSIDEJACKET.Part1 = RSJ
local weldLEFTSIDEJACKET = Instance.new("Weld")
weldLEFTSIDEJACKET.Parent = LSJ
weldLEFTSIDEJACKET.Part0 = char.Torso
weldLEFTSIDEJACKET.Part1 = LSJ
local weldCLOVERJACKET = Instance.new("Weld")
weldCLOVERJACKET.Parent = CJ
weldCLOVERJACKET.Part0 = char.Torso
weldCLOVERJACKET.Part1 = CJ
weldHOOD.C1 = CFrame.new(-0.868278027, 0.821474075, 0.237285614, -0.719009399, 0.661553562, 0.213007808, -0.655310988, -0.543233573, -0.524848282, -0.231502473, -0.516957164, 0.824113786)
weldBLACKHOODBOTTOM.C1 = CFrame.new(-0.0136946458, 1.45829773, -0.751249313, 0.994221807, 0.0546650253, 0.0923596025, -0.0133523401, 0.916879594, -0.39893949, -0.106490687, 0.395402789, 0.912311614)
weldRIGHTCLOAKBOTTOM.C1 = CFrame.new(-1.89380455, -0.480474472, -0.274247646, 0.589364529, -0.652499199, 0.476326406, 0.658837438, 0.0469961166, -0.750808954, 0.467516869, 0.75633055, 0.457589835)
weldLEFTCLOAKBOTTOM.C1 = CFrame.new(0.448446035, -0.0163630843, -1.85565233, 0.58422327, -0.568950713, -0.578768849, 0.561031461, -0.232176393, 0.794560194, -0.586443067, -0.788913012, 0.18355234)
weldRIGHTSIDEJACKET.C1 = CFrame.new(-0.0221998878, -0.476099998, -0.0208996981, 0.00839624368, 0.999964714, 0, 0.999964595, -0.00839624275, -5.92621102E-4, -5.92600205E-4, 4.97579185E-6, -0.999999821)
weldLEFTSIDEJACKET.C1 = CFrame.new(-0.0213999674, 0.498500079, -0.0314000286, -0.00558969192, 0.999975145, -0.00431776373, 0.999967873, 0.00561439199, 0.00572984666, 0.0057539437, -0.00428557908, -0.99997437)
weldCLOVERJACKET.C1 = CFrame.new(0.698013902, 0.177616119, 0.522828579, 0.846173227, 0.526054502, -0.0852145255, 0.0517081767, 0.0781018957, 0.995606184, 0.530398905, -0.846857071, 0.0388864391)
weldRIGHTCLOAKBOTTOMEND.C1 = CFrame.new(-0.848119259, -1.42430496, 0.192653656, 0.896874011, 0.426952571, -0.115449488, -0.437944829, 0.820798695, -0.366734147, -0.0618172809, 0.379474849, 0.923134625)
weldLEFTCLOAKBOTTOMEND.C1 = CFrame.new(-0.549965858, -1.03996277, -1.06208038, -0.43713057, -0.80966264, -0.391616225, 0.898116469, -0.416192681, -0.142022938, -0.0479971059, -0.413799524, 0.909101903)
for i,v in pairs(script.CoatParts:GetChildren()) do
	v.Parent = Character
end
local crystal = script.Crystal
crystal.Anchored = false
crystal.CanCollide = false
local crysweld = Instance.new("Weld",crystal)
crysweld.Part0 = crystal
crysweld.Part1 = tors
crysweld.C0 = CFrame.new(0,0,0)
crystal.Parent = Character

local idlepose = "one"


 

function part(formfactor,parent,reflectance,transparency,brickcolor,name,size)
local fp=it("Part")
fp.formFactor=formfactor 
fp.Parent=parent
fp.Reflectance=reflectance
fp.Transparency=transparency
fp.CanCollide=false 
fp.Locked=true
fp.BrickColor=brickcolor
fp.Name=name
fp.Size=size
fp.Position=Torso.Position 
NoOutline(fp)
fp.Material="SmoothPlastic"
fp:BreakJoints()
return fp 
end 
 
function mesh(Mesh,part,meshtype,meshid,offset,scale)
local mesh=it(Mesh) 
mesh.Parent=part
if Mesh=="SpecialMesh" then
mesh.MeshType=meshtype
if meshid~="nil" then
mesh.MeshId="http://www.roblox.com/asset/?id="..meshid
end
end
mesh.Offset=offset
mesh.Scale=scale
return mesh
end
 
function weld(parent,part0,part1,c0)
local weld=it("Weld") 
weld.Parent=parent
weld.Part0=part0 
weld.Part1=part1 
weld.C0=c0
return weld
end
 
local Color1=Torso.BrickColor

local bodvel=Instance.new("BodyVelocity")
local bg=Instance.new("BodyGyro")

--------- SazEreno's Artificial HB --------------
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")
Frame_Speed = 1 / 60
frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
		lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

------------------
function swait(num)
if num == 0 or num == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, num do
			ArtificialHB.Event:wait()
		end
	end
end
 
 
so = function(id,par,vol,pit) 
coroutine.resume(coroutine.create(function()
local sou = Instance.new("Sound",par or workspace)
sou.Volume=vol
sou.Pitch=pit or 1
sou.SoundId=id
swait() 
sou:play() 
game:GetService("Debris"):AddItem(sou,6)
end))
end
 
function clerp(a,b,t) 
local qa = {QuaternionFromCFrame(a)}
local qb = {QuaternionFromCFrame(b)} 
local ax, ay, az = a.x, a.y, a.z 
local bx, by, bz = b.x, b.y, b.z
local _t = 1-t
return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
end 
 
function QuaternionFromCFrame(cf) 
local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
local trace = m00 + m11 + m22 
if trace > 0 then 
local s = math.sqrt(1 + trace) 
local recip = 0.5/s 
return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
else 
local i = 0 
if m11 > m00 then
i = 1
end
if m22 > (i == 0 and m00 or m11) then 
i = 2 
end 
if i == 0 then 
local s = math.sqrt(m00-m11-m22+1) 
local recip = 0.5/s 
return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
elseif i == 1 then 
local s = math.sqrt(m11-m22-m00+1) 
local recip = 0.5/s 
return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
elseif i == 2 then 
local s = math.sqrt(m22-m00-m11+1) 
local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
end 
end 
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w) 
local xs, ys, zs = x + x, y + y, z + z 
local wx, wy, wz = w*xs, w*ys, w*zs 
local xx = x*xs 
local xy = x*ys 
local xz = x*zs 
local yy = y*ys 
local yz = y*zs 
local zz = z*zs 
return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
end
 
function QuaternionSlerp(a, b, t) 
local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
local startInterp, finishInterp; 
if cosTheta >= 0.0001 then 
if (1 - cosTheta) > 0.0001 then 
local theta = math.acos(cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((1-t)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta  
else 
startInterp = 1-t 
finishInterp = t 
end 
else 
if (1+cosTheta) > 0.0001 then 
local theta = math.acos(-cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((t-1)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta 
else 
startInterp = t-1 
finishInterp = t 
end 
end 
return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
end

local function CFrameFromTopBack(at, top, back)
local right = top:Cross(back)
return CFrame.new(at.x, at.y, at.z,
right.x, top.x, back.x,
right.y, top.y, back.y,
right.z, top.z, back.z)
end

function Triangle(a, b, c)
local edg1 = (c-a):Dot((b-a).unit)
local edg2 = (a-b):Dot((c-b).unit)
local edg3 = (b-c):Dot((a-c).unit)
if edg1 <= (b-a).magnitude and edg1 >= 0 then
a, b, c = a, b, c
elseif edg2 <= (c-b).magnitude and edg2 >= 0 then
a, b, c = b, c, a
elseif edg3 <= (a-c).magnitude and edg3 >= 0 then
a, b, c = c, a, b
else
assert(false, "unreachable")
end
 
local len1 = (c-a):Dot((b-a).unit)
local len2 = (b-a).magnitude - len1
local width = (a + (b-a).unit*len1 - c).magnitude
 
local maincf = CFrameFromTopBack(a, (b-a):Cross(c-b).unit, -(b-a).unit)
 
local list = {}
 
if len1 > 0.01 then
local w1 = Instance.new('WedgePart', m)
game:GetService("Debris"):AddItem(w1,5)
w1.Material = "SmoothPlastic"
w1.FormFactor = 'Custom'
w1.BrickColor = BrickColor.new("Really red")
w1.Transparency = 0
w1.Reflectance = 0
w1.Material = "SmoothPlastic"
w1.CanCollide = false
local l1 = Instance.new("PointLight",w1)
l1.Color = Color3.new(170,0,0)
NoOutline(w1)
local sz = Vector3.new(0.2, width, len1)
w1.Size = sz
local sp = Instance.new("SpecialMesh",w1)
sp.MeshType = "Wedge"
sp.Scale = Vector3.new(0,1,1) * sz/w1.Size
w1:BreakJoints()
w1.Anchored = true
w1.Parent = workspace
w1.Transparency = 0.7
table.insert(Effects,{w1,"Disappear",.01})
w1.CFrame = maincf*CFrame.Angles(math.pi,0,math.pi/2)*CFrame.new(0,width/2,len1/2)
table.insert(list,w1)
end
 
if len2 > 0.01 then
local w2 = Instance.new('WedgePart', m)
game:GetService("Debris"):AddItem(w2,5)
w2.Material = "SmoothPlastic"
w2.FormFactor = 'Custom'
w2.BrickColor = BrickColor.new("Really red")
w2.Transparency = 0
w2.Reflectance = 0
w2.Material = "SmoothPlastic"
w2.CanCollide = false
local l2 = Instance.new("PointLight",w2)
l2.Color = Color3.new(170,0,0)
NoOutline(w2)
local sz = Vector3.new(0.2, width, len2)
w2.Size = sz
local sp = Instance.new("SpecialMesh",w2)
sp.MeshType = "Wedge"
sp.Scale = Vector3.new(0,1,1) * sz/w2.Size
w2:BreakJoints()
w2.Anchored = true
w2.Parent = workspace
w2.Transparency = 0.7
table.insert(Effects,{w2,"Disappear",.01})
w2.CFrame = maincf*CFrame.Angles(math.pi,math.pi,-math.pi/2)*CFrame.new(0,width/2,-len1 - len2/2)
table.insert(list,w2)
end
return unpack(list)
end
 

function Damagefunc(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
  if hit.Parent == nil then
    return
  end

    local Damage = math.random(minim, maxim)
    local blocked = false
    local block = hit.Parent:findFirstChild("Block")
    if block ~= nil and block.className == "IntValue" and block.Value > 0 then
      blocked = true
      block.Value = block.Value - 1
      print(block.Value)
    end
    if blocked == false then
      ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 1.5, Part.BrickColor.Color)
    else
      h.Health = h.Health - Damage / 2
      ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 1.5, Part.BrickColor.Color)
    end
    
end
function ShowDamage(Pos, Text, Time, Color)
  local Rate = 0.03333333333333333
  local Pos = Pos or Vector3.new(0, 0, 0)
  local Text = Text or ""
  local Time = Time or 2
  local Color = Color or Color3.new(1, 0, 1)
  local EffectPart = CreatePart(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
  EffectPart.Anchored = true
  local BillboardGui = Create("BillboardGui")({
    Size = UDim2.new(3, 0, 3, 0),
    Adornee = EffectPart,
    Parent = EffectPart
  })
  local TextLabel = Create("TextLabel")({
    BackgroundTransparency = 1,
    Size = UDim2.new(1, 0, 1, 0),
    Text = Text,
    TextColor3 = Color,
    TextScaled = true,
    Font = Enum.Font.ArialBold,
    Parent = BillboardGui
  })
  game.Debris:AddItem(EffectPart, Time + 0.1)
  EffectPart.Parent = game:GetService("Workspace")
  delay(0, function()
    local Frames = Time / Rate
    for Frame = 1, Frames do
      wait(Rate)
      local Percent = Frame / Frames
      EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
      TextLabel.TextTransparency = Percent
    end
    if EffectPart and EffectPart.Parent then
      EffectPart:Destroy()
    end
  end)
end
function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Torso")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= Player.Name then
          Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://231917784", 1)
        end
      end
    end
  end
end

function MagniDamageWithEffect(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Torso")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= Player.Name then
	MagicBlock(BrickColor.new("Dark indigo"),head.CFrame,5,5,5,1,1,1,0.05)
          Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://231917784", 1)
        end
      end
    end
  end
end

function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore) 
end 

function SkullEffect(brickcolor,cframe,x1,y1,z1,delay)
local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
local msh=mesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=4770583",vt(0,0,0),vt(x1,y1,z1))
--http://www.roblox.com/asset/?id=4770560
game:GetService("Debris"):AddItem(prt,2)
CF=prt.CFrame
coroutine.resume(coroutine.create(function(Part,Mesh,TehCF) 
for i=0,1,0.2 do
wait()
Part.CFrame=CF*cf(0,0,-0.4)
end
for i=0,1,delay do
wait()
--Part.CFrame=CF*cf((math.random(-1,0)+math.random())/5,(math.random(-1,0)+math.random())/5,(math.random(-1,0)+math.random())/5)
Mesh.Scale=Mesh.Scale
end
for i=0,1,0.1 do
wait()
Part.Transparency=i
end
Part.Parent=nil
end),prt,msh,CF)
end
 
function MagicBlock(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.Material = "Neon"
prt.CFrame=cframe
prt.CFrame=prt.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,delay do
swait()
Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh)
end

function MagicBlockSteady(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,rottype)
local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.Material = "Neon"
prt.CFrame=cframe
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
	local rtype = rottype
for i=0,1,delay do
swait()
if rtype == 1 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
elseif rtype == 2 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
end
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh)
end

function MagicSphere(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
prt.CFrame=prt.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,delay do
wait()
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh)
end

function MagicBlockSteady(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,rottype)
local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.Material = "Neon"
prt.CFrame=cframe
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
	local rtype = rottype
for i=0,1,delay do
swait()
if rtype == 1 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
elseif rtype == 2 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
end
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh)
end

function MagicShock(brickcolor,cframe,x1,y1,x3,y3,delay,rottype)
local prt=part(3,char,1,1,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.Material = "Neon"
prt.CFrame=cframe
local dec = decal(prt.Color,"http://www.roblox.com/asset/?id=874580939","Front",prt)
local dec2 = decal(prt.Color,"http://www.roblox.com/asset/?id=874580939","Front",prt)
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,0.01))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
	local rtype = rottype
for i=0,1,delay do
swait()
if rtype == 1 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
elseif rtype == 2 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
end
dec.Transparency=i
dec2.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,0)
end
Part.Parent=nil
end),prt,msh)
end

function MagicShockAlt(brickcolor,cframe,x1,y1,x3,y3,delay,rottype)
local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.Material = "Neon"
prt.CFrame=cframe
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,0.01))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
	local rtype = rottype
for i=0,1,delay do
swait()
if rtype == 1 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
elseif rtype == 2 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
end
prt.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,0)
end
Part.Parent=nil
end),prt,msh)
end

function MagicShockAltCircle(brickcolor,cframe,x1,z1,x3,z3,delay,rottype)
local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.Material = "Neon"
prt.CFrame=cframe
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
	local rtype = rottype
for i=0,1,delay do
swait()
if rtype == 1 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0.1,0)
elseif rtype == 2 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,-0.1,0)
end
prt.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,0,z3)
end
Part.Parent=nil
end),prt,msh)
end

function MagicShockTrailAlt(brickcolor,cframe,x1,y1,z1,x3,y3,delay,rottype)
local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.Material = "Neon"
prt.CFrame=cframe
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
	local rtype = rottype
for i=0,1,delay do
swait()
if rtype == 1 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
elseif rtype == 2 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
end
prt.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,0)
end
Part.Parent=nil
end),prt,msh)
end

function MagicShockTrailAlt2(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,rottype)
local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.Material = "Neon"
prt.CFrame=cframe
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
	local rtype = rottype
for i=0,1,delay do
swait()
if rtype == 1 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
elseif rtype == 2 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
end
prt.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh)
end
 
function MagicBlock2(brickcolor,cframe,Parent,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=false
prt.CFrame=cframe
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
local wld=weld(prt,prt,Parent,cframe)
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh,Weld) 
for i=0,1,delay do
wait()
Weld.C0=euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))*cframe
--Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh,wld)
end
 
function MagicBlock3(brickcolor,cframe,Parent,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=false
prt.CFrame=cframe
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
local wld=weld(prt,prt,Parent,euler(0,0,0)*cf(0,0,0))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh,Weld) 
for i=0,1,delay do
wait()
Weld.C0=euler(i*20,0,0)
--Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh,wld)
end
 
function MagicCircle2(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
local msh=mesh("CylinderMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,2)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,delay do
wait()
Part.CFrame=Part.CFrame
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
local prt2=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt2.Anchored=true
prt2.CFrame=cframe*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
local msh2=mesh("SpecialMesh",prt2,"Sphere","",vt(0,0,0),vt(0.5,0.5,0.5))
game:GetService("Debris"):AddItem(prt2,2)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,0.1 do
wait()
Part.CFrame=Part.CFrame*cf(0,0.5,0)
end
Part.Parent=nil
end),prt2,msh2)
end
for i=0,1,delay*2 do
wait()
Part.CFrame=Part.CFrame
Mesh.Scale=vt((x1+x3)-(x1+x3)*i,(y1+y3)-(y1+y3)*i,(z1+z3)-(z1+z3)*i)
end
Part.Parent=nil
end),prt,msh)
end
 
function MagicCircle(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
local msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,2)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,delay do
wait()
Part.CFrame=Part.CFrame
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh)
end
 
function BreakEffect(brickcolor,cframe,x1,y1,z1)
local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
local msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,2)
coroutine.resume(coroutine.create(function(Part,CF,Numbb,randnumb) 
CF=Part.CFrame
Numbb=0
randnumb=math.random()/10
rand1=math.random()/10
for i=0,1,rand1 do
wait()
CF=CF*cf(0,math.random()/2,0)
--Part.CFrame=Part.CFrame*euler(0.5,0,0)*cf(0,1,0)
Part.CFrame=CF*euler(Numbb,0,0)
Part.Transparency=i
Numbb=Numbb+randnumb
end
Part.Parent=nil
end),prt,CF,Numbb,randnumb)
end
 
function MagicWaveThing(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
msh=mesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=1051557",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,delay do
wait()
Part.CFrame=Part.CFrame*euler(0,0.7,0)
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh)
end
 
function WaveEffect(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
msh=mesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=20329976",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,2)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,delay do
wait()
Part.CFrame=Part.CFrame*cf(0,y3/2,0)
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh)
end
 
function StravEffect(brickcolor,cframe,x,y,z,x1,y1,z1,delay)
local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe*cf(x,y,z)
msh=mesh("SpecialMesh",prt,"FileMesh","rbxassetid://168892363",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh,ex,why,zee) 
local num=math.random()
local num2=math.random(-3,2)+math.random()
local numm=0
for i=0,1,delay*2 do
swait()
Part.CFrame=cframe*euler(0,numm*num*10,0)*cf(ex,why,zee)*cf(-i*10,num2,0)
Part.Transparency=i
numm=numm+0.01
end
Part.Parent=nil
Mesh.Parent=nil
end),prt,msh,x,y,z)
end

function dmgstart(dmg,what)

end

function dmgstop()
	hitcon:disconnect()
end

function Cloak()
Face.Parent=nil
cloaked=true
        for _,v in pairs(Torso.Parent:children()) do
                if v.className=="Part" and v.Name~="HumanoidRootPart" then
                coroutine.resume(coroutine.create(function() 
                for i=0,1,0.2 do
                wait()
                v.Transparency=i
                end
                v.Transparency=1
                end))
                end
                if v.className=="Hat" then
                hatp=v.Handle
                coroutine.resume(coroutine.create(function(derp) 
                for i=0,1,0.2 do
                wait()
                derp.Transparency=i
                end
                derp.Transparency=1
                end),hatp)
                end
        end
        for _,v in pairs(m:children()) do
                if v.className=="Part" then
                coroutine.resume(coroutine.create(function() 
                for i=0,1,0.2 do
                wait()
                v.Transparency=i
                end
                v.Transparency=1
                end))
                end
        end
end
 
function UnCloak()
so("http://roblox.com/asset/?id=2767090",Torso,1,1.1) 
Face.Parent=Head 
cloaked=false
        for _,v in pairs(Torso.Parent:children()) do
                if v.className=="Part" and v.Name~="HumanoidRootPart" then
                coroutine.resume(coroutine.create(function() 
                for i=0,1,0.1 do
                wait()
                v.Transparency=v.Transparency-0.1
                end
                v.Transparency=0
                end))
                end
                if v.className=="Hat" then
                hatp=v.Handle
                coroutine.resume(coroutine.create(function(derp) 
                for i=0,1,0.1 do
                wait()
                derp.Transparency=derp.Transparency-0.1
                end
                derp.Transparency=0
                end),hatp)
                end
        end
        for _,v in pairs(m:children()) do
                if v.className=="Part" and v.Name~="hitbox" and v.Name~='tip' then
                coroutine.resume(coroutine.create(function() 
                for i=0,1,0.1 do
                wait()
                v.Transparency=v.Transparency-0.1
                end
                v.Transparency=0
                end))
                v.Transparency=0
                end
        end
end

local origcolor = BrickColor.new("Dark indigo")
---- This section of explosions.
function Explode(rad,par,pitch,vol,mindam,maxdam)
	local expart = Instance.new("Part",char)
	local expart2 = Instance.new("Part",char)
	local rin = Instance.new("Part",char)
	local rin2 = Instance.new("Part",char)
	local partMesh = Instance.new("SpecialMesh",expart)
	partMesh.MeshType = "Sphere"
	local partMesh2 = Instance.new("SpecialMesh",expart2)
	partMesh2.MeshType = "Sphere"
	local partMesh3 = Instance.new("SpecialMesh",rin)
	partMesh3.MeshType = "Brick"
	local partMesh4 = Instance.new("SpecialMesh",rin2)
	partMesh4.MeshType = "Brick"
	CFuncs["Sound"].Create("rbxassetid://165970126", expart,vol, pitch)
	partMesh.Scale = vt(rad,rad,rad)
	expart.Size = vt(1,1,1)
	expart.Transparency = 1
	expart.Anchored = true
	expart.Material = "Neon"
	expart.BrickColor = bc("White")
	expart.CFrame = par.CFrame
	partMesh2.Scale = vt(rad,rad,rad)
	expart2.Size = vt(1.15,1.15,1.15)
	expart2.Transparency = 0.75
	expart2.Anchored = true
	expart2.Material = "Glass"
	expart2.BrickColor = par.BrickColor
	expart2.CFrame = par.CFrame
	rin.Size = vt(1.15,1.15,1.15)
	rin.Transparency = 1
	rin.Anchored = true
	rin.Material = "Neon"
	rin.BrickColor = par.BrickColor
	rin.CFrame = par.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
	rin2.Size = vt(1.15,1.15,1.15)
	rin2.Transparency = 1
	rin2.Anchored = true
	rin2.Material = "Neon"
	rin2.BrickColor = par.BrickColor
	rin2.CFrame = par.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
	partMesh3.Scale = vt(0,1,0)
	partMesh4.Scale = vt(0,1,0)
local dec2 = Instance.new("Decal", rin)
dec2.Face = "Top"
dec2.Texture = "http://www.roblox.com/asset/?id=874580939"
dec2.Parent = rin
local dec2b = dec2:Clone()
dec2b.Face = "Bottom"
dec2b.Parent = rin

local dec2a = Instance.new("Decal", rin2)
dec2a.Face = "Top"
dec2a.Texture = "http://www.roblox.com/asset/?id=874580939"
dec2a.Parent = rin2
local dec2ab = dec2a:Clone()
dec2ab.Face = "Bottom"
dec2ab.Parent = rin2
expart.CanCollide = false
expart2.CanCollide = false
rin.CanCollide = false
rin2.CanCollide = false
MagniDamage(par, rad*5, mindam, maxdam, 0, "Normal")
        local value = 1*rad/6.5
	for i = 0, 199 do
                partMesh.Scale = partMesh.Scale + vt(value,value,value)
		expart.CFrame = expart.CFrame
                partMesh2.Scale = partMesh2.Scale + vt(value,value,value)
		expart2.CFrame = expart.CFrame
                value = value - 0.035*rad/30
                if value < 7.5 then
	partMesh3.Scale = partMesh3.Scale + vt(rad/5,0,rad/5)
		rin.CFrame = rin.CFrame*CFrame.Angles(0,math.rad(1),0)
	partMesh4.Scale = partMesh4.Scale + vt(rad/7.5,0,rad/7.5)
		rin2.CFrame = rin2.CFrame*CFrame.Angles(0,math.rad(-1),0)
		end
                if value < 0 then
dec2.Transparency = dec2.Transparency + 0.025
dec2a.Transparency = dec2a.Transparency + 0.025
dec2b.Transparency = dec2b.Transparency + 0.025
dec2ab.Transparency = dec2ab.Transparency + 0.025
		expart.Transparency = expart.Transparency + 0.025
		expart2.Transparency = expart2.Transparency + 0.025
		rin.Transparency = rin.Transparency + 0.025
		rin2.Transparency = rin2.Transparency + 0.025
                end
		swait()
	end
game:GetService("Debris"):AddItem(expart, 1)
game:GetService("Debris"):AddItem(expart2, 1)
game:GetService("Debris"):AddItem(rin, 1)
game:GetService("Debris"):AddItem(rin2, 1)
end

function ExplodeShort(rad,par,pitch,vol,mindam,maxdam)
	local expart = Instance.new("Part",char)
	local expart2 = Instance.new("Part",char)
	local partMesh = Instance.new("SpecialMesh",expart)
	partMesh.MeshType = "Sphere"
	local partMesh2 = Instance.new("SpecialMesh",expart2)
	partMesh2.MeshType = "Sphere"
	CFuncs["Sound"].Create("http://www.roblox.com/asset/?id=142070127", expart,vol, pitch)
	partMesh.Scale = vt(rad,rad,rad)
	expart.Size = vt(1,1,1)
	expart.Transparency = 0
	expart.Anchored = true
	expart.Material = "Neon"
	expart.BrickColor = bc("White")
	expart.CFrame = par.CFrame
	partMesh2.Scale = vt(rad,rad,rad)
	expart2.Size = vt(1.15,1.15,1.15)
	expart2.Transparency = 0.5
	expart2.Anchored = true
	expart2.Material = "Neon"
	expart2.BrickColor = par.BrickColor
	expart2.CFrame = par.CFrame
expart.CanCollide = false
expart2.CanCollide = false
MagniDamage(par, rad*2.5, mindam, maxdam, 0, "Normal")
        local value = 1*rad/6.5
	for i = 0, 75 do
                partMesh.Scale = partMesh.Scale + vt(value,value,value)
		expart.CFrame = expart.CFrame
                partMesh2.Scale = partMesh2.Scale + vt(value,value,value)
		expart2.CFrame = expart.CFrame
                value = value - 0.035*rad/5
                if value < 0 then
value = 0
		expart.Transparency = expart.Transparency + 0.05
		expart2.Transparency = expart2.Transparency + 0.05
                end
		swait()
	end
game:GetService("Debris"):AddItem(expart, 1)
game:GetService("Debris"):AddItem(expart2, 1)
end

function AreaDanger(rad,par,mindam,maxdam)
	local expart = Instance.new("Part",char)
	local partMesh = Instance.new("SpecialMesh",expart)
	CFuncs["Sound"].Create("rbxassetid://231917784", expart,1.5,1.15)
	partMesh.MeshType = "Sphere"
	partMesh.Scale = vt(rad,rad,rad)
	expart.Size = vt(1,1,1)
	expart.Transparency = 0.5
	expart.Anchored = true
	expart.Material = "Neon"
	expart.CanCollide = false
	expart.BrickColor = par.BrickColor
	expart.CFrame = par.CFrame
        local value = 1*rad/5
MagicBlock(origcolor,expart.CFrame,0,0,0,rad/2,rad/2,rad/2,0.1)
	for i = 0, 14 do
		wait()
                partMesh.Scale = partMesh.Scale + vt(value,value,value)
		expart.CFrame = expart.CFrame
                value = value - 0.035*rad
                if value < 0 then
	value = 0
end
	end
	wait(0.25)
CFuncs["Sound"].Create("rbxassetid://588738544", expart,1.5,1)
wait(0.5)
CFuncs["Sound"].Create("rbxassetid://588737825", expart,1.5,1)
CFuncs["Sound"].Create("rbxassetid://231917784", expart,1.5,0.75)
MagniDamageWithEffect(par, rad, mindam, maxdam, 0, "Normal")
MagicBlock(origcolor,expart.CFrame,rad*2,rad*2,rad*2,0.1,0.1,0.1,0.025)
for i = 0, 14 do
		wait()
                partMesh.Scale = partMesh.Scale + vt(value,value,value)
		expart.CFrame = expart.CFrame
                value = value - 0.035*rad/2
end
expart.Transparency = 1
game:GetService("Debris"):AddItem(expart, 5)
end

function Swarmsplosions(negrad,rad,par,mindam,maxdam)
		CFuncs["Sound"].Create("rbxassetid://588737825", par, 2.5, 2)
	CFuncs["Sound"].Create("rbxassetid://231917784", par, 2.5,1)
	CFuncs["Sound"].Create("rbxassetid://231917744", par, 2.5,1)
	CFuncs["Sound"].Create("rbxassetid://233856106", par, 2.5, 1)
			MagniDamageWithEffect(par, 25, 5,10, 0, "Normal")
			MagicBlock(origcolor,par.CFrame,5,5,5,5,5,5,0.025)
	for i = 0, 24 do
		MagicShockTrailAlt2(origcolor,par.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),10/5,10/5,5,-0.05/5,-0.05/5,25,0.005,math.random(1,2))
	end
	for i = 0, 24 do
	local expart = Instance.new("Part",char)
	expart.Transparency = 1
	expart.Anchored = true
	expart.CanCollide = false
	expart.CFrame = par.CFrame*CFrame.new(math.random(negrad,rad),math.random(negrad,rad),math.random(negrad,rad))
CFuncs["Sound"].Create("rbxassetid://588737825", expart,1,2)
CFuncs["Sound"].Create("rbxassetid://231917784", expart,1.5,1.15)
MagniDamage(expart, rad/2, mindam, maxdam, 0, "Normal")
MagicBlock(origcolor,expart.CFrame,rad,rad,rad,0.1,0.1,0.1,0.025)
for i = 0, 9 do
		MagicShockTrailAlt2(origcolor,expart.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),10/5,10/5,5,-0.05/5,-0.05/5,5,0.05,math.random(1,2))
	end
game:GetService("Debris"):AddItem(expart, 2)
wait(0.1)
	end
end

function EXterPlosion(par)
		CFuncs["Sound"].Create("rbxassetid://919941001", par, 10, 1)
	CFuncs["Sound"].Create("rbxassetid://138213851", par, 5,0.85)
	CFuncs["Sound"].Create("rbxassetid://157878578", par, 5,0.2)
	CFuncs["Sound"].Create("rbxassetid://233856106", par, 2.5, 1)
			MagniDamageWithEffect(par, 500, 80,99, 0, "Normal")
			MagicBlock(origcolor,par.CFrame,5,5,5,5,5,5,0.005)
			MagicBlock(origcolor,par.CFrame,0,0,0,150,150,150,0.1)
	for i = 0, 24 do
		MagicShockTrailAlt2(origcolor,par.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),10*5,10*5,5,-0.05*10,-0.05*10,500,0.1,math.random(1,2))
	end
	for i = 0, 24 do
		MagicShockTrailAlt2(origcolor,par.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),10*5,10*5,5,-0.05*5,-0.05*5,50,0.005,math.random(1,2))
	end
end
----
function bullit()
	attack = true
	for i = 0,1,0.1 do
		swait()
		MagicBlock(origcolor,sorb.CFrame,3,3,3,0.05,0.05,0.05,0.05)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(-80)),0.3)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(5),math.rad(0),math.rad(80)),.3)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(50), math.rad(0), math.rad(20)), 0.3)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(50), math.rad(0), math.rad(-90)), 0.3)
	end
	CFuncs["Sound"].Create("rbxassetid://558640653", sorb, 1.5, 1)
							local a = Instance.new("Part",Character)
	a.Name = "Direction"	
	a.Anchored = true
	a.BrickColor = bc("Bright red")
a.Material = "Neon"
a.Transparency = 1
	a.CanCollide = false
	local ray = Ray.new(
	    sorb.CFrame.p,                           -- origin
	    (mouse.Hit.p - sorb.CFrame.p).unit * 500 -- direction
	) 
	local ignore = Character
	local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
	a.BottomSurface = 10
	a.TopSurface = 10
	local distance = (root.CFrame.p - position).magnitude
	a.Size = Vector3.new(0.1, 0.1, 0.1)
	a.CFrame = CFrame.new(sorb.CFrame.p, position) * CFrame.new(0, 0, 0)
				 local lb = Instance.new("Part")
  lb.Parent = char
    lb.BrickColor = origcolor
     lb.CanCollide = false
lb.Material = "Glass"
     lb.Anchored = true
lb.TopSurface = 0
        lb.BottomSurface = 0
     lb.Transparency = 0.75
     lb.Size = vt(0.5,0.5,0.5)
     lb.CFrame = a.CFrame
lb.Anchored = false
local thingery = Instance.new("SpecialMesh",lb)
     thingery.MeshType = "Sphere"
thingery.Scale = vt(20,20,20)
game:GetService("Debris"):AddItem(lb, 10)
  local bv = Instance.new("BodyVelocity")
  bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
  bv.velocity = a.CFrame.lookVector*150
  bv.Parent = lb
local hitted = false
game:GetService("Debris"):AddItem(a, 0.1)
wait(0.01)
lb.Touched:connect(function(hit) 
	if hitted == false then
		hitted = true
		lb.Anchored = true
		lb.Transparency = 1
Explode(7.5,lb,1,1,10,15)
	end
end)
	for i = 0,2,0.1 do
		swait()
		MagicBlock(origcolor,sorb.CFrame,3,3,3,0.05,0.05,0.05,0.05)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(20),math.rad(0),math.rad(80)),0.5)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(5),math.rad(0),math.rad(-80)),.5)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(50), math.rad(0), math.rad(20)), 0.5)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(50), math.rad(0), math.rad(-90)), 0.5)
	end
	attack = false
end

function snipe()
	attack = true
	for i = 0,2,0.1 do
		swait()
		MagicBlock(origcolor,sorb.CFrame,1,1,1,0.05,0.05,0.05,0.05)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(90)),0.3)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(0),math.rad(-90)),.3)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(90)), 0.3)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-20)), 0.3)
	end
	CFuncs["Sound"].Create("rbxassetid://171137312", sorb, 2.5, 1)
							local a = Instance.new("Part",Character)
	a.Name = "Direction"	
	a.Anchored = true
	a.BrickColor = bc("Bright red")
a.Material = "Neon"
a.Transparency = 1
	a.CanCollide = false
	local ray = Ray.new(
	    sorb.CFrame.p,                           -- origin
	    (mouse.Hit.p - sorb.CFrame.p).unit * 500 -- direction
	) 
	local ignore = Character
	local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
	a.BottomSurface = 10
	a.TopSurface = 10
	local distance = (root.CFrame.p - position).magnitude
	a.Size = Vector3.new(0.1, 0.1, 0.1)
	a.CFrame = CFrame.new(sorb.CFrame.p, position) * CFrame.new(0, 0, 0)
				 local lb = Instance.new("Part")
  lb.Parent = char
    lb.BrickColor = origcolor
     lb.CanCollide = false
lb.Material = "Neon"
     lb.Anchored = true
lb.TopSurface = 0
        lb.BottomSurface = 0
     lb.Transparency = 1
     lb.Size = vt(0.5,0.5,0.5)
     lb.CFrame = a.CFrame
lb.Anchored = false
local thingery = Instance.new("SpecialMesh",lb)
     thingery.MeshType = "Sphere"
thingery.Scale = vt(2.5,2.5,2.5)
game:GetService("Debris"):AddItem(lb, 3)
  local bv = Instance.new("BodyVelocity")
  bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
  bv.velocity = a.CFrame.lookVector*250*1.5
  bv.Parent = lb
local hitted = false
game:GetService("Debris"):AddItem(a, 0.1)
coroutine.resume(coroutine.create(function()
while wait() do
if hitted == false or lb.Parent ~= nil then
MagicShockTrailAlt(lb.BrickColor,lb.CFrame + lb.CFrame.lookVector*-1,2.5,2.5,22.5*1.5,-0.125,-0.125,0.075,math.random(1,2))
end
if hitted == true or lb.Parent == nil then
break
end
end
end))
wait(0.01)
lb.Touched:connect(function(hit) 
	if hitted == false then
		hitted = true
		lb.Anchored = true
		lb.Transparency = 1
ExplodeShort(3.5,lb,1,2.5,15,42)
	end
end)
	for i = 0,1,0.5 do
		swait()
		MagicBlock(origcolor,sorb.CFrame,1,1,1,0.05,0.05,0.05,0.05)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(90)),0.5)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(0),math.rad(-90)),.5)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(120)), 0.5)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-20)), 0.5)
	end
	attack = false
end

function crystalinestring()
	attack = true
	for i = 0,2,0.1 do
		swait()
		MagicBlock(origcolor,sorb.CFrame,1,1,1,0.05,0.05,0.05,0.05)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(80)),0.3)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(0),math.rad(-80)),.3)
             RW.C0 = clerp(RW.C0, CFrame.new(1.05, 0.5,- 0.5) * angles(math.rad(0), math.rad(0), math.rad(-120)), 0.3)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-20)), 0.3)
	end
	CFuncs["Sound"].Create("rbxassetid://240429289", sorb, 2.5, 0.85)
							local a = Instance.new("Part",Character)
	a.Name = "Direction"	
	a.Anchored = true
	a.BrickColor = bc("Bright red")
a.Material = "Neon"
a.Transparency = 1
	a.CanCollide = false
	local ray = Ray.new(
	    sorb.CFrame.p,                           -- origin
	    (mouse.Hit.p - sorb.CFrame.p).unit * 500 -- direction
	) 
	local ignore = Character
	local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
	a.BottomSurface = 10
	a.TopSurface = 10
	local distance = (root.CFrame.p - position).magnitude
	a.Size = Vector3.new(0.1, 0.1, 0.1)
	a.CFrame = CFrame.new(sorb.CFrame.p, position) * CFrame.new(0, 0, 0)
				 local lb = Instance.new("Part")
  lb.Parent = char
    lb.BrickColor = origcolor
     lb.CanCollide = false
lb.Material = "Neon"
     lb.Anchored = true
lb.TopSurface = 0
        lb.BottomSurface = 0
     lb.Transparency = 0
     lb.Size = vt(0.5,0.5,0.5)
     lb.CFrame = a.CFrame
lb.Anchored = false
local thingery = Instance.new("SpecialMesh",lb)
     thingery.MeshType = "FileMesh"
thingery.MeshId = "http://www.roblox.com/Asset/?id=9756362"
thingery.Scale = vt(2,2,5)
game:GetService("Debris"):AddItem(lb, 3)
  local bv = Instance.new("BodyVelocity")
  bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
  bv.velocity = a.CFrame.lookVector*250/2.5
  bv.Parent = lb
local hitted = false
game:GetService("Debris"):AddItem(a, 0.1)
coroutine.resume(coroutine.create(function()
while wait() do
if hitted == false or lb.Parent ~= nil then
MagicShockTrailAlt(lb.BrickColor,lb.CFrame + lb.CFrame.lookVector*-1,2.5,2.5,22.5/2.5,0.5,0.5,0.05,math.random(1,2))
end
if hitted == true or lb.Parent == nil then
break
end
end
end))
wait(0.01)
lb.Touched:connect(function(hit) 
	if hitted == false then
		hitted = true
		lb.Anchored = true
		lb.Transparency = 1
Swarmsplosions(-25,25,lb,10,15)
	end
end)
	for i = 0,1,0.1 do
		swait()
		MagicBlock(origcolor,sorb.CFrame,1,1,1,0.05,0.05,0.05,0.05)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(-50)),0.3)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(20),math.rad(0),math.rad(50)),.3)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(-10), math.rad(0), math.rad(50)), 0.3)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-50)), 0.3)
	end
	attack = false
end

function endoftheworld()
attack = true
local lb = Instance.new("Part")
  lb.Parent = char
    lb.BrickColor = BrickColor.new("Really black")
     lb.CanCollide = false
lb.Material = "Neon"
     lb.Anchored = true
lb.TopSurface = 0
        lb.BottomSurface = 0
     lb.Transparency = 0.5
     lb.Size = vt(0.1,0.1,0.1)
     lb.CFrame = mouse.Hit
local lbo = lb:Clone()
lbo.Position = lb.Position
lbo.Parent = char
local thingery = Instance.new("SpecialMesh",lb)
     thingery.MeshType = "Sphere"
thingery.Scale = vt(2.5*10,50000*10,2.5*10)
local bon = Instance.new("ParticleEmitter",lb)
bon.Texture = "http://www.roblox.com/asset/?id=874580939"
bon.LightEmission = 0
bon.Color = ColorSequence.new(Color3.new(0,0,0))
bon.Rate = 50
bon.Lifetime = NumberRange.new(2.5)
bon.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,100,0),NumberSequenceKeypoint.new(1,0,0)})
bon.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.25,0),NumberSequenceKeypoint.new(1,1,0)})
bon.Speed = NumberRange.new(1)
bon.LockedToPart = true
bon.Rotation = NumberRange.new(-500,500)
bon.VelocitySpread = 90000
bon.RotSpeed = NumberRange.new(-500,500)
CFuncs["Sound"].Create("rbxassetid://159882578", char, 1, 0.75)
CFuncs["Sound"].Create("rbxassetid://289315275", char, 1, 0.75)
MagicBlock(BrickColor.new("Really black"),lb.CFrame,420,420,420,0,0,0,0.01)
for i = 0,5,0.1 do
		swait()
thingery.Scale = thingery.Scale + vt(2.5*10,0,2.5*10)
		MagicBlock(BrickColor.new("Really red"),sorb.CFrame,1,1,1,0.05,0.05,0.05,0.05)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(-90)),0.1)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(20),math.rad(0),math.rad(90)),.1)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(90)), 0.1)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), 0.1)
	end
for i = 0,2,0.1 do
		swait()
		MagicBlock(BrickColor.new("Really red"),sorb.CFrame,1,1,1,0.05,0.05,0.05,0.05)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(90)),0.3)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(40),math.rad(0),math.rad(-90)),.3)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(120)), 0.3)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-30)), 0.3)
	end
lb.BrickColor = BrickColor.new("Really red")
bon.Enabled = false
local seen = Instance.new("Sound",char)
seen.SoundId = "rbxassetid://445796828"
seen.Pitch = 0.75
seen.Volume = 1
seen.Looped = true
seen:Play()
MagicBlock(BrickColor.new("Really black"),sorb.CFrame,1,1,1,3,3,3,0.1)
MagicBlock(BrickColor.new("Really red"),lb.CFrame,1,1,1,250,250,250,0.1)
lb.Transparency = 0
CFuncs["Sound"].Create("rbxassetid://215395388", char, 1, 0.85)
CFuncs["Sound"].Create("rbxassetid://446876721", char, 0.5, 0.5)
CFuncs["Sound"].Create("rbxassetid://289315275", char, 1, 0.75)
coroutine.resume(coroutine.create(function()
for i = 0, 359 do
swait()
MagniDamage(lb, 150, 10,50, 0, "Normal")
MagicBlock(BrickColor.new("Really red"),lb.CFrame,1,1,1,25,25,25,0.05)
lb.Position = lbo.Position + Vector3.new(math.random(-1,1),0,math.random(-1,1))
end
for i = 0, 49 do
swait()
seen.Volume = seen.Volume - 0.02
lb.Transparency = lb.Transparency + 0.02
lb.Position = lbo.Position + Vector3.new(math.random(-1,1),0,math.random(-1,1))
end
seen:Destroy()
lb:Destroy()
lbo:Destroy()
end))
attack = false
end

function areabul()
	attack = true
	for i = 0,2,0.1 do
		swait()
		MagicBlock(origcolor,sorb.CFrame,1,1,1,0.05,0.05,0.05,0.05)
		MagicBlock(origcolor,sorb2.CFrame,1,1,1,0.05,0.05,0.05,0.05)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(30)),0.3)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(10),math.rad(0),math.rad(-15)),.3)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0.25) * angles(math.rad(0), math.rad(110), math.rad(70)), 0.3)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.25, 0.5, -0.5) * angles(math.rad(0), math.rad(40), math.rad(80)), 0.3)
	end
	for i = 0,2,0.1 do
		swait()
		MagicBlock(origcolor,sorb.CFrame,2,2,2,0.05,0.05,0.05,0.05)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(90)),0.3)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(5),math.rad(0),math.rad(-90)),.3)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(90)), 0.3)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-20)), 0.3)
	end
	CFuncs["Sound"].Create("rbxassetid://240429289", sorb, 2.5, 0.85)
							local a = Instance.new("Part",Character)
	a.Name = "Direction"	
	a.Anchored = true
	a.BrickColor = bc("Bright red")
a.Material = "Neon"
a.Transparency = 1
	a.CanCollide = false
	local ray = Ray.new(
	    sorb.CFrame.p,                           -- origin
	    (mouse.Hit.p - sorb.CFrame.p).unit * 500 -- direction
	) 
	local ignore = Character
	local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
	a.BottomSurface = 10
	a.TopSurface = 10
	local distance = (root.CFrame.p - position).magnitude
	a.Size = Vector3.new(0.1, 0.1, 0.1)
	a.CFrame = CFrame.new(sorb.CFrame.p, position) * CFrame.new(0, 0, 0)
				 local lb = Instance.new("Part")
  lb.Parent = char
    lb.BrickColor = origcolor
     lb.CanCollide = false
lb.Material = "Neon"
     lb.Anchored = true
lb.TopSurface = 0
        lb.BottomSurface = 0
     lb.Transparency = 1
     lb.Size = vt(0.5,0.5,0.5)
     lb.CFrame = a.CFrame
lb.Anchored = false
local thingery = Instance.new("SpecialMesh",lb)
     thingery.MeshType = "Sphere"
thingery.Scale = vt(2.5,2.5,2.5)
game:GetService("Debris"):AddItem(lb, 3)
  local bv = Instance.new("BodyVelocity")
  bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
  bv.velocity = a.CFrame.lookVector*250/2
  bv.Parent = lb
local hitted = false
MagicShockTrailAlt(origcolor,lb.CFrame,1,1,0.1,1,1,0.075,math.random(1,2))
game:GetService("Debris"):AddItem(a, 0.1)
coroutine.resume(coroutine.create(function()
while wait() do
if hitted == false or lb.Parent ~= nil then
MagicShockTrailAlt(lb.BrickColor,lb.CFrame + lb.CFrame.lookVector*-1,2.5*1.,2.5*1.5,22.5/2,0,0,0.075,math.random(1,2))
end
if hitted == true or lb.Parent == nil then
break
end
end
end))
wait(0.01)
lb.Touched:connect(function(hit) 
	if hitted == false then
		hitted = true
		lb.Anchored = true
		lb.Transparency = 1
AreaDanger(25,lb,12,18)
	end
end)
	for i = 0,2,0.1 do
		swait()
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(90)),0.3)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(0),math.rad(-90)),.3)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(120)), 0.3)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-20)), 0.3)
	end
	attack = false
end

local transforming = false
local transformed = false


function ignorance(par)
	local look = Instance.new("Part",char)
	look.Transparency = 1
	look.Anchored = true
	look.CanCollide = false
	look.CFrame = par.CFrame
	local lookam = 0
	for i = 0, 9 do
		lookam = lookam + 10
	local expart = Instance.new("Part",char)
	expart.Transparency = 1
	expart.Anchored = true
	expart.CanCollide = false
	expart.CFrame = look.CFrame + vt(0,-3,0) + look.CFrame.lookVector*lookam
	for i = 0, 9 do
		MagicShockTrailAlt2(origcolor,expart.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),10/5,10/5,5,-0.05/5,-0.05/5,5,0.05,math.random(1,2))
	end
	MagniDamage(expart, 10, 9, 20, 0, "Normal")
CFuncs["Sound"].Create("rbxassetid://588737825", expart,1,2)
CFuncs["Sound"].Create("rbxassetid://231917784", expart,1.5,1.15)
MagicShockTrailAlt(origcolor,look.CFrame + look.CFrame.lookVector*5,10,10,1,1,1,0.05,math.random(1,2))
MagicShockTrailAlt(origcolor,expart.CFrame*CFrame.Angles(math.rad(90),0,0),10,10,1,1,1,0.05,math.random(1,2))
MagicShockTrailAlt2(origcolor,expart.CFrame*CFrame.Angles(math.rad(90),0,0),10,10,1,-0.01,-0.01,10,0.05,math.random(1,2))
game:GetService("Debris"):AddItem(expart, 2)
game:GetService("Debris"):AddItem(expart, 2)
wait(0.1)
	end
look:Destroy()
end

function groond()
	attack = true
	transforming = true
	for i = 0,2,0.1 do
		swait()
		MagicBlock(origcolor,sorb.CFrame,2,2,2,0.05,0.05,0.05,0.05)
		MagicBlock(origcolor,sorb2.CFrame,2,2,2,0.05,0.05,0.05,0.05)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,-2)* angles(math.rad(80),math.rad(0),math.rad(0)),0.3)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-10),math.rad(0),math.rad(0)),.3)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(20)), 0.3)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-20)), 0.3)
RH.C0=clerp(RH.C0,cf(1,-0.05 - 0.05 * math.cos(sine / 25),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.3)
LH.C0=clerp(LH.C0,cf(-1,-0.15 - 0.05 * math.cos(sine / 25),-0.5)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(20)),.3)
	end
	for i = 0,2,0.1 do
		swait()
		MagicBlock(origcolor,sorb.CFrame,2,2,2,0.05,0.05,0.05,0.05)
		MagicBlock(origcolor,sorb2.CFrame,2,2,2,0.05,0.05,0.05,0.05)
		RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-10),math.rad(0),math.rad(0)),.3)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(170), math.rad(0), math.rad(20)), 0.3)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(170), math.rad(0), math.rad(-20)), 0.3)
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
	end
	transforming = false
	attack = false
	ignorance(root)
end

function tran()
	hum.WalkSpeed = 0
	hum.JumpPower = 0
	attack = true
	transforming = true
	transformed = true
	hum.MaxHealth = math.huge
	CFuncs["Sound"].Create("rbxassetid://588718963", root, 1, 1)
	for i = 0,5,0.1 do
		swait()
		MagicShockTrailAlt(origcolor,root.CFrame*CFrame.new(0,5,0)*CFrame.Angles(math.rad(90),0,0),1,1,0.1,1,1,0.05,math.random(1,2))
		RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.1)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.1)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(80)),0.1)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-30),math.rad(0),math.rad(-80)),.1)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(190)), 0.1)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(20)), 0.1)
	end
	CFuncs["Sound"].Create("rbxassetid://231917784", root, 1,0.5)
	CFuncs["Sound"].Create("rbxassetid://588737825", root, 0.25, 0.25)
	CFuncs["Sound"].Create("rbxassetid://588737825", root, 0.5, 2)
	CFuncs["Sound"].Create("rbxassetid://233856106", root, 1, 1)
	MagicBlock(origcolor,root.CFrame*CFrame.new(0,5,0),2,2,2,1,1,1,0.1)
	for i = 0,10,0.1 do
		swait()
		MagicBlock(origcolor,sorb.CFrame,2,2,2,0.05,0.05,0.05,0.05)
		RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.2)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(30)),0.2)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(10),math.rad(0),math.rad(-30)),.2)
             RW.C0 = clerp(RW.C0, CFrame.new(1.25, 0.5, -0.25) * angles(math.rad(0), math.rad(110), math.rad(110)), 0.2)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(20)), 0.2)
	end
	for i = 0,5,0.1 do
		swait()
		MagicBlock(origcolor,sorb.CFrame,2,2,2,0.05,0.05,0.05,0.05)
		RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.2)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(0)),0.2)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-10),math.rad(0),math.rad(-30)),.2)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(170)), 0.2)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(20)), 0.2)
	end
	MagicBlock(origcolor,sorb.CFrame,2,2,2,5,5,5,0.05)
	CFuncs["Sound"].Create("rbxassetid://231917784", root, 1,0.5)
	CFuncs["Sound"].Create("rbxassetid://588737825", root, 0.5, 2)
	CFuncs["Sound"].Create("rbxassetid://233856106", root, 1, 1)
	for i = 0,2.5,0.1 do
		swait()
		MagicShockTrailAlt2(origcolor,root.CFrame*CFrame.new(math.random(-25,25),-3,math.random(-25,25))*CFrame.Angles(math.rad(90),0,0),1,1,5,-0.01,-0.01,10,0.05,math.random(1,2))
				RH.C0=clerp(RH.C0,cf(1,-0.25, -0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-20)),.3)
LH.C0=clerp(LH.C0,cf(-1,-0.25,-0.5)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(20)),.3)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,1)* angles(math.rad(20),math.rad(0),math.rad(0)),0.3)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(20),math.rad(0),math.rad(-0)),.3)
             RW.C0 = clerp(RW.C0, CFrame.new(1.05, 0.5, -0.25) * angles(math.rad(0), math.rad(-50), math.rad(-120)), 0.3)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.05, 0.5, -0.25) * angles(math.rad(0), math.rad(50), math.rad(120)), 0.3)
	end
	MagicBlock(origcolor,tors.CFrame,2,2,2,5,5,5,0.05)
	CFuncs["Sound"].Create("rbxassetid://231917784", root, 1,0.75)
	CFuncs["Sound"].Create("rbxassetid://588737825", root, 1.5, 0.25)
	CFuncs["Sound"].Create("rbxassetid://588737825", root, 1, 0.225)
	local sphscale = 1
	for i = 0,25,0.1 do
		swait()
		MagicShockTrailAlt2(origcolor,root.CFrame*CFrame.new(math.random(-25,25),-3,math.random(-25,25))*CFrame.Angles(math.rad(90),0,0),1,1,5,-0.01,-0.01,10,0.05,math.random(1,2))
		sphscale = sphscale + 0.05
		MagicShockTrailAlt(origcolor,root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(90),0,0),1,1,0.1,1*sphscale/5,1*sphscale/5,0.025,math.random(1,2))
		MagicBlock(origcolor,tors.CFrame,sphscale,sphscale,sphscale,0.05,0.05,0.05,0.05)
		RH.C0=clerp(RH.C0,cf(1,-1, 0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-20)),.05)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(20)),.05)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,2)* angles(math.rad(-20),math.rad(0),math.rad(0)),0.05)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-20),math.rad(0),math.rad(-0)),.05)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(60)), 0.05)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(-60)), 0.05)
	end
	CFuncs["Sound"].Create("rbxassetid://588737825", root, 3, 0.25)
	MagicBlock(origcolor,sorb.CFrame,sphscale,sphscale,sphscale,5,5,5,0.1)
	for z = 0, 9 do
		MagniDamageWithEffect(root, 25, 3, 6, 0, "Normal")
		CFuncs["Sound"].Create("rbxassetid://231917784", root, 2.5,0.75)
		CFuncs["Sound"].Create("rbxassetid://240429289", root, 5, 0.2)
		MagicBlock(origcolor,tors.CFrame,sphscale,sphscale,sphscale,5,5,5,0.1)
	for i = 0,5,0.1 do
		swait()
		MagicShockTrailAlt2(origcolor,root.CFrame*CFrame.new(math.random(-25,25),-3,math.random(-25,25))*CFrame.Angles(math.rad(90),0,0),1,1,5,-0.01,-0.01,10,0.05,math.random(1,2))
		MagicBlock(origcolor,tors.CFrame,sphscale,sphscale,sphscale,0.05,0.05,0.05,0.05)
		MagicShockTrailAlt(origcolor,root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(90),0,0),1,1,0.1,1*sphscale/5,1*sphscale/5,0.025,math.random(1,2))
		RH.C0=clerp(RH.C0,cf(1,-0.25, -0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-20)),.3)
LH.C0=clerp(LH.C0,cf(-1,-0.25,-0.5)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(20)),.3)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,2)* angles(math.rad(20),math.rad(0),math.rad(0)),0.3)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(20),math.rad(0),math.rad(-0)),.3)
             RW.C0 = clerp(RW.C0, CFrame.new(1.05, 0.5, -0.25) * angles(math.rad(0), math.rad(-50), math.rad(-120)), 0.3)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.05, 0.5, -0.25) * angles(math.rad(0), math.rad(50), math.rad(120)), 0.3)
	end
	end
	CFuncs["Sound"].Create("rbxassetid://136007472", root, 2, 0.7)
	for i = 0,20,0.1 do
		swait()
		MagicShockTrailAlt2(origcolor,root.CFrame*CFrame.new(math.random(-25,25),-3,math.random(-25,25))*CFrame.Angles(math.rad(90),0,0),1,1,5,-0.01,-0.01,10,0.05,math.random(1,2))
		MagicShockTrailAlt2(origcolor,tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,-0.01,-0.01,5,0.025,math.random(1,2))
		MagicBlock(origcolor,tors.CFrame,sphscale,sphscale,sphscale,0.05,0.05,0.05,0.05)
		MagicShockTrailAlt(origcolor,root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(90),0,0),1,1,0.1,1*sphscale/5,1*sphscale/5,0.025,math.random(1,2))
		RH.C0=clerp(RH.C0,cf(1,-0.25, -0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-20)),.3)
LH.C0=clerp(LH.C0,cf(-1,-0.25,-0.5)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(20)),.3)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,2)* angles(math.rad(20),math.rad(0),math.rad(0)),0.3)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(20),math.rad(0),math.rad(-0)),.3)
             RW.C0 = clerp(RW.C0, CFrame.new(1.05, 0.5, -0.25) * angles(math.rad(0), math.rad(-50), math.rad(-120)), 0.3)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.05, 0.5, -0.25) * angles(math.rad(0), math.rad(50), math.rad(120)), 0.3)
	end
	---- Change?
	--   [yes] [no] [maybe]
	-- if you want it then ok:

	---- okay then
	-- ill be leaving this around
	MagicBlock(origcolor,tors.CFrame,sphscale,sphscale,sphscale,0.5,0.5,0.5,0.005)
	MagicBlock(origcolor,tors.CFrame,sphscale,sphscale,sphscale,0.5,0.5,0.5,0.005)
	CFuncs["Sound"].Create("rbxassetid://588737825", root, 2.5, 0.5)
	CFuncs["Sound"].Create("rbxassetid://231917784", root, 5,0.5)
	CFuncs["Sound"].Create("rbxassetid://231917744", root, 5,0.5)
	CFuncs["Sound"].Create("rbxassetid://233856106", root, 5, 0.5)
			MagniDamageWithEffect(root, 150, 35, 49, 0, "Normal")
	for i = 0, 24 do
		MagicShockTrailAlt2(origcolor,tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),10,10,5,-0.05,-0.05,25,0.005,math.random(1,2))
	end
	for i = 0,15,0.1 do
		swait()
		RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-10),math.rad(0),math.rad(-30)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-10),math.rad(0),math.rad(20)),.3)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,2.5)* angles(math.rad(-20),math.rad(0),math.rad(0)),0.3)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-20),math.rad(0),math.rad(-0)),.3)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(-10), math.rad(0), math.rad(30)), 0.3)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(-10), math.rad(0), math.rad(-30)), 0.3)
	end
	hum.WalkSpeed = 16
	hum.JumpPower = 50
	attack = false
	transforming = false
	hum.MaxHealth = 5000
end

local exterminated = false

function extermination()
	attack = true
	exterminated = true
	for i = 0,8,0.1 do
		swait()
		MagicBlock(origcolor,sorb.CFrame,1,1,1,0.015,0.015,0.015,0.05)
           RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(80)),0.1)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(0),math.rad(-80)),.1)
             RW.C0 = clerp(RW.C0, CFrame.new(1.05, 0.5,- 0.5) * angles(math.rad(0), math.rad(0), math.rad(-120)), 0.1)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-20)), 0.1)
	end
	CFuncs["Sound"].Create("rbxassetid://577874115", root, 1, 1)
	for i = 0,50,0.1 do
		swait()
		MagicBlock(origcolor,sorb.CFrame,5,5,5,0.075,0.075,0.075,0.05)
		MagicShockTrailAlt2(origcolor,sorb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,1,-0.025,-0.025,5,0.05,math.random(1,2))
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(90)),0.3)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(5),math.rad(0),math.rad(-90)),.3)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(90)), 0.3)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-20)), 0.3)
	end
								local a = Instance.new("Part",Character)
	a.Name = "Direction"	
	a.Anchored = true
	a.BrickColor = bc("Bright red")
a.Material = "Neon"
a.Transparency = 1
	a.CanCollide = false
	local ray = Ray.new(
	    sorb.CFrame.p,                           -- origin
	    (mouse.Hit.p - sorb.CFrame.p).unit * 500 -- direction
	) 
	local ignore = Character
	local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
	a.BottomSurface = 10
	a.TopSurface = 10
	local distance = (root.CFrame.p - position).magnitude
	a.Size = Vector3.new(0.1, 0.1, 0.1)
	a.CFrame = CFrame.new(sorb.CFrame.p, position) * CFrame.new(0, 0, 0)
				 local lb = Instance.new("Part")
				CFuncs["Sound"].Create("rbxassetid://144140670", lb, 10, 1)
  lb.Parent = char
    lb.BrickColor = origcolor
     lb.CanCollide = false
lb.Material = "Neon"
     lb.Anchored = true
lb.TopSurface = 0
        lb.BottomSurface = 0
     lb.Transparency = 1
     lb.Size = vt(0.5,0.5,0.5)
     lb.CFrame = a.CFrame
lb.Anchored = false
local thingery = Instance.new("SpecialMesh",lb)
     thingery.MeshType = "Sphere"
thingery.Scale = vt(2.5,2.5,2.5)
game:GetService("Debris"):AddItem(lb, 15)
  local bv = Instance.new("BodyVelocity")
  bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
  bv.velocity = a.CFrame.lookVector*250/2
  bv.Parent = lb
local hitted = false
MagicShockTrailAlt(origcolor,lb.CFrame,1,1,0.1,1,1,0.075,math.random(1,2))
game:GetService("Debris"):AddItem(a, 0.1)
coroutine.resume(coroutine.create(function()
while wait() do
if hitted == false or lb.Parent ~= nil then
MagicShockTrailAlt(lb.BrickColor,lb.CFrame + lb.CFrame.lookVector*-1,2.5*10,2.5*10,22.5/2,-0.5,-0.5,0.025,math.random(1,2))
end
if hitted == true or lb.Parent == nil then
	exterminated = false
break
end
end
end))
wait(0.01)
lb.Touched:connect(function(hit) 
	if hitted == false then
		hitted = true
		lb.Anchored = true
		lb.Transparency = 1
		EXterPlosion(lb)
	end
end)
	attack = false
end


function RingEffect(pos,startsize,size,col)
local lb = Instance.new("Part")
  lb.Parent = char
    lb.BrickColor = col
     lb.CanCollide = false
lb.Material = "Neon"
     lb.Anchored = true
lb.TopSurface = 0
        lb.BottomSurface = 0
     lb.Transparency = 1
     lb.Size = vt(1,1,1)
     lb.CFrame = pos
local thingery = Instance.new("SpecialMesh",lb)
     thingery.MeshType = "Brick"
thingery.Scale = vt(startsize,0.1,startsize)
local dec2 = Instance.new("Decal", lb)
dec2.Face = "Top"
dec2.Texture = "http://www.roblox.com/asset/?id=874580939"
dec2.Color3 = lb.Color
dec2.Parent = lb
local dec2b = dec2:Clone()
dec2b.Face = "Bottom"
dec2b.Parent = lb
local randomrot = math.random(1,2)
coroutine.resume(coroutine.create(function()
for i = 0, 19 do
swait()
if randomrot == 1 then
lb.CFrame = lb.CFrame*CFrame.new(0,math.rad(5),0)
elseif randomrot == 2 then
lb.CFrame = lb.CFrame*CFrame.new(0,math.rad(-5),0)
end
dec2.Transparency = dec2.Transparency + 0.05
dec2b.Transparency = dec2b.Transparency + 0.05
thingery.Scale = thingery.Scale + vt(size,0,size)
end
lb:Destroy()
end))
end

function SlowRingEffect(pos,startsize,size,col)
local lb = Instance.new("Part")
  lb.Parent = char
    lb.BrickColor = col
     lb.CanCollide = false
lb.Material = "Neon"
     lb.Anchored = true
lb.TopSurface = 0
        lb.BottomSurface = 0
     lb.Transparency = 1
     lb.Size = vt(1,1,1)
     lb.CFrame = pos
local thingery = Instance.new("SpecialMesh",lb)
     thingery.MeshType = "Brick"
thingery.Scale = vt(startsize,0.1,startsize)
local dec2 = Instance.new("Decal", lb)
dec2.Face = "Top"
dec2.Texture = "http://www.roblox.com/asset/?id=874580939"
dec2.Color3 = lb.Color
dec2.Parent = lb
local dec2b = dec2:Clone()
dec2b.Face = "Bottom"
dec2b.Parent = lb
local randomrot = math.random(1,2)
coroutine.resume(coroutine.create(function()
for i = 0, 49 do
swait()
if randomrot == 1 then
lb.CFrame = lb.CFrame*CFrame.new(0,math.rad(5),0)
elseif randomrot == 2 then
lb.CFrame = lb.CFrame*CFrame.new(0,math.rad(-5),0)
end
dec2.Transparency = dec2.Transparency + 0.02
dec2b.Transparency = dec2b.Transparency + 0.02
thingery.Scale = thingery.Scale + vt(size,0,size)
end
lb:Destroy()
end))
end


function groundringaa(pos)
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = origcolor
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 1
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshId = "http://www.roblox.com/asset/?id=3270017"
rngm.Scale = Vector3.new(100,100,5)
local scaler2 = -10/2
coroutine.resume(coroutine.create(function()
for i = 0,10,0.1 do
swait()
scaler2 = scaler2 + 0.1/2
rng.Transparency = rng.Transparency - 0.01
rngm.Scale = rngm.Scale + Vector3.new(scaler2/2.5, scaler2/2.5, 0)
end
rng:Destroy()
end))
end

function groundringbb(pos)
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = origcolor
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos.CFrame - Vector3.new(0,2.5,0)
rng.CFrame = rng.CFrame *CFrame.Angles(math.rad(90),0,0)
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshId = "http://www.roblox.com/asset/?id=3270017"
rngm.Scale = Vector3.new(0,0,5)
local scaler2 = 10
coroutine.resume(coroutine.create(function()
for i = 0,10*2,0.1 do
swait()
scaler2 = scaler2 - 0.1/2
rng.Transparency = rng.Transparency + 0.005
rngm.Scale = rngm.Scale + Vector3.new(scaler2/2.5, scaler2/2.5, scaler2)
end
rng:Destroy()
end))
end

function groundglowaa(pos)
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = origcolor
        rng.CanCollide = false
        rng.FormFactor = 3
rng.Material = "Neon"
        rng.Name = "Ring"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos.CFrame - Vector3.new(0,2.5,0)
rng.CFrame = rng.CFrame *CFrame.Angles(math.rad(90),0,0)
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = Vector3.new(0,0,25)
local scaler2 = 10*2
coroutine.resume(coroutine.create(function()
for i = 0,10*2,0.1 do
swait()
scaler2 = scaler2 - 0.1*2/2
rng.Transparency = rng.Transparency + 0.005
rngm.Scale = rngm.Scale + Vector3.new(scaler2/2.5, scaler2/2.5, 0)
end
rng:Destroy()
end))
end

function bemaa(pos)
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = origcolor
        rng.CanCollide = false
        rng.FormFactor = 3
rng.Material = "Neon"
        rng.Name = "Ring"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos.CFrame - Vector3.new(0,2.5,0)
rng.CFrame = rng.CFrame *CFrame.Angles(math.rad(90),0,0)
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = Vector3.new(0,0,10000)
local scaler2 = 1
coroutine.resume(coroutine.create(function()
for i = 0,99,0.1 do
swait()
scaler2 = scaler2 - 0.0025
rng.Transparency = rng.Transparency + 0.0025
rngm.Scale = rngm.Scale + Vector3.new(scaler2/5, scaler2/5, 0)
end
rng:Destroy()
end))
end

function bemaashake(pos)
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = origcolor
        rng.CanCollide = false
        rng.FormFactor = 3
rng.Material = "Neon"
        rng.Name = "Ring"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos.CFrame - Vector3.new(0,2.5,0)
rng.CFrame = rng.CFrame *CFrame.Angles(math.rad(90),0,0)
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
local oof = Instance.new("Part",char)
oof.Parent = rng
oof.CFrame = rng.CFrame
oof.CanCollide = false
oof.Anchored = true
oof.Transparency = 1
rngm.Scale = Vector3.new(0,0,10000)
local scaler2 = 1*10
coroutine.resume(coroutine.create(function()
for i = 0,99,0.1 do
swait()
scaler2 = scaler2 - 0.0025*10
rng.CFrame = oof.CFrame + Vector3.new(math.random(-1,1),0,math.random(-1,1))
rng.Transparency = rng.Transparency + 0.0025
rngm.Scale = rngm.Scale + Vector3.new(scaler2/5, scaler2/5, 0)
end
rng:Destroy()
end))
end

function groundringlarge(pos)
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = origcolor
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos.CFrame - Vector3.new(0,2.5,0)
rng.CFrame = rng.CFrame *CFrame.Angles(math.rad(90),0,0)
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshId = "http://www.roblox.com/asset/?id=3270017"
rngm.Scale = Vector3.new(0,0,5)
local scaler2 = 10*10
coroutine.resume(coroutine.create(function()
for i = 0,10*2,0.1 do
swait()
scaler2 = scaler2 - 0.1*10/2
rng.Transparency = rng.Transparency + 0.005
rngm.Scale = rngm.Scale + Vector3.new(scaler2/2.5, scaler2/2.5, scaler2)
end
rng:Destroy()
end))
end

function yayballs()
attack = true
for i = 0,1,0.1 do
		swait()
		MagicBlock(origcolor,sorb.CFrame,0.5,0.5,0.5,0.05,0.05,0.05,0.05)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(-5),math.rad(0),math.rad(0)),0.3)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(0),math.rad(0)),.3)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(170), math.rad(0), math.rad(10)), 0.3)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
	end
	CFuncs["Sound"].Create("rbxassetid://18426149", sorb, 1, 1)
							local a = Instance.new("Part",Character)
	a.Name = "Direction"	
	a.Anchored = true
	a.BrickColor = bc("Bright red")
a.Material = "Neon"
a.Transparency = 1
	a.CanCollide = false
	local ray = Ray.new(
	    sorb.CFrame.p,                           -- origin
	    (mouse.Hit.p - sorb.CFrame.p).unit * 500 -- direction
	) 
	local ignore = Character
	local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
	a.BottomSurface = 10
	a.TopSurface = 10
	local distance = (root.CFrame.p - position).magnitude
	a.Size = Vector3.new(0.1, 0.1, 0.1)
	a.CFrame = CFrame.new(sorb.CFrame.p, position) * CFrame.new(0, 0, 0)
				 local lb = Instance.new("Part")
  lb.Parent = char
    lb.BrickColor = origcolor
lb.Material = "Neon"
     lb.Anchored = true
lb.TopSurface = 0
lb.Shape = "Ball"
        lb.BottomSurface = 0
     lb.Transparency = 0
     lb.Size = vt(2.5,2.5,2.5)
     lb.CFrame = a.CFrame
lb.Anchored = false
  local bv = Instance.new("BodyVelocity")
  bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
  bv.velocity = a.CFrame.lookVector*100
  bv.Parent = lb
local hitted = false
game:GetService("Debris"):AddItem(a, 0.1)
wait(0.01)
bv:Destroy()
game:GetService("Debris"):AddItem(lb, 10)
	for i = 0,1,0.1 do
		swait()
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(5),math.rad(0),math.rad(0)),0.3)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(0),math.rad(0)),.3)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(50), math.rad(0), math.rad(10)), 0.3)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
	end
	attack = false
end

function crates()
attack = true
for i = 0,2,0.1 do
		swait()
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(0)),1)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(0),math.rad(0)),1)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(170), math.rad(0), math.rad(10)), 1)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(170), math.rad(0), math.rad(-10)), 1)
	end
	CFuncs["Sound"].Create("rbxassetid://18426149", sorb, 1, 1)
local randomsize = math.random(5,250)
print(randomsize)
				 local lb = Instance.new("Part")
  lb.Parent = workspace
    lb.BrickColor = BrickColor.random()
lb.Material = "WoodPlanks"
     lb.Anchored = true
lb.TopSurface = 0
        lb.BottomSurface = 0
     lb.Transparency = 0
     lb.Size = vt(randomsize,randomsize,randomsize)
     lb.CFrame = root.CFrame*CFrame.new(0,500,0) + root.CFrame.lookVector*250
lb.Anchored = false
local hitted = false
if randomsize >= 20 then
lb.Material = "Marble"
end
if randomsize >= 150 then
lb.Material = "Granite"
end
if randomsize >= 200 then
lb.Material = "Glass"
lb.Transparency = 0.5
end
coroutine.resume(coroutine.create(function()
if randomsize > 20 then
chatfunc("size " ..randomsize,BrickColor.random().Color)
end
end))
function onTouched(part)
if hitted == false then
	local humanoid = part.Parent:findFirstChild("Humanoid")
	if (humanoid ~=nil) then
hitted = true
		for i = 0, 99 do
swait()
lb.Transparency = lb.Transparency + 0.01
end
if randomsize > 20 then
for i = 0, 24 do
MagicBlock(lb.BrickColor,lb.CFrame*CFrame.new(math.random(randomsize*-1,randomsize),math.random(randomsize*-1,randomsize),math.random(randomsize*-1,randomsize)),1,1,1,0.05,0.05,0.05,0.0025)
end
if randomsize < 150 then
CFuncs["Sound"].Create("rbxassetid://402347142", lb, 10,0.65)
elseif randomsize >= 150 then
CFuncs["Sound"].Create("rbxassetid://402347142", char, 10,0.35)
end
Explode(randomsize/1.5,lb,10,0.5,randomsize*-2,randomsize*2)
end
MagicBlock(lb.BrickColor,lb.CFrame,randomsize/1.1,randomsize/1.1,randomsize/1.1,randomsize*-0.0005,randomsize*-0.0005,randomsize*-0.0005,0.0025)
lb.CanCollide = false
lb.Anchored = true
game:GetService("Debris"):AddItem(lb, 5)
	end
end
end
lb.Touched:connect(onTouched)
	attack = false
end

function notcoolm8()
attack = true
	for i = 0,1,0.1 do
		swait()
		MagicBlock(origcolor,sorb.CFrame,0.5,0.5,0.5,0.05,0.05,0.05,0.05)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(-5),math.rad(0),math.rad(0)),0.3)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(0),math.rad(0)),.3)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(170), math.rad(0), math.rad(10)), 0.3)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
	end
	CFuncs["Sound"].Create("rbxassetid://18426149", char, 1, 1)
							local a = Instance.new("Part",Character)
	a.Name = "Direction"	
	a.Anchored = true
	a.BrickColor = bc("Bright red")
a.Material = "Neon"
a.Transparency = 1
	a.CanCollide = false
	local ray = Ray.new(
	    sorb.CFrame.p,                           -- origin
	    (mouse.Hit.p - sorb.CFrame.p).unit * 500 -- direction
	) 
	local ignore = Character
	local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
	a.BottomSurface = 10
	a.TopSurface = 10
	local distance = (root.CFrame.p - position).magnitude
	a.Size = Vector3.new(0.1, 0.1, 0.1)
	a.CFrame = CFrame.new(sorb.CFrame.p, position) * CFrame.new(0, 0, 0)
				 local lb = Instance.new("Part")
  lb.Parent = char
    lb.BrickColor = origcolor
lb.Material = "Neon"
     lb.Anchored = true
lb.TopSurface = 0
        lb.BottomSurface = 0
     lb.Transparency = 0
     lb.Size = vt(1.5,1.5,1.5)
     lb.CFrame = a.CFrame
lb.Anchored = false
local thingery = Instance.new("SpecialMesh",lb)
     thingery.MeshType = "Sphere"
  local bv = Instance.new("BodyVelocity")
  bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
  bv.velocity = a.CFrame.lookVector*100
  bv.Parent = lb
local hitted = false
game:GetService("Debris"):AddItem(a, 0.1)
wait(0.01)
bv:Destroy()
coroutine.resume(coroutine.create(function()
wait(7.5)
CFuncs["Sound"].Create("rbxassetid://200633529", char, 10, 0.6)
for i = 0, 24 do
wait(0.1)
groundringaa(lb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))))
end
wait(2)
lb.Transparency = 1
lb.Rotation = Vector3.new(0,0,0)
CamShake(lb,175,0.5,50)
MagniDamage(lb, 175, 50,90, 0, "Normal")
CFuncs["Sound"].Create("rbxassetid://157878578", char, 10, 1)
CFuncs["Sound"].Create("rbxassetid://142070127", char, 10, 1)
CFuncs["Sound"].Create("rbxassetid://142070127", char, 10, 1)
CFuncs["Sound"].Create("rbxassetid://2248511", char, 10, 0.4)
CFuncs["Sound"].Create("rbxassetid://3264793", char, 10, 0.75)
CFuncs["Sound"].Create("rbxassetid://2767090", char, 10, 1)
CFuncs["Sound"].Create("rbxassetid://13775494", char, 10, 0.4)
CFuncs["Sound"].Create("rbxassetid://2691586", char, 10, 0.3)
CFuncs["Sound"].Create("rbxassetid://3264923", char, 10, 1.125)
CFuncs["Sound"].Create("rbxassetid://1369158", char, 10, 0.6)
CFuncs["Sound"].Create("rbxassetid://2974000", char, 10, 0.8)
CFuncs["Sound"].Create("rbxassetid://2801263", char, 10, 0.5)
groundringbb(lb)
groundglowaa(lb)
bemaa(lb)
wait(0.25)
CFuncs["LongSound"].Create("rbxassetid://2101137", char, 10, 0.1)
for i = 0, 19 do
wait(0.5)
groundringaa(lb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))))
end
wait(5)
CamShake(lb,1500,1.5,250)
groundringlarge(lb)
groundringbb(lb)
bemaashake(lb)
MagniDamage(lb, 9001, 100,10000, 0, "Normal")
MagicBlock(BrickColor.new("Dark indigo"),lb.CFrame,1,1,1,100,100,100,0.075)
CFuncs["Sound"].Create("rbxassetid://919941001", char, 5, 0.25)
CFuncs["Sound"].Create("rbxassetid://2248511", char, 10, 0.2)
wait(10)
lb:Destroy()
end))
	for i = 0,1,0.1 do
		swait()
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(5),math.rad(0),math.rad(0)),0.3)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(0),math.rad(0)),.3)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(50), math.rad(0), math.rad(10)), 0.3)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
	end
	attack = false
end

function NOTNORMAL()
	attack = true
local lb = Instance.new("Part")
  lb.Parent = char
    lb.BrickColor = BrickColor.new("Really black")
     lb.CanCollide = false
lb.Material = "Neon"
     lb.Anchored = true
lb.TopSurface = 0
        lb.BottomSurface = 0
     lb.Transparency = 1
     lb.Size = vt(0.5,0.5,0.5)
     lb.CFrame = sorb.CFrame
local thingery = Instance.new("SpecialMesh",lb)
     thingery.MeshType = "Sphere"
local bon = Instance.new("ParticleEmitter",lb)
bon.Texture = "http://www.roblox.com/asset/?id=874580939"
bon.LightEmission = 1
bon.Color = ColorSequence.new(Color3.new(255/255,255/255,255/255))
bon.Rate = 50
bon.Lifetime = NumberRange.new(2.5)
bon.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,thingery.Scale.X/4,0),NumberSequenceKeypoint.new(1,0,0)})
bon.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.65,0),NumberSequenceKeypoint.new(1,1,0)})
bon.Speed = NumberRange.new(1)
bon.LockedToPart = true
bon.Rotation = NumberRange.new(-500,500)
bon.VelocitySpread = 90000
bon.RotSpeed = NumberRange.new(-500,500)
local bona = Instance.new("ParticleEmitter",lb)
bona.Texture = "http://www.roblox.com/asset/?id=874580939"
bona.LightEmission = 1
bona.Color = ColorSequence.new(Color3.new(0/255,50/255,40/255))
bona.Rate = 50
bona.Lifetime = NumberRange.new(2.5)
bona.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,thingery.Scale.X/8,0),NumberSequenceKeypoint.new(1,thingery.Scale.X/9,0)})
bona.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.5,0),NumberSequenceKeypoint.new(1,0.75,0)})
bona.Speed = NumberRange.new(1)
bona.LockedToPart = true
bona.Rotation = NumberRange.new(-500,500)
bona.VelocitySpread = 90000
bona.RotSpeed = NumberRange.new(-500,500)

local ee = Instance.new("ParticleEmitter",lb)
ee.Texture = "http://www.roblox.com/asset/?id=243664672"
ee.LightEmission = 0.5
ee.Color = ColorSequence.new(Color3.new(0,0,0))
ee.Rate = 25
ee.Lifetime = NumberRange.new(2.5)
ee.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,thingery.Scale.X/8,0),NumberSequenceKeypoint.new(1,0,0)})
ee.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.85,0),NumberSequenceKeypoint.new(1,1,0)})
ee.Speed = NumberRange.new(1)
ee.LockedToPart = true
ee.Rotation = NumberRange.new(-500,500)
ee.VelocitySpread = 90000
ee.RotSpeed = NumberRange.new(-500,500)

local jef = Instance.new("ParticleEmitter",lb)
jef.Texture = "http://www.roblox.com/asset/?id=1175838406"
jef.LightEmission = 1
jef.Color = ColorSequence.new(Color3.new(255,255,255))
jef.Rate = 25
jef.Lifetime = NumberRange.new(2.5)
jef.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,thingery.Scale.X/8,0),NumberSequenceKeypoint.new(1,0,0)})
jef.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
jef.Speed = NumberRange.new(5)
jef.LockedToPart = true
jef.Rotation = NumberRange.new(-200,200)
jef.VelocitySpread = 90000
jef.RotSpeed = NumberRange.new(-200,200)

coroutine.resume(coroutine.create(function()
while wait() do
if hitted == false or lb.Parent ~= nil then
jef.Speed = NumberRange.new(thingery.Scale.X/6.5)
bon.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,thingery.Scale.X/4,0),NumberSequenceKeypoint.new(1,0,0)})
jef.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,thingery.Scale.X/15,0),NumberSequenceKeypoint.new(1,thingery.Scale.X/22.5,0)})
bona.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,thingery.Scale.X/3.25,0),NumberSequenceKeypoint.new(1,thingery.Scale.X/3.75,0)})
ee.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,thingery.Scale.X/2,0),NumberSequenceKeypoint.new(1,thingery.Scale.X/1.5,0)})
end
if hitted == true or lb.Parent == nil then
break
end
end
end))
CFuncs["Sound"].Create("rbxassetid://200633529", sorb, 1.5, 0.5)
	for i = 0,15,0.1 do
		swait()
lb.CFrame = sorb.CFrame
thingery.Scale = thingery.Scale + Vector3.new(0.05,0.05,0.05)
lb.Transparency = lb.Transparency - 0
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(0)),0.1)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(25),math.rad(0),math.rad(0)),.1)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(50), math.rad(0), math.rad(-30)), 0.1)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(50), math.rad(0), math.rad(30)), 0.1)
	end
CFuncs["Sound"].Create("rbxassetid://558640653", sorb, 1, 0.5)
lb.Anchored = false
        local sbs = Instance.new("BodyPosition", lb)
        sbs.P = 3000
        sbs.D = 1000
        sbs.maxForce = Vector3.new(500000, 500000000, 500000)
        sbs.position = RootPart.CFrame.p + Vector3.new(0, 100, 0)
for i = 0,10,0.1 do
		swait()
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(0)),0.3)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-25),math.rad(0),math.rad(0)),.3)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(160), math.rad(0), math.rad(30)), 0.3)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(160), math.rad(0), math.rad(-30)), 0.3)
	end
lb.Anchored = true
sbs:Destroy()
MagicBlock(BrickColor.new("Really black"),lb.CFrame,1,1,1,3,3,3,0.075)
RingEffect(lb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,5,BrickColor.new("White"))
RingEffect(lb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,5,BrickColor.new("White"))
CFuncs["Sound"].Create("rbxassetid://413682983", lb, 10, 0.75)
local scaler = 1
for i = 0, 49 do
swait()
scaler = scaler - 0.02
thingery.Scale = thingery.Scale + Vector3.new(scaler,scaler,scaler)
end
MagicBlock(BrickColor.new("Really black"),lb.CFrame,1,1,1,10,10,10,0.075)
RingEffect(lb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,15,BrickColor.new("White"))
RingEffect(lb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,15,BrickColor.new("White"))
scaler = 1*5
CFuncs["Sound"].Create("rbxassetid://413682983", lb, 10, 0.75)
for i = 0, 49 do
swait()
scaler = scaler - 0.02*5
thingery.Scale = thingery.Scale + Vector3.new(scaler,scaler,scaler)
end
wait(0.5)
for i = 0,1,0.1 do
		swait()
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(90)),0.3)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(10),math.rad(0),math.rad(-90)),.3)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(180)), 0.3)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(50), math.rad(0), math.rad(20)), 0.3)
	end
CFuncs["Sound"].Create("rbxassetid://466493476", lb, 5, 0.9)
CFuncs["Sound"].Create("rbxassetid://466493476", lb, 10, 0.75)
CFuncs["Sound"].Create("rbxassetid://203691467", lb, 10, 0.45)
lb.Anchored = false
							local a = Instance.new("Part",Character)
	a.Name = "Direction"	
	a.Anchored = true
	a.BrickColor = bc("Bright red")
a.Material = "Neon"
a.Transparency = 1
	a.CanCollide = false
	local ray = Ray.new(
	    lb.CFrame.p,                           -- origin
	    (mouse.Hit.p - lb.CFrame.p).unit * 500 -- direction
	) 
	local ignore = Character
	local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
	a.BottomSurface = 10
	a.TopSurface = 10
	local distance = (root.CFrame.p - position).magnitude
	a.Size = Vector3.new(0.1, 0.1, 0.1)
	a.CFrame = CFrame.new(lb.CFrame.p, position) * CFrame.new(0, 0, 0)
a.CFrame = a.CFrame + a.CFrame.lookVector*-5
game:GetService("Debris"):AddItem(lb, 10)
  local bv = Instance.new("BodyVelocity")
  bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
  bv.velocity = a.CFrame.lookVector*150
  bv.Parent = lb
local hitted = false
--[[coroutine.resume(coroutine.create(function()
while wait() do
if hitted == false or lb.Parent ~= nil then
MagicShockTrailAlt(lb.BrickColor,lb.CFrame + lb.CFrame.lookVector*-1,5,5,12.5,-0.25,-0.25,0.05,math.random(1,2))
end
if hitted == true or lb.Parent == nil then
break
end
end
end))]]--
game:GetService("Debris"):AddItem(a, 0.1)
wait(0.01)
lb.Touched:connect(function(hit) 
	if hitted == false then
		hitted = true
local bone = Instance.new("ParticleEmitter",lb)
bone.Texture = "http://www.roblox.com/asset/?id=874580939"
bone.LightEmission = 1
bone.Color = ColorSequence.new(Color3.new(1,1,1))
bone.Rate = 99999
bone.Lifetime = NumberRange.new(5)
bone.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,250,0)})
bone.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,0)})
bone.Speed = NumberRange.new(50)
bone.Rotation = NumberRange.new(-500,500)
bone.VelocitySpread = 90000
bone.RotSpeed = NumberRange.new(-500,500)
bon.Enabled = false

local jefe = Instance.new("ParticleEmitter",lb)
jefe.Texture = "http://www.roblox.com/asset/?id=1175838406"
jefe.LightEmission = 1
jefe.Color = ColorSequence.new(Color3.new(255,255,255))
jefe.Rate = 1000000
jefe.Lifetime = NumberRange.new(5)
jefe.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,25,0),NumberSequenceKeypoint.new(1,75,0)})
jefe.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.25,0),NumberSequenceKeypoint.new(1,1,0)})
jefe.Speed = NumberRange.new(100)
jefe.LockedToPart = true
jefe.Rotation = NumberRange.new(-200,200)
jefe.VelocitySpread = 90000
jefe.RotSpeed = NumberRange.new(-200,200)

jef.Enabled = false
ee.Enabled = false
bona.Enabled = false
RingEffect(lb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,30,BrickColor.new("Bright bluish green"))
RingEffect(lb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,30,BrickColor.new("Bright bluish green"))
RingEffect(lb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,30,BrickColor.new("Bright bluish green"))
		lb.Anchored = true
		lb.Transparency = 1
MagicBlock(BrickColor.new("Bright bluish green"),lb.CFrame,125,125,125,125,125,125,0.05)
MagicBlock(BrickColor.new("Lime green"),lb.CFrame,125,125,125,50,50,50,0.05)
CFuncs["Sound"].Create("rbxassetid://919941001", char, 1, 1)
CFuncs["Sound"].Create("rbxassetid://402347142", lb, 10,0.85)
MagniDamage(lb, 250, 25,50, 0, "Normal")
wait(0.05)
bone.Enabled = false
wait(0.1)
jefe.Enabled = false
for i = 0, 4 do
wait(0.1)
lb.Transparency = lb.Transparency + 0.1
CFuncs["Sound"].Create("rbxassetid://231917744", lb, 2.5,0.75)
MagniDamage(lb, 100, 10,30, 0, "Normal")
SlowRingEffect(lb.CFrame*CFrame.new(0,math.random(-3,3),0),1,30,BrickColor.new("Bright bluish green"))
		MagicBlock(BrickColor.new("Really black"),lb.CFrame,125,125,125,2.5,2.5,2.5,0.01)
end
	end
end)
	for i = 0,2,0.1 do
		swait()
		MagicBlock(BrickColor.new("Really black"),sorb.CFrame,3,3,3,0.05,0.05,0.05,0.05)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(20),math.rad(0),math.rad(80)),0.5)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(5),math.rad(0),math.rad(-80)),.5)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(50), math.rad(0), math.rad(20)), 0.5)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(50), math.rad(0), math.rad(-90)), 0.5)
	end
	attack = false
end

local randomquote = math.random(1,5)
local automaticspecial = false

mouse.KeyDown:connect(function(k)
        if k == "z" and attack == false then
                bullit()
        end
if k == "x" and attack == false then
                snipe()
        end
if k == "c" and attack == false then
                areabul()
        end
if k == "v" and attack == false then
                crystalinestring()
        end
if k == "b" and attack == false then
                groond()
        end
if k == "n" and attack == false and exterminated == false and transformed == true then
                extermination()
        end
if k == "m" and attack == false and plr.Name == "Helkern" or k == "m" and attack == false and plr.Name == "kiukiubol" then
if automaticspecial == true then
randomquote = 2
end
randomquote = math.random(1,5)
                NOTNORMAL()
        end
if k == "l" and attack == false and automaticspecial == false then
                automaticspecial = true
print("Enabled")
elseif k == "l" and attack == false and automaticspecial == true then
                automaticspecial = false
print("Disabled")
        end
if k == "e" and attack == false and plr.Name == "Helkern" then
                notcoolm8()
end
if k == "r" and attack == false then
                yayballs()
end
if k == "t" and attack == false then
                crates()
end
if k == "q" and attack == false and plr.Name == "Helkern" then
                endoftheworld()
        end
if k == "p" and attack == false and transformed == false and plr.Name == "Helkern" then
                tran()
        end
if k == "one" then
	idlepose = "one"
	Humanoid.WalkSpeed = 16
end
if k == "two" then
	idlepose = "two"
	Humanoid.WalkSpeed = 32
end
end)
Humanoid.Animator.Parent = nil
Character.Animate.Parent = nil
idleanim=.4
local niggaspin = 0
while true do
swait()
if transformed == true then
	if transforming == false then
		MagicShockTrailAlt2(origcolor,root.CFrame*CFrame.new(math.random(-5,5),-3,math.random(-5,5))*CFrame.Angles(math.rad(90),0,0),0.5,0.5,0,-0.01,-0.01,5,0.1,math.random(1,2))
	end
end
 sine = sine + change
niggaspin = niggaspin + 5
if niggaspin >= 360 then
	niggaspin = 0
end
if idlepose == "one" then
crysweld.C0=clerp(crysweld.C0,cf(0 - 5 * math.cos(sine / 29),2 - 3 * math.cos(sine / 32),0 + 5 * math.cos(sine / 41))*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
else
crysweld.C0=clerp(crysweld.C0,cf(0,5,0)*angles(math.rad(0),math.rad(niggaspin),math.rad(0)),.1)
end
local torvel=(RootPart.Velocity*Vector3.new(1,0,1)).magnitude 
local velderp=RootPart.Velocity.y
hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
if equipped==true or equipped==false then
if attack==false then
idle=idle+1
else
idle=0
end
if idle>=500 then
if attack==false then
--Sheath()
end
end
if RootPart.Velocity.y > 1 and hitfloor==nil then 
Anim="Jump"
if attack==false then
Neck.C0=clerp(Neck.C0,necko*euler(-0.2,0,0),.3)
Neck.C1=clerp(Neck.C1,necko2*euler(0,0,0),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0.25)*angles(math.rad(-5),math.rad(0),math.rad(0)),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(-.5,0,0.5)*angles(math.rad(-25),math.rad(0),math.rad(0)),.3)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(-.5,0,-0.5),.3)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
RH.C0=clerp(RH.C0,cf(1,-1,-.3)*euler(-0.5,1.57,0)*euler(-.2,0,0),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,-.3)*euler(-0.5,-1.57,0)*euler(-.2,0,0),.2)
end
elseif RootPart.Velocity.y < -1 and hitfloor==nil then 
Anim="Fall"
if attack==false then
Neck.C0=clerp(Neck.C0,necko*euler(0.4,0,0),.3)
Neck.C1=clerp(Neck.C1,necko2*euler(0,0,0),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0.25)*angles(math.rad(5),math.rad(0),math.rad(0)),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(0.3,0,-0.2),.3)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(0.3,0,0.2)*angles(math.rad(-25),math.rad(0),math.rad(0)),.3)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
RH.C0=clerp(RH.C0,cf(1,-1,0)*euler(0.4,1.57,0),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*euler(-0.2,-1.57,0),.2)
end
elseif torvel<1 and hitfloor~=nil then
Anim="Idle"
if transforming == false then
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),-0.3)*angles(math.rad(0),math.rad(80),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
end
if attack==false then
if idlepose == "one" then
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 25))*angles(math.rad(0),math.rad(0),math.rad(20)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5 - 2.5 * math.cos(sine / 25)),math.rad(0),math.rad(-20)),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(10 + 3 * math.cos(sine / 25)),math.rad(0),math.rad(15)),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-10 + 2 * math.cos(sine / 25)),math.rad(0),math.rad(-20)),.1)
elseif idlepose == "two" then
RH.C0=clerp(RH.C0,cf(1,1,-1)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
LH.C0=clerp(LH.C0,cf(-1,-1,-0.2)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(50),math.rad(0),math.rad(5 + 2 * math.cos(sine / 34))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,4 + 0.2 * math.cos(sine/28))*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 1 * math.cos(sine / 28)),math.rad(2 + 3 * math.cos(sine / 41)),math.rad(5 + 2 * math.cos(sine / 53))),.1)
RW.C0=clerp(RW.C0,cf(0.7,0.2,-0.5)*angles(math.rad(60),math.rad(0),math.rad(-90)),.1) --below
LW.C0=clerp(LW.C0,cf(-0.7,0.5,-0.65)*angles(math.rad(80),math.rad(0),math.rad(80)),.1)
end
end
elseif torvel>2 and torvel<22 and hitfloor~=nil then
Anim="Walk"
if transforming == false then
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 4),-0.25 - 0.15 * math.cos(sine / 4))*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0 + 25 * math.cos(sine / 8))),.3)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 4),-0.25 - 0.15 * math.cos(sine / 4))*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0 + 25 * math.cos(sine / 8))),.3)
end
if attack==false then
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 - 0.05 * math.cos(sine / 4))*angles(math.rad(15),math.rad(0),math.rad(0)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-5),math.rad(0),math.rad(0)),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(0 - 25 * math.cos(sine / 8)),math.rad(0),math.rad(10 + 1.25 * math.cos(sine / 16))),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0 + 25 * math.cos(sine / 8)),math.rad(0),math.rad(-10 - 1.25 * math.cos(sine / 16))),.3)
end
elseif torvel>=22 and hitfloor~=nil then
Anim="Run"
if transforming == false then
if idlepose == "one" then
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0 + 75 * math.cos(sine / 3))),.3)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0 + 75 * math.cos(sine / 3))),.3)
elseif idlepose == "two" then
RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 5 + 0.5 * math.cos(sine / 17)) * angles(math.rad(65), math.rad(0), math.rad(0)), 0.15)
tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-45 - 4.5 * math.sin(sine / 30)), math.rad(0), math.rad(0)), 0.3)
RH.C0 = clerp(RH.C0, cf(1, -0.4 - 0.1 * math.cos(sine / 20), -.4 + 0.025 * math.cos(sine / 20)) * CFrame.fromEulerAnglesXYZ(0, 1.6, 0) * angles(math.rad(-16.5 + 3 * math.sin(sine / 20)), math.rad(0), math.rad(-30 + 2.5 * math.sin(sine / 20))), 0.15)
LH.C0 = clerp(LH.C0, cf(-1, -0.9 - 0.1 * math.cos(sine / 20), 0.025 * math.cos(sine / 20)) * CFrame.fromEulerAnglesXYZ(0, -1.6, 0) * angles(math.rad(-16.5 + 3 * math.sin(sine / 20)), math.rad(0), math.rad(30 + 2.5 * math.sin(sine / 20))), 0.15)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(-8 - 4 * math.cos(sine / 59)),math.rad(-20 + 7 * math.cos(sine / 62)),math.rad(20 + 5 * math.cos(sine / 50))),.2)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(-8 - 3 * math.cos(sine / 55)),math.rad(20 + 8 * math.cos(sine / 67)),math.rad(-20 - 4 * math.cos(sine / 29))),.2)
end
end
if attack==false then
RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,-0.25 + 0.05 * math.cos(sine / 32))* angles(math.rad(35),math.rad(0),math.rad(0)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-5),math.rad(0),math.rad(0)),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-50),math.rad(-60),math.rad(25)),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-50),math.rad(0),math.rad(-25)),.3)
end
end
end
end
end)

Section2:CreateButton("Derpz's Hoverboard", function()
	local script = game:GetObjects("rbxassetid://7796899100")[1]
wait(.5)
cammove = false -------Change this to true for the proper & better camera movement for third person.
wait(1/60)
warn([[Derpz 2020 Spring Base
	
	
	
	By DerpzDeNugget_YT.
	EzConvert by Drahazar
	Some assets from Lunnekoo, Footplanting (but slightly edited) by KnottyEeveez.
]])
plr = game:GetService("Players").LocalPlayer
Player = plr
mouse = plr:GetMouse()
cam = game.Workspace.CurrentCamera
cam.CameraType = "Custom"
if cammove == true then
	script.CameraMovement.Disabled = false
elseif cammove == false then

end
char = cam.CameraSubject.Parent
Character = cam.CameraSubject.Parent
hum = char.Humanoid
Humanoid = hum
t = char.Torso
Torso = t
h = char.Head
Head = h
tors = Torso
lleg = char["Left Leg"]
root = char.HumanoidRootPart
RootPart = root
hed = h
rleg = char["Right Leg"]
rarm = char["Right Arm"]
larm = char["Left Arm"]
Euler = CFrame.fromEulerAnglesXYZ
vt = Vector3.new
it = Instance.new
cf = CFrame.new
Face = hed.face
local DerpzMusic = Instance.new("Sound",char.Torso)
DerpzMusic.SoundId = "rbxassetid://5259915583"
DerpzMusic.Name = "DerpzMusic"
DerpzMusic.Volume = 2
DerpzMusic.Pitch = 0.97
DerpzMusic.Looped = true
DerpzMusic:Play()
local sleepymusic = Instance.new("Sound",char.Head)
sleepymusic.SoundId = "rbxassetid://328340676"
sleepymusic.Name = "sleepymusic"
sleepymusic.Volume = 2
sleepymusic.Pitch = 1
sleepymusic.Looped = true
sleepymusic:Play()
sleepymusic:Pause()
script.Main.VisFrame.Visualiser.Disabled = false
--Face changing functions

--Derpz (And some others') Faces
function Bored() --hhh..
Face.Texture = "http://www.roblox.com/asset/?id=4611467856"
end
function Neutral() --okthen
Face.Texture = "rbxassetid://2755423294"
end
function Upset() --cri
Face.Texture = "http://www.roblox.com/asset/?id=4611468085"
end
function Happy() --HHHHHHHHHHHHHHHHHHHHHHHH
Face.Texture = "http://www.roblox.com/asset/?id=4611484914"
end
function Determined() --It'S NOt oVEr uNtIl iT'S OveR
	Face.Texture = "rbxassetid://2755480100"
end
function Insane() --hahahhahah
	Face.Texture = "http://www.roblox.com/asset/?id=4611467568"
end
function Sleeping() --Yes, I did make a sleeping face.
	Face.Texture = "rbxassetid://3009289203"
end
function HappyMemey() --c:
	Face.Texture = "rbxassetid://3988001776"
end
function Shocked() --JESUS CHRIST WHAT THE HELL IS THAT DEAD BODY DOING ON THE FLOOR
	Face.Texture = "http://www.roblox.com/asset/?id=4365795547"
end
function die() --die
	Face.Texture = "rbxassetid://4821072198"
end
--rbxassetid://4821072198
--Jake_D Faces (If the script is about them)
function JakeNeutral() --meh.
Face.Texture = "rbxassetid://3557021423"
end
function JakeUpset() --u mak me mad >:c
Face.Texture = "rbxassetid://3557022030"
end
function JakeHappy() --help
Face.Texture = "rbxassetid://3557022523"
end
--Face changing functions

--Focus
function Focus(whatone,timebeforeend,twoplayersonly,playerone,playertwo) --Time is used in ticks, Not seconds.
					if twoplayersonly == true then
							for i,v in pairs(game:GetService("Players"):GetChildren()) do
		if script.Focus[whatone].Parent ~= nil then
			if v.Name == playerone or v.Name == playertwo then
	local var = script.Focus[whatone]:Clone()
	var.PersonName.Value = plr.Name
	var.Time.Value = timebeforeend
	var.Parent = v.PlayerGui
	var.Disabled = false
			else
				end
	end
	end
					elseif twoplayersonly == false or twoplayersonly == nil then
						

	for i,v in pairs(game:GetService("Players"):GetChildren()) do
		if script.Focus[whatone].Parent ~= nil then
			if plr.Name == "DerpzDeNugget_YT" then
	local var = script.Focus[whatone]:Clone()
		var.PersonName.Value = plr.Name
	var.Time.Value = timebeforeend
	var.Parent = v.PlayerGui
	var.Disabled = false

	end
		end
		end
	end
end
--Focus

--Shaking (Old)
--[[function shakes(power,length)
	for i,v in pairs(game:GetService("Players"):GetChildren()) do
	local var = script.Shaker:Clone()
	var.Parent = v.Character
	local pw = var.Shakeval
	local lgth = var.MultLength
	pw.Value = power/2
	lgth.Value = length
	var.Disabled = false
	game:GetService("Debris"):AddItem(var, length+4)
	end
end

function localshakes(power,length)
local var = script.Shaker:Clone()
var.Parent = plr.Character
local pw = var.Shakeval
local lgth = var.MultLength
pw.Value = power/2
lgth.Value = length
var.Disabled = false
game:GetService("Debris"):AddItem(var, length+4)
end
function CameraEnshaking(power,length)
	for i,v in pairs(game:GetService("Players"):GetChildren()) do
	local var = script.Shaker:Clone()
	var.Parent = v.Character
	local pw = var.Shakeval
	local lgth = var.MultLength
	pw.Value = power/2
	lgth.Value = length
	var.Disabled = false
	game:GetService("Debris"):AddItem(var, length+4)
	end
end]]
--Shaking (Old)

--Shaking (New, Thanks to Drahazar)
	local NewInstance = function(instance,parent,properties)
		local inst = Instance.new(instance,parent)
		if(properties)then
			for i,v in next, properties do
				pcall(function() inst[i] = v end)
			end
		end
		return inst;
	end
FXFolder=script.Effects
function CamShake2(who,data)
	coroutine.wrap(function()
		if(FXFolder:FindFirstChild'CamShake')then
			local cam = FXFolder.CamShake:Clone()
			cam:WaitForChild'intensity'.Value = data.Intensity or 5
			cam:WaitForChild'duration'.Value = data.Duration or 5
			cam:WaitForChild'speed'.Value = data.Speed or 10;
	 		if(data.Origin)then NewInstance((typeof(data.Origin) == 'Instance' and "ObjectValue" or typeof(data.Origin) == 'Vector3' and 'Vector3Value' or typeof(data.Origin)=='CFrame' and 'CFrameValue'),cam,{Name='origin',Value=data.Origin}) end
			cam:WaitForChild'rot'.Value = data.Rotation or Vector3.new(1,1,5)
			cam:WaitForChild'pos'.Value = data.Position or Vector3.new(.5,.5,.5)
			cam:WaitForChild'startdist'.Value = data.DropDist or 25;
			cam:WaitForChild'enddist'.Value = data.IneffectiveDist or 150;
			
			cam.Parent = who
			wait()
			cam.Disabled = false
			wait(3)
			cam:Destroy()
		end
	end)()
end

function CamShakeAll2(data)
	for _,v in next, game:service'Players':players() do
		CamShake2(v:FindFirstChildOfClass'PlayerGui' or v:FindFirstChildOfClass'Backpack' or v.Character,data)
	end
end
--Shaking (New, Thanks to Drahazar)
--Animation Testing
function nonlerpanim(jointorweld,cframe,alpha,easestyle,easedirect)
	local info = TweenInfo.new(alpha,easestyle,easedirect,0,false,0)
	local actualanim = game:GetService("TweenService"):Create(jointorweld,info,{C0=cframe})
	actualanim:Play()
	return actualanim
end
function Animate(jointorweld,cframe,alpha,easestyle,easedirect)
	local info = TweenInfo.new(alpha,easestyle,easedirect,0,false,0)
	local actualanim = game:GetService("TweenService"):Create(jointorweld,info,{C0=cframe})
	actualanim:Play()
	return actualanim
end
--Animation Testing


--Morphs
-----------------Derpz-----------------
--[[
	lol = script.DerpzMorph["morph (Derpz)"] lol.Name = "morph (Derpz) for "..plr.Name lol.Parent = game:GetService("ServerStorage")
			local derpz = Character:GetChildren()
	for i=1, #derpz do 
		if (derpz[i].className == "Accessory") then 
			derpz[i].Parent = nil
		elseif (derpz[i].className == "Shirt") then
			derpz[i].Parent = nil
		elseif (derpz[i].className == "Pants") then
			derpz[i].Parent = nil
		elseif (derpz[i].className == "CharacterMesh") then
			derpz[i].Parent = nil
		elseif (derpz[i].className == "ShirtGraphic") then
			derpz[i].Parent = nil
			
		end 
		
	end

	local clothesa = game:GetService("ServerStorage")["morph (Derpz) for "..plr.Name]:Clone()
	local clothes1 = clothesa:GetChildren()
	for i=1, #clothes1 do 
		if (clothes1[i].className == "Accessory") then 
			clothes1[i].Parent = Character
		elseif (clothes1[i].className == "Shirt") then
			clothes1[i].Parent = Character
			elseif (clothes1[i].className == "Pants") then
			clothes1[i].Parent = Character
			elseif (clothes1[i].className == "BodyColors") then
			clothes1[i].Parent = Character
			elseif (clothes1[i].className == "CharacterMesh") then
			clothes1[i].Parent = Character
			elseif (clothes1[i].className == "ShirtGraphic") then
			clothes1[i].Parent = Character
		end 
		
	end
--else
	
--end
local DerpzMorphLARM = script.DerpzMorph["L Arm"]
local finalweld3 = Instance.new("Weld",DerpzMorphLARM.main)
finalweld3.Part0 = DerpzMorphLARM.main
finalweld3.Part1 = larm
finalweld3.C0 = CFrame.new(0,-0.03,-0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
finalweld3.Name = "Weldiuehgiuewhguishgafgbsdgkfvjdhsagbk.sfk derpz's weld ok"
local DerpzMorphRARM = script.DerpzMorph["R Arm"]
local finalweld3 = Instance.new("Weld",DerpzMorphRARM.main)
finalweld3.Part0 = DerpzMorphRARM.main
finalweld3.Part1 = rarm
finalweld3.C0 = CFrame.new(0,-0.03,-0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
finalweld3.Name = "Weldiuehgiuewhguishgafgbsdgkfvjdhsagbk.sfk derpz's weld ok"
local DerpzMorphLLEG = script.DerpzMorph["L Leg"]
local finalweld3 = Instance.new("Weld",DerpzMorphLLEG.main)
finalweld3.Part0 = DerpzMorphLLEG.main
finalweld3.Part1 = lleg
finalweld3.C0 = CFrame.new(0,-0.045,-0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
finalweld3.Name = "Weldiuehgiuewhguishgafgbsdgkfvjdhsagbk.sfk derpz's weld ok"
local DerpzMorphRLEG = script.DerpzMorph["R Leg"]
local finalweld3 = Instance.new("Weld",DerpzMorphRLEG.main)
finalweld3.Part0 = DerpzMorphRLEG.main
finalweld3.Part1 = rleg
finalweld3.C0 = CFrame.new(0,-0.045,-0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
finalweld3.Name = "Weldiuehgiuewhguishgafgbsdgkfvjdhsagbk.sfk derpz's weld ok"
local DerpzMorphTORS = script.DerpzMorph["Tors"]
local finalweld3 = Instance.new("Weld",DerpzMorphTORS.main)
finalweld3.Part0 = DerpzMorphTORS.main
finalweld3.Part1 = tors
finalweld3.C0 = CFrame.new(0,-0.03,-0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
finalweld3.Name = "Weldiuehgiuewhguishgafgbsdgkfvjdhsagbk.sfk derpz's weld ok"


DerpzVisor = script.DerpzMorph.Hed.Visor.main
local finalweld33 = Instance.new("Weld",DerpzVisor)
finalweld33.Part0 = DerpzVisor
finalweld33.Part1 = Head
finalweld33.C0 = CFrame.new(0,-.18,.65)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
finalweld33.Name = "Weldiuehgiuewhguishgafgbsdgkfvjdhsagbk.sfk derpz's weld ok"


DerpzTail = script.DerpzMorph.Tail
local finalweld333 = Instance.new("Weld",DerpzTail.Main)
finalweld333.Part0 = DerpzTail.Main
finalweld333.Part1 = Torso
finalweld333.C0 = CFrame.new(0.222665405, 1.05234146, 0.358361816)*CFrame.Angles(math.rad(0),math.rad(180),math.rad(0))
finalweld333.Name = "Weldiuehgiuewhguishgafgbsdgkfvjdhsagbk.sfk derpz's weld ok"
TailWeld = DerpzTail.Main.TailWeld


script.DerpzMorph.Parent = char


local DerpzMorph2LARM = script.DerpzMorph2["L Arm"]
local finalweld3 = Instance.new("Weld",DerpzMorph2LARM.main)
finalweld3.Part0 = DerpzMorph2LARM.main
finalweld3.Part1 = larm
finalweld3.C0 = CFrame.new(0,-0.03,-0.01)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
finalweld3.Name = "Weldiuehgiuewhguishgafgbsdgkfvjdhsagbk.sfk derpz's weld ok"
local DerpzMorph2RARM = script.DerpzMorph2["R Arm"]
local finalweld3 = Instance.new("Weld",DerpzMorph2RARM.main)
finalweld3.Part0 = DerpzMorph2RARM.main
finalweld3.Part1 = rarm
finalweld3.C0 = CFrame.new(0,-0.03,-0.01)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
finalweld3.Name = "Weldiuehgiuewhguishgafgbsdgkfvjdhsagbk.sfk derpz's weld ok"
local DerpzMorph2LLEG = script.DerpzMorph2["L Leg"]
local finalweld3 = Instance.new("Weld",DerpzMorph2LLEG.main)
finalweld3.Part0 = DerpzMorph2LLEG.main
finalweld3.Part1 = lleg
finalweld3.C0 = CFrame.new(0,-0.045,-0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
finalweld3.Name = "Weldiuehgiuewhguishgafgbsdgkfvjdhsagbk.sfk derpz's weld ok"
local DerpzMorph2RLEG = script.DerpzMorph2["R Leg"]
local finalweld3 = Instance.new("Weld",DerpzMorph2RLEG.main)
finalweld3.Part0 = DerpzMorph2RLEG.main
finalweld3.Part1 = rleg
finalweld3.C0 = CFrame.new(0,-0.045,-0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
finalweld3.Name = "Weldiuehgiuewhguishgafgbsdgkfvjdhsagbk.sfk derpz's weld ok"
local DerpzMorph2TORS = script.DerpzMorph2["Tors"]
local finalweld3 = Instance.new("Weld",DerpzMorph2TORS.main)
finalweld3.Part0 = DerpzMorph2TORS.main
finalweld3.Part1 = tors
finalweld3.C0 = CFrame.new(0,-0.03,-0.01)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
finalweld3.Name = "Weldiuehgiuewhguishgafgbsdgkfvjdhsagbk.sfk derpz's weld ok"



script.DerpzMorph2.Parent = char




-----------------Derpz-----------------

-----------------Eyes------------------
--CFrame.new(.2,.2,-.2)
EyesFolder = script.Eyes
local finalweld3 = Instance.new("Weld",EyesFolder.LeftEye)
finalweld3.Part0 = EyesFolder.LeftEye
finalweld3.Part1 = Head
finalweld3.C0 = CFrame.new( 0.0984573364, -0.200519562, 0.586151123)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
finalweld3.C1 = CFrame.new(-0.5,0,-0.5)*CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))
finalweld3.Name = "Weldiuehgiuewhguishgafgbsdgkfvjdhsagbk.sfk derpz's weld ok"
local finalweld3 = Instance.new("Weld",EyesFolder.RightEye)
finalweld3.Part0 = EyesFolder.RightEye
finalweld3.Part1 = Head
finalweld3.C0 = CFrame.new( -0.0984573364, -0.200519562, 0.586151123)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
finalweld3.C1 = CFrame.new(0.5,0,-0.5)*CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))
finalweld3.Name = "Weldiuehgiuewhguishgafgbsdgkfvjdhsagbk.sfk derpz's weld ok"

-----------------Eyes------------------
--Morphs
--]]

	local NewInstance = function(instance,parent,properties)
		local inst = Instance.new(instance,parent)
		if(properties)then
			for i,v in next, properties do
				pcall(function() inst[i] = v end)
			end
		end
		return inst;
	end
MAINRUINCOLOR = BrickColor.new("Navy blue")
loadstring(game:HttpGet("https://paste.ee/r/oPpQI"))()
local Create = LoadLibrary("RbxUtility").Create
New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end



--Rainbow Effects
function boop(X)
	 return math.acos(math.cos(X*math.pi))/math.pi
	 end

counter = 0
--Rainbow Effects





function CreateParta(parent,transparency,reflectance,material,brickcolor)
local p = Instance.new("Part")
p.TopSurface = 0
p.BottomSurface = 0
p.Parent = parent
p.Size = Vector3.new(0.1,0.1,0.1)
p.Transparency = transparency
p.Reflectance = reflectance
p.CanCollide = false
p.Locked = true
p.BrickColor = brickcolor
p.Material = material
return p
end

function CreateMesh(parent,meshtype,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = meshtype
mesh.Scale = Vector3.new(x1*10,y1*10,z1*10)
return mesh
end

function CreateSpecialMesh(parent,meshid,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = "FileMesh"
mesh.MeshId = meshid
mesh.Scale = Vector3.new(x1,y1,z1)
return mesh
end


function CreateSpecialGlowMesh(parent,meshid,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = "FileMesh"
mesh.MeshId = meshid
mesh.TextureId = "http://www.roblox.com/asset/?id=269748808"
mesh.Scale = Vector3.new(x1,y1,z1)
mesh.VertexColor = Vector3.new(parent.BrickColor.r, parent.BrickColor.g, parent.BrickColor.b)
return mesh
end

function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
local weld = Instance.new("Weld")
weld.Parent = parent
weld.Part0 = part0
weld.Part1 = part1
weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
return weld
end


function RemoveOutlines(part)
  part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
  local Part = Create("Part")({
    Parent = Parent,
    Reflectance = Reflectance,
    Transparency = Transparency,
    CanCollide = false,
    Locked = true,
    BrickColor = BrickColor.new(tostring(BColor)),
    Name = Name,
    Size = Size,
    Material = Material
  })
  Part.CustomPhysicalProperties = PhysicalProperties.new(0.001, 0.001, 0.001, 0.001, 0.001)
  RemoveOutlines(Part)
  return Part
end
function CreateMesha(Mesh, Part, MeshType, MeshId, OffSet, Scale)
  local Msh = Create(Mesh)({
    Parent = Part,
    Offset = OffSet,
    Scale = Scale
  })
  if Mesh == "SpecialMesh" then
    Msh.MeshType = MeshType
    Msh.MeshId = MeshId
  end
  return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
  local Weld = Create("Weld")({
    Parent = Parent,
    Part0 = Part0,
    Part1 = Part1,
    C0 = C0,
    C1 = C1
  })
  return Weld
end

function Align(Part0, Part1, Position, Angle)
	if Part0:FindFirstChild("Attachment") then
		Part0:FindFirstChild("Attachment"):Remove()
	end
    local AlignPosition = Instance.new("AlignPosition",Part0)
    local AlignOrientation = Instance.new("AlignOrientation",Part0)
    
    local Attachment1 = Instance.new("Attachment", Part0)
    local Attachment2 = Instance.new("Attachment", Part1)

    AlignPosition.Attachment0 = Attachment1
    AlignPosition.Attachment1 = Attachment2
    
    AlignOrientation.Attachment0 = Attachment1
    AlignOrientation.Attachment1 = Attachment2
    
    Attachment2.Position = Position or Vector3.new(0,0,0)
    Attachment2.Orientation = Angle or Vector3.new(0,0,0)
    
    AlignOrientation.MaxTorque = math.huge
    AlignOrientation.MaxAngularVelocity = math.huge
    AlignOrientation.PrimaryAxisOnly = false 
    AlignOrientation.Responsiveness = 200
    AlignOrientation.RigidityEnabled = false
    AlignOrientation.ReactionTorqueEnabled = false
    AlignPosition.MaxForce = math.huge
    AlignPosition.MaxVelocity = math.huge
    AlignPosition.ReactionForceEnabled = false
    AlignPosition.Responsiveness = 200
    AlignPosition.ApplyAtCenterOfMass = true
    AlignPosition.RigidityEnabled = true
    game:GetService("RunService").Heartbeat:Connect(function()
        Part0.Velocity = Vector3.new(-29.99,0,0)
    end)
    if Part0.Parent:IsA("Accessory") then
    	Part0:BreakJoints()
    end
end
-- 4315489767
local MPASword = {}
for _,v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
	if v:IsA("Accessory") and v.Name == "MeshPartAccessory" and v.Handle.Size == Vector3.new(4,4,1) then
		table.insert(MPASword,v)
		v.Name = "LMAOSWORDYES"
	end
end
for _,v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
	if v:IsA("Accessory") and v.Name == "MeshPartAccessory" and v.Handle.Size == Vector3.new(5.15097, 5.15097, 0.425024) then
		table.insert(MPASword,v)
		v.Name = "LMAOSWORDYES"
	end
end



local funnyboard = script["Derpz - Hoverboard"]
funnyboard.Parent = char
local finalweld36 = Instance.new("Weld",funnyboard.main)
if MPASword[1] then
Align(MPASword[1].Handle, funnyboard.main, Vector3.new(0, -0, 0), Vector3.new(-45, -90, 90))
end
finalweld36.Part0 = funnyboard.main
finalweld36.Part1 = tors
finalweld36.C0 = CFrame.new(0,3,-0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
finalweld36.Name = "Weldiuehgiuewhguishgafgbsdgkfvjdhsagbk.sfk derpz's weld ok"



Player = plr
Character=cam.CameraSubject.Parent
PlayerGui=Player.PlayerGui 
Backpack=Player.Backpack 
Torso=Character.Torso 
Head=Character.Head 
Humanoid=Character.Humanoid
m=Instance.new('Model',Character)
LeftArm=Character["Left Arm"] 
LeftLeg=Character["Left Leg"] 
RightArm=Character["Right Arm"] 
RightLeg=Character["Right Leg"] 
LS=Torso["Left Shoulder"] 
LH=Torso["Left Hip"] 
RS=Torso["Right Shoulder"] 
RH=Torso["Right Hip"] 
Face = Head.face
Neck=Torso.Neck
it=Instance.new
attacktype=1
vt=Vector3.new
cf=CFrame.new
euler=CFrame.fromEulerAnglesXYZ
angles=CFrame.Angles
cloaked=false
necko=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
necko2=cf(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
LHC0=cf(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
LHC1=cf(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
RHC0=cf(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
RHC1=cf(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
RootPart=Character.HumanoidRootPart
RootJoint=RootPart.RootJoint
RootCF=euler(-1.57,0,3.14)
attack = false 
attackdebounce = false 
deb=false
equipped=true
hand=false
MMouse=nil
combo=0
mana=0
trispeed=.2
attackmode='none'
local idle=0
local Anim="Idle"
local Effects={}
local gun=false
local shoot=false
local sine = 0
local change = 1

--Lunnekoo's Arm Weld Setup 
RSH, LSH=nil, nil
RW, LW=Instance.new("Weld"), Instance.new("Weld") 
RW.Name="Right Shoulder" LW.Name="Left Shoulder"
LH=Torso["Left Hip"]
RH=Torso["Right Hip"]
TorsoColor=Torso.BrickColor
function NoOutline(Part)
Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
end
ch=Character
RSH=ch.Torso["Right Shoulder"] 
LSH=ch.Torso["Left Shoulder"] 
-- 
RSH.Parent=nil 
LSH.Parent=nil 
-- 
RW.Name="Right Shoulder"
RW.Part0=ch.Torso 
RW.C0=cf(1.5, 0.5, 0)
RW.C1=cf(0, 0.5, 0) 
RW.Part1=ch["Right Arm"] 
RW.Parent=ch.Torso 
-- 
LW.Name="Left Shoulder"
LW.Part0=ch.Torso 
LW.C0=cf(-1.5, 0.5, 0)
LW.C1=cf(0, 0.5, 0) 
LW.Part1=ch["Left Arm"] 
LW.Parent=ch.Torso 

local toggleTag = true
local txt = Instance.new("BillboardGui", Head)
txt.Adornee = nil
txt.Name = "NameDetect"
txt.Size = UDim2.new(4, 0, 1.2, 0)
txt.StudsOffset = Vector3.new(-8, 5.333333333333333, 0)
local text = Instance.new("TextLabel", txt)
text.Size = UDim2.new(5, 0, 3.5, 0)
text.FontSize = "Size8"
text.TextScaled = true
text.TextTransparency = 0
text.BackgroundTransparency = 1
text.TextTransparency = 0
text.TextStrokeTransparency = 0
text.Font = "Arcade" --Font. duh
text.TextStrokeColor3 = Color3.fromRGB(0,0,100) --Outside Color
text.TextColor3 = Color3.fromRGB(0,0,255) --Inside Color
text.Text = " " --Overhead Name Text

--GUI STUFF
gui = script.Main
gui.Parent = plr.PlayerGui
MainFrame = gui.Main


function swait(num)
if num == 0 or num == nil then
game:GetService("RunService").Stepped:wait()
	else
		for i = 1, num do
game:GetService("RunService").Stepped:wait()
		end
	end
end




--Blink Functions
blinking = false
function blinkfunction()
	if blinking == false then
		blinking = true
EyesFolder.RightEye.Size = Vector3.new(0.05, 0.082, 0.162)
EyesFolder.LeftEye.Size = Vector3.new(0.05, 0.082, 0.162)
		for i = 0,4,0.1 do
			swait()
		end
		EyesFolder.RightEye.Size = Vector3.new(0.05, 0.202, 0.162)
EyesFolder.LeftEye.Size = Vector3.new(0.05, 0.202, 0.162)
		blinking = false
	end
end
--Blink Functions

--Wacky Effects
-- Start of Pity's Variables
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
local SINE = 0
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
--ROBLOXIDLEANIMATION.Parent = Humanoid
local WEAPONGUI = IT("ScreenGui", PlayerGui)
WEAPONGUI.Name = "eggdog"
local Weapon = IT("Model")
Weapon.Name = "Adds"
local Effects = Instance.new("Folder",char)
Effects.Name = "EffectsWack"

local S = Instance.new("Sound")
function CreateSound5(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "rbxassetid://" .. ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat
				wait(1)
			until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function CreateMesh5(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
    local NEWMESH = IT(MESH)
    if MESH == "SpecialMesh" then
        NEWMESH.MeshType = MESHTYPE
        if MESHID ~= "nil" and MESHID ~= "" then
            NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
        end
        if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
            NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
        end
    end
    NEWMESH.Offset = OFFSET or VT(0, 0, 0)
    NEWMESH.Scale = SCALE
    NEWMESH.Parent = PARENT
    return NEWMESH
end
 
function CreatePart5(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
    local NEWPART = IT("Part")
    NEWPART.formFactor = FORMFACTOR
    NEWPART.Reflectance = REFLECTANCE
    NEWPART.Transparency = TRANSPARENCY
    NEWPART.CanCollide = false
    NEWPART.Locked = true
    NEWPART.Anchored = true
    if ANCHOR == false then
        NEWPART.Anchored = false
    end
    NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
    NEWPART.Name = NAME
    NEWPART.Size = SIZE
    NEWPART.Position = Torso.Position
    NEWPART.Material = MATERIAL
    NEWPART:BreakJoints()
    NEWPART.Parent = PARENT
    return NEWPART
end

-- End of Pity's Variables --

--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLORLOOP = (Table.ColorLoop or false)
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
	local BOOMERANG = (Table.Boomerang or 0)
	local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart5(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound5(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh5("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wedge" then
			MSH = CreateMesh5("SpecialMesh", EFFECT, "Wedge", "", "", SIZE, VT(0,0,0))	
		elseif TYPE == "Wave" then
			MSH = CreateMesh5("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh5("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh5("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh5("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh5("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh5("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh5("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local BOOMR1 = 1+BOOMERANG/50
			local BOOMR2 = 1+SIZEBOOMERANG/50
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				if USEBOOMERANGMATH == true then
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
				else
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
				end
			end
			local GROWTH = nil
			if USEBOOMERANGMATH == true then
				GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
			else
				GROWTH = (SIZE - ENDSIZE)
			end
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			EFFECT.CFrame = CFRAME
			if USEBOOMERANGMATH == true then
				for LOOP = 1, TIME+1 do
					swait()
					if COLORLOOP == true then
					EFFECT.Color = COLOR
					end
					MSH.Scale = MSH.Scale - (VT((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
						EFFECT.Orientation = ORI
					end
				end
			else
				for LOOP = 1, TIME+1 do
					swait()
					if COLORLOOP == true then
						EFFECT.Color = COLOR
					end
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
						EFFECT.Orientation = ORI
					end
				end
			end
			EFFECT.Transparency = 1
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		end
	end))
end
--Wacky Effects
 
--Sound Effects
function soundeffect(id,pit,parent,vol,pos,name)
local sound = Instance.new("Sound")
sound.Parent = parent
sound.Name = name
sound.SoundId = "rbxassetid://"..id
sound.Pitch = pit
sound.Volume = vol
sound.TimePosition = pos
sound.PlayOnRemove = true
sound:Remove()
end

--Guis
function chatfunc(textie,speed,color)
		coroutine.wrap(function()
			if(Character.Head:FindFirstChild'ChatGUI')then Character.Head.ChatGUI:destroy() end
			local BBG = script.GuiStuff.ChatGUI:Clone()	
			BBG.Parent = hed
			BBG.Adornee = hed
			BBG.Enabled = true
			local Txt1 = BBG.txt1
			local Txt2 = BBG.txt2
			local Txt3 = BBG.txt3
Txt1.Text = "Derpz: "
Txt2.Text = "Derpz: "
Txt3.Text = "Derpz: "

						text.TextStrokeTransparency = 0.9
text.TextTransparency = 0.9
		coroutine.resume(coroutine.create(function()
			repeat swait()
			--lol
											Txt1.Rotation = math.random(-2,2)
											Txt3.Rotation = math.random(-3,3)
				if color ~= "Random" and color ~= "Rainbow" then
					Txt1.TextColor3 = color
					Txt1.TextStrokeColor3 = color
					Txt2.TextColor3 = color
					Txt2.TextStrokeColor3 = color
					Txt3.TextColor3 = color
					Txt3.TextStrokeColor3 = color
					elseif color == "Random" then
										Txt1.TextColor3 = Color3.new(math.random(-255,255),math.random(-255,255),math.random(-255,255))
					Txt1.TextStrokeColor3 = Color3.new(math.random(-255,255),math.random(-255,255),math.random(-255,255))
					Txt2.TextColor3 = Color3.new(math.random(-255,255),math.random(-255,255),math.random(-255,255))
					Txt2.TextStrokeColor3 = Color3.new(math.random(-255,255),math.random(-255,255),math.random(-255,255))
					Txt3.TextColor3 = Color3.new(math.random(-255,255),math.random(-255,255),math.random(-255,255))
					Txt3.TextStrokeColor3 = Color3.new(math.random(-255,255),math.random(-255,255),math.random(-255,255))
				elseif color == "Rainbow" then
										Txt1.TextColor3 = Color3.fromHSV(boop(counter),1,1)
					Txt1.TextStrokeColor3 = Color3.fromHSV(boop(counter),1,1)
					Txt2.TextColor3 = Color3.fromHSV(boop(counter),1,1)
					Txt2.TextStrokeColor3 = Color3.fromHSV(boop(counter),1,1)
					Txt3.TextColor3 = Color3.fromHSV(boop(counter),1,1)
					Txt3.TextStrokeColor3 = Color3.fromHSV(boop(counter),1,1)
					end
			until Txt2.Transparency > 1 and Txt1.Transparency > 1
			end))
			for i = 1, #textie do
				delay(i/speed, function()
					soundeffect(4756932544,0.95,Head,10,0,"pixel")

					Txt2.Text = "Derpz: "  ..textie:sub(1,i)
					Txt1.Text = "Derpz: "..textie:sub(1,i)
					Txt3.Text = "Derpz: "..textie:sub(1,i)


				end)
			end
			delay((#textie/speed), function()
				wait(0.2)
            for i = 1, 15 do
	       swait()
	Txt1.Rotation = math.random(-5,5)
	Txt2.Rotation = math.random(-5,5)
	Txt3.Rotation = math.random(-5,5)
            end
			end)
			delay((#textie/25)+3, function()
				for i = 1,15 do
					swait()
						       Txt1.TextTransparency = Txt1.TextTransparency + 1/15
	       Txt1.TextStrokeTransparency = Txt1.TextStrokeTransparency + 1/15
							       Txt2.TextTransparency = Txt2.TextTransparency + 1/15
	       Txt2.TextStrokeTransparency = Txt2.TextStrokeTransparency + 1/15
							       Txt3.TextTransparency = Txt3.TextTransparency + 1/15
	       Txt3.TextStrokeTransparency = Txt3.TextStrokeTransparency + 1/15
											text.TextStrokeTransparency = text.TextStrokeTransparency - 0.99/15
text.TextTransparency = text.TextTransparency - 0.99/15

				end
				BBG:destroy()
			end)
		end)()
end


function FillScreen(color,timetowait)
	
	for i,v in pairs(game:GetService("Players"):GetPlayers()) do
if v.PlayerGui:FindFirstChild("FillScrLocal")~= nil then
v.PlayerGui:FindFirstChild("FillScrLocal"):destroy()
end

thing = script.GuiStuff.FillScrLocal:Clone()
thing.valuetowait.Value = timetowait
thing.Color.Value = color
thing.Parent = v.PlayerGui
thing.Disabled = false
end
	

end

function BossChatFuncTop(text,represfont,color,color2)
	for i,v in pairs(game:GetService("Players"):GetPlayers()) do
if v.PlayerGui:FindFirstChild("TopBossChatLocal")~= nil then
v.PlayerGui:FindFirstChild("TopBossChatLocal"):destroy()
end

thing = script.GuiStuff.TopBossChatLocal:Clone()
thing.Font.Value = represfont
thing.Text.Value = text
thing.Color1.Value = color
thing.Color2.Value = color2
thing.Parent = v.PlayerGui
thing.Disabled = false
end
end

function Alert(valuetowait)
for i,v in pairs(game:GetService("Players"):GetPlayers()) do
if v.PlayerGui:FindFirstChild("AlertLocal")~= nil then
v.PlayerGui:FindFirstChild("AlertLocal"):destroy()
end

thing = script.GuiStuff.AlertLocal:Clone()
thing.valuetowait.Value = valuetowait
thing.Parent = v.PlayerGui
thing.Disabled = false
end
end


--Clerp functions
function clerp(a,b,t) 
local qa = {QuaternionFromCFrame(a)}
local qb = {QuaternionFromCFrame(b)} 
local ax, ay, az = a.x, a.y, a.z 
local bx, by, bz = b.x, b.y, b.z
local _t = 1-t
return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
end 
 
function QuaternionFromCFrame(cf) 
local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
local trace = m00 + m11 + m22 
if trace > 0 then 
local s = math.sqrt(1 + trace) 
local recip = 0.5/s 
return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
else 
local i = 0 
if m11 > m00 then
i = 1
end
if m22 > (i == 0 and m00 or m11) then 
i = 2 
end 
if i == 0 then 
local s = math.sqrt(m00-m11-m22+1) 
local recip = 0.5/s 
return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
elseif i == 1 then 
local s = math.sqrt(m11-m22-m00+1) 
local recip = 0.5/s 
return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
elseif i == 2 then 
local s = math.sqrt(m22-m00-m11+1) 
local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
end 
end 
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w) 
local xs, ys, zs = x + x, y + y, z + z 
local wx, wy, wz = w*xs, w*ys, w*zs 
local xx = x*xs 
local xy = x*ys 
local xz = x*zs 
local yy = y*ys 
local yz = y*zs 
local zz = z*zs 
return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
end
 
function QuaternionSlerp(a, b, t) 
local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
local startInterp, finishInterp; 
if cosTheta >= 0.0001 then 
if (1 - cosTheta) > 0.0001 then 
local theta = math.acos(cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((1-t)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta  
else 
startInterp = 1-t 
finishInterp = t 
end 
else 
if (1+cosTheta) > 0.0001 then 
local theta = math.acos(-cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((t-1)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta 
else 
startInterp = t-1 
finishInterp = t 
end 
end 
return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
end

local function CFrameFromTopBack(at, top, back)
local right = top:Cross(back)
return CFrame.new(at.x, at.y, at.z,
right.x, top.x, back.x,
right.y, top.y, back.y,
right.z, top.z, back.z)
end

function Triangle(a, b, c)
local edg1 = (c-a):Dot((b-a).unit)
local edg2 = (a-b):Dot((c-b).unit)
local edg3 = (b-c):Dot((a-c).unit)
if edg1 <= (b-a).magnitude and edg1 >= 0 then
a, b, c = a, b, c
elseif edg2 <= (c-b).magnitude and edg2 >= 0 then
a, b, c = b, c, a
elseif edg3 <= (a-c).magnitude and edg3 >= 0 then
a, b, c = c, a, b
else
assert(false, "unreachable")
end
 
local len1 = (c-a):Dot((b-a).unit)
local len2 = (b-a).magnitude - len1
local width = (a + (b-a).unit*len1 - c).magnitude
 
local maincf = CFrameFromTopBack(a, (b-a):Cross(c-b).unit, -(b-a).unit)
 
local list = {}
 
if len1 > 0.01 then
local w1 = Instance.new('WedgePart', m)
game:GetService("Debris"):AddItem(w1,5)
w1.Material = "SmoothPlastic"
w1.FormFactor = 'Custom'
w1.BrickColor = BrickColor.new("Really red")
w1.Transparency = 0
w1.Reflectance = 0
w1.Material = "SmoothPlastic"
w1.CanCollide = false
local l1 = Instance.new("PointLight",w1)
l1.Color = Color3.new(170,0,0)
NoOutline(w1)
local sz = Vector3.new(0.2, width, len1)
w1.Size = sz
local sp = Instance.new("SpecialMesh",w1)
sp.MeshType = "Wedge"
sp.Scale = Vector3.new(0,1,1) * sz/w1.Size
w1:BreakJoints()
w1.Anchored = true
w1.Parent = workspace
w1.Transparency = 0.7
table.insert(Effects,{w1,"Disappear",.01})
w1.CFrame = maincf*CFrame.Angles(math.pi,0,math.pi/2)*CFrame.new(0,width/2,len1/2)
table.insert(list,w1)
end
 
if len2 > 0.01 then
local w2 = Instance.new('WedgePart', m)
game:GetService("Debris"):AddItem(w2,5)
w2.Material = "SmoothPlastic"
w2.FormFactor = 'Custom'
w2.BrickColor = BrickColor.new("Really red")
w2.Transparency = 0
w2.Reflectance = 0
w2.Material = "SmoothPlastic"
w2.CanCollide = false
local l2 = Instance.new("PointLight",w2)
l2.Color = Color3.new(170,0,0)
NoOutline(w2)
local sz = Vector3.new(0.2, width, len2)
w2.Size = sz
local sp = Instance.new("SpecialMesh",w2)
sp.MeshType = "Wedge"
sp.Scale = Vector3.new(0,1,1) * sz/w2.Size
w2:BreakJoints()
w2.Anchored = true
w2.Parent = workspace
w2.Transparency = 0.7
table.insert(Effects,{w2,"Disappear",.01})
w2.CFrame = maincf*CFrame.Angles(math.pi,math.pi,-math.pi/2)*CFrame.new(0,width/2,-len1 - len2/2)
table.insert(list,w2)
end
return unpack(list)
end
 

function getAttachment0(character, attachmentName)
    for _,child in next,character:GetChildren() do
        local attachment = child:FindFirstChild(attachmentName)
        if attachment then
            return attachment
        end
    end
end
 
function recurse(root,callback,i)
    i= i or 0
    for _,v in pairs(root:GetChildren()) do
        i = i + 1
        callback(i,v)
       
        if #v:GetChildren() > 0 then
            i = recurse(v,callback,i)
        end
    end
   
    return i
end

weldfolder = Instance.new("Folder",workspace)
function weldBetween(part1,part2)
local ANewWeld = Instance.new("Weld",weldfolder)
ANewWeld.Part0 = part1
ANewWeld = part2
end
 function ArtificialHitbox(Part)
    local HITBOX = CreatePart(3, Part, "Metal", 0, 1, "Really black", "Hitbox", Part.Size/2, false)
    HITBOX.CanCollide = true
    HITBOX.CFrame = Part.CFrame
    weldBetween(Part,HITBOX)
end
function ragdollJoint(character, part0, part1, attachmentName, className, properties)
    attachmentName = attachmentName.."RigAttachment"
    local constraint = Instance.new(className.."Constraint")
    constraint.Attachment0 = part0:FindFirstChild(attachmentName)
    constraint.Attachment1 = part1:FindFirstChild(attachmentName)
    constraint.Name = "RagdollConstraint"..part1.Name
   
    for _,propertyData in next,properties or {} do
        constraint[propertyData[1]] = propertyData[2]
    end
   
    constraint.Parent = character
end
function R15Ragdoll(character,KeepArms)
    character:BreakJoints()
    coroutine.resume(coroutine.create(function()
        recurse(character, function(_,v)
            if v:IsA("Attachment") then
                v.Axis = Vector3.new(0, 1, 0)
                v.SecondaryAxis = Vector3.new(0, 0, 1)
                v.Rotation = Vector3.new(0, 0, 0)
            end
        end)
        for _,child in next,character:GetChildren() do
            if child:IsA("Accoutrement") then
                for _,part in next,child:GetChildren() do
                    if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                        local attachment1 = part:FindFirstChildOfClass("Attachment")
                        local attachment0 = getAttachment0(character,attachment1.Name)
                        if attachment0 and attachment1 then
                            local constraint = Instance.new("HingeConstraint")
                            constraint.Attachment0 = attachment0
                            constraint.Attachment1 = attachment1
                            constraint.LimitsEnabled = true
                            constraint.UpperAngle = 0
                            constraint.LowerAngle = 0
                            constraint.Parent = character
                        end
                        ArtificialHitbox(part)
                    elseif part.Name == "HumanoidRootPart" then
                        part:remove()
                    end
                end
            end
        end
       
        ragdollJoint(character,character.LowerTorso, character.UpperTorso, "Waist", "BallSocket", {
            {"LimitsEnabled",true};
            {"UpperAngle",5};
        })
        if character:FindFirstChild("Head") then
            ragdollJoint(character,character.UpperTorso, character.Head, "Neck", "BallSocket", {
                {"LimitsEnabled",true};
                {"UpperAngle",15};
            })
        end
       
        local handProperties = {
            {"LimitsEnabled", true};
            {"UpperAngle",0};
            {"LowerAngle",0};
        }
        ragdollJoint(character,character.LeftLowerArm, character.LeftHand, "LeftWrist", "Hinge", handProperties)
        ragdollJoint(character,character.RightLowerArm, character.RightHand, "RightWrist", "Hinge", handProperties)
       
        local shinProperties = {
            {"LimitsEnabled", true};
            {"UpperAngle", 0};
            {"LowerAngle", -75};
        }
        ragdollJoint(character,character.LeftUpperLeg, character.LeftLowerLeg, "LeftKnee", "Hinge", shinProperties)
        ragdollJoint(character,character.RightUpperLeg, character.RightLowerLeg, "RightKnee", "Hinge", shinProperties)
       
        local footProperties = {
            {"LimitsEnabled", true};
            {"UpperAngle", 15};
            {"LowerAngle", -45};
        }
        ragdollJoint(character,character.LeftLowerLeg, character.LeftFoot, "LeftAnkle", "Hinge", footProperties)
        ragdollJoint(character,character.RightLowerLeg, character.RightFoot, "RightAnkle", "Hinge", footProperties)
        if KeepArms == true then
            ragdollJoint(character,character.UpperTorso, character.RightUpperArm, "RightShoulder", "BallSocket")
            ragdollJoint(character,character.RightUpperArm, character.RightLowerArm, "RightElbow", "BallSocket")
            ragdollJoint(character,character.UpperTorso, character.LeftUpperArm, "LeftShoulder", "BallSocket")
            ragdollJoint(character,character.LeftUpperArm, character.LeftLowerArm, "LeftElbow", "BallSocket")
        end
        ragdollJoint(character,character.LowerTorso, character.LeftUpperLeg, "LeftHip", "BallSocket")
        ragdollJoint(character,character.LowerTorso, character.RightUpperLeg, "RightHip", "BallSocket")
        game:GetService("Debris"):AddItem(character,50)
    end))
end
 
function Ragdoll(Character2,CharTorso,KeepArms)
    coroutine.resume(coroutine.create(function()
	Character2:BreakJoints()
		if Character2:FindFirstChild("HumanoidRootPart") then
			Character2.HumanoidRootPart:Destroy()
			else
		end
        local hum = Character2:FindFirstChildOfClass("Humanoid")
        hum:remove()
        local function Scan(ch)
            local e
            for e = 1,#ch do
                Scan(ch[e]:GetChildren())
                if ch[e].ClassName == "Weld" or ch[e].ClassName == "Motor6D" then
                    ch[e]:remove()
                end
            end
        end
        local NEWHUM = Instance.new("Humanoid")
        NEWHUM.Health = 0
        NEWHUM.MaxHealth = 0
        NEWHUM.PlatformStand = true
        NEWHUM.Parent = Character2
        NEWHUM.DisplayDistanceType = "None"
   
        local ch = Character2:GetChildren()
        local i
        for i = 1,#ch do
            if ch[i].Name == "THandle1" or ch[i].Name == "THandle2" then
                ch[i]:remove()
            end
        end
   
        local Torso2 = Character2.Torso
        local movevector = Vector3.new()
   
        if Torso2 then
            movevector = CFrame.new(CharTorso.Position,Torso2.Position).lookVector
            local Head = Character2:FindFirstChild("Head")
            if Head then
                local Neck = Instance.new("Weld")
                Neck.Name = "Neck"
                Neck.Part0 = Torso2
                Neck.Part1 = Head
                Neck.C0 = CFrame.new(0, 1.5, 0)
                Neck.C1 = CFrame.new()
                Neck.Parent = Torso2
   
            end
            local Limb = Character2:FindFirstChild("Right Arm")
            if Limb and KeepArms == true then
   
                Limb.CFrame = Torso2.CFrame * CFrame.new(1.5, 0, 0)
                local Joint = Instance.new("Glue")
                Joint.Name = "RightShoulder"
                Joint.Part0 = Torso2
                Joint.Part1 = Limb
                Joint.C0 = CFrame.new(1.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
                Joint.C1 = CFrame.new(-0, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
                Joint.Parent = Torso2
   
                local B = Instance.new("Part")
                B.TopSurface = 0
                B.BottomSurface = 0
                B.formFactor = "Symmetric"
                B.Size = Vector3.new(1, 1, 1)
                B.Transparency = 1
                B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
                B.Parent = Character2
                local W = Instance.new("Weld")
                W.Part0 = Limb
                W.Part1 = B
                W.C0 = CFrame.new(0, -0.5, 0)
                W.Parent = Limb
   
            end
            local Limb = Character2:FindFirstChild("Left Arm")
            if Limb and KeepArms == true then
   
                Limb.CFrame = Torso2.CFrame * CFrame.new(-1.5, 0, 0)
                local Joint = Instance.new("Glue")
                Joint.Name = "LeftShoulder"
                Joint.Part0 = Torso2
                Joint.Part1 = Limb
                Joint.C0 = CFrame.new(-1.5, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
                Joint.C1 = CFrame.new(0, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
                Joint.Parent = Torso2
   
                local B = Instance.new("Part")
                B.TopSurface = 0
                B.BottomSurface = 0
                B.formFactor = "Symmetric"
                B.Size = Vector3.new(1, 1, 1)
                B.Transparency = 1
                B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
                B.Parent = Character2
                local W = Instance.new("Weld")
                W.Part0 = Limb
                W.Part1 = B
                W.C0 = CFrame.new(0, -0.5, 0)
                W.Parent = Limb
   
            end
            local Limb = Character2:FindFirstChild("Right Leg")
            if Limb then
   
                Limb.CFrame = Torso2.CFrame * CFrame.new(0.5, -2, 0)
                local Joint = Instance.new("Glue")
                Joint.Name = "RightHip"
                Joint.Part0 = Torso2
                Joint.Part1 = Limb
                Joint.C0 = CFrame.new(0.5, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
                Joint.C1 = CFrame.new(0, 1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
                Joint.Parent = Torso2
   
                local B = Instance.new("Part")
                B.TopSurface = 0
                B.BottomSurface = 0
                B.formFactor = "Symmetric"
                B.Size = Vector3.new(1, 1, 1)
                B.Transparency = 1
                B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
                B.Parent = Character2
                local W = Instance.new("Weld")
                W.Part0 = Limb
                W.Part1 = B
                W.C0 = CFrame.new(0, -0.5, 0)
                W.Parent = Limb
   
            end
            local Limb = Character2:FindFirstChild("Left Leg")
            if Limb then
   
                Limb.CFrame = Torso2.CFrame * CFrame.new(-0.5, -2, 0)
                local Joint = Instance.new("Glue")
                Joint.Name = "LeftHip"
                Joint.Part0 = Torso2
                Joint.Part1 = Limb
                Joint.C0 = CFrame.new(-0.5, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
                Joint.C1 = CFrame.new(-0, 1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
                Joint.Parent = Torso2
   
                local B = Instance.new("Part")
                B.TopSurface = 0
                B.BottomSurface = 0
                B.formFactor = "Symmetric"
                B.Size = Vector3.new(1, 1, 1)
                B.Transparency = 1
                B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
                B.Parent = Character2
                local W = Instance.new("Weld")
                W.Part0 = Limb
                W.Part1 = B
                W.C0 = CFrame.new(0, -0.5, 0)
                W.Parent = Limb
   
            end
            --[
            local Bar = Instance.new("Part")
            Bar.TopSurface = 0
            Bar.BottomSurface = 0
            Bar.formFactor = "Symmetric"
            Bar.Size = Vector3.new(1, 1, 1)
            Bar.Transparency = 1
            Bar.CFrame = Torso2.CFrame * CFrame.new(0, 0.5, 0)
            Bar.Parent = Character2
            local Weld = Instance.new("Weld")
            Weld.Part0 = Torso2
            Weld.Part1 = Bar
            Weld.C0 = CFrame.new(0, 0.5, 0)
            Weld.Parent = Torso2
            --]]
        end
        Character2.Parent = workspace
       game:GetService("Debris"):AddItem(Character2,90)
   
        return Character2,Torso2
    end))
end


function Damagefunc(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)

      
end
function RemoveOutlines(part)
  part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
  local Part = Create("Part")({
    Parent = Parent,
    Reflectance = Reflectance,
    Transparency = Transparency,
    CanCollide = false,
    Locked = true,
    BrickColor = BrickColor.new(tostring(BColor)),
    Name = Name,
    Size = Size,
    Material = Material
  })
  Part.CustomPhysicalProperties = PhysicalProperties.new(0.001, 0.001, 0.001, 0.001, 0.001)
  RemoveOutlines(Part)
  return Part
end

function ShowDamage(Pos, Text, Time, Color)
coroutine.resume(coroutine.create(function()
  local Rate = 0.03333333333333333
  local Pos = Pos or Vector3.new(0, 0, 0)
  local Text = Text or ""
  local Color = Color or Color3.new(1, 0, 1)
  local EffectPart = CreatePart(Character, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
  EffectPart.Anchored = true
  EffectPart.CFrame = CFrame.new(Pos)
  local BillboardGui = Create("BillboardGui")({
    Size = UDim2.new(6, 0, 6, 0),
    Adornee = EffectPart,
    Parent = EffectPart,
	AlwaysOnTop=true,
	Active=true
  })
  local TextLabel = Create("TextLabel")({
    BackgroundTransparency = 1,
	AnchorPoint=Vector2.new(.5,.5),
    Position = UDim2.new(.5, 0, .5, 0),
    Size = UDim2.new(1, 0, 1, 0),
    Text = Text,
    TextColor3 = MAINRUINCOLOR.Color,
   	TextStrokeColor3 = Color3.new(0,0,0),
	TextStrokeTransparency=0,
    TextScaled = true,
    Font = "Arcade",
    Parent = BillboardGui,
	ZIndex=4,
  })
local raise=.2
local rot=math.random(-10,10)/15
local aaa=math.random(-360,360)
local bbb=math.random(-360,360)
for aaa=0,2.7,.01 do
swait()
raise=raise-.008
TextLabel.Rotation = TextLabel.Rotation+rot
TextLabel.TextTransparency=aaa
TextLabel.TextStrokeTransparency=aaa
EffectPart.Position=EffectPart.Position+Vector3.new(0,raise,0)
end
wait(3)
BillboardGui:Remove()
EffectPart:Remove()
end))
end

function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChildOfClass("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Head")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= Player.Name then
          Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://231917784", 1)
        end
      end
    end
  end
end

function MagniDamageWithEffect(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Torso")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= Player.Name then
	--MagicBlock(BrickColor.new("Pastel light blue"),head.CFrame,5,5,5,1,1,1,0.05)
          Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://231917784", 1)
        end
      end
    end
  end
end
function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore) 
end 

--[Head movement core]

local Ang = CFrame.Angles
local aSin = math.asin
local aTan = math.atan

--[Constants]:

local Cam = cam
headmovementenabled = true
local Plr = plr
local Mouse = mouse
local Body = cam.CameraSubject.Parent
local Head = hed
local Hum = hum
local Core = Body:WaitForChild("HumanoidRootPart")
local IsR6 = (Hum.RigType.Value==0)
local Trso = (IsR6 and Body:WaitForChild("Torso")) or Body:WaitForChild("UpperTorso")
local Neck = (IsR6 and Trso:WaitForChild("Neck")) or Head:WaitForChild("Neck")
local Waist = (not IsR6 and Trso:WaitForChild("Waist"))
local MseGuide = true
local TurnCharacterToMouse = false
local HeadHorFactor = 1
local HeadVertFactor = 0.6
local BodyHorFactor = 0.5
local BodyVertFactor = 0.4
local UpdateSpeed = 0.1

local NeckOrgnC0 = Neck.C0
local WaistOrgnC0 = (not IsR6 and Waist.C0)

--[Setup]:

Neck.MaxVelocity = 1/3

-- Activation]:
if TurnCharacterToMouse == true then
	MseGuide = true
	HeadHorFactor = 0
	BodyHorFactor = 0
end
game:GetService("RunService").Stepped:Connect(function()
	if headmovementenabled then
	local CamCF = Cam.CoordinateFrame
	if ((IsR6 and Body["Torso"]) or Body["UpperTorso"])~=nil and Body["Head"]~=nil then	
		local TrsoLV = Trso.CFrame.lookVector
		local HdPos = Head.CFrame.p
		if IsR6 and Neck or Neck and Waist then
			if UpdateSpeed == 0.1 then
				local Dist = nil;
				local Diff = nil;
				if not MseGuide then	
					Dist = (Head.CFrame.p-CamCF.p).magnitude
					Diff = Head.CFrame.Y-CamCF.Y
					if not IsR6 then
						Neck.C0 = Neck.C0:lerp(NeckOrgnC0*Ang((aSin(Diff/Dist)*HeadVertFactor), -(((HdPos-CamCF.p).Unit):Cross(TrsoLV)).Y*HeadHorFactor, 0), UpdateSpeed/2)
						Waist.C0 = Waist.C0:lerp(WaistOrgnC0*Ang((aSin(Diff/Dist)*BodyVertFactor), -(((HdPos-CamCF.p).Unit):Cross(TrsoLV)).Y*BodyHorFactor, 0), UpdateSpeed/2)
					else
						Neck.C0 = Neck.C0:lerp(NeckOrgnC0*Ang(-(aSin(Diff/Dist)*HeadVertFactor), 0, -(((HdPos-CamCF.p).Unit):Cross(TrsoLV)).Y*HeadHorFactor),UpdateSpeed/2)
					end
				else
					local Point = Mouse.Hit.p
					Dist = (Head.CFrame.p-Point).magnitude
					Diff = Head.CFrame.Y-Point.Y
					if not IsR6 then
						Neck.C0 = Neck.C0:lerp(NeckOrgnC0*Ang(-(aTan(Diff/Dist)*HeadVertFactor), (((HdPos-Point).Unit):Cross(TrsoLV)).Y*HeadHorFactor, 0), UpdateSpeed/2)
						Waist.C0 = Waist.C0:lerp(WaistOrgnC0*Ang(-(aTan(Diff/Dist)*BodyVertFactor), (((HdPos-Point).Unit):Cross(TrsoLV)).Y*BodyHorFactor, 0), UpdateSpeed/2)
					else
						Neck.C0 = Neck.C0:lerp(NeckOrgnC0*Ang((aTan(Diff/Dist)*HeadVertFactor), 0, (((HdPos-Point).Unit):Cross(TrsoLV)).Y*HeadHorFactor), UpdateSpeed/2)
					end
				end
			end
		end
	end
	if TurnCharacterToMouse == true then
		Hum.AutoRotate = false
		Core.CFrame = Core.CFrame:lerp(CFrame.new(Core.Position, Vector3.new(Mouse.Hit.p.x, Core.Position.Y, Mouse.Hit.p.z)), UpdateSpeed / 2)
	else
		Hum.AutoRotate = true
	end
	end
end)
------------------

function ring(type,pos,scale,value)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = origcolor
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshId = "http://www.roblox.com/asset/?id=3270017"
rngm.Scale = scale
local scaler2 = 1
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value
end
rng.Transparency = rng.Transparency + 0.01
rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, 0)
end
rng:Destroy()
end))
end


function wave(type,pos,scale,value)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = origcolor
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshId = "http://www.roblox.com/asset/?id=20329976"
rngm.Scale = scale
local scaler2 = 1
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value
end
rng.Transparency = rng.Transparency + 0.01
rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
end
rng:Destroy()
end))
end

function wind(type,pos,scale,value,speed)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = origcolor
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshId = "http://www.roblox.com/asset/?id=1051557"
rngm.Scale = scale
local scaler2 = 1
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value
end
rng.CFrame = rng.CFrame*CFrame.Angles(0,0.025*speed,0)
rng.Transparency = rng.Transparency + 0.01
rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
end
rng:Destroy()
end))
end

function groundwind(type,pos,scale,value,speed)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = origcolor
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshId = "http://www.roblox.com/asset/?id=1051557"
rngm.Scale = scale
local scaler2 = 1
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value
end
rng.CFrame = rng.CFrame*CFrame.Angles(0,0.025*speed,0)
rng.Transparency = rng.Transparency + 0.01
rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2/5, scaler2)
end
rng:Destroy()
end))
end

function CameraManager()
  if TwoD and not CamInterrupt then
    if Humanoid.Health > 0 then
      Camera.CameraSubject = Humanoid
      Camera.CameraType = "Scriptable"
      Humanoid.AutoRotate = false
      if Booleans.GyroUse then
        Directer.MaxTorque = Vec3(0, huge, 0)
      else
        Directer.MaxTorque = Vec3(0, 0, 0)
      end
      if TargetInfo[1] ~= nil and TargetInfo[2] ~= nil then
        if Booleans.CamFollow then
          CPart.CFrame = cFrame(RootPart.Position, Vec3(TargetInfo[1].Position.X, RootPart.Position.Y, TargetInfo[1].Position.Z))
          Directer.CFrame = cFrame((RootPart.CFrame * cFrame(0, 0, 10)).p, TargetInfo[1].Position)
        else
          CPart.Position = RootPart.Position
        end
      else
        local ahead = (RootPart.CFrame * cFrame(0, 0, -3)).p
        CPart.CFrame = cFrame(RootPart.Position, Vec3(ahead.X, RootPart.Position.Y, ahead.Z))
      end
      Camera.CFrame = lerp(Camera.CFrame, CPart.CFrame * cFrame(25, 3, 0) * Euler(0, radian(90), 0), 0.2)
    else
      Camera.CameraSubject = Humanoid
      Camera.CameraType = "Custom"
    end
  end
end

function ring(type,pos,scale,value)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = origcolor
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshId = "http://www.roblox.com/asset/?id=3270017"
rngm.Scale = scale
local scaler2 = 1
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value
end
rng.Transparency = rng.Transparency + 0.01
rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, 0)
end
rng:Destroy()
end))
end


function wave(type,pos,scale,value)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = origcolor
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshId = "http://www.roblox.com/asset/?id=20329976"
rngm.Scale = scale
local scaler2 = 1
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value
end
rng.Transparency = rng.Transparency + 0.01
rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
end
rng:Destroy()
end))
end

function sphere(bonuspeed,type,pos,scale,value,color)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.BrickColor = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = scale
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if ModeOfGlitch == 9 then
coroutine.resume(coroutine.create(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end))
end
local scaler2 = 1
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
end
rng:Destroy()
end))
end

function sphere2(bonuspeed,type,pos,scale,value,value2,value3,color)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.BrickColor = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
if ModeOfGlitch == 9 then
coroutine.resume(coroutine.create(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end))
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end))
end

function slash(bonuspeed,rotspeed,rotatingop,typeofshape,type,typeoftrans,pos,scale,value,color)
local type = type
local rotenable = rotatingop
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
if typeoftrans == "In" then
rng.Transparency = 1
end
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "FileMesh"
if typeofshape == "Normal" then
rngm.MeshId = "rbxassetid://662586858"
elseif typeofshape == "Round" then
rngm.MeshId = "rbxassetid://662585058"
end
rngm.Scale = scale
local scaler2 = 1/10
if type == "Add" then
scaler2 = 1*value/10
elseif type == "Divide" then
scaler2 = 1/value/10
end
local randomrot = math.random(1,2)
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed/10
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed/10
end
if rotenable == true then
if randomrot == 1 then
rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(rotspeed*bonuspeed/2),0)
elseif randomrot == 2 then
rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(-rotspeed*bonuspeed/2),0)
end
end
if typeoftrans == "Out" then
rng.Transparency = rng.Transparency + 0.01*bonuspeed
elseif typeoftrans == "In" then
rng.Transparency = rng.Transparency - 0.01*bonuspeed
end
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed/10, 0, scaler2*bonuspeed/10)
end
rng:Destroy()
end))
end

function PixelBlock(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Brick"
rngm.Scale = vt(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 1
local speeder = FastSpeed/10
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed/10
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
--rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
end
rng:Destroy()
end))
end

function PixelBlockX(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Brick"
rngm.Scale = vt(x1,y1,z1)

local scaler2 = 1
local speeder = FastSpeed/10
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()

if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end

speeder = speeder - 0.01*FastSpeed*bonuspeed/10
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
end
rng:Destroy()
end))
end

function PixelBlockNeg(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Brick"
rngm.Scale = vt(x1,y1,z1)

local scaler2 = 0
local speeder = FastSpeed/10
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()

if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end

speeder = speeder + 0.01*FastSpeed*bonuspeed/10
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
--rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
end
rng:Destroy()
end))
end

function block(bonuspeed,type,pos,scale,value,value2,value3,color,color3)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.Color = color3
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Brick"
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.CFrame = rng.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end))
end

function sphereMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true

        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = vt(x1,y1,z1)



local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()

if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end

speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end))
end


function sphereMKCharge(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 1
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = vt(x1,y1,z1)

local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()

if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end

speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency - 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end))
end

dmgbrickcolor = BrickColor.new("Really blue")
function dmg(dude)
if dude.Name ~= Character then
local keptcolor = dmgbrickcolor
local bgf = Instance.new("BodyGyro",dude.Head)
bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(math.rad(-90),0,0)
--[[local val = Instance.new("BoolValue",dude)
val.Name = "IsHit"]]--
local ds = coroutine.wrap(function()
dude:WaitForChild("Head"):BreakJoints()
for i, v in pairs(dude:GetChildren()) do
if v:IsA("Part") or v:IsA("MeshPart") then
v.Name = "NIL"
end
end
wait(0.5)
targetted = nil
			soundeffect(623904185,0.5,char,1.5,0,"a")
			soundeffect(257001402,0.1,char,1,0,"a")
--CFuncs["Sound"].Create("rbxassetid://623904185", char, 1.5, 0.5)
--CFuncs["Sound"].Create("rbxassetid://257001402", char, 1, 0.1)
coroutine.resume(coroutine.create(function()
for i, v in pairs(dude:GetChildren()) do
if v:IsA("Accessory") then
v:Destroy()
end
if v:IsA("Humanoid") then
v:Destroy()
end
if v:IsA("Model") then
v:Destroy()
end
if v:IsA("Part") or v:IsA("MeshPart") then
for x, o in pairs(v:GetChildren()) do
if o:IsA("Decal") then
o:Destroy()
end
end
coroutine.resume(coroutine.create(function()
v.Material = "Neon"
v.CanCollide = false
v.Anchored = false
local bld = Instance.new("ParticleEmitter",v)
bld.LightEmission = 1
bld.Texture = "rbxassetid://284205403"
bld.Color = ColorSequence.new(keptcolor.Color)
bld.Rate = 50
bld.Lifetime = NumberRange.new(1)
bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0.75,0),NumberSequenceKeypoint.new(1,0,0)})
bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,0)})
bld.Speed = NumberRange.new(0,0)
bld.VelocitySpread = 50000
bld.Rotation = NumberRange.new(-500,500)
bld.RotSpeed = NumberRange.new(-500,500)
        local sbs = Instance.new("BodyPosition", v)
        sbs.P = 3000
        sbs.D = 1000
        sbs.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
        sbs.position = v.Position + Vector3.new(math.random(-2,2),10 + math.random(-2,2),math.random(-2,2))
v.Color = keptcolor.Color
coroutine.resume(coroutine.create(function()
for i = 0, 49 do
swait(1)
v:BreakJoints()
sphere(10,"Add",v.CFrame,Vector3.new(0.01,0.01,0.01),0.01,keptcolor)
v.Transparency = v.Transparency + 0.005
end
v:BreakJoints()
PixelBlockX(1,1,"Add",v.CFrame,0.2,0.2,0.2,0.1,keptcolor,0)
								soundeffect(138210320,3,v,0.8,0,"a")
								for i = 0, 49 do
v.Transparency = v.Transparency + 0.015
end
--CFuncs["Sound"].Create("rbxassetid://138210320", v, 0.8, 3)
bld.Speed = NumberRange.new(10,25)
bld.Drag = 5
bld.Acceleration = vt(0,2,0)
wait(1)
bld.Enabled = false
wait(8)
v:Destroy()
dude:Destroy()
end))
end))
end
end
end))
end)
ds()
end
end

function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return (SinglePlayer.Torso.CFrame.p - Position).magnitude < Distance
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") then
			if v:findFirstChild("Head") then
				if v ~= Character then
					if (v.Head.Position - Position).magnitude <= Distance then
						table.insert(List, v)
					end 
				end 
			end 
		end 
	end
	return List
end

function FaceMouse()
  Cam = workspace.CurrentCamera
  return {
    CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
    Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
  }
end

function FaceMouse2()
  Cam = workspace.CurrentCamera
  return {
    CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)),
    Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
  }
end
local storehumanoidWS = 16

--Ability Storage
SwimType = 4
function Hello()
attack = true
hum.WalkSpeed = 0
 Animate(LW,cf(-1.5,0.9,0.1)*angles(math.rad(38.8),math.rad(-47.4),math.rad(-132.5)),.5,Enum.EasingStyle.Back,Enum.EasingDirection.InOut)
	chatfunc("Hello! I'm Derpz.")
  for i = 0, 5, 0.1 do
  	swait()
  	local Alpha = .2
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0.1,0 + 0.1 * math.cos(sine/30),0)*angles(math.rad(0),math.rad(-0.1),math.rad(-7.6))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1 - 0.1 * math.cos(sine/30),0.1)*angles(math.rad(0),math.rad(6.9),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.9 - 0.1 * math.cos(sine/30),0.1)*angles(math.rad(2.1),math.rad(-14.8),math.rad(11.4))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,0.5,0.1)*angles(math.rad(-4.8),math.rad(-1),math.rad(11.3)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(-0.1,0,0.2)*angles(math.rad(-6.3 + 3 * math.cos(sine/7)),math.rad(0.5),math.rad(-4.9))*necko,Alpha)
  end
for i = 0,15,0.1 do
swait()
  	local Alpha = .2
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0.1,0 + 0.1 * math.cos(sine/30),0)*angles(math.rad(0),math.rad(-0.1),math.rad(-7.6))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1 - 0.1 * math.cos(sine/30),0.1)*angles(math.rad(0),math.rad(6.9),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.9 - 0.1 * math.cos(sine/30),0.1)*angles(math.rad(2.1),math.rad(-14.8),math.rad(11.4))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,0.5,0.1)*angles(math.rad(-4.8),math.rad(-1),math.rad(11.3)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(-0.1,0,0.2)*angles(math.rad(-6.3 + 3 * math.cos(sine/7)),math.rad(0.5),math.rad(-4.9))*necko,Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.5,0.9,0)*angles(math.rad(38.8),math.rad(-47.4 + 15 * math.cos(sine/5)),math.rad(-132.5 - 2 * math.cos(sine/5))),Alpha)
end
hum.WalkSpeed = storehumanoidWS
attack = false
end
function attackone() --new
attack = true
hum.WalkSpeed = 0

  local easingstyle = Enum.EasingStyle.Quad
  local easingdir = Enum.EasingDirection.In
  local animatetime = .25
   Animate(RootJoint,cf(0,0,0)*angles(math.rad(11.9),math.rad(20.3),math.rad(-9.8))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1.1,-1.2,-0.3)*angles(math.rad(-11.5),math.rad(10.2),math.rad(-15.8))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1,0)*angles(math.rad(-27.6),math.rad(-26.8),math.rad(7.6))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.6,0.6,0.8)*angles(math.rad(73.7),math.rad(13.6),math.rad(-31.2)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.4,0.7,0.2)*angles(math.rad(9),math.rad(-20),math.rad(24.9)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(-0.1,0,0.2)*angles(math.rad(-13.2),math.rad(-20),math.rad(-4.6))*necko,animatetime,easingstyle,easingdir).Completed:wait()

  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.Out
  local animatetime = .25
   Animate(RootJoint,cf(0,0,0)*angles(math.rad(17.9),math.rad(45.2),math.rad(-13.1))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-0.9,-0.5,-0.5)*angles(math.rad(-11.5),math.rad(10.2),math.rad(-15.8))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1.1,0.1)*angles(math.rad(-27.6),math.rad(-26.8),math.rad(-5.8))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.5,0.6,0.8)*angles(math.rad(73.7),math.rad(13.6),math.rad(-8.1)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.3,0.9,0.2)*angles(math.rad(1.6),math.rad(-42.4),math.rad(46.5)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(-0.1,0,0.2)*angles(math.rad(-15.7),math.rad(-43),math.rad(-5.9))*necko,animatetime,easingstyle,easingdir).Completed:wait()
soundeffect(4306980885,.4,tors,5,0,"punch")
  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.In
  local animatetime = .2
   Animate(RootJoint,cf(-0.1,0,-0.2)*angles(math.rad(-0.8),math.rad(8.7),math.rad(-5.4))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-0.9,-0.7,-0.3)*angles(math.rad(-3.7),math.rad(7.9),math.rad(-17))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1,0)*angles(math.rad(-6.6),math.rad(-22.7),math.rad(16.5))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.7,0.3,-0.4)*angles(math.rad(105.2),math.rad(-25.6),math.rad(41.7)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.3,0.8,0.3)*angles(math.rad(-2.7),math.rad(-42.9),math.rad(35)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(-0.1,0.1,0.3)*angles(math.rad(-18.3),math.rad(-10),math.rad(-6.4))*necko,animatetime,easingstyle,easingdir).Completed:wait()
		local bodyvel = Instance.new("BodyVelocity",RootPart)
local pep = 10000000
bodyvel.P = pep
bodyvel.MaxForce = Vector3.new(pep,0,pep)
bodyvel.Velocity = RootPart.CFrame.lookVector*5

  local easingstyle = Enum.EasingStyle.Back
  local easingdir = Enum.EasingDirection.Out
  local animatetime = .2
   Animate(RootJoint,cf(0.1,0,-1)*angles(math.rad(-29.5),math.rad(-34.6),math.rad(-20.8))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1,-1.3,-0.1)*angles(math.rad(23.6),math.rad(12.6),math.rad(3.7))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1.1,0.2)*angles(math.rad(-8.5),math.rad(-23.2),math.rad(15.8))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1,0.5,-1.1)*angles(math.rad(86.1),math.rad(-10.9),math.rad(39.1)),animatetime,Enum.EasingStyle.Sine,easingdir)
  	Animate(RW,cf(1.1,0.8,0.4)*angles(math.rad(31.5),math.rad(-61.7),math.rad(62.7)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(0.2,0.1,0.3)*angles(math.rad(-22.4),math.rad(21.5),math.rad(9.7))*necko,animatetime,easingstyle,easingdir).Completed:wait()
MagniDamage(larm,4,20,30,0.1,"Normal")
  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.In
  local animatetime = .2
   Animate(RootJoint,cf(0.1,0.1,-1)*angles(math.rad(-24.6),math.rad(-26),math.rad(-14.6))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1,-1.3,-0.1)*angles(math.rad(21.6),math.rad(12.2),math.rad(3))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1.2,0.2)*angles(math.rad(-2.5),math.rad(-21.5),math.rad(18.1))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-0.5,0,-1.6)*angles(math.rad(73.5),math.rad(9.2),math.rad(76.3)),animatetime,easingstyle,Enum.EasingDirection.Out)
  	Animate(RW,cf(1.2,0.8,0.3)*angles(math.rad(16.1),math.rad(-46),math.rad(45.1)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(0.1,0,0.3)*angles(math.rad(-17.1),math.rad(16.4),math.rad(7))*necko,animatetime,easingstyle,easingdir).Completed:wait()
bodyvel:Destroy()

  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.Out
  local animatetime = .1
   Animate(RootJoint,cf(0.1,0.2,-1)*angles(math.rad(-22.3),math.rad(-18.9),math.rad(-10.5))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1,-1.4,-0.2)*angles(math.rad(20.8),math.rad(12.1),math.rad(3.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1.3,0.2)*angles(math.rad(3.1),math.rad(-19.7),math.rad(20))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.2,0.1,-1)*angles(math.rad(48.1),math.rad(-32.9),math.rad(39.2)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.3,0.8,0.2)*angles(math.rad(10.5),math.rad(-29.8),math.rad(36.7)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(0.1,0,0.2)*angles(math.rad(-12.4),math.rad(12.7),math.rad(5.4))*necko,animatetime,easingstyle,easingdir).Completed:wait()


  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.Out
  local animatetime = .3
   Animate(RootJoint,cf(0.1,0.2,-1)*angles(math.rad(-21.4),math.rad(-15.5),math.rad(-8.7))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1,-1.4,-0.2)*angles(math.rad(20.4),math.rad(12.1),math.rad(3.3))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1.1,-1.4,0.2)*angles(math.rad(5.8),math.rad(-18.8),math.rad(20.9))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.5,0.1,-0.7)*angles(math.rad(46.8),math.rad(-34),math.rad(23.3)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.4,0.8,0.2)*angles(math.rad(9),math.rad(-21.9),math.rad(33.8)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(0.1,0,0.2)*angles(math.rad(-10.3),math.rad(10.8),math.rad(4.8))*necko,animatetime,easingstyle,easingdir).Completed:wait()

hum.WalkSpeed = storehumanoidWS
attack = false
end

function attacktwo() --new
attack = true
hum.WalkSpeed = 0

  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.Out
  local animatetime = .15
   Animate(RootJoint,cf(0,0,0)*angles(math.rad(6),math.rad(-24.9),math.rad(-3.2))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1,-1.2,-0.1)*angles(math.rad(-9.6),math.rad(24.3),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1,0.1)*angles(math.rad(1),math.rad(-20.4),math.rad(15.1))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.5,0.4,0.2)*angles(math.rad(-9),math.rad(26),math.rad(-12.7)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.3,0.5,0.3)*angles(math.rad(60.9),math.rad(-7.1),math.rad(20.7)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(0,0,0.3)*angles(math.rad(-14.3),math.rad(16.1),math.rad(-1.9))*necko,animatetime,easingstyle,easingdir).Completed:wait()

  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.In
  local animatetime = .15
   Animate(RootJoint,cf(0,0,0)*angles(math.rad(11.5),math.rad(-48.1),math.rad(-3.8))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-0.9,-1.4,-0.1)*angles(math.rad(-14.6),math.rad(37),math.rad(8.6))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-0.9,0.1)*angles(math.rad(1),math.rad(-20.4),math.rad(23.3))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.5,0.4,0.2)*angles(math.rad(6.1),math.rad(24.1),math.rad(-24.1)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(0.9,0.5,0.7)*angles(math.rad(80.9),math.rad(-19.6),math.rad(50.2)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(0,0,0.3)*angles(math.rad(-13.4),math.rad(39.6),math.rad(-2.3))*necko,animatetime,easingstyle,easingdir).Completed:wait()

  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.In
  local animatetime = .15
   Animate(RootJoint,cf(0,0,-0.3)*angles(math.rad(1.1),math.rad(-10.1),math.rad(-4.9))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1,-0.6,-0.3)*angles(math.rad(-11.4),math.rad(16.7),math.rad(7.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1.1,-0.8,-0.3)*angles(math.rad(2.8),math.rad(-19.7),math.rad(23.9))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.5,0.4,0.2)*angles(math.rad(-15),math.rad(30.7),math.rad(-14.2)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(0.9,0.5,0.7)*angles(math.rad(108.3),math.rad(15.1),math.rad(51.4)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(0,0.1,0.4)*angles(math.rad(-21.9),math.rad(5.3),math.rad(-1.1))*necko,animatetime,easingstyle,easingdir).Completed:wait()


soundeffect(4306980885,0.8,tors,5,0,"punch")
		local bodyvel = Instance.new("BodyVelocity",RootPart)
local pep = 10000000
bodyvel.P = pep
bodyvel.MaxForce = Vector3.new(pep,0,pep)
bodyvel.Velocity = RootPart.CFrame.lookVector*5

MagniDamage(rarm,4,10,15,0.1,"Normal")

  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.Out
  local animatetime = .15
   Animate(RootJoint,cf(0.1,-0.2,-0.9)*angles(math.rad(-24.2),math.rad(37.6),math.rad(12.6))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1,-1.1,-0.4)*angles(math.rad(18.8),math.rad(18),math.rad(-2.1))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1.1,-1.1,0.1)*angles(math.rad(-17.2),math.rad(-50),math.rad(17.4))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.6,0.3,0.1)*angles(math.rad(-34.4),math.rad(13.2),math.rad(-26.4)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.1,0.4,-1.3)*angles(math.rad(108.3),math.rad(15.1),math.rad(-42.9)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(0,0.1,0.4)*angles(math.rad(-22.7),math.rad(-31.1),math.rad(-1.3))*necko,animatetime,easingstyle,easingdir).Completed:wait()
soundeffect(4306980885,0.95,tors,5,0,"punch")
bodyvel.Velocity = RootPart.CFrame.lookVector*10
MagniDamage(rarm,4,20,30,0.1,"Normal")

  local easingstyle = Enum.EasingStyle.Back
  local easingdir = Enum.EasingDirection.Out
  local animatetime = .3
   Animate(RootJoint,cf(-0.3,-0.2,-1.1)*angles(math.rad(-34.9),math.rad(35.2),math.rad(5.8))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1.1,-1.1,-0.7)*angles(math.rad(18.8),math.rad(18),math.rad(13))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(0.7,-1,0.4)*angles(math.rad(-45.1),math.rad(-54.3),math.rad(2.8))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.6,0.1,-0.1)*angles(math.rad(-48),math.rad(-14.6),math.rad(-26.6)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(0.8,0.3,-1.2)*angles(math.rad(120),math.rad(15.8),math.rad(-88)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(-0.2,0.1,0.2)*angles(math.rad(-22.8),math.rad(-36.2),math.rad(-14.3))*necko,animatetime,easingstyle,easingdir).Completed:wait()

bodyvel:Destroy()
  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.Out
  local animatetime = .3
   Animate(RootJoint,cf(-0.1,0.1,-0.9)*angles(math.rad(-26.7),math.rad(33.5),math.rad(8.6))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1,-1.3,-0.3)*angles(math.rad(21.3),math.rad(-25.5),math.rad(-3.1))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1.4,0.2)*angles(math.rad(-16.9),math.rad(-31.7),math.rad(-2.7))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.6,0.3,-0.1)*angles(math.rad(14.4),math.rad(-37.9),math.rad(-14.9)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.6,0.5,-0.1)*angles(math.rad(73.8),math.rad(16.3),math.rad(-40.6)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(-0.2,0.1,0.4)*angles(math.rad(-31.9),math.rad(-32.6),math.rad(-16.8))*necko,animatetime,easingstyle,easingdir).Completed:wait()

  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.InOut
  local animatetime = .6
   Animate(RootJoint,cf(0,0.1,-0.8)*angles(math.rad(-5.3),math.rad(34),math.rad(-1.3))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1,-1.3,-0.2)*angles(math.rad(1.2),math.rad(13.3),math.rad(-1.8))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1.1,0.1)*angles(math.rad(-11.4),math.rad(-24.8),math.rad(18.5))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.6,0.1,-0.1)*angles(math.rad(-7.3),math.rad(-28.1),math.rad(-11.1)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.4,0.3,-0.3)*angles(math.rad(15),math.rad(27.7),math.rad(-6.1)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(-0.1,0,0.3)*angles(math.rad(-22),math.rad(-39.3),math.rad(-10.6))*necko,animatetime,easingstyle,easingdir).Completed:wait()

hum.WalkSpeed = storehumanoidWS
attack = false
end





function attackthree() --new
attack = true
hum.WalkSpeed = 0
  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.In
  local animatetime = .15
   Animate(RootJoint,cf(0,0,0)*angles(math.rad(-5.7),math.rad(-6.9),math.rad(0.9))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1,-0.4,-0.5)*angles(math.rad(-30),math.rad(9.9),math.rad(-0.7))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1.2,0)*angles(math.rad(11.7),math.rad(-15.8),math.rad(6.4))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.5,0.4,0.2)*angles(math.rad(4.2),math.rad(27.5),math.rad(-8.1)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.5,0.4,0.2)*angles(math.rad(2.8),math.rad(-19.7),math.rad(8.2)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(0,0,0.2)*angles(math.rad(-11.3),math.rad(8.9),math.rad(1.2))*necko,animatetime,easingstyle,easingdir).Completed:wait()
  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.Out
  local animatetime = .3
   Animate(RootJoint,cf(0,0,0)*angles(math.rad(10.6),math.rad(-22.8),math.rad(7))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-0.9,0.3,-0.3)*angles(math.rad(4.1),math.rad(7.9),math.rad(-6.1))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1.1,0)*angles(math.rad(-15.6),math.rad(-17),math.rad(-1.5))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.4,0.8,0.3)*angles(math.rad(4.2),math.rad(27.5),math.rad(-8.1)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.4,0.8,0.2)*angles(math.rad(2.8),math.rad(-19.7),math.rad(8.2)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(0,0,0.1)*angles(math.rad(-3.4),math.rad(30.7),math.rad(0))*necko,animatetime,easingstyle,easingdir).Completed:wait()
MagniDamage(rleg,4,30,40,0.1,"Normal")
  local easingstyle = Enum.EasingStyle.Back
  local easingdir = Enum.EasingDirection.Out
  local animatetime = .3
   Animate(RootJoint,cf(0,0,0)*angles(math.rad(31.4),math.rad(-19),math.rad(14.5))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1.1,-0.9,-0.7)*angles(math.rad(75.5),math.rad(0.3),math.rad(-29.5))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1.3,0)*angles(math.rad(-22.9),math.rad(-16.7),math.rad(-3.6))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.3,0.6,0.3)*angles(math.rad(-29.6),math.rad(27.5),math.rad(-21.9)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.5,0.3,0)*angles(math.rad(-42.3),math.rad(-19.8),math.rad(15.1)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(0,0.1,0.4)*angles(math.rad(-21.8),math.rad(27.3),math.rad(-2.4))*necko,animatetime,easingstyle,easingdir).Completed:wait()
MagniDamage(rleg,4,20,30,0.1,"Normal")
  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.In
  local animatetime = .4
   Animate(RootJoint,cf(0,0,0)*angles(math.rad(10.6),math.rad(-22.8),math.rad(7))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1,-1.3,-0.4)*angles(math.rad(57),math.rad(10.5),math.rad(-27.7))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1.1,0)*angles(math.rad(-15.6),math.rad(-17),math.rad(-1.5))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.5,0.4,0.2)*angles(math.rad(-24.4),math.rad(27.7),math.rad(-4.3)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.5,0.2,0.1)*angles(math.rad(-25.1),math.rad(-21.2),math.rad(10)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(0,0,0.1)*angles(math.rad(-8.8),math.rad(19.6),math.rad(1))*necko,animatetime,easingstyle,easingdir).Completed:wait()
hum.WalkSpeed = storehumanoidWS
attack = false
end


function attackfour()
	attack = true
	   Animate(RootJoint,cf(0,0,0)*angles(math.rad(-42.9),math.rad(-41.7),math.rad(-31.7))*RootCF,.5,Enum.EasingStyle.Sine,Enum.EasingDirection.In)
  	Animate(LH,cf(-1,-1.2,-0.1)*angles(math.rad(37.3),math.rad(50.8),math.rad(-7.7))*angles(math.rad(0),math.rad(-90),math.rad(0)),.5,Enum.EasingStyle.Sine,Enum.EasingDirection.In)
  	Animate(RH,cf(1.1,-1.2,0.1)*angles(math.rad(26.6),math.rad(-35.7),math.rad(-1.1))*angles(math.rad(0),math.rad(90),math.rad(0)),.5,Enum.EasingStyle.Sine,Enum.EasingDirection.In)
  	Animate(LW,cf(-1.1,0.2,0.6)*angles(math.rad(1.1),math.rad(48),math.rad(3.3)),.5,Enum.EasingStyle.Sine,Enum.EasingDirection.In)
  	Animate(RW,cf(1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.5,Enum.EasingStyle.Sine,Enum.EasingDirection.In)
  	Animate(Torso.Neck,cf(0.2,0,-0.1)*angles(math.rad(-3.2),math.rad(39.2),math.rad(18.3))*necko,.55,Enum.EasingStyle.Sine,Enum.EasingDirection.In).Completed:Wait()
--Anim 2
   Animate(RootJoint,cf(0,0,0)*angles(math.rad(158.2),math.rad(-84.6),math.rad(148.9))*RootCF,.7,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
  	Animate(LH,cf(-1,-1,0.3)*angles(math.rad(-45.4),math.rad(71.2),math.rad(32.4))*angles(math.rad(0),math.rad(-90),math.rad(0)),.7,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
  	Animate(RH,cf(0.9,-0.9,0)*angles(math.rad(12.2),math.rad(-27.3),math.rad(25.3))*angles(math.rad(0),math.rad(90),math.rad(0)),.7,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
  	Animate(LW,cf(-1.3,0.9,0.2)*angles(math.rad(85.2),math.rad(-25.2),math.rad(-101.1)),.7,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
  	Animate(RW,cf(1.4,0.7,0.3)*angles(math.rad(34.8),math.rad(-14.7),math.rad(38.1)),.7,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
  	Animate(Torso.Neck,cf(0.1,0,0.2)*angles(math.rad(-27.4),math.rad(75.5),math.rad(17.7))*necko,.7,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
local distlook = 5
for i = 0, 6 do
swait(1)
local heck = Instance.new("Part", char)
        heck.Anchored = true
        heck.CanCollide = false
        heck.FormFactor = 3
        heck.Material = "Neon"
        heck.Size = Vector3.new(1, 1, 1)
        heck.Transparency = 1
        heck.TopSurface = 0
        heck.BottomSurface = 0
heck.CFrame = root.CFrame + root.CFrame.lookVector*distlook
sphere(3,"Add",heck.CFrame,vt(0,0,0),0.1,MAINRUINCOLOR)
sphere(6,"Add",heck.CFrame,vt(0,0,0),0.2,MAINRUINCOLOR)
MagniDamage(heck, 10, 15,35, 0, "Normal")
for i = 0, 2 do
sphereMK(3,0.2,"Add",heck.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),0.1,0.1,2,-0.005,MAINRUINCOLOR,0)
end
soundeffect(183763506,0.9,heck,4,0,"boom")
soundeffect(178452221,0.8,heck,7,0,"heck")
game:GetService("Debris"):AddItem(heck, 5)
distlook = distlook + 7
end
attack = false
end



function jumpup()
	attack = true
hum.WalkSpeed = 0
soundeffect(1666361078,1.2,tors,3,0,"zoom")
for i = 0,5,0.1 do
swait()
root.Velocity = vt(0,200,0)
  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0.1)*angles(math.rad(8.2),math.rad(-0.1),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,0.1)*angles(math.rad(-7),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,0.2,-0.6)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.2,0.4,0.4)*angles(math.rad(-26.8),math.rad(0),math.rad(21)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.3,0.3,0.2)*angles(math.rad(-26.8),math.rad(4.2),math.rad(-13.5)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,-0.3)*angles(math.rad(18.5),math.rad(0),math.rad(0))*necko,Alpha)
end
hum.WalkSpeed = storehumanoidWS
attack = false
end
aerrtee = 0
freefall = 0
--Ability Storage
swimtypenum = 1
function swimtypechange()
	swimtypenum = swimtypenum + 1
	if swimtypenum == 1 then
		SwimType = swimtypenum
		chatfunc("Changed to front crawl.")
	elseif swimtypenum == 2 then
		SwimType = swimtypenum
		chatfunc("Changed to back stroke.")
			elseif swimtypenum == 3 then
		SwimType = swimtypenum
		chatfunc("Changed to butterfly.")
	elseif swimtypenum == 4 then
		SwimType = swimtypenum
		chatfunc("Changed to that one stroke i can't actually name due to roblox.")
	elseif swimtypenum == 5 then
		SwimType = 1
		swimtypenum = 1
	end
end
sittingstyle = 1
function sittingstylechange()
	sittingstyle = sittingstyle + 1

			if sittingstyle == 4 then
sittingstyle = 1
	end
end

function dmgfuncdeath()
dmg(char)
end
function biga()
Animate(RW,cf(1.5,0.5,0)*angles(math.rad(152.4),math.rad(0),math.rad(0)),1,Enum.EasingStyle.Back,Enum.EasingDirection.InOut).Completed:wait()
end
function magicattack()
attack = true
Animate(LW,cf(-0.7,0.5,-0.9)*angles(math.rad(90),math.rad(-7.3),math.rad(77.5)),.5,Enum.EasingStyle.Exponential,Enum.EasingDirection.InOut)
  for i = 0, 2, 0.1 do
  	swait()
  	local Alpha = .5
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(0),math.rad(-23.9),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,0)*angles(math.rad(0),math.rad(31.2),math.rad(-8.1))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-1,0)*angles(math.rad(-2.6),math.rad(-44.6),math.rad(4.3))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)

  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(-0.1,0,0)*angles(math.rad(0),math.rad(22.7),math.rad(-6.5))*necko,Alpha)
  end

	 Animate(RW,cf(1.4,0.7,0.2)*angles(math.rad(-2.6),math.rad(-23.8),math.rad(24.8)),1,Enum.EasingStyle.Exponential,Enum.EasingDirection.In).Completed:wait()
	Animate(LW,cf(-1.3,0.8,0.4)*angles(math.rad(54),math.rad(9.4),math.rad(-89)),.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
	 Animate(RW,cf(1.3,0.7,0.3)*angles(math.rad(-11.7),math.rad(-53.2),math.rad(18.4)),.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
  for i = 0, 7, 0.1 do
  	swait()
  	local Alpha = .3
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(-11.3),math.rad(41.1),math.rad(7.5))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,0)*angles(math.rad(-7.1),math.rad(18.7),math.rad(-17.5))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1.2,-1.1,-0.2)*angles(math.rad(9.6),math.rad(-46.1),math.rad(16.8))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(-0.1,0,0.1)*angles(math.rad(-9.9),math.rad(-37.9),math.rad(-4.5))*necko,Alpha)
  end
attack = false
end
function easports()
	attack = true
	  for i = 0, 3, 0.1 do
  	swait()
  	local Alpha = .3
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0.1,-0.3,-0.2)*angles(math.rad(-19),math.rad(-21.4),math.rad(-7.2))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,0)*angles(math.rad(-15),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.6,-0.5)*angles(math.rad(19.4),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.2,0.2,-0.4)*angles(math.rad(48.5),math.rad(0),math.rad(71.6)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.1,0.2,-0.4)*angles(math.rad(53.3),math.rad(0),math.rad(-75.8)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0.2,0,0.2)*angles(math.rad(-14.3),math.rad(19.7),math.rad(9.9))*necko,Alpha)
	  end
	--Anim 1
		Animate(RootJoint,cf(-0.3,0,-0.1)*angles(math.rad(-12.1),math.rad(32.5),math.rad(-1.6))*RootCF,.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
	 Animate(Torso.Neck,cf(0.1,0,0.2)*angles(math.rad(-11.8),math.rad(9.8),math.rad(5))*necko,.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
		Animate(LH,cf(-0.8,-0.4,-0.6)*angles(math.rad(-44),math.rad(9.7),math.rad(-11.3))*angles(math.rad(0),math.rad(-90),math.rad(0)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
	 Animate(RH,cf(1.1,-1,-0.3)*angles(math.rad(-21.5),math.rad(-16.2),math.rad(17.9))*angles(math.rad(0),math.rad(90),math.rad(0)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
		Animate(LW,cf(-1.3,0.7,0.3)*angles(math.rad(48.5),math.rad(0),math.rad(-47.7)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
	 Animate(RW,cf(1.4,0.7,0.3)*angles(math.rad(53.3),math.rad(0),math.rad(43)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In).Completed:wait()
	--Anim 2
			Animate(RootJoint,cf(-0.3,0,-0.1)*angles(math.rad(140.6),math.rad(67.4),math.rad(-157.7))*RootCF,.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
	 Animate(Torso.Neck,cf(0,0,0.2)*angles(math.rad(-10.3),math.rad(0.7),math.rad(0.9))*necko,.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
		Animate(LH,cf(-1,-1,0)*angles(math.rad(-3.7),math.rad(0),math.rad(-14.8))*angles(math.rad(0),math.rad(-90),math.rad(0)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
	 Animate(RH,cf(1,-0.6,-0.5)*angles(math.rad(19.4),math.rad(0),math.rad(23.9))*angles(math.rad(0),math.rad(90),math.rad(0)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
		Animate(LW,cf(-1,0.8,0.4)*angles(math.rad(48.5),math.rad(0),math.rad(-92.7)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
	 Animate(RW,cf(1.1,0.8,0.4)*angles(math.rad(53.3),math.rad(0),math.rad(82.8)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In).Completed:wait()
	--Anim 3
	   Animate(RootJoint,cf(0.3,-0.1,-0.1)*angles(math.rad(162),math.rad(-4.5),math.rad(-171.6))*RootCF,.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
  	Animate(LH,cf(-1.2,-0.9,-0.3)*angles(math.rad(-29.7),math.rad(1.9),math.rad(-29.4))*angles(math.rad(0),math.rad(-90),math.rad(0)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
  	Animate(RH,cf(1,-1.4,-0.2)*angles(math.rad(-21.5),math.rad(-16.2),math.rad(-12.6))*angles(math.rad(0),math.rad(90),math.rad(0)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
  	Animate(LW,cf(-1.5,0.8,0.4)*angles(math.rad(48.5),math.rad(0),math.rad(-92.7)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
  	Animate(RW,cf(1.4,0.8,0.4)*angles(math.rad(53.3),math.rad(0),math.rad(82.8)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
  	Animate(Torso.Neck,cf(-0.1,0,0.2)*angles(math.rad(-9.5),math.rad(-8.5),math.rad(-2.9))*necko,.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In).Completed:wait()
	--Anim 4
	   Animate(RootJoint,cf(0.6,0.3,-0.4)*angles(math.rad(-176.7),math.rad(-68.4),math.rad(-168.9))*RootCF,.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
  	Animate(LH,cf(-1.2,-1.1,-0.3)*angles(math.rad(-0.3),math.rad(-13.9),math.rad(-13))*angles(math.rad(0),math.rad(-90),math.rad(0)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
  	Animate(RH,cf(1.2,-0.5,-0.5)*angles(math.rad(41.6),math.rad(-18.8),math.rad(8.3))*angles(math.rad(0),math.rad(90),math.rad(0)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
  	Animate(LW,cf(-2,0.7,0.3)*angles(math.rad(48.5),math.rad(0),math.rad(-40.2)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
  	Animate(RW,cf(1.7,0.7,0.2)*angles(math.rad(53.3),math.rad(0),math.rad(40)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
  	Animate(Torso.Neck,cf(-0.1,0,0.2)*angles(math.rad(-8.7),math.rad(6.8),math.rad(-2.9))*necko,.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In).Completed:wait()
	--Anim 5
	   Animate(RootJoint,cf(0,-0.9,-0.6)*angles(math.rad(-12.8),math.rad(14.3),math.rad(0))*RootCF,.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
  	Animate(LH,cf(-1,-0.1,-0.6)*angles(math.rad(12.1),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
  	Animate(RH,cf(1,-1.2,-0.3)*angles(math.rad(-52.7),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
  	Animate(LW,cf(-1.6,0.5,0.4)*angles(math.rad(75.4),math.rad(7.8),math.rad(-76.8)),.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
  	Animate(RW,cf(1.4,0.6,-0.3)*angles(math.rad(-8.6),math.rad(29),math.rad(17.4)),.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
  	Animate(Torso.Neck,cf(0,0,0)*angles(math.rad(0),math.rad(-15.8),math.rad(0))*necko,.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out).Completed:Wait()
wait(1)
	attack = false
end
function ragdolldeath()
	hum.Health = 0
	headmovementenabled = false
Ragdoll(char,Torso,true)
end
function DerpzMorphTrans(trans)

end
function DerpzMorph2Trans(trans)

end
hoodval = false
DerpzMorphTrans(1)
function unzip() --HOODIE, NOT WHATEVER YOU MIGHT THINK YOU DIRTY MINDED HECK
	attack = true
	hum.WalkSpeed = 0
	if hoodval== false then
	  for i = 0, 1, 0.1 do
  	swait()
  	local Alpha = .3
					--RootJoint.C0 = RootJoint.C0:lerp(cf(0,3.5 + .7 * math.cos(sine/25),0)*angles(math.rad(0),math.rad(-90-Vec.X*25),math.rad(Vec.Z*20))*RootCF,Alpha)
LH.C0 = LH.C0:lerp(cf(-1,-0.95 - .1*math.cos(sine/30),0)*angles(math.rad(1.9),math.rad(42.9),math.rad(-10.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
RH.C0 = RH.C0:lerp(cf(1,-0.95 - .1*math.cos(sine/30),0)*angles(math.rad(0),math.rad(0),math.rad(9.1))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.4,0.1,-0.3)*angles(math.rad(74.6),math.rad(17.8),math.rad(76.3)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,0.2,0)*angles(math.rad(0),math.rad(0),math.rad(4.3)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.2,0.5)*angles(math.rad(-32.6),math.rad(6.6),math.rad(0.3))*necko,Alpha)
		  end
		soundeffect(157869722,1.05,tors,4,0,"zip")
hoodval = true
		DerpzMorphTrans(0)
		DerpzMorph2Trans(1)
	  for i = 0, 2, 0.1 do
  	swait()
  	local Alpha = .2
					--RootJoint.C0 = RootJoint.C0:lerp(cf(0,3.5 + .7 * math.cos(sine/25),0)*angles(math.rad(0),math.rad(-90-Vec.X*25),math.rad(Vec.Z*20))*RootCF,Alpha)
LH.C0 = LH.C0:lerp(cf(-1,-0.95 - .1*math.cos(sine/30),0)*angles(math.rad(1.9),math.rad(42.9),math.rad(-10.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
RH.C0 = RH.C0:lerp(cf(1,-0.95 - .1*math.cos(sine/30),0)*angles(math.rad(0),math.rad(0),math.rad(9.1))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.4,0.1,-0.3)*angles(math.rad(67.4),math.rad(-12.5),math.rad(76.6)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,0.2,0)*angles(math.rad(0),math.rad(0),math.rad(2)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.2,0.6)*angles(math.rad(-37.8),math.rad(6.6),math.rad(0.9))*necko,Alpha)
		  end
		
	  for i = 0, 4, 0.1 do
  	swait()
  	local Alpha = .1
					--RootJoint.C0 = RootJoint.C0:lerp(cf(0,3.5 + .7 * math.cos(sine/25),0)*angles(math.rad(0),math.rad(-90-Vec.X*25),math.rad(Vec.Z*20))*RootCF,Alpha)
LH.C0 = LH.C0:lerp(cf(-1,-0.95 - .1*math.cos(sine/30),0)*angles(math.rad(1.9),math.rad(42.9),math.rad(-10.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
RH.C0 = RH.C0:lerp(cf(1,-0.95 - .1*math.cos(sine/30),0)*angles(math.rad(0),math.rad(0),math.rad(9.1))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.7,0,-0.2)*angles(math.rad(62.2),math.rad(-21.1),math.rad(59.3)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,0.2,0)*angles(math.rad(0),math.rad(0),math.rad(0.9)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.2,0.6)*angles(math.rad(-40.1),math.rad(6.6),math.rad(1.1))*necko,Alpha)
	  end
	  for i = 0, 10, 0.1 do
  	swait()
  	local Alpha = .05
					--RootJoint.C0 = RootJoint.C0:lerp(cf(0,3.5 + .7 * math.cos(sine/25),0)*angles(math.rad(0),math.rad(-90-Vec.X*25),math.rad(Vec.Z*20))*RootCF,Alpha)
LH.C0 = LH.C0:lerp(cf(-1,-0.95 - .1*math.cos(sine/30),0)*angles(math.rad(1.9),math.rad(42.9),math.rad(-10.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
RH.C0 = RH.C0:lerp(cf(1,-0.95 - .1*math.cos(sine/30),0)*angles(math.rad(0),math.rad(0),math.rad(9.1))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.5,0.3,0)*angles(math.rad(0),math.rad(0),math.rad(-7.2)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,0.2,0)*angles(math.rad(0),math.rad(0),math.rad(3.5)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0.1,0,0.1)*angles(math.rad(-5.7),math.rad(18.3),math.rad(3.2))*necko,Alpha)
		  end
	else
		hoodval = false
		
			  for i = 0, 1, 0.1 do
  	swait()
  	local Alpha = .3
					--RootJoint.C0 = RootJoint.C0:lerp(cf(0,3.5 + .7 * math.cos(sine/25),0)*angles(math.rad(0),math.rad(-90-Vec.X*25),math.rad(Vec.Z*20))*RootCF,Alpha)
LH.C0 = LH.C0:lerp(cf(-1,-0.95 - .1*math.cos(sine/30),0)*angles(math.rad(1.9),math.rad(42.9),math.rad(-10.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
RH.C0 = RH.C0:lerp(cf(1,-0.95 - .1*math.cos(sine/30),0)*angles(math.rad(0),math.rad(0),math.rad(9.1))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.7,0,-0.2)*angles(math.rad(62.2),math.rad(-21.1),math.rad(59.3)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,0.2,0)*angles(math.rad(0),math.rad(0),math.rad(0.9)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.2,0.6)*angles(math.rad(-40.1),math.rad(6.6),math.rad(1.1))*necko,Alpha)
		  end
		soundeffect(157869722,0.95,tors,4,0,"zip")
			  for i = 0, 2, 0.1 do
  	swait()
  	local Alpha = .2
					--RootJoint.C0 = RootJoint.C0:lerp(cf(0,3.5 + .7 * math.cos(sine/25),0)*angles(math.rad(0),math.rad(-90-Vec.X*25),math.rad(Vec.Z*20))*RootCF,Alpha)
LH.C0 = LH.C0:lerp(cf(-1,-0.95 - .1*math.cos(sine/30),0)*angles(math.rad(1.9),math.rad(42.9),math.rad(-10.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
RH.C0 = RH.C0:lerp(cf(1,-0.95 - .1*math.cos(sine/30),0)*angles(math.rad(0),math.rad(0),math.rad(9.1))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.4,0.1,-0.3)*angles(math.rad(67.4),math.rad(-12.5),math.rad(76.6)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,0.2,0)*angles(math.rad(0),math.rad(0),math.rad(2)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.2,0.6)*angles(math.rad(-37.8),math.rad(6.6),math.rad(0.9))*necko,Alpha)
		  end
		DerpzMorphTrans(1)
		DerpzMorph2Trans(0)
			  for i = 0, 4, 0.1 do
  	swait()
  	local Alpha = .1
					--RootJoint.C0 = RootJoint.C0:lerp(cf(0,3.5 + .7 * math.cos(sine/25),0)*angles(math.rad(0),math.rad(-90-Vec.X*25),math.rad(Vec.Z*20))*RootCF,Alpha)
LH.C0 = LH.C0:lerp(cf(-1,-0.95 - .1*math.cos(sine/30),0)*angles(math.rad(1.9),math.rad(42.9),math.rad(-10.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
RH.C0 = RH.C0:lerp(cf(1,-0.95 - .1*math.cos(sine/30),0)*angles(math.rad(0),math.rad(0),math.rad(9.1))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.4,0.1,-0.3)*angles(math.rad(74.6),math.rad(17.8),math.rad(76.3)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,0.2,0)*angles(math.rad(0),math.rad(0),math.rad(4.3)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.2,0.5)*angles(math.rad(-32.6),math.rad(6.6),math.rad(0.3))*necko,Alpha)
		  end
					  for i = 0, 10, 0.1 do
  	swait()
  	local Alpha = .05
					--RootJoint.C0 = RootJoint.C0:lerp(cf(0,3.5 + .7 * math.cos(sine/25),0)*angles(math.rad(0),math.rad(-90-Vec.X*25),math.rad(Vec.Z*20))*RootCF,Alpha)
LH.C0 = LH.C0:lerp(cf(-1,-0.95 - .1*math.cos(sine/30),0)*angles(math.rad(1.9),math.rad(42.9),math.rad(-10.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
RH.C0 = RH.C0:lerp(cf(1,-0.95 - .1*math.cos(sine/30),0)*angles(math.rad(0),math.rad(0),math.rad(9.1))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.5,0.3,0)*angles(math.rad(0),math.rad(0),math.rad(-7.2)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,0.2,0)*angles(math.rad(0),math.rad(0),math.rad(3.5)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0.1,0,0.1)*angles(math.rad(-5.7),math.rad(18.3),math.rad(3.2))*necko,Alpha)
		  end
	end
	attack = false
hum.WalkSpeed = storehumanoidWS
end
--Important Removal Stuff
Humanoid.Animator.Parent = nil
for i,v in pairs (char:GetChildren()) do
if v.ClassName == "LocalScript" and v.Name ~= "Client" then
v:Destroy()
print(v.Name.. " Destroyed")
end
end
--Important Removal Stuff

--Click, Letter and Number Key Setup + Chat Setup
local attacknumber = 1
mouse.Button1Down:connect(function()
  if attack == false and attacknumber == 1 then
    attacknumber = 2
    attackone()
  elseif attack == false and attacknumber == 2 then
    attacknumber = 3
   attacktwo()
  elseif attack == false and attacknumber == 3 then
    attacknumber = 4
    attackthree()
  elseif attack == false and attacknumber == 4 then
    attacknumber = 1
    attackfour()
  end
end)
muted = false
mouse.KeyDown:connect(function(k)
if k == "l" and muted == false then
muted = true
chatfunc("Muted.",10,BrickColor.new("Really red").Color)
DerpzMusic.Volume = 0
elseif k == "l" and muted == true then
muted = false
chatfunc("Unmuted.",10,BrickColor.new("Bright green").Color)
DerpzMusic.Volume = 1.25
end
if k == "t" and attack == false then
--Hello() to be remade
end
if k == "h" and attack == false then
Alert(1)
wait(4)
FillScreen(BrickColor.new("Really red").Color,1)
wait(4)
BossChatFuncTop("Testing","Fantasy",Color3.new(0,0,0),Color3.new(1,1,1))
end
if k == "x" and attack == false then
	--magicattack()
end
if k == "c" and attack == false then
	--easports()
end
if k == "z" and attack == false then
unzip()
end
if k == "f" and attack == false then
swimtypechange()
end
if k == "g" and attack == false then
sittingstylechange()
end
if k == "u" and attack == false then
--dmgfuncdeath()
end
if k == "]" and attack == false then
--ragdolldeath() this breaks stuff. alot.
end
if k == "p" and attack == false then
hum.WalkSpeed = 16
storehumanoidWS = 16
DerpzMusic.SoundId = "rbxassetid://5259946954"
songnameboi = "Far Too Loud - Speed Of Light"
MainFrame.SongName.Text = "Music Name: " ..songnameboi
end
if k == "[" and attack == false then
hum.WalkSpeed = 40
storehumanoidWS = 40

end
if k == "]" and attack == false then
hum.WalkSpeed = 210
storehumanoidWS = 210

end
end)
mouse.KeyUp:connect(function(k)

end)


plr.Chatted:connect(function(message)
chatfunc(message,20,BrickColor.new("Really blue").Color)
end)





--song name
DerpzMusic.SoundId = "rbxassetid://5259946954"
songnameboi = "Far Too Loud - Speed Of Light"
MainFrame.SongName.Text = "Music Name: " ..songnameboi
--song name




--Click, Letter and Number Key Setup + Chat Setup

--Protection & Name
Humanoid.Name = "DERPZDENUGGET BASE"
Instance.new("ForceField",char).Visible = false
--Protection & Name
spiney = 0
--"while true do" Animations, repeated colors, effects
	tired = false
	particles = script.Particles
	particles.Parent = Head
while true do
	finalweld36.C0 = CFrame.new(0,3 + .1 * math.cos(sine/30),-0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))

	MainFrame.SongName.Text = "Music Name: " ..songnameboi
		 counter = counter + 0.005 --This is for the rainbow function thing! Example to be used: Color3.fromHSV(boop(counter),1,1)
Humanoid.MaxHealth = math.huge
Humanoid.Health = math.huge
swait()
 sine = sine + change


    --Footplanting code, no need to modify anything, variable is Vec.X,Y or Z
    local Walking = hum.MoveDirection.magnitude>0
    local FwdDir = (Walking and hum.MoveDirection*root.CFrame.lookVector or Vector3.new())
    local RigDir = (Walking and hum.MoveDirection*root.CFrame.rightVector or Vector3.new())
    local Vec = {
        X=RigDir.X+RigDir.Z,
        Z=FwdDir.X+FwdDir.Z
    };
    local Divide = 1
    if(Vec.Z<0)then
        Divide=math.clamp(-(1.25*Vec.Z),1,2)
    end
    Vec.Z = Vec.Z/Divide
    Vec.X = Vec.X/Divide




local torvel=(RootPart.Velocity*Vector3.new(1,0,1)).magnitude 
local velderp=RootPart.Velocity.y
hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
coroutine.resume(coroutine.create(function()
					--Eye Blink
	local randomblink = math.random(0,300)
	if randomblink == 0 and blinking == false then
		blinkfunction()
		else
	end
	--Tail Movement
	if Anim == "Idle" then
					finalweld333.C1 = finalweld333.C1:lerp(cf(0 - .1 *math.cos(sine/30),0.1,-0.1 + .05 * math.cos(sine/30))*angles(math.rad(0 + 10 * math.cos(sine/40)),math.rad(0 + 10 * math.cos(sine/30)),math.rad(0 + 4 * math.cos(sine/30))),.1)
	elseif Anim == "Walk" then
		local wsvv = 8
local wsvv2 = 4
					finalweld333.C1 = finalweld333.C1:lerp(cf(0 - .1 *math.cos(sine/wsvv/2),0.1,-0.1 + .05 * math.cos(sine/wsvv/2))*angles(math.rad(0 + 10 * math.cos(sine/wsvv2/2)),math.rad(0 + 10 * math.cos(sine/wsvv2/2)),math.rad(0 + 4 * math.cos(sine/wsvv/2))),.1)
	elseif Anim == "Run" or Anim == "FasterRun" then
		local wsvv = 4
local wsvv2 = 2
					finalweld333.C1 = finalweld333.C1:lerp(cf(0 - .1 *math.cos(sine/wsvv/2),0.1,-0.1 + .05 * math.cos(sine/wsvv/2))*angles(math.rad(0 + 10 * math.cos(sine/wsvv2/2)),math.rad(0 + 10 * math.cos(sine/wsvv2/2)),math.rad(0 + 4 * math.cos(sine/wsvv/2))),.1)

	end
	
if hitfloor ~= nil then
	local rval = 0 
	freefall = 0
--			WACKYEFFECT({
--				Time = 30, -- Time. Duh
--				EffectType = "Sphere", -- Effect Type. Effect Types: "Box", "Wedge", "Sphere", "Ring", "Wave", "Slash", "Swirl", "Round Slash", "Skull", "Crystal"
--				Size = VT(0.01,0.01,0.01), -- Start Size
--				Size2 = VT(0.3, math.random(3,6), 0.3), -- End Size
--				Transparency = 0.4,-- Start Transparency
--				Transparency2 = 1, -- End Transparency
--				CFrame = root.CFrame*CFrame.new(math.random(-6,6),-3,math.random(-6,6))*CFrame.Angles(math.rad(0 + math.random(-3,3)),math.rad(math.random(-3,3)),math.rad(math.random(-3,3))), -- Start CFrame
--				MoveToPos = nil, -- Move to position. You must add .p at the end of a cframe. Do not use angles
--				RotationX = 0, -- Rotation X
--				RotationY = 0, -- Rotation Y
--				RotationZ = 0, -- Rotation Z
--				Material = "Neon", -- Material
--				Color = Color3.fromRGB(0,155+100*math.cos(sine/40),155+100*math.cos(sine/40)), -- Color (NOT BRICKCOLOR)
--				SoundID = nil, -- Sound that plays while effect is being done
--				SoundPitch = 0, -- Pitch
--				SoundVolume = 10, -- Vol
--				UseBoomerangMath = false, -- Boomerang Enabled
--				Boomerang = 0, -- Makes it come back to start position
--				SizeBoomerang = 50 -- Makes it come back to start size
--})
spiney = spiney + 5

--			WACKYEFFECT({
--				Time = 40, -- Time. Duh
--				EffectType = "Sphere", -- Effect Type. Effect Types: "Box", "Wedge", "Sphere", "Ring", "Wave", "Slash", "Swirl", "Round Slash", "Skull", "Crystal"
--				Size = VT(0.1,1,0.1), -- Start Size
--				Size2 = VT(1,10,1), -- End Size
--				Transparency = 0,-- Start Transparency
--				Transparency2 = 1, -- End Transparency
--				CFrame = root.CFrame*CFrame.new(math.random(-25,25),20 - 5 * math.cos(sine/2),math.random(-25,25))*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), -- Start CFrame
--				MoveToPos = nil, -- Move to position. You must add .p at the end of a cframe. Do not use angles
--				RotationY = 0, -- Rotation Y
--				RotationZ = 0, -- Rotation Z
--				Material = Enum.Material.Neon, -- Material
--				ColorLoop = true, --e
--				Color = Color3.fromRGB(0,0,255 - 100 * math.cos(sine/10)), -- Color (NOT BRICKCOLOR)
--				SoundID = nil, -- Sound that plays while effect is being done
--				SoundPitch = 0, -- Pitch
--				SoundVolume = 10, -- Vol
--				UseBoomerangMath = false, -- Boomerang Enabled
--				Boomerang = 0, -- Makes it come back to start position
--				SizeBoomerang = 50 -- Makes it come back to start size
--})
--			WACKYEFFECT({
--				Time = 20, -- Time. Duh
--				EffectType = "Sphere", -- Effect Type. Effect Types: "Box", "Wedge", "Sphere", "Ring", "Wave", "Slash", "Swirl", "Round Slash", "Skull", "Crystal"
--				Size = VT(0.1,0.1,0.1), -- Start Size
--				Size2 = VT(1,1,1), -- End Size
--				Transparency = 0,-- Start Transparency
--				Transparency2 = 1, -- End Transparency
--				CFrame = root.CFrame*CFrame.new(math.random(-5,5),math.random(-3,3),math.random(-5,5))*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), -- Start CFrame
--				MoveToPos = nil, -- Move to position. You must add .p at the end of a cframe. Do not use angles
--				RotationY = 0, -- Rotation Y
--				RotationZ = 0, -- Rotation Z
--				Material = Enum.Material.Neon, -- Material
--				ColorLoop = true, --e
--				Color = Color3.fromRGB(0,0,255 - 100 * math.cos(sine/10)), -- Color (NOT BRICKCOLOR)
--				SoundID = nil, -- Sound that plays while effect is being done
--				SoundPitch = 0, -- Pitch
--				SoundVolume = 10, -- Vol
--				UseBoomerangMath = true, -- Boomerang Enabled
--				Boomerang = 0, -- Makes it come back to start position
--				SizeBoomerang = 50 -- Makes it come back to start size
--})

end
end))
if tired == false then
particles.Enabled = false
Happy()
DerpzMusic:Resume()
sleepymusic:Pause()
elseif tired == true then
particles.Enabled = true
Sleeping()
sleepymusic:Resume()
DerpzMusic:Pause()
end
if equipped==true or equipped==false then
if attack==false and Anim == "Idle" then
idle=idle+1
else
idle=0
tired = false
end
if idle>=30000 then
if attack==false then
tired = true
end
end

		if hum:GetState() == Enum.HumanoidStateType.Swimming and torvel<1 and hum.Sit ~= true then
Anim="SwimIdle"
if attack == false then
  	local Alpha = .3
if SwimType ~= "ICANTSWIMIMUSEDTOFLYING" then
hum.WalkSpeed = storehumanoidWS
local rm = math.random(1,100)
if rm == 1 then
soundeffect(357616080,0.95,hed,10,0,"HELP")
else end
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,-0.1)*angles(math.rad(11.2),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.5,-0.6)*angles(math.rad(-24.8),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.4,0.6,-0.1)*angles(math.rad(70.5),math.rad(-15.8),math.rad(-53.9 + 40 * math.cos(sine/30))),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.7,0.5,-0.1)*angles(math.rad(64.7),math.rad(19),math.rad(43.1 - 40 * math.cos(sine/30))),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*necko,.1)
elseif SwimType == "ICANTSWIMIMUSEDTOFLYING" then
	local rm = math.random(1,30)
if rm == 1 then
soundeffect(357616080,0.95,hed,10,0,"HELP")


else end
Static1:Resume()
	hum.WalkSpeed = 0
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,-0.1)*angles(math.rad(11.2),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.5,-0.6)*angles(math.rad(-24.8),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.4,0.6,-0.1)*angles(math.rad(160),math.rad(-15.8),math.rad(-53.9 + 40 * math.cos(sine/9))),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.7,0.5,-0.1)*angles(math.rad(160),math.rad(19),math.rad(43.1 - 40 * math.cos(sine/11))),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,-0.7)*angles(math.rad(40),math.rad(0),math.rad(0))*necko,.1)
end
end
elseif hum:GetState() == Enum.HumanoidStateType.Swimming and torvel>1 and hum.Sit ~= true then
	Anim="Swim"
	local rm = math.random(1,150)
if rm == 1 then
soundeffect(357616080,0.95,hed,1,0,"HELP")
else end
	if attack == false then
		hum.WalkSpeed = 16
		local Alpha = .3
		if SwimType == 1 then
	--Front crawl
	aerrtee = aerrtee + 10
			hum.WalkSpeed = 16
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1.1,0.2)*angles(math.rad(-5 - 20 * math.cos(sine/7)),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.8,-0.1)*angles(math.rad(5 + 20 * math.cos(sine/7)),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.5,0.5,0)*angles(math.rad(180 + aerrtee),math.rad(0),math.rad(0)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,0.5,0)*angles(math.rad(0 + aerrtee),math.rad(0),math.rad(0)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.1,-0.5)*angles(math.rad(28.4),math.rad(0),math.rad(0))*necko,.1)
		elseif SwimType == 2 then
			--Back stroke
				aerrtee = aerrtee + 10
						hum.WalkSpeed = 16
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(0),math.rad(180),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1.1,0.2)*angles(math.rad(-5 + 20 * math.cos(sine/7)),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.8,-0.1)*angles(math.rad(5 - 20 * math.cos(sine/7)),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.5,0.5,0)*angles(math.rad(180 - aerrtee),math.rad(0),math.rad(0)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,0.5,0)*angles(math.rad(0 - aerrtee),math.rad(0),math.rad(0)),Alpha)
  	  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*necko,.1)
		elseif SwimType == 3 then
			--Butterfly
				aerrtee = aerrtee + 10
						hum.WalkSpeed = 16
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(0 - 5 * math.cos(sine/3.5)),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1.1,0.2)*angles(math.rad(-5 + 20 * math.cos(sine/7)),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.8,-0.1)*angles(math.rad(5 + 20 * math.cos(sine/7)),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.5,0.5,0)*angles(math.rad(180 - aerrtee),math.rad(0),math.rad(0)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,0.5,0)*angles(math.rad(180 - aerrtee),math.rad(0),math.rad(0)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.1,-0.5)*angles(math.rad(28.4),math.rad(0),math.rad(0))*necko,.1)
		elseif SwimType == 4 then
			--Breast Stroke (Don't mind the name, That's actually what it's called.)
		  for i = 0, 1, 0.1 do
  	swait()
  	local Alpha = .25
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(10),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1.4,-0.6,-0.7)*angles(math.rad(-19.8),math.rad(-5.8),math.rad(15.6))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1.5,-0.5,-0.4)*angles(math.rad(0),math.rad(0),math.rad(-22.8))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1,1.2,-1)*angles(math.rad(141),math.rad(-22.7),math.rad(23.8)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(0.6,0.8,-1.2)*angles(math.rad(133.9),math.rad(-15.4),math.rad(-15.2)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,-0.2)*angles(math.rad(5.9),math.rad(0),math.rad(0))*necko,Alpha)
		  end
		  for i = 0, 1, 0.1 do
  	swait()
  	local Alpha = .3
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(-10),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-0.6,-0.5,0.1)*angles(math.rad(-0.3),math.rad(-8.5),math.rad(-51))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(0.9,-0.7,0)*angles(math.rad(0),math.rad(0),math.rad(40))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.8,1.1,-0.5)*angles(math.rad(141),math.rad(-22.7),math.rad(-45.6)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.4,0.5,-0.2)*angles(math.rad(139.1),math.rad(-4.1),math.rad(66)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.2,-0.7)*angles(math.rad(28),math.rad(0),math.rad(0))*necko,Alpha)
		  end
		  for i = 0, 2, 0.1 do
  	swait()
  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,0)*angles(math.rad(-0.3),math.rad(-8.5),math.rad(-8.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-1,0)*angles(math.rad(0),math.rad(0),math.rad(-1.4))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-0.8,0.8,-0.8)*angles(math.rad(141),math.rad(-22.7),math.rad(76.2)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.3,0.6,-0.6)*angles(math.rad(107.2),math.rad(5),math.rad(-49.4)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.2,-0.7)*angles(math.rad(28),math.rad(0),math.rad(0))*necko,Alpha)
  end
			end
	end
				elseif Humanoid:GetState() == Enum.HumanoidStateType.Climbing and Humanoid.MoveDirection ~= Vector3.new(0,0,0) and hum.Sit ~= true then
					Anim = "Climbing"
					Humanoid.WalkSpeed = 16
					  for i = 0, 2, 0.1 do
  	swait()
  	local Alpha = .2
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0.5,-0.2)*angles(math.rad(-5.1),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-0.5,-0.6)*angles(math.rad(9),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.3,-0.7)*angles(math.rad(11.9),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.4,0.5,0.2)*angles(math.rad(69.8),math.rad(8.4),math.rad(-27.9)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.4,0.2,0.1)*angles(math.rad(104.6),math.rad(-29),math.rad(19.6)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.1,-0.4)*angles(math.rad(25.5),math.rad(0.6),math.rad(0))*necko,Alpha)
					  end
					Humanoid.WalkSpeed = 25
					  for i = 0, 3, 0.1 do
  	swait()
  	local Alpha = .25
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,3.3,0)*angles(math.rad(-21.5),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1.2,-0.3)*angles(math.rad(-21.2),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-1.1,-0.4)*angles(math.rad(-17.6),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.5,1.5,0.1)*angles(math.rad(168),math.rad(-28.8),math.rad(-3.5)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,1.2,-0.1)*angles(math.rad(179.6),math.rad(-11.2),math.rad(10.4)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.2,-0.6)*angles(math.rad(34.4),math.rad(0.6),math.rad(-0.1))*necko,Alpha)
					  end
					Humanoid.WalkSpeed = 20
					  for i = 0, 2, 0.1 do
  	swait()
  	local Alpha = .15
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,2.4,-0.2)*angles(math.rad(-3.7),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1.2,-0.3)*angles(math.rad(-21.8),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-1.1,-0.4)*angles(math.rad(-49.4),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.6,1.1,-0.1)*angles(math.rad(142.3),math.rad(-25),math.rad(-15.3)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,1,-0.1)*angles(math.rad(170.9),math.rad(32.9),math.rad(-10.5)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,0.1)*angles(math.rad(-4.4),math.rad(0.6),math.rad(0.3))*necko,Alpha)
					  end
										Humanoid.WalkSpeed = 16
					 for i = 0, 2, 0.1 do
  	swait()
  	local Alpha = .3
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0.8,-0.2)*angles(math.rad(5.3),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-0.3,-0.3)*angles(math.rad(15.3),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.6,-0.6)*angles(math.rad(3.8),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.6,0.8,0)*angles(math.rad(87.6),math.rad(-1.3),math.rad(-29)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.4,0.5,0.1)*angles(math.rad(104.3),math.rad(-2.7),math.rad(15.3)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.1,0.5)*angles(math.rad(-32.9),math.rad(0.3),math.rad(0.5))*necko,Alpha)
  end
	if attack == false then
end
	elseif Humanoid.MoveDirection == Vector3.new(0,0,0) and Humanoid:GetState() == Enum.HumanoidStateType.Climbing and  attack == false and hum.Sit ~= true then
		Anim="ClimbingIdle"
		Humanoid.WalkSpeed = storehumanoidWS
		  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0.5,-0.2)*angles(math.rad(-5.1),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-0.5,-0.6)*angles(math.rad(9),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.3,-0.7)*angles(math.rad(11.9),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.4,0.5,0.2)*angles(math.rad(69.8),math.rad(8.4),math.rad(-27.9)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.4,0.2,0.1)*angles(math.rad(104.6),math.rad(-29),math.rad(19.6)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.1,-0.4)*angles(math.rad(25.5),math.rad(0.6),math.rad(0))*necko,Alpha)

		elseif hum.Sit == true then
			Anim="Sitting"
			hum.WalkSpeed = storehumanoidWS
			if sittingstyle == 1 then
				--Sitting on a chair
  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0 -   0.1 * math.cos(sine/50),0.1)*angles(math.rad(10.7),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-0.9,-1,-0.2)*angles(math.rad(89.5),math.rad(0),math.rad(20.7))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.8,-0.4)*angles(math.rad(39.5),math.rad(0),math.rad(-23.6))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1,0.2 +  0.1 * math.cos(sine/40),-0.4)*angles(math.rad(54.7),math.rad(0),math.rad(91)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.1,0.1 +  0.1 * math.cos(sine/40),-0.2)*angles(math.rad(32.1),math.rad(-19.9),math.rad(-83)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0.1,0,0.3)*angles(math.rad(-16.7),math.rad(0),math.rad(4.6))*necko,Alpha)

				elseif sittingstyle == 2 then
				--Sitting on a stool
				  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0 + 0.1 * math.cos(sine/50),0)*angles(math.rad(-10.3),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1.1,-0.4)*angles(math.rad(54.4),math.rad(5.6),math.rad(-7))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(0.9,-0.7,-0.2)*angles(math.rad(44.3),math.rad(2.5),math.rad(10.8))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-0.7,0 - 0.1 * math.cos(sine/40),-0.6)*angles(math.rad(48.3),math.rad(8.4),math.rad(90.5)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(0.8,0.2 - 0.1 * math.cos(sine/40),-0.4)*angles(math.rad(54.2),math.rad(-19),math.rad(-77.1)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,0)*angles(math.rad(0.1),math.rad(-4.3 - 2 * math.cos(sine/60)),math.rad(2.9))*necko,Alpha)
			elseif sittingstyle == 3 then
				--Sitting on the floor
				  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0 + 0.05 * math.cos(sine/50),0)*angles(math.rad(-8.1),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1.1,-1,-0.3)*angles(math.rad(89.3),math.rad(0),math.rad(-19.7))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-1,-0.3)*angles(math.rad(93.4),math.rad(0),math.rad(15.4))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.5,0.1,0.3)*angles(math.rad(-14.4),math.rad(0),math.rad(0)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.4,0.3,-0.3)*angles(math.rad(38.6),math.rad(0),math.rad(-21.8)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(-0.1,0,-0.1)*angles(math.rad(3.4),math.rad(-0.2),math.rad(-3.7))*necko,.02)
			end

		elseif RootPart.Velocity.y > 1 and hitfloor == nil and hum:GetState() ~= Enum.HumanoidStateType.Swimming and hum:GetState() ~= Enum.HumanoidStateType.Climbing and hum.Sit ~= true then
Anim="Jump"
if attack == false then

	hum.WalkSpeed = storehumanoidWS
 	local Alpha = .05
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0 + 0.1 * math.cos(sine/29),0.4 - 0.1 * math.cos(sine/30),0 + 0.1 * math.cos(sine/31))*angles(math.rad(17.8 + 3 * math.cos(sine/40)),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,0)*angles(math.rad(-19.7),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.1,-1)*angles(math.rad(-34.2),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.4,0.5,0.4)*angles(math.rad(-17.1 -3 * math.cos(sine/40)),math.rad(29.5),math.rad(-13.8 - 3 * math.cos(sine/30))),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.4,0.5,0.4)*angles(math.rad(-19.4 - 3 * math.cos(sine/40)),math.rad(-22.3),math.rad(11.3 + 3 * math.cos(sine/30))),Alpha)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-20 - 5 * math.cos(sine/60)),math.rad(0),math.rad(0)),.05)
end
elseif RootPart.Velocity.y < -1  and freefall < 252 and hitfloor==nil and hum:GetState() ~= Enum.HumanoidStateType.Swimming and hum:GetState() ~= Enum.HumanoidStateType.Climbing and hum.Sit ~= true then 
Anim="Fall"
if attack==false then
	freefall = freefall + 1
	--print(freefall)
	hum.WalkSpeed = storehumanoidWS
  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0.4 + tors.Velocity.Y/300,0)*angles(math.rad(-17.4),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,0)*angles(math.rad(22.7),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,0.1,-0.5)*angles(math.rad(11.8),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.5,0.6,0.3)*angles(math.rad(104.4 +tors.Velocity.Y/8),math.rad(20.1 +tors.Velocity.Y/8),math.rad(-81.2)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.3,0.4,0.4)*angles(math.rad(89 +tors.Velocity.Y/8),math.rad(-26.7 -tors.Velocity.Y/8),math.rad(90.7)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.1,0.3)*angles(math.rad(-18.4),math.rad(0),math.rad(0))*necko,Alpha)
end
			elseif RootPart.Velocity.y < -1 and freefall > 350 and hitfloor==nil and hum:GetState() ~= Enum.HumanoidStateType.Swimming and hum:GetState() ~= Enum.HumanoidStateType.Climbing and hum.Sit ~= true then
Anim="FreeFall2"
chaeng = 1
if attack==false then
  	local Alpha = .02
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(-123.8 + 5 * math.cos(sine/70)),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-0.3,-0.7)*angles(math.rad(-14.3 - 5 * math.cos(sine/80)),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-1.1,0.1)*angles(math.rad(-32 - 5 * math.cos(sine/80)),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.4,0.3,0.4)*angles(math.rad(-28.5 - 10 * math.cos(sine/51)),math.rad(28.3),math.rad(-11.5)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,0.3,0.4)*angles(math.rad(-35.2 - 10 * math.cos(sine/50)),math.rad(-23.3),math.rad(0)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,-0.3)*angles(math.rad(14.8),math.rad(-4.7),math.rad(0.1))*necko,Alpha)
end
elseif RootPart.Velocity.y < -1 and freefall > 250 and freefall <355 and hitfloor==nil and hum:GetState() ~= Enum.HumanoidStateType.Swimming and hum:GetState() ~= Enum.HumanoidStateType.Climbing and hum.Sit ~= true then
Anim="FreeFall1"
chaeng = 1
freefall = freefall + 0.1
--print(freefall)
if attack == false then
  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(-78.1 + 10 * math.cos(sine/50)),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,0.2)*angles(math.rad(-33.5 - 10 * math.cos(sine/81)),math.rad(6.2),math.rad(-20.6))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-1.3,0.1)*angles(math.rad(-34.1 + 10 * math.cos(sine/80)),math.rad(-4),math.rad(24.4))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.6,1.1,-0.2)*angles(math.rad(102.3 + 10 * math.cos(sine/30)),math.rad(-41.2),math.rad(-68.5)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.4,0.8,0)*angles(math.rad(95.2 - 10 * math.cos(sine/70)),math.rad(38),math.rad(72)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,-0.2)*angles(math.rad(13.8),math.rad(-4.7),math.rad(0))*necko,Alpha)
end
		elseif torvel < 1 and hitfloor ~= nil and hum:GetState() ~= Enum.HumanoidStateType.Swimming and hum:GetState() ~= Enum.HumanoidStateType.Climbing and hum.Sit ~= true then
			Anim = "Idle"
			if attack == false then
				if tired == false then
				hum.WalkSpeed = storehumanoidWS
					local Alpha = .1
					RootJoint.C0 = RootJoint.C0:lerp(cf(0,3 + .7 * math.cos(sine/25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*RootCF,Alpha)
LH.C0 = LH.C0:lerp(cf(-1,-0.95- .1*math.cos(sine/30),0)*angles(math.rad(1.9),math.rad(42.9),math.rad(-10.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
RH.C0 = RH.C0:lerp(cf(1,-0.95- .1*math.cos(sine/30),0)*angles(math.rad(0),math.rad(0),math.rad(9.1))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
LW.C0 = LW.C0:lerp(cf(-1.6,0.1- .1* math.cos(sine/41),0)*angles(math.rad(0 + 7 * math.cos(sine/71)),math.rad(0- 10 * math.cos(sine/72)),math.rad(-8.3)),Alpha)
RW.C0 = RW.C0:lerp(cf(1.6,0.2 - .1* math.cos(sine/40),0)*angles(math.rad(0 + 6 * math.cos(sine/70)),math.rad(0+ 10 * math.cos(sine/72)),math.rad(14.2)),Alpha)
Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,0 + .1* math.cos(sine/40))*angles(math.rad(-6.7 * math.cos(sine/40)),math.rad(80 + 10 * math.cos(sine/130)),math.rad(6.7))*necko,Alpha)
			elseif tired == true then
				  	local Alpha = .05
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,-0.2)*angles(math.rad(-22.2),math.rad(0.3),math.rad(0.1))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-0.9,-0.1)*angles(math.rad(22.7),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.9,-0.2)*angles(math.rad(16.4),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.5,0.1,-0.3)*angles(math.rad(24.5),math.rad(0),math.rad(0)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,0.2,-0.1)*angles(math.rad(19.1),math.rad(0),math.rad(0)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.3,0.4)*angles(math.rad(-32.8),math.rad(0),math.rad(0))*necko,1)
				end
			end
		elseif torvel > 2 and torvel < 22 and hitfloor ~= nil and hum:GetState() ~= Enum.HumanoidStateType.Swimming and hum:GetState() ~= Enum.HumanoidStateType.Climbing and hum.Sit ~= true then
			Anim = "Walk"
			if attack == false then
				      local Alpha = .15
local wsv = 4.5
local wsv2 = 9
					RootJoint.C0 = RootJoint.C0:lerp(cf(0,3.4 + .7 * math.cos(sine/25),0)*angles(math.rad(0),math.rad(-90-Vec.X*10),math.rad(Vec.Z*11))*RootCF,Alpha)
LH.C0 = LH.C0:lerp(cf(-1,-0.95 - .1*math.cos(sine/30),0)*angles(math.rad(1.9),math.rad(42.9),math.rad(-10.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
RH.C0 = RH.C0:lerp(cf(1,-0.95 - .1*math.cos(sine/30),0)*angles(math.rad(0),math.rad(0),math.rad(9.1))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
LW.C0 = LW.C0:lerp(cf(-1.4,0.5 + .1 * math.cos(sine/32),0.3)*angles(math.rad(14),math.rad(35.1 - 2 * math.cos(sine/34)),math.rad(-28.8 + 5 * math.cos(sine/36))),Alpha)
RW.C0 = RW.C0:lerp(cf(1.6,0.2 + .15 * math.cos(sine/33),0.2)*angles(math.rad(13.5),math.rad(-19 + 2 * math.cos(sine/34)),math.rad(28.1 - 5 * math.cos(sine/36))),Alpha)
				Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,-.1-Vec.Z*.1)*angles(math.rad(0+Vec.Z*10),math.rad(80 + 10 * math.cos(sine/130)-Vec.X*25),math.rad(6.7))*necko,Alpha)
			end
		elseif torvel >= 22 and torvel < 170 and hitfloor ~= nil and hum:GetState() ~= Enum.HumanoidStateType.Swimming and hum:GetState() ~= Enum.HumanoidStateType.Climbing and hum.Sit ~= true then
			Anim = "Run"
			if attack == false then
      local Alpha = .2
local wsv = 2.5
local wsv2 = 5
					RootJoint.C0 = RootJoint.C0:lerp(cf(0,3.5 + .7 * math.cos(sine/25),0)*angles(math.rad(0),math.rad(-90-Vec.X*25),math.rad(Vec.Z*20))*RootCF,Alpha)
LH.C0 = LH.C0:lerp(cf(-1,-0.95 - .1*math.cos(sine/30),0)*angles(math.rad(1.9),math.rad(42.9),math.rad(-10.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
RH.C0 = RH.C0:lerp(cf(1,-0.95 - .1*math.cos(sine/30),0)*angles(math.rad(0),math.rad(0),math.rad(9.1))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.1,0.2,-1.1)*angles(math.rad(78.2 + 15 * math.cos(sine/28)),math.rad(-25.2 + 4 * math.cos(sine/62)),math.rad(76.5)),Alpha)
				  	RW.C0 = RW.C0:lerp(cf(1.6,0.2,0)*angles(math.rad(-7+ 4 * math.cos(sine/26)),math.rad(0+ 8 * math.cos(sine/53)),math.rad(25+Vec.Z*20)),Alpha)
				Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,-.1-Vec.Z*.2)*angles(math.rad(0+Vec.Z*20),math.rad(80 + 10 * math.cos(sine/130)-Vec.X*30),math.rad(6.7))*necko,.15)
			end

		elseif torvel > 170 and hitfloor ~= nil and hum:GetState() ~= Enum.HumanoidStateType.Swimming and hum:GetState() ~= Enum.HumanoidStateType.Climbing and hum.Sit ~= true then
			Anim = "FasterRun"
			if attack == false then

      local Alpha = .15
local wsv = 1.5
local wsv2 = 3
					RootJoint.C0 = RootJoint.C0:lerp(cf(0,3.5 + .7 * math.cos(sine/25),0)*angles(math.rad(0),math.rad(-90-Vec.X*25),math.rad(Vec.Z*20))*RootCF,Alpha)
LH.C0 = LH.C0:lerp(cf(-1,-0.95 - .1*math.cos(sine/30),0)*angles(math.rad(1.9),math.rad(42.9),math.rad(-10.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
RH.C0 = RH.C0:lerp(cf(1,-0.95 - .1*math.cos(sine/30),0)*angles(math.rad(0),math.rad(0),math.rad(9.1))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.1,0.2,-1.1)*angles(math.rad(78.2 + 15 * math.cos(sine/28)),math.rad(-25.2 + 4 * math.cos(sine/62)),math.rad(76.5)),Alpha)
				  	RW.C0 = RW.C0:lerp(cf(1.6,0.2,0)*angles(math.rad(-7+ 4 * math.cos(sine/26)),math.rad(0+ 8 * math.cos(sine/53)),math.rad(25+Vec.Z*20)),Alpha)
				Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,-.1-Vec.Z*.2)*angles(math.rad(0+Vec.Z*20),math.rad(80 + 10 * math.cos(sine/130)-Vec.X*30),math.rad(6.7))*necko,.15)

										end
			end
		end
	end

--"while true do" Animations, repeated colors, effects
	
end)

Section1:CreateButton("Mr. Pixels", function()
	--//====================================================\\--
--||			   CREATED BY SHACKLUSTER
--\\====================================================//--

wait(0.2)

Player = game.Players.LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = workspace.CurrentCamera.CameraSubject.Parent
Humanoid = Character.Humanoid
RootPart = Character["HumanoidRootPart"]
Torso = Character["Torso"]
Head = Character["Head"]
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart["RootJoint"]
Neck = Torso["Neck"]
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor

--//=================================\\
--|| 	      USEFUL VALUES
--\\=================================//

Animation_Speed = 3
Frame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)
local Speed = 20
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local EQUIPPED = false
local HOLD = false
local COMBO = 1
local Rooted = false
local SINE = 0
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
--ROBLOXIDLEANIMATION.Parent = Humanoid
local WEAPONGUI = IT("ScreenGui", PlayerGui)
WEAPONGUI.Name = "PIXELGUI"
local Effects = IT("Folder", Character)
Effects.Name = "Effects"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character.Animate
local UNANCHOR = true
local SONG = 853518668
local DEAD = false

--//=================================\\
--\\=================================//


--//=================================\\
--|| SAZERENOS' ARTIFICIAL HEARTBEAT
--\\=================================//
--[[
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
		lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
--]]
--//=================================\\
--\\=================================//

--//=================================\\
--|| 	      SOME FUNCTIONS
--\\=================================//

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		game:GetService("RunService").Heartbeat:wait()
	else
		for i = 1, NUMBER do
			game:GetService("RunService").Heartbeat:wait()
		end
	end
end

function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

	local function weldBetween(a, b)
	    local weldd = Instance.new("ManualWeld")
	    weldd.Part0 = a
	    weldd.Part1 = b
	    weldd.C0 = CFrame.new()
	    weldd.C1 = b.CFrame:inverse() * a.CFrame
	    weldd.Parent = a
	    return weldd
	end


function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end

function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
	local frame = IT("Frame")
	frame.BackgroundTransparency = TRANSPARENCY
	frame.BorderSizePixel = BORDERSIZEPIXEL
	frame.Position = POSITION
	frame.Size = SIZE
	frame.BackgroundColor3 = COLOR
	frame.BorderColor3 = BORDERCOLOR
	frame.Name = NAME
	frame.Parent = PARENT
	return frame
end

function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
	local label = IT("TextLabel")
	label.BackgroundTransparency = 1
	label.Size = UD2(1, 0, 1, 0)
	label.Position = UD2(0, 0, 0, 0)
	label.TextColor3 = TEXTCOLOR
	label.TextStrokeTransparency = STROKETRANSPARENCY
	label.TextTransparency = TRANSPARENCY
	label.FontSize = TEXTFONTSIZE
	label.Font = TEXTFONT
	label.BorderSizePixel = BORDERSIZEPIXEL
	label.TextScaled = false
	label.Text = TEXT
	label.Name = NAME
	label.Parent = PARENT
	return label
end

function NoOutlines(PART)
	PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
end

function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end

local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function CFrameFromTopBack(at, top, back)
	local right = top:Cross(back)
	return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end

--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME+1 do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = VT(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		end
	end))
end

function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

Debris = game:GetService("Debris")

function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end

function turnto(position)
	RootPart.CFrame=CFrame.new(RootPart.CFrame.p,VT(position.X,RootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
end

--//=================================\\
--||	     WEAPON CREATION
--\\=================================//

local sick = CreateSound(853518668, Torso, 3, 0.9, true)

--Head:ClearAllChildren()

local HAT1 = CreatePart(3, Character, "SmoothPlastic", 0, 0, "Really black", "Detail", VT(2,0.2,2),false)
HATWELD = CreateWeldOrSnapOrMotor("Weld", Head, Head, HAT1, CF(0,0.35,0), CF(0, 0, 0))
local BELT = CreatePart(3, Character, "SmoothPlastic", 0, 0, "Really black", "Part", VT(1.35,0.4,1.35),false)
CreateWeldOrSnapOrMotor("Weld", HAT1, HAT1, BELT, CF(0,0.25,0), CF(0, 0, 0))
local HAT2 = CreatePart(3, Character, "SmoothPlastic", 0, 0, "Really black", "Detail", VT(1.3,2.2,1.3),false)
CreateWeldOrSnapOrMotor("Weld", HAT1, HAT1, HAT2, CF(0,1.1,0), CF(0, 0, 0))

local TIE1 = CreatePart(3, Character, "SmoothPlastic", 0, 0, "Really black", "Detail", VT(0.5,0.5,0),false)
CreateWeldOrSnapOrMotor("Weld", Torso, Torso, TIE1, CF(0,0.8,-0.5), CF(0, 0, 0))
local TIE2 = CreatePart(3, Character, "SmoothPlastic", 0, 0, "Really black", "Detail", VT(0.2,0.5,0),false)
CreateWeldOrSnapOrMotor("Weld", TIE1, TIE1, TIE2, CF(0,-0.5,0), CF(0, 0, 0))
local TIE3 = CreatePart(3, Character, "SmoothPlastic", 0, 0, "Really black", "Detail", VT(0.5,1,0),false)
CreateWeldOrSnapOrMotor("Weld", TIE2, TIE2, TIE3, CF(0,-0.75,0), CF(0, 0, 0))

Humanoid.DisplayDistanceType = "None"
local naeeym2 = IT("BillboardGui",Character)
naeeym2.AlwaysOnTop = true
naeeym2.Size = UDim2.new(5,35,2,15)
naeeym2.StudsOffset = Vector3.new(0,6,0)
naeeym2.MaxDistance = 75
naeeym2.Adornee = RootPart
naeeym2.Name = "Name"
naeeym2.PlayerToHideFrom = Player
local tecks2 = IT("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.TextScaled = true
tecks2.BorderSizePixel = 0
tecks2.Text = "Mr Pixels"
tecks2.Font = "Arcade"
tecks2.TextSize = 20
tecks2.TextStrokeTransparency = 1
tecks2.TextColor3 = BRICKC"Cyan".Color
tecks2.TextStrokeColor3 = BRICKC"Cyan".Color
tecks2.Size = UDim2.new(1,0,0.5,0)
tecks2.Parent = naeeym2

--local MESH = IT("BlockMesh",Head)
--MESH.Scale = VT(0.5,1,1)

local SKILLTEXTCOLOR = BRICKC"Cyan".Color
local SKILLFONT = "Arcade"
local SKILLTEXTSIZE = 7

Humanoid.Died:connect(function()

end)

local SKILL1FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.8, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 1 Frame")
local SKILL2FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.8, 0, 0.84, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 2 Frame")
local SKILL3FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.8, 0, 0.78, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 3 Frame")
local SKILL4FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.8, 0, 0.72, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 4 Frame")

local SKILL1TEXT = CreateLabel(SKILL1FRAME, "[Z]", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0, "Text 1")
local SKILL2TEXT = CreateLabel(SKILL2FRAME, "[B]", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0, "Text 2")
local SKILL3TEXT = CreateLabel(SKILL3FRAME, "[C]", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0, "Text 3")
local SKILL4TEXT = CreateLabel(SKILL4FRAME, "[V]", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0, "Text 4")

--//=================================\\
--||			DAMAGING
--\\=================================//

function ApplyDamage(Humanoid,Damage)

end

function ApplyAoE(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if INSTAKILL == true then
							CHILD:BreakJoints()
						else
							local DMG = MRANDOM(MINDMG,MAXDMG)
							ApplyDamage(HUM,DMG)
						end
						if FLING > 0 then
							for _, c in pairs(CHILD:GetChildren()) do
								if c:IsA("BasePart") then
									local bv = Instance.new("BodyVelocity") 
									bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
									bv.Parent = c
									Debris:AddItem(bv,0.05)
								end
							end
						end
					end
				end
			end
		end
	end
end

function APPLYMELEE(PART,MINDMG,MAXDMG)
	local ONESHOT = false
	if MINDMG == "inf" then
		ONESHOT = true
	end
	local HITS = {}
	local TOUCH = PART.Touched:Connect(function(hit)
		if hit.Parent:FindFirstChildOfClass("Humanoid") and hit.Parent ~= Character then
			local HUM = hit.Parent:FindFirstChildOfClass("Humanoid")
			local TORSO = hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")
			if TORSO and HUM.Health > 0 then
				local PASS = true
				for i = 1, #HITS do
					if HITS[i] == hit.Parent then
						PASS = false
					end
				end
				table.insert(HITS,hit.Parent)
				if PASS == true then
					if ONESHOT == false then
						ApplyDamage(HUM,MRANDOM(MINDMG,MAXDMG))
					else
						CreateSound(1538571923, TORSO, 10, 1, false)
						HUM.Parent:BreakJoints()
						HUM:remove()
						for _, c in pairs(TORSO.Parent:GetChildren()) do
							if c:IsA("BasePart") then
								c.CanCollide = true
								c.Velocity = VT(MRANDOM(-45,45),MRANDOM(45,85),MRANDOM(-45,45))
								Debris:AddItem(c,MRANDOM(5,20)/10)
							end
						end
					end
				end
			end
		end
	end)
	return TOUCH
end

function GoombaStomp(OBJECT)
	
end

--//=================================\\
--||	ATTACK FUNCTIONS AND STUFF
--\\=================================//

function MushroomAi(Mushroom)
	coroutine.resume(coroutine.create(function()
		for i = 1, 500 do
			wait()
			local DISTANCE = 500
			local TARGET = nil
			local HUMAN = nil
			for _, c in pairs(workspace:GetChildren()) do
				if c.ClassName == "Model" and c:FindFirstChildOfClass("Humanoid") and c ~= Character then
					local HUM = c:FindFirstChildOfClass("Humanoid")
					local TORSO = c:FindFirstChild("Torso") or c:FindFirstChild("UpperTorso")
					if TORSO and HUM.Health > 0 then
						if (TORSO.Position - Mushroom.PrimaryPart.Position).Magnitude < DISTANCE then
							DISTANCE = (TORSO.Position - Mushroom.PrimaryPart.Position).Magnitude
							TARGET = TORSO
							HUMAN = HUM
						end
					end
				end
			end
			if TARGET then
				local HITFLOOR,HITPOS = Raycast(Mushroom.PrimaryPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 1, Mushroom)
				if HITFLOOR then
					local CFRAME = CF(Mushroom.PrimaryPart.Position,VT(TARGET.Position.X,Mushroom.PrimaryPart.Position.Y,TARGET.Position.Z))*CF(0,0,-0.3).p
					Mushroom:SetPrimaryPartCFrame(CF(CFRAME))
					local DIST = (TARGET.Position - Mushroom.PrimaryPart.Position).Magnitude
					if DIST < 4*(TARGET.Size.Y/2) then
						HUMAN.Health = HUMAN.Health - (HUMAN.MaxHealth-1)
						break
					end
				else
					Mushroom:SetPrimaryPartCFrame(CF(HITPOS))
				end
			end
		end
		Mushroom:remove()
	end))
end

function QuestionMarkBlock()
	ATTACK = true
	Rooted = true
	local BLOCKMODEL = IT("Model",Effects)
	local LOAD = false
	local BLOCK = CreatePart(3, BLOCKMODEL, "Neon", 0, 0, "New Yeller", "Base", VT(2,2,2))
	BLOCK.CFrame = CF(RootPart.CFrame*CF(0,15,0).p)
	BLOCKMODEL.PrimaryPart = BLOCK
	for i = 1, 4 do
		local BASE = CreatePart(3, BLOCKMODEL, "Neon", 0, 1, "New Yeller", "Blocc", VT(1.3,1.3,2)*1.001)
		BASE.CFrame = BLOCK.CFrame * ANGLES(RAD(0), RAD((360/4)*i), RAD(0))
		local DECAL = IT("Decal",BASE)
		DECAL.Texture = "http://www.roblox.com/asset/?id=1019185679"
		local PART = CreatePart(3, BLOCKMODEL, "Neon", 0, 0, "Pearl", "Blocc", VT(0.2,0.2,2.1))
		PART.CFrame = BASE.CFrame*CF(0.75,0.75,0)
		local PART = CreatePart(3, BLOCKMODEL, "Neon", 0, 0, "Pearl", "Blocc", VT(0.2,0.2,2.1))
		PART.CFrame = BASE.CFrame*CF(0.75,-0.75,0)
	end
	local LANDED = false
	local HIT = false
	local LOOP = 0
	coroutine.resume(coroutine.create(function()
		repeat
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0+sick.PlaybackLoudness/800) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1+sick.PlaybackLoudness/800) - 1)) * ANGLES(RAD(0), RAD(7.5-30*SIN(sick.PlaybackLoudness/300)), RAD(0 - 25 * SIN(SINE / 15))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5+sick.PlaybackLoudness/1200, 0) * ANGLES(RAD(0), RAD(-15), RAD(-2+sick.PlaybackLoudness/45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.3) * ANGLES(RAD(0), RAD(55), RAD(-12)) * ANGLES(RAD(-45), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		until LOAD == true
		repeat
			Swait()
			if HIT == false then
				local HITFLOOR = Raycast(BLOCK.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 1.2, BLOCKMODEL)
				if HITFLOOR then
					HIT = true
					coroutine.resume(coroutine.create(function()
						local CFRAME = BLOCK.CFrame
						RootPart.Velocity = VT(0,0,0)
						RootPart.RotVelocity = VT(0,0,0)
						for i = 1, 5 do
							wait()
							RootPart.Velocity = VT(0,-i*4,0)
							RootPart.RotVelocity = VT(0,0,0)
							BLOCKMODEL:SetPrimaryPartCFrame(Clerp(CFRAME, CFRAME*CF(0,(5-i),0), 1 / Animation_Speed))
						end
						BLOCK.BrickColor = BRICKC"Dirt brown"
						for _, c in pairs(BLOCKMODEL:GetChildren()) do
							if c:IsA("BasePart") and c.Name ~= "Base" then
								c:remove()
							end
						end
						CreateSound(1246464612, BLOCK, 10, 1, false)
						local SIZE = 2.25
						local MUSHROOM = IT("Model",Effects)
						local BASE = CreatePart(3, MUSHROOM, "Neon", 0, 0, "Fawn brown", "Shroom", VT(0.5,0.5,0.5)*SIZE)
						MUSHROOM.PrimaryPart = BASE
						local HEAD = CreatePart(3, MUSHROOM, "Neon", 0, 0, "Mulberry", "Shroom", VT(0.75,0.45,0.75)*SIZE)
						HEAD.CFrame = BASE.CFrame*CF(0,0.35*SIZE,0)
						for i = 1, 2 do
							local DOT = CreatePart(3, MUSHROOM, "Neon", 0, 0, "Lime green", "Shroom", VT(0.35,0.35,0.8)*SIZE)
							DOT.CFrame = HEAD.CFrame * ANGLES(RAD(0), RAD((180/2)*i), RAD(0))
						end
						local HEAD = CreatePart(3, MUSHROOM, "Neon", 0, 0, "Mulberry", "Shroom", VT(0.55,0.45,0.55)*SIZE)
						HEAD.CFrame = BASE.CFrame*CF(0,0.55*SIZE,0)
						MUSHROOM:SetPrimaryPartCFrame(BLOCK.CFrame)
						for i = 1, 30 do
							wait()
							MUSHROOM:SetPrimaryPartCFrame(BLOCK.CFrame*CF(0,-0.35+(i/18),0))
						end
						MushroomAi(MUSHROOM)
						Debris:AddItem(BLOCKMODEL,5)			
					end))
				end
			else
				local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
				if HITFLOOR then
					LANDED = true
				end
			end
			LOOP = LOOP + 1
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0+sick.PlaybackLoudness/800) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1+sick.PlaybackLoudness/800) - 1)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 2 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.75, -0.2) * ANGLES(RAD(150), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 2 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(-15)) * LEFTSHOULDERC0, 2 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.4-sick.PlaybackLoudness/800, -0.7) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-sick.PlaybackLoudness/800, -0.3) * ANGLES(RAD(-25), RAD(-80), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 2 / Animation_Speed)
		until LANDED == true or ATTACK == false
	end))
	wait(1)
	LOAD = true
	CreateSound(158309736, Torso, 10, 1, false)
	local bv = Instance.new("BodyVelocity",RootPart) 
	bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
	bv.velocity = CF(RootPart.Position,BLOCK.Position).lookVector*150
	Debris:AddItem(bv,0.05)
	repeat wait() until LANDED == true or LOOP > 45
	Debris:AddItem(BLOCKMODEL,5)	
	ATTACK = false
	Rooted = false
end

function SwordBeam()
	ATTACK = true
	Rooted = false
	local SWORDMODEL = IT("Model",Effects)
	local HANDLE = CreatePart(3, SWORDMODEL, "Neon", 0, 0, "Shamrock", "Stic", VT(0.2,2,0.2),false)
	local GRIP = CreateWeldOrSnapOrMotor("Weld", RightArm, RightArm, HANDLE, CF(0,-1,0)* ANGLES(RAD(-90), RAD(90), RAD(0)), CF(0, -0.3, 0))
	local PART = CreatePart(3, SWORDMODEL, "Neon", 0, 0, "Shamrock", "Stic", VT(1,0.2,0.2),false)
	CreateWeldOrSnapOrMotor("Weld", HANDLE, HANDLE, PART, CF(0,1,0), CF(0, 0, 0))
	local PART = CreatePart(3, SWORDMODEL, "Neon", 0, 0, "Pearl", "Stic", VT(0.5,2,0.1),false)
	CreateWeldOrSnapOrMotor("Weld", HANDLE, HANDLE, PART, CF(0,2,0), CF(0, 0, 0))
	local PART = CreatePart(3, SWORDMODEL, "Neon", 0, 0, "Pearl", "Stic", VT(0.25,2,0.1),false)
	CreateWeldOrSnapOrMotor("Weld", HANDLE, HANDLE, PART, CF(0,2.25,0), CF(0, 0, 0))
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0+sick.PlaybackLoudness/800) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1+sick.PlaybackLoudness/800) - 1)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5+sick.PlaybackLoudness/1200, 0) * ANGLES(RAD(160), RAD(15), RAD(-2+sick.PlaybackLoudness/45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.3) * ANGLES(RAD(0), RAD(55), RAD(-12)) * ANGLES(RAD(-45), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	coroutine.resume(coroutine.create(function()
		local BEAM = IT("Model",Effects)
		local BASE = CreatePart(3, BEAM, "Neon", 0, 0, "Really red", "Stic", VT(0.1,0.5,2))
		BASE.CFrame = RootPart.CFrame*CF(1.5,-0.4,0)
		local PART = CreatePart(3, BEAM, "Neon", 0, 0, "Really red", "Stic", VT(0.1,0.25,2))
		PART.CFrame = BASE.CFrame*CF(0,0,-0.2)
		for i = 1, 4 do
			local PART = CreatePart(3, BEAM, "Neon", 0, 0, "Really red", "Stic", VT(0.1,0.75,0.1))
			PART.CFrame = BASE.CFrame*CF(0,0,-0.8+(i/2.5))
		end
		BEAM.PrimaryPart = BASE
		for i = 1, 75 do
			wait()
			BEAM:SetPrimaryPartCFrame(BASE.CFrame*CF(0,0,-2))
			local HITFLOOR = Raycast(BASE.Position, BASE.CFrame.lookVector, 2.1, Character)
			if HITFLOOR then
				if HITFLOOR.Parent:FindFirstChildOfClass("Humanoid") then
					local HUM = HITFLOOR.Parent:FindFirstChildOfClass("Humanoid")
					ApplyDamage(HUM,15)
				end
				break
			end
		end
		BEAM:remove()
	end))
	for i=0, 0.05, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0+sick.PlaybackLoudness/800) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1+sick.PlaybackLoudness/800) - 1)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5+sick.PlaybackLoudness/1200, 0) * ANGLES(RAD(25), RAD(15), RAD(-2+sick.PlaybackLoudness/45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.3) * ANGLES(RAD(0), RAD(55), RAD(-12)) * ANGLES(RAD(-45), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	for i=0, 0.5, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0+sick.PlaybackLoudness/800) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1+sick.PlaybackLoudness/800) - 1)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5+sick.PlaybackLoudness/1200, 0) * ANGLES(RAD(-25), RAD(15), RAD(-2+sick.PlaybackLoudness/45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.3) * ANGLES(RAD(0), RAD(55), RAD(-12)) * ANGLES(RAD(-45), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	SWORDMODEL:remove()
	ATTACK = false
	Rooted = false
end

function Candy()
	ATTACK = true
	Rooted = true
	local CANDYMODEL = IT("Model",Effects)
	local HANDLE = CreatePart(3, CANDYMODEL, "Neon", 0, 0, "Dirt brown", "Stic", VT(0.2,1,0.2),false)
	local GRIP = CreateWeldOrSnapOrMotor("Weld", RightArm, RightArm, HANDLE, CF(0,-1,0)* ANGLES(RAD(-90), RAD(90), RAD(0)), CF(0, -0.3, 0))
	local HEAD1 = CreatePart(3, CANDYMODEL, "Neon", 0, 0, "Pearl", "Stic", VT(1,1,0.21),false)
	CreateWeldOrSnapOrMotor("Weld", HANDLE, HANDLE, HEAD1, CF(0,1,0)* ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
	local HEAD2 = CreatePart(3, CANDYMODEL, "Neon", 0, 0, "Really red", "Stic", VT(0.85,0.85,0.22),false)
	CreateWeldOrSnapOrMotor("Weld", HEAD1, HEAD1, HEAD2, CF(0,0,0)* ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
	local HEAD3 = CreatePart(3, CANDYMODEL, "Neon", 0, 0, "Pearl", "Stic", VT(0.55,0.55,0.23),false)
	CreateWeldOrSnapOrMotor("Weld", HEAD2, HEAD2, HEAD3, CF(0,0,0)* ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
	local HEAD4 = CreatePart(3, CANDYMODEL, "Neon", 0, 0, "Really red", "Stic", VT(0.25,0.25,0.24),false)
	CreateWeldOrSnapOrMotor("Weld", HEAD3, HEAD3, HEAD4, CF(0,0,0)* ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
	local THROWN = false
	local THROW = Mouse.Button1Down:connect(function(NEWKEY)
		THROWN = true
	end)
	for i=0, 2, 0.1 / Animation_Speed do
		Swait()
		if THROWN == true then
			break
		end
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0+sick.PlaybackLoudness/800) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1+sick.PlaybackLoudness/800) - 1)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5+sick.PlaybackLoudness/1200, 0) * ANGLES(RAD(120), RAD(15), RAD(-2+sick.PlaybackLoudness/45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.3) * ANGLES(RAD(0), RAD(55), RAD(-12)) * ANGLES(RAD(-45), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	THROW:disconnect()
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		if THROWN == true then
			break
		end
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0+sick.PlaybackLoudness/800) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1+sick.PlaybackLoudness/800) - 1)) * ANGLES(RAD(25), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.15+sick.PlaybackLoudness/1200, 0.3) * ANGLES(RAD(100), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.3) * ANGLES(RAD(0), RAD(55), RAD(-12)) * ANGLES(RAD(-45), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	if THROWN == false then
		CANDYMODEL:remove()
		coroutine.resume(coroutine.create(function()
			SONG = 554418756
			Speed = 35
			sick:Play()
			for i = 1, 150 do
				local MELEES = {}
				for _, c in pairs(Character:GetChildren()) do
					if c:IsA("BasePart") then
						local MELEE = APPLYMELEE(c,"inf","inf")
						table.insert(MELEES,MELEE)
						WACKYEFFECT({Time = 25, EffectType = "Block", Size = VT(1,1,1)/2, Size2 = VT(1,1,1)/2, Transparency = .7, Transparency2 = 1, CFrame = c.CFrame*ANGLES(RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)))*CF(0,0,2), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					end
				end
				wait(0.1)
				for e = 1, #MELEES do
					MELEES[e]:disconnect()
				end
			end
			sick:Play()
			Speed = 20
			SONG = 853518668
		end))
	else
		local GIVEINV = function(OBJECT,HUMAN)
			local TORSO = OBJECT:FindFirstChild("Torso") or OBJECT:FindFirstChild("UpperTorso")
			if TORSO then
				if TORSO:FindFirstChild("YAY") == nil then
					local MUSIC = CreateSound(554418756, TORSO, 3, 1, true)
					MUSIC.Name = "YAY"
					HUMAN.WalkSpeed = 35
					local HEALTH = HUMAN.MaxHealth
					for i = 1, 150 do
						HUMAN.MaxHealth = 999999999999999999*999999999999999999*999999999999999999*999999999999999999
						HUMAN.Health = HUMAN.MaxHealth
						MUSIC.Parent = TORSO
						local MELEES = {}
						for _, c in pairs(OBJECT:GetChildren()) do
							if c:IsA("BasePart") then
								local MELEE = APPLYMELEE(c,"inf","inf")
								table.insert(MELEES,MELEE)
								WACKYEFFECT({Time = 25, EffectType = "Block", Size = VT(1,1,1)/2, Size2 = VT(1,1,1)/2, Transparency = .7, Transparency2 = 1, CFrame = c.CFrame*ANGLES(RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)))*CF(0,0,2), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							end
						end
						wait(0.1)
						for e = 1, #MELEES do
							MELEES[e]:disconnect()
						end
					end
					HUMAN.MaxHealth = HEALTH
					HUMAN.Health = HUMAN.MaxHealth
					MUSIC:remove()
					HUMAN.WalkSpeed = 16
				end
			end
		end
		for i=0, 1, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0+sick.PlaybackLoudness/800) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1+sick.PlaybackLoudness/800) - 1)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5+sick.PlaybackLoudness/1200, 0) * ANGLES(RAD(160), RAD(15), RAD(-2+sick.PlaybackLoudness/45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.3) * ANGLES(RAD(0), RAD(55), RAD(-12)) * ANGLES(RAD(-45), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		for i=0, 0.05, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0+sick.PlaybackLoudness/800) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1+sick.PlaybackLoudness/800) - 1)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5+sick.PlaybackLoudness/1200, 0) * ANGLES(RAD(25), RAD(15), RAD(-2+sick.PlaybackLoudness/45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.3) * ANGLES(RAD(0), RAD(55), RAD(-12)) * ANGLES(RAD(-45), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		for _, c in pairs(CANDYMODEL:GetChildren()) do
			if c:IsA("BasePart") then
				c.CanCollide = true
				c.Touched:Connect(function(hit)
					if hit.Parent ~= Character then
						if hit.Parent:FindFirstChildOfClass("Humanoid") then
							CANDYMODEL:remove()
							GIVEINV(hit.Parent,hit.Parent:FindFirstChildOfClass("Humanoid"))
						end
					end
				end)
			end
		end
		GRIP:remove()
		HANDLE.Velocity = CF(HANDLE.Position,Torso.CFrame*CF(0,7,-15).p).lookVector*MRANDOM(45,80)
		Debris:AddItem(CANDYMODEL,10)
		for i=0, 0.4, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0+sick.PlaybackLoudness/800) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1+sick.PlaybackLoudness/800) - 1)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5+sick.PlaybackLoudness/1200, 0) * ANGLES(RAD(25), RAD(15), RAD(-2+sick.PlaybackLoudness/45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.3) * ANGLES(RAD(0), RAD(55), RAD(-12)) * ANGLES(RAD(-45), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
	end
	ATTACK = false
	Rooted = false
end

function Peashooter()
	ATTACK = true
	Rooted = true
	local LOADED = false
	local BLASTER = IT("Model",Effects)	
	local HANDLE = CreatePart(3, BLASTER, "Neon", 0, 1, "Cyan", "Shooter", VT(1.3,1.4,1.3),false)
	CreateWeldOrSnapOrMotor("Weld", RightArm, RightArm, HANDLE, CF(0,-0.5,0), CF(0, 0, 0))
	local HANDLE = CreatePart(3, BLASTER, "Neon", 0, 1, "Cyan", "Shooter", VT(1.1,1.4,1.1),false)
	CreateWeldOrSnapOrMotor("Weld", RightArm, RightArm, HANDLE, CF(0,-0.75,0), CF(0, 0, 0))
	local SHOT = false
	local FINISHED = false
	coroutine.resume(coroutine.create(function()
		for i=0, 1, 0.1 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0+sick.PlaybackLoudness/800) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1+sick.PlaybackLoudness/800) - 1)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5+sick.PlaybackLoudness/1200, 0) * ANGLES(RAD(160), RAD(15), RAD(-2+sick.PlaybackLoudness/45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.3) * ANGLES(RAD(0), RAD(55), RAD(-12)) * ANGLES(RAD(-45), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		LOADED = true
		WACKYEFFECT({Time = 25, EffectType = "Block", Size = VT(1,1,1)*3, Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		for _, c in pairs(BLASTER:GetChildren()) do
			if c:IsA("BasePart") then
				c.Transparency = 0
			end
		end
		repeat
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0+sick.PlaybackLoudness/800) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1+sick.PlaybackLoudness/800) - 1)) * ANGLES(RAD(-5), RAD(0), RAD(-45)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5+sick.PlaybackLoudness/1200, 0) * ANGLES(RAD(80), RAD(15), RAD(45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.3) * ANGLES(RAD(0), RAD(55), RAD(-12)) * ANGLES(RAD(-45), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		until SHOT == true
		repeat
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0+sick.PlaybackLoudness/800) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1+sick.PlaybackLoudness/800) - 1)) * ANGLES(RAD(-5), RAD(0), RAD(-45)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5+sick.PlaybackLoudness/1200, 0) * ANGLES(RAD(80), RAD(15), RAD(45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.3) * ANGLES(RAD(0), RAD(55), RAD(-12)) * ANGLES(RAD(-45), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			coroutine.resume(coroutine.create(function()
				local BULLET = IT("Model",Effects)
				local MAIN = CreatePart(3, BULLET, "Neon", 0, 0, "Cork", "Bullet", VT(1,1,1.5))
				CreateSound(635556833, RightArm, 3, 1, false)
				BULLET.PrimaryPart = MAIN
				local PART = CreatePart(3, BULLET, "Neon", 0, 0, "Cork", "Bullet", VT(0.8,0.8,2))
				MAIN.CFrame = CF(RightArm.CFrame*CF(0,-2,0).p,Mouse.Hit.p)
				PART.CFrame = MAIN.CFrame
				for i = 1, 75 do
					wait()
					BULLET:SetPrimaryPartCFrame(MAIN.CFrame*CF(0,0,-2))
					local HITFLOOR = Raycast(MAIN.Position, MAIN.CFrame.lookVector, 2.1, Character)
					if HITFLOOR then
						if HITFLOOR.Parent:FindFirstChildOfClass("Humanoid") then
							local HUM = HITFLOOR.Parent:FindFirstChildOfClass("Humanoid")
							ApplyDamage(HUM,10)
						end
						break
					end
				end
				BULLET:remove()
			end))
			for i = 1, 25 do
				Swait()
				turnto(Mouse.Hit.p)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0+sick.PlaybackLoudness/800) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1+sick.PlaybackLoudness/800) - 1)) * ANGLES(RAD(-5), RAD(0), RAD(-45)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5+sick.PlaybackLoudness/1200, 0) * ANGLES(RAD(80), RAD(15), RAD(45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.3) * ANGLES(RAD(0), RAD(55), RAD(-12)) * ANGLES(RAD(-45), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		until HOLD == false
		for i=0, 0.2, 0.1 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0+sick.PlaybackLoudness/800) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1+sick.PlaybackLoudness/800) - 1)) * ANGLES(RAD(-5), RAD(0), RAD(-45)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5+sick.PlaybackLoudness/1200, 0) * ANGLES(RAD(80), RAD(15), RAD(45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.3) * ANGLES(RAD(0), RAD(55), RAD(-12)) * ANGLES(RAD(-45), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		WACKYEFFECT({Time = 25, EffectType = "Block", Size = VT(1,1,1)*3, Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		BLASTER:remove()
		FINISHED = true
	end))
	repeat wait() until LOADED == true
	wait(0.5)
	local FIRE = Mouse.Button1Down:connect(function(NEWKEY)
		SHOT = true
	end)
	repeat wait() until SHOT == true
	FIRE:disconnect()
	repeat wait() until FINISHED == true
	ATTACK = false
	Rooted = false
end

function QuestionMarkBlock2()
	ATTACK = true
	Rooted = true
	local BLOCKMODEL = IT("Model",Effects)
	local LOAD = false
	local BLOCK = CreatePart(3, BLOCKMODEL, "Neon", 0, 0, "New Yeller", "Base", VT(2,2,2))
	BLOCK.CFrame = CF(RootPart.CFrame*CF(0,15,0).p)
	BLOCKMODEL.PrimaryPart = BLOCK
	local FRAME = RootPart.CFrame*CF(0,15,0)
	for i = 1, 4 do
		local BASE = CreatePart(3, BLOCKMODEL, "Neon", 0, 1, "New Yeller", "Blocc", VT(1.3,1.3,2)*1.001)
		BASE.CFrame = BLOCK.CFrame * ANGLES(RAD(0), RAD((360/4)*i), RAD(0))
		local DECAL = IT("Decal",BASE)
		DECAL.Texture = "http://www.roblox.com/asset/?id=1019185679"
		local PART = CreatePart(3, BLOCKMODEL, "Neon", 0, 0, "Pearl", "Blocc", VT(0.2,0.2,2.1))
		PART.CFrame = BASE.CFrame*CF(0.75,0.75,0)
		local PART = CreatePart(3, BLOCKMODEL, "Neon", 0, 0, "Pearl", "Blocc", VT(0.2,0.2,2.1))
		PART.CFrame = BASE.CFrame*CF(0.75,-0.75,0)
	end
	local LANDED = false
	local HIT = false
	local LOOP = 0
	coroutine.resume(coroutine.create(function()
		repeat
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0+sick.PlaybackLoudness/800) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1+sick.PlaybackLoudness/800) - 1)) * ANGLES(RAD(0), RAD(7.5-30*SIN(sick.PlaybackLoudness/300)), RAD(0 - 25 * SIN(SINE / 15))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5+sick.PlaybackLoudness/1200, 0) * ANGLES(RAD(0), RAD(-15), RAD(-2+sick.PlaybackLoudness/45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.3) * ANGLES(RAD(0), RAD(55), RAD(-12)) * ANGLES(RAD(-45), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		until LOAD == true
		repeat
			Swait()
			if HIT == false then
				local HITFLOOR = Raycast(BLOCK.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 1.2, BLOCKMODEL)
				if HITFLOOR then
					HIT = true
					coroutine.resume(coroutine.create(function()
						local CFRAME = BLOCK.CFrame
						RootPart.Velocity = VT(0,0,0)
						RootPart.RotVelocity = VT(0,0,0)
						coroutine.resume(coroutine.create(function()
							CreateSound(138702491, BLOCK, 10, 1, false)
							local COIN = CreatePart(3, BLOCKMODEL, "Neon", 0, 1, "New Yeller", "Coin", VT(1.8,1.8,0))
							COIN.CFrame = BLOCK.CFrame
							local DECAL = IT("Decal",COIN)
							DECAL.Texture = "http://www.roblox.com/asset/?id=1512322302"
							local DECAL = IT("Decal",COIN)
							DECAL.Texture = "http://www.roblox.com/asset/?id=1512322302"
							DECAL.Face = "Back"
							for i = 1, 15 do
								wait()
								COIN.CFrame = Clerp(FRAME, FRAME*CF(0,(15-(i/10)),0), 1 / Animation_Speed)
							end
							COIN:remove()
						end))
						for i = 1, 5 do
							wait()
							RootPart.Velocity = VT(0,-i*4,0)
							RootPart.RotVelocity = VT(0,0,0)
							BLOCKMODEL:SetPrimaryPartCFrame(Clerp(CFRAME, CFRAME*CF(0,(5-i),0), 1 / Animation_Speed))
						end
						BLOCK.BrickColor = BRICKC"Dirt brown"
						for _, c in pairs(BLOCKMODEL:GetChildren()) do
							if c:IsA("BasePart") and c.Name ~= "Base" then
								c:remove()
							end
						end
						Debris:AddItem(BLOCKMODEL,5)			
					end))
				end
			else
				local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
				if HITFLOOR then
					LANDED = true
				end
			end
			LOOP = LOOP + 1
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0+sick.PlaybackLoudness/800) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1+sick.PlaybackLoudness/800) - 1)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 2 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.75, -0.2) * ANGLES(RAD(150), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 2 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(-15)) * LEFTSHOULDERC0, 2 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.4-sick.PlaybackLoudness/800, -0.7) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-sick.PlaybackLoudness/800, -0.3) * ANGLES(RAD(-25), RAD(-80), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 2 / Animation_Speed)
		until LANDED == true or ATTACK == false
	end))
	wait(0.3)
	LOAD = true
	CreateSound(158309736, Torso, 10, 1, false)
	local bv = Instance.new("BodyVelocity",RootPart) 
	bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
	bv.velocity = CF(RootPart.Position,BLOCK.Position).lookVector*150
	Debris:AddItem(bv,0.05)
	repeat wait() until LANDED == true or LOOP > 45
	Debris:AddItem(BLOCKMODEL,5)	
	ATTACK = false
	Rooted = false
end

--//=================================\\
--||	  ASSIGN THINGS TO KEYS
--\\=================================//

function MouseDown(Mouse)
	HOLD = true
	if ATTACK == false then
	end
end

function MouseUp(Mouse)
HOLD = false
end

function KeyDown(Key)
	KEYHOLD = true
	if Key == "z" and ATTACK == false then
		QuestionMarkBlock()
	end

	if Key == "b" and ATTACK == false then
		SwordBeam()
	end

	if Key == "c" and ATTACK == false and SONG == 853518668 then
		Candy()
	end

	if Key == "v" and ATTACK == false then
		Peashooter()
	end

	if Key == "t" and ATTACK == false then
		QuestionMarkBlock2()
	end
end

function KeyUp(Key)
	KEYHOLD = false
end
Mouse = game.Players.LocalPlayer:GetMouse()
	Mouse.Button1Down:connect(function(NEWKEY)
		MouseDown(NEWKEY)
	end)
	Mouse.Button1Up:connect(function(NEWKEY)
		MouseUp(NEWKEY)
	end)
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end)

--//=================================\\
--\\=================================//

function unanchor()
	if UNANCHOR == true then
		for _, c in pairs(Character:GetChildren()) do
			if c:IsA("BasePart") then
				c.Anchored = false
			end
		end
	else
		for _, c in pairs(Character:GetChildren()) do
			if c:IsA("BasePart") then
				c.Anchored = true
			end
		end
	end
end

--//=================================\\
--||	WRAP THE WHOLE SCRIPT UP
--\\=================================//

local JUMPED = false

Humanoid.Changed:connect(function(Jump)
	if Jump == "Jump" and (Disable_Jump == true) then
		Humanoid.Jump = false
	elseif Jump == "Jump" and Disable_Jump == false and JUMPED == false then
		JUMPED = true
		--Anim = "Midair"
		CreateSound(158309736, Torso, 10, 1, false)
	end
end)

while true do
	Swait()
	script.Parent = WEAPONGUI
	ANIMATE.Parent = nil
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
	Humanoid.JumpPower = 75
	SINE = SINE + CHANGE
	local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
	local TORSOVERTICALVELOCITY = RootPart.Velocity.y
	local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
	local WALKSPEEDVALUE = 4 / (Humanoid.WalkSpeed / 16)
	if ANIM == "Walk" and TORSOVELOCITY > 1 then
		RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, -0.15 * COS(SINE / (WALKSPEEDVALUE / 2))) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 0.825 - 0.175 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.125 * COS(SINE / WALKSPEEDVALUE) +0.1- 0.5 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(76 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 0.825 + 0.175 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), 0.125 * COS(SINE / WALKSPEEDVALUE) +0.1+ 0.5 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(76 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
	elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) then
		RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	if HITFLOOR == nil then
		ANIM = "Midair"
		local JUMPHIT = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 5, Character)
		if JUMPHIT ~= nil and TORSOVERTICALVELOCITY < 0 then
			if JUMPHIT.Name == "Head" and JUMPHIT:FindFirstChild("Stomped") == nil then
				local HIT = IT("Folder",JUMPHIT)
				HIT.Name = "Stomped"
				CreateSound(165013277, JUMPHIT, 10, 1, false)
				--RootPart.Velocity = VT(0,80,0)
				--GoombaStomp(JUMPHIT.Parent)
			elseif JUMPHIT.Parent.ClassName == "Accessory" then
				local HEAD = JUMPHIT.Parent.Parent:FindFirstChild("Head")
				if HEAD then
					if HEAD:FindFirstChild("Stomped") == nil then
						local HIT = IT("Folder",HEAD)
						HIT.Name = "Stomped"
						CreateSound(165013277, HEAD, 10, 1, false)
						--RootPart.Velocity = VT(0,80,0)
						--GoombaStomp(HEAD.Parent)
					end
				end
			end
		end
		local JUMPHIT = Raycast(RootPart.CFrame*CF(1,0,0).p, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 5, Character)
		if JUMPHIT ~= nil and TORSOVERTICALVELOCITY < 0 then
			if JUMPHIT.Name == "Head" and JUMPHIT:FindFirstChild("Stomped") == nil then
				local HIT = IT("Folder",JUMPHIT)
				HIT.Name = "Stomped"
				CreateSound(165013277, JUMPHIT, 10, 1, false)
				--RootPart.Velocity = VT(0,80,0)
				--GoombaStomp(JUMPHIT.Parent)
			elseif JUMPHIT.Parent.ClassName == "Accessory" then
				local HEAD = JUMPHIT.Parent.Parent:FindFirstChild("Head")
				if HEAD then
					if HEAD:FindFirstChild("Stomped") == nil then
						local HIT = IT("Folder",HEAD)
						HIT.Name = "Stomped"
						CreateSound(165013277, HEAD, 10, 1, false)
						--RootPart.Velocity = VT(0,80,0)
						--GoombaStomp(HEAD.Parent)
					end
				end
			end
		end
		local JUMPHIT = Raycast(RootPart.CFrame*CF(-1,0,0).p, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 5, Character)
		if JUMPHIT ~= nil and TORSOVERTICALVELOCITY < 0 then
			if JUMPHIT.Name == "Head" and JUMPHIT:FindFirstChild("Stomped") == nil then
				local HIT = IT("Folder",JUMPHIT)
				HIT.Name = "Stomped"
				CreateSound(165013277, JUMPHIT, 10, 1, false)
				RootPart.Velocity = VT(0,80,0)
				GoombaStomp(JUMPHIT.Parent)
			elseif JUMPHIT.Parent.ClassName == "Accessory" then
				local HEAD = JUMPHIT.Parent.Parent:FindFirstChild("Head")
				if HEAD then
					if HEAD:FindFirstChild("Stomped") == nil then
						local HIT = IT("Folder",HEAD)
						HIT.Name = "Stomped"
						CreateSound(165013277, HEAD, 10, 1, false)
						RootPart.Velocity = VT(0,80,0)
						GoombaStomp(HEAD.Parent)
					end
				end
			end
		end
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0+sick.PlaybackLoudness/800) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1+sick.PlaybackLoudness/800) - 1)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 2 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.75, -0.2) * ANGLES(RAD(150), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 2 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(-15)) * LEFTSHOULDERC0, 2 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.4-sick.PlaybackLoudness/800, -0.7) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-sick.PlaybackLoudness/800, -0.3) * ANGLES(RAD(-25), RAD(-80), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 2 / Animation_Speed)
	    end
	elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
		ANIM = "Idle"
		JUMPED = false
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0+sick.PlaybackLoudness/800) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1+sick.PlaybackLoudness/800) - 1)) * ANGLES(RAD(0), RAD(7.5-30*SIN(sick.PlaybackLoudness/300)), RAD(0 - 25 * SIN(SINE / 15))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5+sick.PlaybackLoudness/1200, 0) * ANGLES(RAD(0), RAD(-15), RAD(-2+sick.PlaybackLoudness/45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.3) * ANGLES(RAD(0), RAD(55), RAD(-12)) * ANGLES(RAD(-45), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-sick.PlaybackLoudness/800, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
	elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
		ANIM = "Walk"
		JUMPED = false
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1+sick.PlaybackLoudness/800) * ANGLES(RAD(5), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1+sick.PlaybackLoudness/800) - 1)) * ANGLES(RAD(5 - 2 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(7.5-30*SIN(sick.PlaybackLoudness/300)), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5+sick.PlaybackLoudness/1200, 0) * ANGLES(RAD(60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * RIGHTSHOULDERC0, 0.35 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.3) * ANGLES(RAD(0), RAD(55), RAD(-12)) * ANGLES(RAD(-45), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1-sick.PlaybackLoudness/800, 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-3)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-sick.PlaybackLoudness/800, 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(3)), 2 / Animation_Speed)
		end
	end
	unanchor()
	Humanoid.MaxHealth = 999999999999999999*999999999999999999*999999999999999999*999999999999999999
	Humanoid.Health = Humanoid.MaxHealth
	if Rooted == false then
		Disable_Jump = false
		Humanoid.WalkSpeed = Speed
	elseif Rooted == true then
		Disable_Jump = true
		Humanoid.WalkSpeed = 0
	end
	local COLOR = C3((0+sick.PlaybackLoudness/200)/510,(115+sick.PlaybackLoudness/25)/510,(150+sick.PlaybackLoudness*1.5)/610)
	
		for _, c in pairs(Character:GetChildren()) do
		if c:IsA("BasePart") and c.Name ~= "Detail" then
			c.Material = "Neon"
			if c:FindFirstChildOfClass("ParticleEmitter") then
				c:FindFirstChildOfClass("ParticleEmitter"):remove()
			end
			c.Color = BRICKC"Steel blue".Color
			if c == Head then
				if c:FindFirstChild("face") then
					--c.face:remove()
				end
			end
		elseif c.ClassName == "CharacterMesh" or c.ClassName == "Accessory" or c.Name == "Body Colors" then
			--c:remove()
		elseif (c.ClassName == "Shirt" or c.ClassName == "Pants") and c.Name ~= "Cloth" then
			--c:remove()
		elseif c.Name == "Detail" then
			c.Material = "Neon"
			c.Color = COLOR
		end
	end
	
	if DEAD == false then
		sick.SoundId = "rbxassetid://"..SONG
		sick.Looped = true
		sick.Pitch = 1
		sick.Volume = 2
		sick.Playing = true
		sick.Parent = Torso
	else
		sick:remove()
	end
	--Humanoid.Name = "Mr Pixels"
end

--//=================================\\
--\\=================================//





--//====================================================\\--
--||			  		 END OF SCRIPT
--\\====================================================//--
end)

Section2:CreateButton("Spellcaster", function()
	--//====================================================\\--
--||			   7_qz's Spellcaster.
--\\====================================================//--

--[[
-gh 1560604139,498748537,5893937975,4903134690,5674239091,5460032471,5355316452
--]]

local script = game:GetObjects("rbxassetid://5989999361")[1]

plr = game:GetService("Players").LocalPlayer
Player = plr
char = workspace.Camera.CameraSubject.Parent
hum = char.Humanoid
mouse = plr:GetMouse()
local cam = game.Workspace.CurrentCamera
Camera = cam
local CamInterrupt = false
local TwoD = false
local TargetInfo = {nil, nil}
cam.CameraType = "Custom"
t = char.Torso
h = char.Head
ra = char["Right Arm"]
la = char["Left Arm"]
rl = char["Right Leg"]
ll = char["Left Leg"]
tors = char.Torso
lleg = char["Left Leg"]
root = char.HumanoidRootPart
hed = char.Head
rleg = char["Right Leg"]
rarm = char["Right Arm"]
larm = char["Left Arm"]
radian = math.rad
random = math.random
Vec3 = Vector3.new
Inst = Instance.new
cFrame = CFrame.new
Euler = CFrame.fromEulerAnglesXYZ
vt = Vector3.new
bc = BrickColor.new
br = BrickColor.random
it = Instance.new
cf = CFrame.new
local Player_Size = 0
cam = game.Workspace.CurrentCamera
CF = CFrame.new
angles = CFrame.Angles
attack = false
Euler = CFrame.fromEulerAnglesXYZ
Rad = math.rad
IT = Instance.new
BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
local SINE = 0
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
local ModeOfGlitch = 1
CF = CFrame.new
local hed = char.Head
local root = char.HumanoidRootPart
local rootj = root.RootJoint
local tors = char.Torso
local musics = script.Sounds.Song:Clone()
musics.Parent = char
musics.Volume = 3.5
musics:Play()
local Anim = "Idle"
LeftArm=char["Left Arm"] 
LeftLeg=char["Left Leg"] 
RightArm=char["Right Arm"] 
RightLeg=char["Right Leg"] 
LS=tors["Left Shoulder"] 
LH=tors["Left Hip"] 
RS=tors["Right Shoulder"] 
RH=tors["Right Hip"] 
necko = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
necko2 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
LHC0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
LHC1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
RHC0 = cf(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
RHC1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
RootPart = char.HumanoidRootPart
RootJoint = RootPart.RootJoint
RootCF = EULER(-1.57, 0, 3.14)
local Character = char
local Torso = tors
local book1 = script.Books.earthbook:Clone()
book1.Parent = char
local book2 = script.Books.firebook:Clone()
book2.Parent = char
local book3 = script.Books.thunderbook:Clone()
book3.Parent = char
local book4 = script.Books.icebook:Clone()
book4.Parent = char
local book5 = script.Books.darkbook:Clone()
book5.Parent = char
local book6 = script.Books.lightbook:Clone()
book6.Parent = char
local book7 = script.Books.lunarbook:Clone()
book7.Parent = char

local hat = game:GetService("Players").LocalPlayer.Character["jOKES"]

local hat1 = game:GetService("Players").LocalPlayer.Character["Textbook"]

local hat2 = game:GetService("Players").LocalPlayer.Character["Magic Spell Book - Blue"]

local hat3 = game:GetService("Players").LocalPlayer.Character["Eggcyclopedia_WaistFront"]

local hat4 = game:GetService("Players").LocalPlayer.Character["Waist Red Spellbook"]

local hat5 = game:GetService("Players").LocalPlayer.Character["SpellBookAccessory"]

local hat6 = game:GetService("Players").LocalPlayer.Character["Meshes/SpellbookBlackAccessory"]
function runfunnymoment(funnypart)
	function swait(num)
function swait(num)
if num==0 or num==nil then
game:service'RunService'.Stepped:wait(0)
else
for i=0,num do
game:service'RunService'.Stepped:wait(0)
end
end
end
end

asd = 0
spawn(function()
while true do
	swait(0.1)
	asd = asd + 0.4
	funnypart.Orientation = Vector3.new(math.cos(asd/30)*360,math.cos(asd/40)*360,math.cos(asd/140)*360)
end
end)
end
function align(Part0, Part1, Position, Angle)
	if Part0:FindFirstChild("Attachment") then
		Part0:FindFirstChild("Attachment"):Remove()
	end
    local AlignPosition = Instance.new("AlignPosition",Part0)
    local AlignOrientation = Instance.new("AlignOrientation",Part0)
    
    local Attachment1 = Instance.new("Attachment", Part0)
    local Attachment2 = Instance.new("Attachment", Part1)

    AlignPosition.Attachment0 = Attachment1
    AlignPosition.Attachment1 = Attachment2
    
    AlignOrientation.Attachment0 = Attachment1
    AlignOrientation.Attachment1 = Attachment2
    
    Attachment2.Position = Position or Vector3.new(0,0,0)
    Attachment2.Orientation = Angle or Vector3.new(0,0,0)
    
    AlignOrientation.MaxTorque = math.huge
    AlignOrientation.MaxAngularVelocity = math.huge
    AlignOrientation.PrimaryAxisOnly = false 
    AlignOrientation.Responsiveness = 200
    AlignOrientation.RigidityEnabled = false
    AlignOrientation.ReactionTorqueEnabled = false
    AlignPosition.MaxForce = 57346342 -- just cuz it WONT FREAKING WORK
    AlignPosition.MaxVelocity = math.huge
    AlignPosition.ReactionForceEnabled = false
    AlignPosition.Responsiveness = 200
    AlignPosition.ApplyAtCenterOfMass = true
    AlignPosition.RigidityEnabled = false
    game:GetService("RunService").Heartbeat:Connect(function()
        Part0.Velocity = Vector3.new(-29.99,0,0)
        Part1.Transparency = 1
        	Attachment2.Orientation = Vector3.new(math.cos(asd/30)*360,math.cos(asd/40)*360,math.cos(asd/140)*360)
        
    end)
    if Part0.Parent:IsA("Accessory") then
    	Part0:BreakJoints()
    end
    
    --Part0.Parent.Name = "swordlmao_"..numberlolololol
    --numberlolololol = numberlolololol + 1
end
runfunnymoment(book1)
align(hat.Handle, book1)
align(hat1.Handle, book2)
align(hat2.Handle, book3)
align(hat3.Handle, book4)
align(hat4.Handle, book5)
align(hat5.Handle, book6)
align(hat6.Handle, book7)


selected = "fire"
--save shoulders 
RSH, LSH=nil, nil 
--welds 
RW, LW=Instance.new("Weld"), Instance.new("Weld") 
RW.Name="Right Shoulder" LW.Name="Left Shoulder"
LH=Torso["Left Hip"]
RH=Torso["Right Hip"]
TorsoColor=Torso.BrickColor
function NoOutline(Part)
	Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
end
ch=Character
RSH=ch.Torso["Right Shoulder"] 
LSH=ch.Torso["Left Shoulder"] 
-- 
RSH.Parent=nil 
LSH.Parent=nil 
-- 
RW.Name="Right Shoulder"
RW.Part0=ch.Torso 
RW.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5) 
RW.C1=cf(0, 0.5, 0) 
RW.Part1=ch["Right Arm"] 
RW.Parent=ch.Torso 
-- 
LW.Name="Left Shoulder"
LW.Part0=ch.Torso 
LW.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8) 
LW.C1=cf(0, 0.5, 0) 
LW.Part1=ch["Left Arm"] 
LW.Parent=ch.Torso 

-------------------------------------

if hum:findFirstChild("Animator")~=nil then
	hum:findFirstChild("Animator").Parent=nil
end

if char:findFirstChild("Animate")~=nil then
	char:findFirstChild("Animate").Parent=nil
end
-------------------------------------

-- Needed Functions --

------------------
function swait(num)
	function swait(num)
		if num==0 or num==nil then
			game:service'RunService'.Stepped:wait(0)
		else
			for i=0,num do
				game:service'RunService'.Stepped:wait(0)
			end
		end
	end
end

so = function(id,par,vol,pit) 
	coroutine.resume(coroutine.create(function()
		local sou = Instance.new("Sound",par or workspace)
		sou.Volume=vol
		sou.Pitch=pit or 1
		sou.SoundId=id
		swait() 
		sou:play() 
		game:GetService("Debris"):AddItem(sou,6)
	end))
end

function clerp(a,b,t) 
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)} 
	local ax, ay, az = a.x, a.y, a.z 
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1-t
	return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
end 

function QuaternionFromCFrame(cf) 
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
	local trace = m00 + m11 + m22 
	if trace > 0 then 
		local s = math.sqrt(1 + trace) 
		local recip = 0.5/s 
		return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
	else 
		local i = 0 
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then 
			i = 2 
		end 
		if i == 0 then 
			local s = math.sqrt(m00-m11-m22+1) 
			local recip = 0.5/s 
			return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
		elseif i == 1 then 
			local s = math.sqrt(m11-m22-m00+1) 
			local recip = 0.5/s 
			return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
		elseif i == 2 then 
			local s = math.sqrt(m22-m00-m11+1) 
			local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
		end 
	end 
end

function QuaternionToCFrame(px, py, pz, x, y, z, w) 
	local xs, ys, zs = x + x, y + y, z + z 
	local wx, wy, wz = w*xs, w*ys, w*zs 
	local xx = x*xs 
	local xy = x*ys 
	local xz = x*zs 
	local yy = y*ys 
	local yz = y*zs 
	local zz = z*zs 
	return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
end

function QuaternionSlerp(a, b, t) 
	local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
	local startInterp, finishInterp; 
	if cosTheta >= 0.0001 then 
		if (1 - cosTheta) > 0.0001 then 
			local theta = math.acos(cosTheta) 
			local invSinTheta = 1/math.sin(theta) 
			startInterp = math.sin((1-t)*theta)*invSinTheta 
			finishInterp = math.sin(t*theta)*invSinTheta  
		else 
			startInterp = 1-t 
			finishInterp = t 
		end 
	else 
		if (1+cosTheta) > 0.0001 then 
			local theta = math.acos(-cosTheta) 
			local invSinTheta = 1/math.sin(theta) 
			startInterp = math.sin((t-1)*theta)*invSinTheta 
			finishInterp = math.sin(t*theta)*invSinTheta 
		else 
			startInterp = t-1 
			finishInterp = t 
		end 
	end 
	return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
end

function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
	return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
end

function aclerp(startCF,endCF,alpha)
	return startCF:lerp(endCF, alpha)
end

-- Effect Functions --

function CreateParta(parent,transparency,reflectance,material,brickcolor)
	local p = Instance.new("Part")
	p.TopSurface = 0
	p.BottomSurface = 0
	p.Parent = parent
	p.Size = Vector3.new(0.1,0.1,0.1)
	p.Transparency = transparency
	p.Reflectance = reflectance
	p.CanCollide = false
	p.Locked = true
	p.BrickColor = brickcolor
	p.Material = material
	return p
end

loadstring(game:HttpGet("https://paste.ee/r/oPpQI"))()

local Create = LoadLibrary("RbxUtility").Create

CFuncs = {
	["Part"] = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part"){
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material,
			}
			RemoveOutlines(Part)
			return Part
		end;
	};

	["Mesh"] = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end;
	};

	["Weld"] = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld"){
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1,
			}
			return Weld
		end;
	};

	["Sound"] = {
		Create = function(id, par, vol, pit)
			local S = Create("Sound"){
				Volume = vol,
				Name = "EffectSoundo",
				Pitch = pit or 1,
				SoundId = id,
				Parent = par or workspace,
			}
			S:play()
			game:GetService("Debris"):AddItem(S, 10)
		end;
	};

	["TimeSound"] = {
		Create = function(id, par, vol, pit, timepos)
			local S = Create("Sound"){
				Volume = vol,
				Name = "EffectSoundo",
				Pitch = pit or 1,
				SoundId = id,
				TimePosition = timepos,
				Parent = par or workspace,
			}
			wait()
			S:play()
			game:GetService("Debris"):AddItem(S, 10)
		end;
	};
	["EchoSound"] = {
		Create = function(id, par, vol, pit, timepos,delays,echodelay,fedb,dryl)
			local Sas = Create("Sound"){
				Volume = vol,
				Name = "EffectSoundo",
				Pitch = pit or 1,
				SoundId = id,
				TimePosition = timepos,
				Parent = par or workspace,
			}
			local E = Create("EchoSoundEffect"){
				Delay = echodelay,
				Name = "Echo",
				Feedback = fedb,
				DryLevel = dryl,
				Parent = Sas,
			}
			wait()
			Sas:play()
			game:GetService("Debris"):AddItem(Sas, delays)
		end;
	};

	["LongSound"] = {
		Create = function(id, par, vol, pit)
			local S = Create("Sound"){
				Volume = vol,
				Pitch = pit or 1,
				SoundId = id,
				Parent = par or workspace,
			}
			wait()
			S:play()
			game:GetService("Debris"):AddItem(S, 60)
		end;
	};

	["ParticleEmitter"] = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter"){
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread,
			}
			return fp
		end;
	};

	CreateTemplate = {

	};
}



New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end

function ring(type,pos,scale,value)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = origcolor
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshId = "http://www.roblox.com/asset/?id=3270017"
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value
			end
			rng.Transparency = rng.Transparency + 0.01
			rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, 0)
		end
		rng:Destroy()
	end))
end


function wave(type,pos,scale,value)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = origcolor
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshId = "http://www.roblox.com/asset/?id=20329976"
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value
			end
			rng.Transparency = rng.Transparency + 0.01
			rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
		end
		rng:Destroy()
	end))
end

function wind(type,pos,scale,value,speed)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = origcolor
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshId = "http://www.roblox.com/asset/?id=1051557"
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value
			end
			rng.CFrame = rng.CFrame*CFrame.Angles(0,0.025*speed,0)
			rng.Transparency = rng.Transparency + 0.01
			rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
		end
		rng:Destroy()
	end))
end

function groundwind(type,pos,scale,value,speed)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = origcolor
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshId = "http://www.roblox.com/asset/?id=1051557"
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value
			end
			rng.CFrame = rng.CFrame*CFrame.Angles(0,0.025*speed,0)
			rng.Transparency = rng.Transparency + 0.01
			rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2/5, scaler2)
		end
		rng:Destroy()
	end))
end

function CameraManager()
	if TwoD and not CamInterrupt then
		if Humanoid.Health > 0 then
			Camera.CameraSubject = Humanoid
			Camera.CameraType = "Scriptable"
			Humanoid.AutoRotate = false
			if Booleans.GyroUse then
				Directer.MaxTorque = Vec3(0, huge, 0)
			else
				Directer.MaxTorque = Vec3(0, 0, 0)
			end
			if TargetInfo[1] ~= nil and TargetInfo[2] ~= nil then
				if Booleans.CamFollow then
					CPart.CFrame = cFrame(RootPart.Position, Vec3(TargetInfo[1].Position.X, RootPart.Position.Y, TargetInfo[1].Position.Z))
					Directer.CFrame = cFrame((RootPart.CFrame * cFrame(0, 0, 10)).p, TargetInfo[1].Position)
				else
					CPart.Position = RootPart.Position
				end
			else
				local ahead = (RootPart.CFrame * cFrame(0, 0, -3)).p
				CPart.CFrame = cFrame(RootPart.Position, Vec3(ahead.X, RootPart.Position.Y, ahead.Z))
			end
			Camera.CFrame = lerp(Camera.CFrame, CPart.CFrame * cFrame(25, 3, 0) * Euler(0, radian(90), 0), 0.2)
		else
			Camera.CameraSubject = Humanoid
			Camera.CameraType = "Custom"
			Controller.Disabled = false
		end
	end
end

function sphere(bonuspeed,type,pos,scale,value,color,heart,invert,notaffectbychaosrainbow)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Sphere"


	if(heart)then
		rngm.MeshType = Enum.MeshType.FileMesh
		rngm.MeshId = "rbxassetid://105992239"
		rngm.Offset = Vector3.new(0,0,-.25)
	end
	rngm.Scale = scale
	if rainbowmode == true and not notaffectbychaosrainbow then
		rng.Color = Color3.new(r/255,g/255,b/255)
	end
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if rainbowmode == true and not notaffectbychaosrainbow then
				rng.Color = Color3.new(r/255,g/255,b/255)
			end
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			if chaosmode == true and not notaffectbychaosrainbow then
				rng.BrickColor = BrickColor.random()
			end
			if glitchymode then
				local val = math.random(1,255)
				local color = Color3.fromRGB(val,val,val)
				rng.Color = color
			end
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			if(invert)then
				if(heart)then
					rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
				else
					rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
				end
			else
				if(heart)then
					rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
				else
					rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
				end
			end
			rng.CFrame = pos
		end
		rng:Destroy()
	end))
end

function newBezier(startpos, pos2, pos3, endpos, t)
	local A = clerp(startpos, pos2, t)
	local B = clerp(pos2, pos3, t)
	local C = clerp(pos3, endpos, t)
	local lerp1 = clerp(A, B, t)
	local lerp2 = clerp(B, C, t)
	local cubic = clerp(lerp1, lerp2, t)
	return cubic
end


function PixelBlock(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos,heart,invert)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Brick"
	if(heart)then
		rngm.MeshType = Enum.MeshType.FileMesh
		rngm.MeshId = "rbxassetid://105992239"
		rngm.Offset = Vector3.new(0,0,-.25)
	end
	rngm.Scale = vt(x1,y1,z1)
	if rainbowmode == true then
		rng.Color = Color3.new(r/255,g/255,b/255)
	end
	local scaler2 = 1
	local speeder = FastSpeed/10
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if rainbowmode == true then
				rng.Color = Color3.new(r/255,g/255,b/255)
			end
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			if chaosmode == true then
				rng.BrickColor = BrickColor.random()
			end
			if glitchymode then
				local val = math.random(1,255)
				local color = Color3.fromRGB(val,val,val)
				rng.Color = color
			end
			speeder = speeder - 0.01*FastSpeed*bonuspeed/10
			if(invert)then rng.CFrame = rng.CFrame - rng.CFrame.lookVector*speeder*bonuspeed else rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed end
			--rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
		end
		rng:Destroy()
	end))
end

function PixelBlockX(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Brick"
	rngm.Scale = vt(x1,y1,z1)
	if rainbowmode == true then
		rng.Color = Color3.new(r/255,g/255,b/255)
	end
	local scaler2 = 1
	local speeder = FastSpeed/10
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if rainbowmode == true then
				rng.Color = Color3.new(r/255,g/255,b/255)
			end
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			if chaosmode == true then
				rng.BrickColor = BrickColor.random()
			end
			speeder = speeder - 0.01*FastSpeed*bonuspeed/10
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
		end
		rng:Destroy()
	end))
end 

function PixelBlockNeg(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos,heart,invert)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Brick"
	if(heart)then
		rngm.MeshType = Enum.MeshType.FileMesh
		rngm.MeshId = "rbxassetid://105992239"
		rngm.Offset = Vector3.new(0,0,-.25)
	end
	rngm.Scale = vt(x1,y1,z1)
	if rainbowmode == true then
		rng.Color = Color3.new(r/255,g/255,b/255)
	end
	local scaler2 = 0
	local speeder = FastSpeed/10
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if rainbowmode == true then
				rng.Color = Color3.new(r/255,g/255,b/255)
			end
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			if chaosmode == true then
				rng.BrickColor = BrickColor.random()
			end
			if glitchymode then
				local val = math.random(1,255)
				local color = Color3.fromRGB(val,val,val)
				rng.Color = color
			end
			speeder = speeder + 0.01*FastSpeed*bonuspeed/10
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
			if(invert)then rng.CFrame = rng.CFrame - rng.CFrame.lookVector*speeder*bonuspeed else rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed end
			--rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
		end
		rng:Destroy()
	end))
end

function sphereMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = vt(x1,y1,z1)
	if rainbowmode == true then
		rng.Color = Color3.new(r/255,g/255,b/255)
	end
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if rainbowmode == true then
				rng.Color = Color3.new(r/255,g/255,b/255)
			end
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			if chaosmode == true then
				rng.BrickColor = BrickColor.random()
			end
			if glitchymode then
				local val = math.random(1,255)
				local color = Color3.fromRGB(val,val,val)
				rng.Color = color
			end
			speeder = speeder - 0.01*FastSpeed*bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
		end
		rng:Destroy()
	end))
end

function Pillar(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
	local type = type
	local rng = script.Pillar:Clone()
	rng.Parent = workspace["xDivern"]
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(x1, y1, z1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			speeder = speeder - 0.01*FastSpeed*bonuspeed
			rng.CFrame = rng.CFrame + Vector3.new(0,0.05,0)
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
		end
		rng:Destroy()
	end))
end

function sphere2(bonuspeed,type,pos,scale,value,value2,value3,color)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = scale
	local scaler2 = 1
	local scaler2b = 1
	local scaler2c = 1
	if type == "Add" then
		scaler2 = 1*value
		scaler2b = 1*value2
		scaler2c = 1*value3
	elseif type == "Divide" then
		scaler2 = 1/value
		scaler2b = 1/value2
		scaler2c = 1/value3
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
				scaler2b = scaler2b - 0.01*value/bonuspeed
				scaler2c = scaler2c - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
				scaler2b = scaler2b - 0.01/value*bonuspeed
				scaler2c = scaler2c - 0.01/value*bonuspeed
			end
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
		end
		rng:Destroy()
	end))
end

function Beamring(col,pos,bonsize,esize,fasten,textr)
	local sa = script.Objects.Ring:Clone()
	sa.Parent = char
	sa.CFrame = pos
	local bem = sa.Beam
	if textr ~= nil then
		bem.Texture = "rbxassetid://" ..textr
	end
	local at1 = sa.a1
	local at2 = sa.a2
	at1.Position = vt(0,0,0.5*esize)
	at2.Position = vt(0,0,-0.5*esize)
	bem.Width0 = 1*esize
	bem.Width1 = 1*esize
	bem.Color = ColorSequence.new(col)
	coroutine.resume(coroutine.create(function()
		local trans = 0
		for i = 0, 99/fasten do
			swait()
			trans = trans + 0.01*fasten
			bem.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,trans,0),NumberSequenceKeypoint.new(1,trans,0)})
			at1.Position = at1.Position + vt(0,0,0.5*bonsize*fasten)
			at2.Position = at2.Position - vt(0,0,0.5*bonsize*fasten)
			bem.Width0 = bem.Width0 + 1*bonsize*fasten
			bem.Width1 = bem.Width1 + 1*bonsize*fasten
		end
		sa:Destroy()
	end))
end 

function sphereMKCharge(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 1
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = vt(x1,y1,z1)
	if rainbowmode == true then
		rng.Color = Color3.new(r/255,g/255,b/255)
	end
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if rainbowmode == true then
				rng.Color = Color3.new(r/255,g/255,b/255)
			end
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			if chaosmode == true then
				rng.BrickColor = BrickColor.random()
			end
			if glitchymode then
				local val = math.random(1,255)
				local color = Color3.fromRGB(val,val,val)
				rng.Color = color
			end
			speeder = speeder - 0.01*FastSpeed*bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
			rng.Transparency = rng.Transparency - 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
		end
		rng:Destroy()
	end))
end

function dmg(dude)
	if dude.Name ~= Character then
		local bgf = Instance.new("BodyGyro",dude.Head)
		bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(math.rad(-90),0,0)
		local val = Instance.new("BoolValue",dude)
		val.Name = "IsHit"
		local ds = coroutine.wrap(function()
			local torso = dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso'
			for i = 1, 10 do
				sphereMK(1.5,2,"Add",torso.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,25,-.01,BrickColor.new("White"),0,true)
			end
			dude:WaitForChild("Head"):BreakJoints()
			wait(0.5)
			targetted = nil
			CFuncs["Sound"].Create("rbxassetid://62339698", char, 0.5, 0.3)

			coroutine.resume(coroutine.create(function()
				for i, v in pairs(dude:GetChildren()) do
					if v:IsA("Accessory") then
						v:Destroy()
					end
					if v:IsA("Humanoid") then
						v:Destroy()
					end
					if v:IsA("CharacterMesh") then
						v:Destroy()
					end
					if v:IsA("Model") then
						v:Destroy()
					end
					if v:IsA("Part") or v:IsA("MeshPart") then
						for x, o in pairs(v:GetChildren()) do
							if o:IsA("Decal") then
								o:Destroy()
							end
						end
						coroutine.resume(coroutine.create(function()
							v.Material = "Neon"
							v.CanCollide = false
							local bld = Instance.new("ParticleEmitter",v)
							bld.LightEmission = 1
							bld.Texture = "rbxassetid://284205403"
							bld.Color = ColorSequence.new(Color3.new(1,1,1))
							bld.Rate = 50
							bld.Lifetime = NumberRange.new(1)
							bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0.75,0),NumberSequenceKeypoint.new(1,0,0)})
							bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,0)})
							bld.Speed = NumberRange.new(0,0)
							bld.VelocitySpread = 50000
							bld.Rotation = NumberRange.new(-500,500)
							bld.RotSpeed = NumberRange.new(-500,500)
							local sbs = Instance.new("BodyPosition", v)
							sbs.P = 3000
							sbs.D = 1000
							sbs.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
							sbs.position = v.Position + Vector3.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))
							v.Color = Color3.new(1,1,1)
							coroutine.resume(coroutine.create(function()
								for i = 0, 49 do
									swait(1)
									v.Transparency = v.Transparency + 0.02
								end
								CFuncs["Sound"].Create("rbxassetid://1192402877", v, 0.25, 1)
								bld.Speed = NumberRange.new(1,5)
								bld.Acceleration = vt(0,10,0)
								wait(0.5)
								bld.Enabled = false
								wait(3)
								v:Destroy()
								dude:Destroy()
							end))
						end))
					end
				end
			end))
		end)
		ds()
	end
end


function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return (SinglePlayer.Torso.CFrame.p - Position).magnitude < Distance
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") then
			if v:findFirstChild("Head") then
				if v ~= Character then
					if (v.Head.Position - Position).magnitude <= Distance then
						table.insert(List, v)
					end
				end
			end
		end
	end
	return List
end

function FaceMouse()
	Cam = workspace.CurrentCamera
	return {
		CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
		Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
	}
end

function FaceMouse2()
	Cam = workspace.CurrentCamera
	return {
		CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)),
		Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
	}
end

local ModeOfGlitch = 1

function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part")({
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material
	})
	Part.CustomPhysicalProperties = PhysicalProperties.new(0.001, 0.001, 0.001, 0.001, 0.001)
	return Part
end

function chatfunc(text,color)
	local chat = coroutine.wrap(function()
		if Character:FindFirstChild("TalkingBillBoard")~= nil then
			Character:FindFirstChild("TalkingBillBoard"):destroy()
		end
		local naeeym2 = Instance.new("BillboardGui",Character)
		naeeym2.Size = UDim2.new(0,100,0,40)
		naeeym2.StudsOffset = Vector3.new(0,3,0)
		naeeym2.Adornee = Character.Head
		naeeym2.Name = "TalkingBillBoard"
		local tecks2 = Instance.new("TextLabel",naeeym2)
		tecks2.BackgroundTransparency = 1
		tecks2.BorderSizePixel = 0
		tecks2.Text = ""
		tecks2.Font = "SciFi"
		tecks2.TextSize = 30
		tecks2.TextStrokeTransparency = 0
		tecks2.TextColor3 = color
		tecks2.TextStrokeColor3 = Color3.new(0,0,0)
		tecks2.Size = UDim2.new(1,0,0.5,0)
		local tecks3 = Instance.new("TextLabel",naeeym2)
		tecks3.BackgroundTransparency = 1
		tecks3.BorderSizePixel = 0
		tecks3.Text = ""
		tecks3.Font = "SciFi"
		tecks3.TextSize = 30
		tecks3.TextStrokeTransparency = 0
		tecks3.TextColor3 = Color3.new(0,0,0)
		tecks3.TextStrokeColor3 = color
		tecks3.Size = UDim2.new(1,0,0.5,0)
		coroutine.resume(coroutine.create(function()
			while true do
				swait(1)
				tecks2.Position = UDim2.new(0,math.random(-5,5),0,math.random(-5,5))
				tecks3.Position = UDim2.new(0,math.random(-5,5),0,math.random(-5,5))
				tecks2.Rotation = math.random(-5,5)
				tecks3.Rotation = math.random(-5,5)
			end
		end))
		for i = 1,string.len(text),1 do
			CFuncs["Sound"].Create("rbxassetid://274118116", char, 0.25, 0.115)
			tecks2.Text = string.sub(text,1,i)
			tecks3.Text = string.sub(text,1,i)
			swait(1)
		end
		wait(1)
		local randomrot = math.random(1,2)
		if randomrot == 1 then
			for i = 1, 50 do
				swait()
				tecks2.Rotation = tecks2.Rotation - .75
				tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
				tecks2.TextTransparency = tecks2.TextTransparency + .04
				tecks3.Rotation = tecks2.Rotation + .75
				tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
				tecks3.TextTransparency = tecks2.TextTransparency + .04
			end
		elseif randomrot == 2 then
			for i = 1, 50 do
				swait()
				tecks2.Rotation = tecks2.Rotation + .75
				tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
				tecks2.TextTransparency = tecks2.TextTransparency + .04
				tecks3.Rotation = tecks2.Rotation - .75
				tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
				tecks3.TextTransparency = tecks2.TextTransparency + .04
			end
		end
		naeeym2:Destroy()
	end)
	chat()
end

local NewInstance = function(instance,parent,properties)
	local inst = Instance.new(instance,parent)
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end

FXFolder = script.Effects

function CamShake(who,data)
	coroutine.wrap(function()
		if(FXFolder:FindFirstChild'CamShake')then
			local cam = FXFolder.CamShake:Clone()
			cam:WaitForChild'intensity'.Value = data.Intensity or 5
			cam:WaitForChild'duration'.Value = data.Duration or 5
			cam:WaitForChild'speed'.Value = data.Speed or 10;
			if(data.Origin)then NewInstance((typeof(data.Origin) == 'Instance' and "ObjectValue" or typeof(data.Origin) == 'Vector3' and 'Vector3Value' or typeof(data.Origin)=='CFrame' and 'CFrameValue'),cam,{Name='origin',Value=data.Origin}) end
			cam:WaitForChild'rot'.Value = data.Rotation or Vector3.new(1,1,5)
			cam:WaitForChild'pos'.Value = data.Position or Vector3.new(.5,.5,.5)
			cam:WaitForChild'startdist'.Value = data.DropDist or 25;
			cam:WaitForChild'enddist'.Value = data.IneffectiveDist or 150;

			cam.Parent = who
			wait()
			cam.Disabled = false
		end
	end)()
end

function CamShakeAll(data)
	for _,v in next, game:service'Players':players() do
		CamShake(v:FindFirstChildOfClass'PlayerGui' or v:FindFirstChildOfClass'Backpack' or v.Character,data)
	end
end

-- Damage functions --

DoDamage = true

function Vanish(person)
	
end

function Damagefunc(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	
end

-- Attacks --

function volcaniceruption()
	attack = true
	hum.WalkSpeed = 2
	chatfunc("I'll make you burnt toast!",Color3.new(1,0,0))
	local volcano = script.Objects.Volcano:Clone()
	volcano.Parent = char
	volcano.Transparency = 1
	volcano.CFrame = root.CFrame + root.CFrame.lookVector*150
	for i = 1,20,0.1 do
		swait()
		RH.C0=clerp(RH.C0,cf(1,-1.1,0)*angles(math.rad(0),math.rad(85),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(0)),.01)
		LH.C0=clerp(LH.C0,cf(-1,-1.1,0)*angles(math.rad(0),math.rad(-85),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(0)),.01)
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,.1)*angles(math.rad(0),math.rad(0),math.rad(-25)),.01)
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-15),math.rad(0),math.rad(25)),.01)
		RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(175),math.rad(0),math.rad(10)),.02)
		LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(175),math.rad(0),math.rad(-10)),.02)
		volcano.Position = Vector3.new(volcano.Position.X,volcano.Position.Y + 0.1, volcano.Position.Z)
		book1.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/17) * 8, RootPart.Position.Y + 0.5 * math.cos(SINE / 25 + 30), RootPart.Position.Z  - math.cos(SINE/17) * 8)
		book3.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/17) * 8, RootPart.Position.Y + - 1.5 + 0.5 * math.cos(SINE / 25 + 90), RootPart.Position.Z  + math.cos(SINE/17) * 8)
		book4.Position = Vector3.new(RootPart.Position.X + math.sin(SINE/17) * 8, RootPart.Position.Y + 3 + 0.5 * math.cos(SINE / 25 + 120), RootPart.Position.Z  + math.cos(SINE/17) * 8)
		book2.CFrame = hed.CFrame + root.CFrame.lookVector*4
		book2.Position = Vector3.new(book2.Position.X,book2.Position.Y + 3 + 0.5 * math.cos(SINE / 25 + 120), book2.Position.Z)
		book5.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/14) * 6, RootPart.Position.Y + 1.5 + 0.5 * math.cos(SINE / 25 + 150), RootPart.Position.Z  - math.cos(SINE/14) * 6)
		book6.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/14) * 6, RootPart.Position.Y - 0.5 * math.cos(SINE / 25 + 150), RootPart.Position.Z  - math.cos(SINE/14) * 6)
		book7.Position = Vector3.new(RootPart.Position.X - math.cos(SINE/14) * 3, RootPart.Position.Y + 5 + 1* math.cos(SINE / 35), RootPart.Position.Z  - math.sin(SINE/14) * 3)
		volcano.Transparency = 1 - (i * 5)/100
	end
	for i = 1,100 do
		swait()
		RH.C0=clerp(RH.C0,cf(1,-1.1,0)*angles(math.rad(0),math.rad(85),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(0)),.01)
		LH.C0=clerp(LH.C0,cf(-1,-1.1,0)*angles(math.rad(0),math.rad(-85),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(0)),.01)
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,.1)*angles(math.rad(0),math.rad(0),math.rad(-25)),.01)
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-15),math.rad(0),math.rad(25)),.01)
		RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(175),math.rad(0),math.rad(10)),.02)
		LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(175),math.rad(0),math.rad(-10)),.02)
		book1.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/17) * 8, RootPart.Position.Y + 0.5 * math.cos(SINE / 25 + 30), RootPart.Position.Z  - math.cos(SINE/17) * 8)
		book3.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/17) * 8, RootPart.Position.Y + - 1.5 + 0.5 * math.cos(SINE / 25 + 90), RootPart.Position.Z  + math.cos(SINE/17) * 8)
		book4.Position = Vector3.new(RootPart.Position.X + math.sin(SINE/17) * 8, RootPart.Position.Y + 3 + 0.5 * math.cos(SINE / 25 + 120), RootPart.Position.Z  + math.cos(SINE/17) * 8)
		book2.CFrame = hed.CFrame + root.CFrame.lookVector*4
		book2.Position = Vector3.new(book2.Position.X,book2.Position.Y + 3 + 0.5 * math.cos(SINE / 25 + 120), book2.Position.Z)
		book5.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/14) * 6, RootPart.Position.Y + 1.5 + 0.5 * math.cos(SINE / 25 + 150), RootPart.Position.Z  - math.cos(SINE/14) * 6)
		book6.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/14) * 6, RootPart.Position.Y - 0.5 * math.cos(SINE / 25 + 150), RootPart.Position.Z  - math.cos(SINE/14) * 6)
		book7.Position = Vector3.new(RootPart.Position.X - math.cos(SINE/14) * 3, RootPart.Position.Y + 5 + 1* math.cos(SINE / 35), RootPart.Position.Z  - math.sin(SINE/14) * 3)
		coroutine.resume(coroutine.create(function()
			local magma = Instance.new("Part",char)
			magma.Position = Vector3.new(volcano.Position.X,volcano.Position.Y + 150, volcano.Position.Z)
			magma.Size = Vector3.new(10,10,10)
			magma.BrickColor = BrickColor.Red()
			magma.Velocity = Vector3.new(math.random(-300,300),math.random(-300,300),math.random(-300,300))
			swait(50)
			for i = 1,100 do
				swait(1)
				--MagniDamage(magma, 40, 3,5, 0, "Burn")
			end
			magma:Destroy()
		end))
	end
	volcano:Destroy()
	hum.WalkSpeed = 16
	attack = false
end

local Alpha = .1

function LithosphereSpikes()
	local distlook = 0
	attack = true
	hum.WalkSpeed = 0
	chatfunc("Have fun flopping like a fish.",Color3.new(0.5,0.5,0))
	for i = 1,10 do
		swait()
		RootJoint.C0 = RootJoint.C0:lerp(cf(-0.2,-1.4,-0.5)*angles(math.rad(-36),math.rad(-16.3),math.rad(0))*RootCF,Alpha)
		LH.C0 = LH.C0:lerp(cf(-0.9,0.3,-0.1)*angles(math.rad(17.7),math.rad(15.6),math.rad(-4.9))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
		RH.C0 = RH.C0:lerp(cf(1.2,-1.2,-0.3)*angles(math.rad(-32.5),math.rad(13.9),math.rad(8.7))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
		LW.C0 = LW.C0:lerp(cf(-1.5,0.3,-0.4)*angles(math.rad(43.5),math.rad(12),math.rad(-11.1)),Alpha)
		RW.C0 = RW.C0:lerp(cf(0.9,0.2,-0.4)*angles(math.rad(41.2),math.rad(0),math.rad(-63.3)),Alpha)
		Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0.1,0.2,0.4)*angles(math.rad(-29.6),math.rad(16.9),math.rad(9.4))*necko,Alpha)
		book2.Position = Vector3.new(RootPart.Position.X + math.sin(SINE/17) * 8, RootPart.Position.Y + 0.5 * math.cos(SINE / 25 + 60), RootPart.Position.Z  - math.cos(SINE/17) * 8)
		book3.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/17) * 8, RootPart.Position.Y + - 1.5 + 0.5 * math.cos(SINE / 25 + 90), RootPart.Position.Z  + math.cos(SINE/17) * 8)
		book4.Position = Vector3.new(RootPart.Position.X + math.sin(SINE/17) * 8, RootPart.Position.Y + 3 + 0.5 * math.cos(SINE / 25 + 120), RootPart.Position.Z  + math.cos(SINE/17) * 8)
		book1.CFrame = hed.CFrame + root.CFrame.lookVector*4
		book1.Position = Vector3.new(book1.Position.X,book1.Position.Y + 3 + 0.5 * math.cos(SINE / 25 + 120), book1.Position.Z)
		book5.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/14) * 6, RootPart.Position.Y + 1.5 + 0.5 * math.cos(SINE / 25 + 150), RootPart.Position.Z  - math.cos(SINE/14) * 6)
		book6.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/14) * 6, RootPart.Position.Y - 0.5 * math.cos(SINE / 25 + 150), RootPart.Position.Z  - math.cos(SINE/14) * 6)
		book7.Position = Vector3.new(RootPart.Position.X - math.cos(SINE/14) * 3, RootPart.Position.Y + 5 + 1* math.cos(SINE / 35), RootPart.Position.Z  - math.sin(SINE/14) * 3)
		coroutine.resume(coroutine.create(function()
			local hite = script.Objects.Spike:Clone()
			hite.Parent = char
			hite.Transparency = 0
			hite.Anchored = true
			hite.CanCollide = false
			hite.CFrame = root.CFrame + root.CFrame.lookVector*(distlook + 10)
			distlook = distlook + 10
			--MagniDamage(hite, 10, 30,50, 0, "UpKnock")
			swait(100)
			for i = 1,30 do
				swait()
				hite.Position = hite.Position - Vector3.new(0,0.5,0)
				hite.Transparency = i/30
			end
			hite:Destroy()
		end))
	end
	attack = false
	hum.WalkSpeed = 16
end

function Mountain()
	attack = true
	hum.WalkSpeed = 0	
	local a = Instance.new("Part",workspace)
	a.Position = Torso.Position - Vector3.new(0,4,0)
	a.Material = "Grass"
	a.BrickColor = BrickColor.new("Earth green")
	a.Anchored = true
	a.Size = Vector3.new(10,1,10)
	CamShakeAll({
		Duration=0.5; 
		Intensity=5;
		Position=Vector3.new(2,2,2);
		Rotation=Vector3.new(2,2,6);
		DropDist=1000;
		IneffectiveDist=1000;
		Origin=tors.Position;
	})
	for i = 1,50 do
		swait()
		RootJoint.C0 = RootJoint.C0:lerp(cf(-0.2,-1.4,-0.5)*angles(math.rad(-36),math.rad(-16.3),math.rad(0))*RootCF,Alpha)
		LH.C0 = LH.C0:lerp(cf(-0.9,0.3,-0.1)*angles(math.rad(17.7),math.rad(15.6),math.rad(-4.9))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
		RH.C0 = RH.C0:lerp(cf(1.2,-1.2,-0.3)*angles(math.rad(-32.5),math.rad(13.9),math.rad(8.7))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
		LW.C0 = LW.C0:lerp(cf(-1.5,0.3,-0.4)*angles(math.rad(43.5),math.rad(12),math.rad(-11.1)),Alpha)
		RW.C0 = RW.C0:lerp(cf(0.9,0.2,-0.4)*angles(math.rad(41.2),math.rad(0),math.rad(-63.3)),Alpha)
		Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0.1,0.2,0.4)*angles(math.rad(-29.6),math.rad(16.9),math.rad(9.4))*necko,Alpha)
		book2.Position = Vector3.new(RootPart.Position.X + math.sin(SINE/17) * 8, RootPart.Position.Y + 0.5 * math.cos(SINE / 25 + 60), RootPart.Position.Z  - math.cos(SINE/17) * 8)
		book3.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/17) * 8, RootPart.Position.Y + - 1.5 + 0.5 * math.cos(SINE / 25 + 90), RootPart.Position.Z  + math.cos(SINE/17) * 8)
		book4.Position = Vector3.new(RootPart.Position.X + math.sin(SINE/17) * 8, RootPart.Position.Y + 3 + 0.5 * math.cos(SINE / 25 + 120), RootPart.Position.Z  + math.cos(SINE/17) * 8)
		book1.CFrame = hed.CFrame + root.CFrame.lookVector*4
		book1.Position = Vector3.new(book1.Position.X,book1.Position.Y + 3 + 0.5 * math.cos(SINE / 25 + 120), book1.Position.Z)
		book5.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/14) * 6, RootPart.Position.Y + 1.5 + 0.5 * math.cos(SINE / 25 + 150), RootPart.Position.Z  - math.cos(SINE/14) * 6)
		book6.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/14) * 6, RootPart.Position.Y - 0.5 * math.cos(SINE / 25 + 150), RootPart.Position.Z  - math.cos(SINE/14) * 6)
		book7.Position = Vector3.new(RootPart.Position.X - math.cos(SINE/14) * 3, RootPart.Position.Y + 5 + 1* math.cos(SINE / 35), RootPart.Position.Z  - math.sin(SINE/14) * 3)		
		a.Size = a.Size + Vector3.new(0,2,0)
	end
	attack = false
	hum.WalkSpeed = 16
end

function LightningStrike()
	chatfunc("Take it!",Color3.new(1,1,0))
	CFuncs["EchoSound"].Create("rbxassetid://1625448638", root, 4, 1,0,10,0.15,0.5,1)
	swait(30)
	local a = Instance.new("Part",char)
	a.Name = "Direction"	
	a.Anchored = true
	a.BrickColor = BrickColor.new("New Yeller")
	a.Material = "Neon"
	a.Transparency = 1
	a.Shape = "Cylinder"
	local ray = Ray.new(
		root.CFrame.p,                           -- origin
		(mouse.Hit.p - root.CFrame.p).unit * 500 -- direction
	) 
	local ignore = char
	local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
	a.BottomSurface = 10
	a.TopSurface = 10
	local distance = (root.CFrame.p - position).magnitude
	a.Size = Vector3.new(distance,1,1)
	a.CFrame = CFrame.new(root.CFrame.p, position) * CFrame.new(1, 1, -distance)
	local ht = Instance.new("Part",char)
	ht.Name = "Hit"	
	ht.Anchored = true
	--MagniDamage(ht, 20, 10,15, 0, "Burn")
	ht.CanCollide = false
	ht.Transparency = 1
	ht.Size = vt(0.1,0.1,0.1)
	CFuncs["Sound"].Create("rbxassetid://782353443", char, 3, 1)
	CFuncs["Sound"].Create("rbxassetid://763717897", char, 1, 1.35)
	a.CanCollide = false
	ht.Position = a.Position
	sphere2(2,"Add",ht.CFrame,vt(24,24,24),2,2,2,BrickColor.new("New Yeller"))
	sphere2(1,"Add",ht.CFrame,vt(1,100000,1),0.25,0.25,0.25,BrickColor.new("New Yeller"))
	sphere2(1,"Add",ht.CFrame,vt(24,24,24),1,1,1,BrickColor.new("New Yeller"))
	for i = 0, 9 do
		Beamring(Color3.new(1,1,1),ht.CFrame*CFrame.new(0,0,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),math.random(10,100)/10,0,math.random(1,5),348103573)
	end
	for i, v in pairs(FindNearestHead(ht.CFrame.p, 80)) do
		if v:FindFirstChild('Head') then
			--MagniDamage(v.Head, 5, 10,15, 0, "Burn")
		end
	end
	coroutine.resume(coroutine.create(function()
		game:GetService("Debris"):AddItem(a,5)
		game:GetService("Debris"):AddItem(ht,5)
	end))
end

function DryFreeze()
	attack = true
	hum.WalkSpeed = 0
	CFuncs["EchoSound"].Create("rbxassetid://1690476035", root, 10, 1,0.1,10,0.15,0.5,1)
	for i = 1,100 do
		swait()
		RH.C0=clerp(RH.C0,cf(1,-1.1,0)*angles(math.rad(0),math.rad(85),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(0)),.01)
		LH.C0=clerp(LH.C0,cf(-1,-1.1,0)*angles(math.rad(0),math.rad(-85),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(0)),.01)
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,.1)*angles(math.rad(0),math.rad(0),math.rad(-25)),.01)
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-15),math.rad(0),math.rad(25)),.01)
		RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(175),math.rad(0),math.rad(10)),.02)
		LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(175),math.rad(0),math.rad(-10)),.02)
		book1.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/17) * 8, RootPart.Position.Y + 0.5 * math.cos(SINE / 25 + 30), RootPart.Position.Z  - math.cos(SINE/17) * 8)
		book2.Position = Vector3.new(RootPart.Position.X + math.sin(SINE/17) * 8, RootPart.Position.Y + 0.5 * math.cos(SINE / 25 + 60), RootPart.Position.Z  - math.cos(SINE/17) * 8)
		book3.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/17) * 8, RootPart.Position.Y + - 1.5 + 0.5 * math.cos(SINE / 25 + 90), RootPart.Position.Z  + math.cos(SINE/17) * 8)
		book4.CFrame = hed.CFrame + root.CFrame.lookVector*4
		book4.Position = Vector3.new(book4.Position.X,book4.Position.Y + 3 + 0.5 * math.cos(SINE / 25 + 120), book4.Position.Z)
		book5.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/14) * 6, RootPart.Position.Y + 1.5 + 0.5 * math.cos(SINE / 25 + 150), RootPart.Position.Z  - math.cos(SINE/14) * 6)
		book6.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/14) * 6, RootPart.Position.Y - 0.5 * math.cos(SINE / 25 + 150), RootPart.Position.Z  - math.cos(SINE/14) * 6)
		book7.Position = Vector3.new(RootPart.Position.X - math.cos(SINE/14) * 3, RootPart.Position.Y + 5 + 1* math.cos(SINE / 35), RootPart.Position.Z  - math.sin(SINE/14) * 3)
		coroutine.resume(coroutine.create(function()
			local icespike = script.Objects.IceSpike:Clone()
			icespike.Parent = char
			icespike.Transparency = 0.1
			icespike.CFrame = root.CFrame * CFrame.new((i-50)/5,-2,0)
			icespike.CFrame = icespike.CFrame + root.CFrame.lookVector*10
			icespike.Orientation = Vector3.new(math.random(-35,35),math.random(85,95),math.random(-35,35))
			--MagniDamage(icespike, 5, 10,15, 0, "Freeze")
			swait(100)
			for i = 1,30 do
				swait()
				icespike.Position = icespike.Position - Vector3.new(0,0.5,0)
				icespike.Transparency = i/30
			end
			icespike:Destroy()
		end))
	end
	attack = false
	hum.WalkSpeed = 16
end

function DarkPillar() -- some things here are from Spectrum v7.
	chatfunc("The end times are upon us.",Color3.new(0,0,0))
	attack = true
	hum.WalkSpeed = 0
	for i = 1,10,0.1 do
		swait()
		RH.C0=clerp(RH.C0,cf(1,-1.1,0)*angles(math.rad(0),math.rad(85),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(0)),.01)
		LH.C0=clerp(LH.C0,cf(-1,-1.1,0)*angles(math.rad(0),math.rad(-85),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(0)),.01)
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,.1)*angles(math.rad(0),math.rad(0),math.rad(-25)),.01)
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-15),math.rad(0),math.rad(25)),.01)
		RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(175),math.rad(0),math.rad(10)),.02)
		LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(175),math.rad(0),math.rad(-10)),.02)
		book1.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/17) * 8, RootPart.Position.Y + 0.5 * math.cos(SINE / 25 + 30), RootPart.Position.Z  - math.cos(SINE/17) * 8)
		book2.Position = Vector3.new(RootPart.Position.X + math.sin(SINE/17) * 8, RootPart.Position.Y + 0.5 * math.cos(SINE / 25 + 60), RootPart.Position.Z  - math.cos(SINE/17) * 8)
		book3.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/17) * 8, RootPart.Position.Y + - 1.5 + 0.5 * math.cos(SINE / 25 + 90), RootPart.Position.Z  + math.cos(SINE/17) * 8)
		book4.Position = Vector3.new(RootPart.Position.X + math.sin(SINE/17) * 8, RootPart.Position.Y + 3 + 0.5 * math.cos(SINE / 25 + 120), RootPart.Position.Z  + math.cos(SINE/17) * 8)
		book5.CFrame = hed.CFrame + root.CFrame.lookVector*4
		book5.Position = Vector3.new(book5.Position.X,book5.Position.Y + 3 + 0.5 * math.cos(SINE / 25 + 120), book5.Position.Z)
		book6.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/14) * 6, RootPart.Position.Y - 0.5 * math.cos(SINE / 25 + 150), RootPart.Position.Z  - math.cos(SINE/14) * 6)
		book7.Position = Vector3.new(RootPart.Position.X - math.cos(SINE/14) * 3, RootPart.Position.Y + 5 + 1* math.cos(SINE / 35), RootPart.Position.Z  - math.sin(SINE/14) * 3)
	end
	local keptcolor = BrickColor.Black()
	local pil = script.Objects.Pillar:Clone()
	pil.Parent = char
	pil.CFrame = root.CFrame + root.CFrame.lookVector*15
	pil.Position = pil.Position + Vector3.new(0,3,0)
	pil.Transparency = 0
	--MagniDamage(pil, 30, 10,15, 0, "UpKnock")
	local locat = Instance.new("Part", char)
	locat.CanCollide = false
	locat.FormFactor = 3
	locat.Name = "Ring"
	locat.Material = "Neon"
	locat.Size = Vector3.new(1, 1, 1)
	locat.Transparency = 1
	locat.TopSurface = 0
	locat.BottomSurface = 0
	locat.Anchored = true
	locat.CFrame = pil.CFrame*CFrame.new(0,-3,0)
	local poste = 0
	local rotation = 0
	local upperpos = 0
	local rate = 0
	local x = locat


	CFuncs["Sound"].Create("rbxassetid://763717897", char, 1.2, 1)
	CFuncs["Sound"].Create("rbxassetid://1192402877", char, 0.5, 0.75)
	CFuncs["Sound"].Create("rbxassetid://1664711478", char, 1.2, 0.95)
	sphere2(1,"Add",x.CFrame*CFrame.new(0,0,0),vt(5,50000,5),1.5,1,1.5,BrickColor.Black())
	sphere2(2,"Add",x.CFrame*CFrame.new(0,0,0),vt(5,50000,5),1.5,1,1.5,BrickColor.Black())
	sphere2(4,"Add",x.CFrame*CFrame.new(0,0,0),vt(5,50000,5),1.5,1,1.5,BrickColor.Black())
	for i = 0, 99 do
		local dis = CreateParta(char,1,1,"Neon",BrickColor.Black())
		dis.CFrame = root.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
		local at1 = Instance.new("Attachment",dis)
		at1.Position = vt(-25000,0,0)
		local at2 = Instance.new("Attachment",dis)
		at2.Position = vt(25000,0,0)
		local bv = Instance.new("BodyVelocity")
		bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
		bv.velocity = dis.CFrame.lookVector*math.random(500,2500)
		bv.Parent = dis
		game:GetService("Debris"):AddItem(dis, 10)
	end
	coroutine.resume(coroutine.create(function()
		coroutine.resume(coroutine.create(function()
			local eff = Instance.new("ParticleEmitter",x)
			eff.Texture = "rbxassetid://2273224484"
			eff.LightEmission = 1
			eff.Color = ColorSequence.new(BrickColor.Black().Color)
			eff.Rate = 90000
			eff.Lifetime = NumberRange.new(3,8)
			eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,120,0),NumberSequenceKeypoint.new(0.2,25,0),NumberSequenceKeypoint.new(1,0.1,0)})
			eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.2,0,0),NumberSequenceKeypoint.new(1,1,0)})
			eff.Speed = NumberRange.new(250,1500)
			eff.Drag = 5
			eff.Rotation = NumberRange.new(-500,500)
			eff.VelocitySpread = 9000
			eff.RotSpeed = NumberRange.new(-100,100)
			wait(0.7)
			eff.Enabled = false
		end))

		for i = 0, 154 do
			swait()
			rotation = rotation + 5
			poste = poste + 1
			upperpos = upperpos + rate
			rate = rate + 0.2
			sphere2(8,"Add",x.CFrame*CFrame.Angles(0,math.rad(rotation),0)*CFrame.new(0,upperpos,poste),vt(2.5+upperpos/5,2.5+upperpos/5,2.5+upperpos/5),-0.05,-0.05,-0.05,BrickColor.Black())
			sphere2(8,"Add",x.CFrame*CFrame.Angles(0,math.rad(90+rotation),0)*CFrame.new(0,upperpos,poste),vt(2.5+upperpos/5,2.5+upperpos/5,2.5+upperpos/5),-0.05,-0.05,-0.05,BrickColor.Black())
			sphere2(8,"Add",x.CFrame*CFrame.Angles(0,math.rad(180+rotation),0)*CFrame.new(0,upperpos,poste),vt(2.5+upperpos/5,2.5+upperpos/5,2.5+upperpos/5),-0.05,-0.05,-0.05,BrickColor.Black())
			sphere2(8,"Add",x.CFrame*CFrame.Angles(0,math.rad(270+rotation),0)*CFrame.new(0,upperpos,poste),vt(2.5+upperpos/5,2.5+upperpos/5,2.5+upperpos/5),-0.05,-0.05,-0.05,BrickColor.Black())
			sphere2(8,"Add",x.CFrame*CFrame.Angles(0,math.rad(-rotation),0)*CFrame.new(0,upperpos/2,poste*2),vt(2.5+upperpos/10,2.5+upperpos/10,2.5+upperpos/10),-0.05,-0.05,-0.05,keptcolor)
			sphere2(8,"Add",x.CFrame*CFrame.Angles(0,math.rad(90-rotation),0)*CFrame.new(0,upperpos/2,poste*2),vt(3.5+upperpos/10,3.5+upperpos/10,3.5+upperpos/10),-0.05,-0.05,-0.05,keptcolor)
			sphere2(8,"Add",x.CFrame*CFrame.Angles(0,math.rad(180-rotation),0)*CFrame.new(0,upperpos/2,poste*2),vt(3.5+upperpos/10,3.5+upperpos/10,3.5+upperpos/10),-0.05,-0.05,-0.05,keptcolor)
			sphere2(8,"Add",x.CFrame*CFrame.Angles(0,math.rad(270-rotation),0)*CFrame.new(0,upperpos/2,poste*2),vt(3.5+upperpos/10,3.5+upperpos/10,3.5+upperpos/10),-0.05,-0.05,-0.05,keptcolor)
		end
		wait(6)
		x:Destroy()
	end))
	attack = false
	hum.WalkSpeed = 16
	swait(30)
	for i = 1,30 do
		swait()
		pil.Position = pil.Position - Vector3.new(0,0.5,0)
		pil.Transparency = i/30
	end
	pil:Destroy()
end

function Torpefy(plr)
	coroutine.resume(coroutine.create(function()
		tree(plr)	
	end))	
end

function tree(who)
	pcall(function()
		local ded = who
		ded.Humanoid:Remove()
		for i,v in pairs(ded:GetDescendants()) do
			if v:IsA("Part") then
				v.Material = "Grass"
				v.BrickColor = BrickColor.new("Forest green")
			elseif v:IsA("MeshPart") and v.Name ~= "treemesh" then
				v:Remove()
			elseif 	v:IsA("SpecialMesh") then
				v:Destroy()
			end
		end
		local h1 = ded:FindFirstChild("Head")
		local t1 = ded:FindFirstChild("Torso")
		local ff = ded:FindFirstChildOfClass("ForceField")
		if ff ~= nil then
			ff:Destroy()
		end
		local ra1 = ded:FindFirstChild("Right Arm")
		local la1 = ded:FindFirstChild("Left Arm")
		local rl1 = ded:FindFirstChild("Right Leg")
		local ll1 = ded:FindFirstChild("Left Leg")
		local acc = ded:FindFirstChild("xdded")
		if acc == nil then 
			local ac = Instance.new("Glue",ded) ac.Name = "xdded"
			local rut1 = ded:FindFirstChild("HumanoidRootPart")
			if rut1 ~= nil then
				rut1.Parent = nil
			end
			pcall(function()
				for i,v in pairs(who:GetChildren()) do
					if v:IsA("Accessory") or v:IsA("Hat") then
						v:Destroy()
					end
				end
				for i,v in pairs(who:GetChildren()) do
					if v:IsA("Script") or v:IsA("LocalScript") then
						if v.Name == "Health" then
							v.Parent = nil
						end
					end
				end
			end)
			t1:BreakJoints()
			ra1:BreakJoints()
			la1:BreakJoints()
			rl1:BreakJoints()
			ll1:BreakJoints()

			--//Joints~//--
			--Neck--
			if h1 ~= nil then
				local neca = Instance.new("Glue",t1) neca.Part0 = t1 neca.Part1 = h1 neca.C0 = CFrame.new(0,t1.Size.y/2,0) neca.C1 = CFrame.new(0,-h1.Size.y/2,0) neca.Name = "yo"
				local ch = Instance.new("Part",t1) ch.Name = "yo" ch.Size = Vector3.new(h1.Size.x/2,h1.Size.y/2,h1.Size.z/2 + h1.Size.z/4) ch.TopSurface = "Smooth" ch.BottomSurface = "Smooth" ch.Transparency = 1
				local wh = Instance.new("Weld",ch) wh.Part0 = h1 wh.Part1 = ch
			end
			--Right Arm--
			if ra1 ~= nil then
				local rsa = Instance.new("Glue",t1) rsa.Part0 = t1 rsa.Part1 = ra1 rsa.C0 = CFrame.new(t1.Size.x/2 + t1.Size.x/4,t1.Size.y/4,0) rsa.C1 = CFrame.new(0,ra1.Size.y/4,0) rsa.Name = "yo"
				local cra = Instance.new("Part",t1) cra.Name = "yo" cra.Size = Vector3.new(ra1.Size.y/2 + ra1.Size.y/4,ra1.Size.y/2,ra1.Size.z) cra.TopSurface = "Smooth" cra.BottomSurface = "Smooth" cra.Transparency = 1
				local wra = Instance.new("Weld",cra) wra.Part0 = ra1 wra.Part1 = cra wra.C0 = CFrame.new(0,-ra1.Size.y/8,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90))
			end
			--Left Arm--
			if la1 ~= nil then
				local lsa = Instance.new("Glue",t1) lsa.Part0 = t1 lsa.Part1 = la1 lsa.C0 = CFrame.new(-t1.Size.x/2 - t1.Size.x/4,t1.Size.y/4,0) lsa.C1 = CFrame.new(0,la1.Size.y/4,0) lsa.Name = "yo"
				local cla = Instance.new("Part",t1) cla.Name = "yo" cla.Size = Vector3.new(la1.Size.y/2 + la1.Size.y/4,la1.Size.y/2,la1.Size.z) cla.TopSurface = "Smooth" cla.BottomSurface = "Smooth" cla.Transparency = 1
				local wla = Instance.new("Weld",cla) wla.Part0 = la1 wla.Part1 = cla wla.C0 = CFrame.new(0,-la1.Size.y/8,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90))
			end
			--Right Leg--
			if rl1 ~= nil then
				local rha = Instance.new("Glue",t1) rha.Part0 = t1 rha.Part1 = rl1 rha.C0 = CFrame.new(t1.Size.x/4,-t1.Size.y/2,0) rha.C1 = CFrame.new(0,rl1.Size.y/2,0) rha.Name = "yo"
				local crl = Instance.new("Part",t1) crl.Name = "yo" crl.Size = Vector3.new(rl1.Size.y/2 + rl1.Size.y/4,rl1.Size.y/2,rl1.Size.z) crl.TopSurface = "Smooth" crl.BottomSurface = "Smooth" crl.Transparency = 1
				local wrl = Instance.new("Weld",crl) wrl.Part0 = rl1 wrl.Part1 = crl wrl.C0 = CFrame.new(0,-rl1.Size.y/8,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90))
			end
			--Left Leg--
			if ll1 ~= nil then
				local lha = Instance.new("Glue",t1) lha.Part0 = t1 lha.Part1 = ll1 lha.C0 = CFrame.new(-t1.Size.x/4,-t1.Size.y/2,0) lha.C1 = CFrame.new(0,ll1.Size.y/2,0) lha.Name = "yo"
				local cll = Instance.new("Part",t1) cll.Name = "yo" cll.Size = Vector3.new(ll1.Size.y/2 + ll1.Size.y/4,ll1.Size.y/2,ll1.Size.z) cll.TopSurface = "Smooth" cll.BottomSurface = "Smooth" cll.Transparency = 1
				local wll = Instance.new("Weld",cll) wll.Part0 = ll1 wll.Part1 = cll wll.C0 = CFrame.new(0,-ll1.Size.y/8,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90))
			end
			--//End of Joints~//--
			swait(50)
			local nou = who
			swait(300)
			local BRUTAL = Instance.new("Sound",nou)
			BRUTAL.SoundId = "rbxassetid://256509968"
			BRUTAL.Volume = 7
			BRUTAL:Play()
			coroutine.resume(coroutine.create(function()
				for i,v in pairs(nou:GetChildren()) do
					if v:IsA("Part") then
						v.Anchored = true
					end
				end
			end))
			local trae = script.Objects.treemesh:Clone()
			trae.Parent = nou
			trae.Transparency = 0
			trae.Position = nou.Torso.Position
			wait(7)
			BRUTAL:Destroy()
			local BRUTAL = Instance.new("Sound",nou)
			BRUTAL.SoundId = "rbxassetid://256509968"
			BRUTAL.Volume = 7
			BRUTAL:Play()
			trae.Size = Vector3.new(14,40,14)
			wait(7)
			BRUTAL:Destroy()
		end
	end)
end

function TreeReduce()
	attack = true
	hum.WalkSpeed = 0
	for i = 1,100,0.75 do
		swait()
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(25 - 1 * math.cos(0)),math.rad(0 + 2 * math.cos(SINE / 32)),math.rad(1 + 2 * math.cos(SINE / 32))),.6)
		RootJoint.C0 = clerp(RootJoint.C0,RootCF*CFrame.new(0,-.3,-1.6) * CFrame.Angles(math.rad(20),math.rad(0 + 1.5 * math.sin(SINE / 2)),math.rad(0)),.25)
		LW.C0 = aclerp(LW.C0,CFrame.new(-0.80868268, 0.497842163, -0.14479053, 0.744864702, -0.66721499, -0.00102781132, -0.0409338176, -0.0441599488, -0.998185575, 0.665959001, 0.743555188, -0.0602048337)*angles(0,math.rad(0+2*math.cos(SINE/0.134561367)),math.rad(0+5*math.cos(SINE/0.127347))),0.3)
		RW.C0 = clerp(RW.C0, cf(1.5* Player_Size, 0.5 + 0.06 * math.sin(SINE / 20)* Player_Size, 0* Player_Size) * angles(math.rad(145), math.rad(0), math.rad(15 + 2.5 * math.sin(SINE / 20))), 0.12)
		RH.C0 = clerp(RH.C0,CFrame.new(-0.5, 0.4 + 0.01 * math.sin(SINE / 12), -0.05 + 0.001 * math.sin(SINE / 12)) * CFrame.Angles(math.rad(-10), math.rad(0 + 0.05 * math.cos(SINE / 12)), math.rad(0 + 0.05 * math.cos(SINE / 12))), 0.25)
		LH.C0 = clerp(LH.C0,CFrame.new(0.5, 0.4 + 0.01 * math.sin(SINE / 12), -0.05 + 0.001 * math.sin(SINE / 12)) * CFrame.Angles(math.rad(-10), math.rad(0 + 0.05 * math.cos(SINE / 12)), math.rad(0 + 0.05 * math.cos(SINE / 12))), 0.25)		
		book1.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/17) * 8, RootPart.Position.Y + 0.5 * math.cos(SINE / 25 + 30), RootPart.Position.Z  - math.cos(SINE/17) * 8)
		book2.Position = Vector3.new(RootPart.Position.X + math.sin(SINE/17) * 8, RootPart.Position.Y + 1.5 + 0.5 * math.cos(SINE / 25 + 60), RootPart.Position.Z  - math.cos(SINE/17) * 8)
		book3.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/17) * 8, RootPart.Position.Y + - 1.5 + 0.5 * math.cos(SINE / 25 + 90), RootPart.Position.Z  + math.cos(SINE/17) * 8)
		book4.Position = Vector3.new(RootPart.Position.X + math.sin(SINE/17) * 8, RootPart.Position.Y + 3 + 0.5 * math.cos(SINE / 25 + 120), RootPart.Position.Z  + math.cos(SINE/17) * 8)
		book5.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/14) * 6, RootPart.Position.Y + 1.5 + 0.5 * math.cos(SINE / 25 + 150), RootPart.Position.Z  - math.cos(SINE/14) * 6)
		book6.CFrame = hed.CFrame + root.CFrame.lookVector*4
		book6.Position = Vector3.new(book6.Position.X,book6.Position.Y + 3 + 0.5 * math.cos(SINE / 25 + 120), book6.Position.Z)
		book7.Position = Vector3.new(RootPart.Position.X - math.cos(SINE/14) * 3, RootPart.Position.Y + 5 + 1* math.cos(SINE / 35), RootPart.Position.Z  - math.sin(SINE/14) * 3)
	end
	CFuncs["Sound"].Create("rbxassetid://438666141", root, 7.5,1)
	CFuncs["Sound"].Create("rbxassetid://1208650519", root, 7.5, 1)
	CamShakeAll({
		Duration=0.4; 
		Intensity=3;
		Position=Vector3.new(2,2,2);
		Rotation=Vector3.new(2,2,6);
		DropDist=1000;
		IneffectiveDist=1000;
		Origin=tors.Position;
	})
	--MagniDamage(tors, 50, 1,2, 0, "Tree")
	chatfunc("Leave the dead where they fall.",Color3.new(1,1,1))
	CFuncs["Sound"].Create("rbxassetid://907329669", root, 10, 1)
	attack = false
	hum.WalkSpeed = 16
end

-- transparent objects --
for i,v in pairs(script.Objects:GetChildren()) do
	if v:IsA("Part") then
		v.Transparency = 1
	end
end

-- Keystrokes --

--[[z,x,c,v,b,n and m select spell books
	q,e,r,t,y, and u are attacks 
--]]

mouse.KeyDown:connect(function(k)
	if attack == false then
		if k == "z" then
			selected = "fire"
		elseif k == "x" then
			selected = "earth"
		elseif k == "c" then
			selected = "thunder"
		elseif k == "v" then
			selected = "ice"
		elseif k == "b" then
			selected = "dark"
		elseif k == "n" then
			selected = "light"
		elseif k == "m" then
			selected = "lunar"
		end
		if selected == "fire" then
			if k == "q" then
				volcaniceruption()
			end
		elseif selected == "earth" then
			if k == "q" then
				LithosphereSpikes()
			elseif k == "e" then
				Mountain()
			end
		elseif selected == "thunder" then
			if k == "q" then
				LightningStrike()
			end
		elseif selected == "ice" then
			if k == "q" then
				DryFreeze()
			end
		elseif selected == "dark" then
			if k == "q" then
				DarkPillar()
			end
		elseif selected == "light" then
			if k == "q" then
				TreeReduce()
			end
		end
	end
end)
-- Final loop--

--[[

--]]

local idle = 0

hum.Name = "Humanoid"
hum.MaxHealth = math.huge
hum.Health = math.huge
hum.BreakJointsOnDeath = false
Instance.new("ForceField",char).Visible = false

while true do
	swait()
	hum.MaxHealth = math.huge
	hum.Health = math.huge
	hum.BreakJointsOnDeath = false
	SINE = SINE + 1
	if attack ~= true then
		book1.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/17) * 8, RootPart.Position.Y + 0.5 * math.cos(SINE / 25 + 30), RootPart.Position.Z  - math.cos(SINE/17) * 8)
		book2.Position = Vector3.new(RootPart.Position.X + math.sin(SINE/17) * 8, RootPart.Position.Y + 1.5 + 0.5 * math.cos(SINE / 25 + 60), RootPart.Position.Z  - math.cos(SINE/17) * 8)
		book3.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/17) * 8, RootPart.Position.Y + - 1.5 + 0.5 * math.cos(SINE / 25 + 90), RootPart.Position.Z  + math.cos(SINE/17) * 8)
		book4.Position = Vector3.new(RootPart.Position.X + math.sin(SINE/17) * 8, RootPart.Position.Y + 3 + 0.5 * math.cos(SINE / 25 + 120), RootPart.Position.Z  + math.cos(SINE/17) * 8)
		book5.Position = Vector3.new(RootPart.Position.X - math.sin(SINE/14) * 6, RootPart.Position.Y + 1.5 + 0.5 * math.cos(SINE / 25 + 150), RootPart.Position.Z  - math.cos(SINE/14) * 6)
		book6.Position = Vector3.new(RootPart.Position.X - math.cos(SINE/14) * 6, RootPart.Position.Y - 0.5 * math.sin(SINE / 25 + 150), RootPart.Position.Z  - math.sin(SINE/14) * 6)
		book7.Position = Vector3.new(RootPart.Position.X - math.cos(SINE/14) * 3, RootPart.Position.Y + 5 + 1* math.cos(SINE / 35), RootPart.Position.Z  - math.sin(SINE/14) * 3)
	end
	if selected == "fire" then
		book2.Material = "Neon"
		book1.Material = "Plastic"
		book3.Material = "Plastic"
		book4.Material = "Plastic"
		book5.Material = "Plastic"
		book6.Material = "Plastic"
		book7.Material = "Plastic"
	elseif selected == "earth" then
		book2.Material = "Plastic"
		book1.Material = "Neon"
		book3.Material = "Plastic"		
		book4.Material = "Plastic"
		book5.Material = "Plastic"
		book6.Material = "Plastic"
		book7.Material = "Plastic"
	elseif selected == "thunder" then
		book2.Material = "Plastic"
		book1.Material = "Plastic"
		book3.Material = "Neon" 
		book4.Material = "Plastic"
		book5.Material = "Plastic"
		book6.Material = "Plastic"
		book7.Material = "Plastic"
	elseif selected == "ice" then
		book2.Material = "Plastic"
		book1.Material = "Plastic"
		book3.Material = "Plastic" 
		book4.Material = "Neon"
		book5.Material = "Plastic"	
		book6.Material = "Plastic"
		book7.Material = "Plastic"
	elseif selected == "dark" then
		book2.Material = "Plastic"
		book1.Material = "Plastic"
		book3.Material = "Plastic" 
		book4.Material = "Plastic"
		book5.Material = "Neon"
		book6.Material = "Plastic"
		book7.Material = "Plastic"
	elseif selected == "light" then
		book2.Material = "Plastic"
		book1.Material = "Plastic"
		book3.Material = "Plastic" 
		book4.Material = "Plastic"
		book5.Material = "Plastic"
		book6.Material = "Neon"
		book7.Material = "Plastic"
	elseif selected == "lunar" then
		book2.Material = "Plastic"
		book1.Material = "Plastic"
		book3.Material = "Plastic" 
		book4.Material = "Plastic"
		book5.Material = "Plastic"
		book6.Material = "Plastic"
		book7.Material = "Neon"
	end
	local torvel = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
	local velderp = RootPart.Velocity.y
	hf, pf = rayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 4, Character)
	hitfloor, posfloor = rayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 4, Character)
	if attack == false then
		idle = idle + 1
	else
		idle = 0
	end
	if not (idle >= 500) or attack == false then
	end
	if 1 < RootPart.Velocity.y and hitfloor == nil then
		Anim = "Jump"
		if attack == false then
			RH.C0 = clerp(RH.C0, cf(1, -1 - 0.05 * math.cos(SINE / 25), 0) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(-5), math.rad(0), math.rad(-20)), 0.1)
			LH.C0 = clerp(LH.C0, cf(-1, -1 - 0.05 * math.cos(SINE / 25), 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-5), math.rad(0), math.rad(20)), 0.1)
			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0 + 0.05 * math.cos(SINE / 25)) * angles(math.rad(-10), math.rad(0), math.rad(0)), 0.1)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(-2.5), math.rad(0), math.rad(0)), 0.1)
			RW.C0 = clerp(RW.C0, cf(1.45, 0.5 + 0.1 * math.cos(SINE / 25), 0) * angles(math.rad(-5), math.rad(0), math.rad(25)), 0.1)
			LW.C0 = clerp(LW.C0, cf(-1.45, 0.5 + 0.1 * math.cos(SINE / 25), 0) * angles(math.rad(-5), math.rad(0), math.rad(-25)), 0.1)
		end
	elseif -1 > RootPart.Velocity.y and hitfloor == nil then
		Anim = "Fall"
		if attack == false then
			RH.C0 = clerp(RH.C0, cf(1, -1 - 0.05 * math.cos(SINE / 25), 0) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(-5), math.rad(0), math.rad(-20)), 0.1)
			LH.C0 = clerp(LH.C0, cf(-1, -1 - 0.05 * math.cos(SINE / 25), 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-5), math.rad(0), math.rad(20)), 0.1)
			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0 + 0.05 * math.cos(SINE / 25)) * angles(math.rad(0), math.rad(0), math.rad(0)), 0.1)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(0)), 0.1)
			RW.C0 = clerp(RW.C0, cf(1.45, 0.5 + 0.1 * math.cos(SINE / 25), 0) * angles(math.rad(-20), math.rad(0), math.rad(50)), 0.1)
			LW.C0 = clerp(LW.C0, cf(-1.45, 0.5 + 0.1 * math.cos(SINE / 25), 0) * angles(math.rad(-20), math.rad(0), math.rad(-50)), 0.1)
		end
	elseif torvel < 1 and hitfloor ~= nil then
		Anim = "Idle"
		if attack == false then
			RH.C0=clerp(RH.C0,cf(1,-0.7,-0.5)*angles(math.rad(0),math.rad(80),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(10)),.15)
			LH.C0=clerp(LH.C0,cf(-1,-0.8,0)*angles(math.rad(0),math.rad(-80),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0)),.15)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-.25)*angles(math.rad(0),math.rad(0),math.rad(-30)),.15)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15),math.rad(0),math.rad(30)),.15)
			RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(SINE / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(SINE / 72)),math.rad(3 - 2 * math.cos(SINE / 58)),math.rad(-82 + 2 * math.cos(SINE / 45))),.1)
			LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(SINE / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(SINE / 66)),math.rad(4 - 3 * math.cos(SINE / 59)),math.rad(67 - 4 * math.cos(SINE / 45))),.1)
		end
	elseif torvel > 2 and torvel < 22 and hitfloor ~= nil then
		Anim = "Walk"
		if attack == false then
			RH.C0 = clerp(RH.C0, cf(1, -0.85 - 0.15 * math.cos(SINE / 3), -0.15 - 0.15 * math.cos(SINE / 3)) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(0), math.rad(0), math.rad(0 + 55 * math.cos(SINE / 6))), 0.1)
			LH.C0 = clerp(LH.C0, cf(-1, -0.85 + 0.15 * math.cos(SINE / 3), -0.15 + 0.15 * math.cos(SINE / 3)) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(0), math.rad(0), math.rad(0 + 55 * math.cos(SINE / 6))), 0.1)
			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.15 - 0.1 * math.cos(SINE / 3)) * angles(math.rad(5), math.rad(0), math.rad(0 - 5 * math.cos(SINE / 6))), 0.1)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(10 + 2.5 * math.cos(SINE / 100)), math.rad(0), math.rad(0 + 5 * math.cos(SINE / 6))), 0.1)
			RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * angles(math.rad(0 - 75 * math.cos(SINE / 6)), math.rad(0), math.rad(10 - 10 * math.cos(SINE / 3))), 0.1)
			LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * angles(math.rad(0 + 75 * math.cos(SINE / 6)), math.rad(0), math.rad(-10 + 10 * math.cos(SINE / 3))), 0.1)
		end
	elseif torvel >= 22 and hitfloor ~= nil then
		Anim = "Run"
		if attack == false then
			RH.C0 = clerp(RH.C0, cf(1, -0.75 - 0.25 * math.cos(SINE / 3), -0.25 - 0.25 * math.cos(SINE / 3)) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(0), math.rad(0), math.rad(0 + 95 * math.cos(SINE / 6))), 0.1)
			LH.C0 = clerp(LH.C0, cf(-1, -0.75 + 0.25 * math.cos(SINE / 3), -0.25 + 0.25 * math.cos(SINE / 3)) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(0), math.rad(0), math.rad(0 + 95 * math.cos(SINE / 6))), 0.1)
			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.125 + 0.125 * math.cos(SINE / 3)) * angles(math.rad(20), math.rad(0), math.rad(0 - 15 * math.cos(SINE / 6))), 0.1)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(-10 + 2.5 * math.cos(SINE / 100)), math.rad(0), math.rad(0 + 15 * math.cos(SINE / 6))), 0.1)
			RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * angles(math.rad(0 - 125 * math.cos(SINE / 6)), math.rad(0), math.rad(5 - 10 * math.cos(SINE / 3))), 0.1)
			LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * angles(math.rad(0 + 125 * math.cos(SINE / 6)), math.rad(0), math.rad(-5 + 10 * math.cos(SINE / 3))), 0.1)
		end
	end
end
end)

Section2:CreateButton("Arsenal Tec-9", function()
	local script = game:GetObjects("rbxassetid://7277032855")[1]
--//====================================================\\--
--||			   CREATED BY SHACKLUSTER
--\\====================================================//--
--repeat wait() until script:WaitForChild'Owner'.Value
local Player = game.Players.LocalPlayer

PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = Cam.CameraSubject.Parent
Humanoid = Character.Humanoid
RootPart = Character.HumanoidRootPart
Torso = Character.Torso
Head = Character.Head
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart.RootJoint
Neck = Torso.Neck
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
local MOUSEPOS = RootPart.Position
local TIME = 0
local sick = Instance.new("Sound",Torso)

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
--//=================================\\
--|| 	      USEFUL VALUES
--\\=================================//

Animation_Speed = 3
Frame_Speed = 0.016666666666666666
local FORCERESET = false
Frame_Speed = 1 / 80 -- (1 / 60) OR (1 / 80)
local Speed = 25
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local BMUSIC = IT("Sound", RootPart)
local VOLUME = 2
local PITCH = 1
local SONGID = 1305709235  --1347700465
local EQUIPPED = false
local HOLD = false
local COMBO = 1
local Type = "Ban"
local reason = "Ur damn skids nigga"
local Rooted = false
local SINE = 0
local SIZE = 1
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
--ROBLOXIDLEANIMATION.Parent = Humanoid
local WEAPONGUI = IT("ScreenGui", PlayerGui)
WEAPONGUI.Name = "BanishV3Gui"
local Characterb = IT("Model")
Characterb.Name = "shackisgaylol"
local CharacterA = IT("Model")
CharacterA.Name = "shackismegagaylol"
local Effects = IT("Folder", CharacterA)
Effects.Name = "Effects"
local Effects2 = IT("Folder", Characterb)
Effects.Name = "Effects"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character:FindFirstChild("Animate")
local UNANCHOR = true
local TOBANISH = {}
script.Parent = PlayerGui

--//=================================\\
--\\=================================//


--//=================================\\
--|| SAZERENOS' ARTIFICIAL HEARTBEAT
--\\=================================//

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
		lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

--//=================================\\
--\\=================================//

--//=================================\\
--|| 	      SOME FUNCTIONS
--\\=================================//

local BODY = {}
for _, c in pairs(Character:GetDescendants()) do
	if c:IsA("BasePart") and c.Name ~= "Handle" then
		if c ~= RootPart and c ~= Torso and c ~= Head and c ~= RightArm and c ~= LeftArm and c ~= RightLeg and c ~= LeftLeg then
			c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		end
		table.insert(BODY,{c,c.Parent,c.Material,c.Color,c.Transparency})
	elseif c:IsA("JointInstance") then
		table.insert(BODY,{c,c.Parent,nil,nil,nil})
	end
end
for e = 1, #BODY do
	if BODY[e] ~= nil then
		local STUFF = BODY[e]
		local PART = STUFF[1]
		local PARENT = STUFF[2]
		local MATERIAL = STUFF[3]
		local COLOR = STUFF[4]
		local TRANSPARENCY = STUFF[5]
		if PART.ClassName == "Part" and PART ~= RootPart then
			PART.Material = MATERIAL
			PART.Color = COLOR
			PART.Transparency = TRANSPARENCY
		end
		PART.AncestryChanged:Connect(function()
			PART.Parent = PARENT
		end)
	end
end

function refit()
	
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end

function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

	local function weldBetween(a, b)
	    local weldd = Instance.new("ManualWeld")
	    weldd.Part0 = a
	    weldd.Part1 = b
	    weldd.C0 = CFrame.new()
	    weldd.C1 = b.CFrame:inverse() * a.CFrame
	    weldd.Parent = a
	    return weldd
	end


function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end

function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
	local frame = IT("Frame")
	frame.BackgroundTransparency = TRANSPARENCY
	frame.BorderSizePixel = BORDERSIZEPIXEL
	frame.Position = POSITION
	frame.Size = SIZE
	frame.BackgroundColor3 = COLOR
	frame.BorderColor3 = BORDERCOLOR
	frame.Name = NAME
	frame.Parent = PARENT
	return frame
end

function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
	local label = IT("TextLabel")
	label.BackgroundTransparency = 1
	label.Size = UD2(1, 0, 1, 0)
	label.Position = UD2(0, 0, 0, 0)
	label.TextColor3 = TEXTCOLOR
	label.TextStrokeTransparency = STROKETRANSPARENCY
	label.TextTransparency = TRANSPARENCY
	label.FontSize = TEXTFONTSIZE
	label.Font = TEXTFONT
	label.BorderSizePixel = BORDERSIZEPIXEL
	label.TextScaled = false
	label.Text = TEXT
	label.Name = NAME
	label.Parent = PARENT
	return label
end


function NoOutlines(PART)
	PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
end

function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
local weld = Instance.new("Weld")
weld.Parent = parent
weld.Part0 = part0
weld.Part1 = part1
weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
return weld
end

--NewSound({ID = 0,PARENT = ROOT,VOLUME = 0.5,PITCH = 1,LOOP = false,MAXDISTANCE = 1000,EMITTERSIZE = 10,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
function NewSound(TABLE)
	local ID = "rbxassetid://"..(TABLE.ID or 0)
	local PARENT = (TABLE.PARENT or RootPart)
	local VOLUME = (TABLE.VOLUME or 0.5)
	local PITCH = (TABLE.PITCH or 1)
	local LOOP = (TABLE.LOOP or false)
	local MAXDISTANCE = (TABLE.MAXDISTANCE or 100)
	local EMITTERSIZE = (TABLE.EMITTERSIZE or 10)
	local PLAYING = (TABLE.PLAYING or true)
	local PLAYONREMOVE = (TABLE.PLAYONREMOVE or false)
	local DOESDEBRIS = (TABLE.DOESDEBRIS or true)
	if ID ~= "rbxassetid://0" then
		local SOUND = IT("Sound",PARENT)
		SOUND.SoundId = ID
		SOUND.Volume = VOLUME
		SOUND.Pitch = PITCH
		SOUND.Looped = LOOP
		SOUND.MaxDistance = MAXDISTANCE
		SOUND.EmitterSize = EMITTERSIZE
		SOUND.PlayOnRemove = PLAYONREMOVE
		if DOESDEBRIS == true and PLAYING == true and LOOP == false then
			Debris:AddItem(SOUND,SOUND.TimeLength+5)
		end
		if PLAYING == true then
			SOUND:Play()
		end
		return SOUND
	end
end

function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end

local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false or NEWSOUND.Parent ~= PARENT
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function CFrameFromTopBack(at, top, back)
	local right = top:Cross(back)
	return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end

--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME+1 do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = VT(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				SOUND.Stopped:Connect(function()
					EFFECT:remove()
				end)
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		end
	end))
end

function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

function SpawnTrail(FROM,TO,BIG)
	local TRAIL = CreatePart(3, Effects, "Neon", 0, 0.5, "New Yeller", "Trail", VT(0,0,0))
	MakeForm(TRAIL,"Cyl")
	local DIST = (FROM - TO).Magnitude
	if BIG == true then
		TRAIL.Size = VT(0.5,DIST,0.5)
	else
		TRAIL.Size = VT(0.25,DIST,0.25)
	end
	TRAIL.CFrame = CF(FROM, TO) * CF(0, 0, -DIST/2) * ANGLES(RAD(90),RAD(0),RAD(0))
	coroutine.resume(coroutine.create(function()
		for i = 1, 5 do
			Swait()
			TRAIL.Transparency = TRAIL.Transparency + 0.1
		end
		TRAIL:remove()
	end))
end

function MagicSphere(SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
	local mesh = IT("SpecialMesh",wave)
	mesh.MeshType = "Sphere"
	mesh.Scale = SIZE
	mesh.Offset = VT(0,0,0)
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.Transparency = wave.Transparency + (1/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function MagicSphereCo(SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
	local mesh = IT("SpecialMesh",wave)
	mesh.MeshType = "Sphere"
	mesh.Scale = SIZE
	mesh.Offset = VT(0,0,0)
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.Transparency = wave.Transparency + (1/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function MagicBlock(SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "ForceField", 0, 0.5, BRICKC(COLOR), "Effect", VT(SIZE,SIZE,SIZE), true)
	local mesh = IT("BlockMesh",wave)
	wave.CFrame = CFRAME * ANGLES(RAD(math.random(-360,360)),RAD(math.random(-360,360)),RAD(math.random(-360,360)))
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.CFrame = CFRAME * ANGLES(RAD(math.random(-360,360)),RAD(math.random(-360,360)),RAD(math.random(-360,360)))
			wave.Transparency = wave.Transparency + (0.5/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function CreateRing(SIZE, DOESROT, ROT, WAIT, CFRAME, COLOR, GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(0, 0, 0))
	local mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "559831844", "", SIZE, VT(0, 0, 0))
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			if DOESROT == true then
				wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0, ROT, 0)
			end
			wave.Transparency = wave.Transparency + 0.5 / WAIT
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

local DECAL = IT("Decal")
function MagicRing()
	local RING = CreatePart(3, Effects, "Granite", 0, 1, "Maroon", "MagicRing", VT(0,0,0),true)
	local MESH = IT("BlockMesh",RING)
	local BOTTOMTEXTURE = DECAL:Clone()
	BOTTOMTEXTURE.Parent = RING
	BOTTOMTEXTURE.Face = "Bottom"
	BOTTOMTEXTURE.Name = "BottomTexture"
	local TOPTEXTURE = DECAL:Clone()
	TOPTEXTURE.Parent = RING
	TOPTEXTURE.Face = "Top"
	TOPTEXTURE.Name = "TopTexture"
	BOTTOMTEXTURE.Texture = "http://www.roblox.com/asset/?id=1208118228"
	TOPTEXTURE.Texture = "http://www.roblox.com/asset/?id=1208118228"
	BOTTOMTEXTURE.Color3 = C3(0,0,0)
	TOPTEXTURE.Color3 = C3(1,1,1)
	return RING,MESH,TOPTEXTURE,BOTTOMTEXTURE
end

Debris = game:GetService("Debris")

function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end

function turnto(position)
	RootPart.CFrame=CFrame.new(RootPart.CFrame.p,VT(position.X,RootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
end

function SHAKECAM(POSITION, RANGE, INTENSITY, TIME)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO and RANGE >= (TORSO.Position - POSITION).Magnitude then
					local CAMSHAKER = script.CamShake:Clone()
					CAMSHAKER.Shake.Value = INTENSITY
					CAMSHAKER.Timer.Value = TIME
					CAMSHAKER.Parent = CHILD
					CAMSHAKER.Disabled = false
				end
			end
		end
	end
end

--//=================================\\
--||	     WEAPON CREATION
--\\=================================//

--usedmostly on shackluster edits and shit
---------------------------------Weapon/armor creation------------------------

function WWeld(a, b, acf)
    local we = Instance.new("Weld", a)
    we.Part0 = a
    we.Part1 = b
if acf ~= nil then
    we.C0 = acf
end
end

for i = 1,10 do
wait()
end

-------------------------------------------------------------------------------------------
--- outfit

---
local Tec9 = script.Tec9:Clone()
Tec9.Parent = RightArm
CreateWeld(Tec9.Handle,RightArm,Tec9.Handle,-0.3,-0.2,-0.9,math.rad(90),math.rad(0),math.rad(180),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local Hole = Tec9.Hole

for i,v in pairs(Tec9:GetChildren()) do
	if v:IsA("BasePart") or v:IsA("MeshPart") then
		v.Transparency = 1
	end
end

function Align(Part0, Part1, Position, Angle)
	if Part0:FindFirstChild("Attachment") then
		Part0:FindFirstChild("Attachment"):Remove()
	end
    local AlignPosition = Instance.new("AlignPosition",Part0)
    local AlignOrientation = Instance.new("AlignOrientation",Part0)
    
    local Attachment1 = Instance.new("Attachment", Part0)
    local Attachment2 = Instance.new("Attachment", Part1)

    AlignPosition.Attachment0 = Attachment1
    AlignPosition.Attachment1 = Attachment2
    
    AlignOrientation.Attachment0 = Attachment1
    AlignOrientation.Attachment1 = Attachment2
    
    Attachment2.Position = Position or Vector3.new(0,0,0)
    Attachment2.Orientation = Angle or Vector3.new(0,0,0)
    
    AlignOrientation.MaxTorque = math.huge
    AlignOrientation.MaxAngularVelocity = math.huge
    AlignOrientation.PrimaryAxisOnly = false 
    AlignOrientation.Responsiveness = 200
    AlignOrientation.RigidityEnabled = false
    AlignOrientation.ReactionTorqueEnabled = false
    AlignPosition.MaxForce = math.huge
    AlignPosition.MaxVelocity = math.huge
    AlignPosition.ReactionForceEnabled = false
    AlignPosition.Responsiveness = 200
    AlignPosition.ApplyAtCenterOfMass = true
    AlignPosition.RigidityEnabled = true
    game:GetService("RunService").Heartbeat:Connect(function()
        Part0.Velocity = Vector3.new(-29.99,0,0)
    end)
    if Part0.Parent:IsA("Accessory") then
    	Part0:BreakJoints()
    end
end

-- 5410674378
Align(game.Players.LocalPlayer.Character["METALXLIGHTSEER77Accessory"].Handle, Tec9.Handle, Vector3.new(0, 0.6, 0.15), Vector3.new(-0, 90, -35))

local Particle = IT("ParticleEmitter",nil)
Particle.Enabled = false
Particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.3),NumberSequenceKeypoint.new(0.3,0),NumberSequenceKeypoint.new(1,1)})
Particle.LightEmission = 0.5
Particle.Rate = 150
Particle.ZOffset = 0.2
Particle.Rotation = NumberRange.new(-180, 180)
Particle.RotSpeed = NumberRange.new(-180, 180)
Particle.Texture = "http://www.roblox.com/asset/?id=304437537"
Particle.Color = ColorSequence.new(C3(1,1,1),C3(0,0,0))

--ParticleEmitter({Speed = 5, Drag = 0, Size1 = 1, Size2 = 5, Lifetime1 = 1, Lifetime2 = 1.5, Parent = Torso, Emit = 100, Offset = 360, Enabled = false})
function ParticleEmitter(Table)
	local PRTCL = Particle:Clone()
	local Speed = Table.Speed or 5
	local Drag = Table.Drag or 0
	local Size1 = Table.Size1 or 1
	local Size2 = Table.Size2 or 5
	local Lifetime1 = Table.Lifetime1 or 1
	local Lifetime2 = Table.Lifetime2 or 1.5
	local Parent = Table.Parent or Torso
	local Emit = Table.Emit or 100
	local Offset = Table.Offset or 360
	local Acel = Table.Acel or VT(0,0,0)
	local Enabled = Table.Enabled or false
	PRTCL.Parent = Parent
	PRTCL.Size = NumberSequence.new(Size1,Size2)
	PRTCL.Lifetime = NumberRange.new(Lifetime1,Lifetime2)
	PRTCL.Speed = NumberRange.new(Speed)
	PRTCL.VelocitySpread = Offset
	PRTCL.Drag = Drag
	PRTCL.Acceleration = Acel
	if Enabled == false then
		PRTCL:Emit(Emit)
		Debris:AddItem(PRTCL,Lifetime2)
	else
		PRTCL.Enabled = true
	end
	return PRTCL
end

--ParticleEmitter({Speed = 5, Drag = 0, Size1 = 1, Size2 = 5, Lifetime1 = 1, Lifetime2 = 1.5, Parent = Torso, Emit = 100, Offset = 360, Enabled = false})

for _, c in pairs(CharacterA:GetChildren()) do
	if c.ClassName == "Part" then
		c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
	end
end

CharacterA.Parent = Character

Characterb.Parent = Character


local SKILLTEXTCOLOR = C3(1,1,1)
local SKILLFONT = ""
local SKILLTEXTSIZE = 7

local BODY = {}
for _, c in pairs(Character:GetDescendants()) do
	if c:IsA("BasePart") and c.Name ~= "Handle" then
		if c ~= RootPart and c ~= Torso and c ~= Head and c ~= RightArm and c ~= LeftArm and c ~= RightLeg and c ~= LeftLeg then
			c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		end
		table.insert(BODY, {
			c,
			c.Parent,
			c.Material,
			c.Color,
			c.Transparency,
			c.Size,
			c.Name
		})
	elseif c:IsA("JointInstance") or c:IsA("Shirt") or c:IsA("Pants") then
		table.insert(BODY, {
			c,
			c.Parent,
			nil,
			nil,
			nil,
			nil,
			nil
		})
	end
end
function refit()
	
end
Humanoid.Died:connect(function()
	refit()
end)

--[[local SKILL1FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.1, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 1 Frame")
local SKILL2FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.63, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 2 Frame")
local SKILL3FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.215, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 3 Frame")
local SKILL4FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.525, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 4 Frame")
local SKILL5FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.365, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 5 Frame")
]]
--[[local SKILL1TEXT = CreateLabel(SKILL1FRAME, "[Z] Banish Bullet", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 1")
local SKILL2TEXT = CreateLabel(SKILL2FRAME, "[B] Ability 2", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 2")
local SKILL3TEXT = CreateLabel(SKILL3FRAME, "[C] Ability 3", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 3")
local SKILL4TEXT = CreateLabel(SKILL4FRAME, "[V] Ability 4", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 4")
local SKILL5TEXT = CreateLabel(SKILL5FRAME, "[X] Mercy", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 5")
]]

function chatfunc(text)
	local chat = coroutine.wrap(function()
	if Character:FindFirstChild("TalkingBillBoard")~= nil then
		Character:FindFirstChild("TalkingBillBoard"):destroy()
	end
	local Bill = Instance.new("BillboardGui",Character)
	Bill.Size = UDim2.new(0,100,0,40)
	Bill.StudsOffset = Vector3.new(0,3,0)
	Bill.Adornee = Character.Head
	Bill.Name = "TalkingBillBoard"
	local Hehe = Instance.new("TextLabel",Bill)
	Hehe.BackgroundTransparency = 1
	Hehe.BorderSizePixel = 0
	Hehe.Text = ""
	Hehe.Font = "SourceSansItalic"
	Hehe.TextSize = 40
	Hehe.TextStrokeTransparency = 0
	Hehe.Size = UDim2.new(1,0,0.5,0)
	coroutine.resume(coroutine.create(function()
		while Hehe ~= nil do
			Swait()	
			Hehe.Position = UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))	
			Hehe.Rotation = math.random(-5,5)
			Hehe.TextColor3 = Color3.new(0,0,0)
			Hehe.TextStrokeColor3 = Color3.new(1,1,1)
		end
	end))
	for i = 1,string.len(text),1 do
		Swait()
		Hehe.Text = string.sub(text,1,i)
	end
	Swait(90)--Re[math.random(1, 93)]
	for i = 0, 1, .025 do
		Swait()
		Bill.ExtentsOffset = Vector3.new(math.random(-i, i), math.random(-i, i), math.random(-i, i))
		Hehe.TextStrokeTransparency = i
		Hehe.TextTransparency = i
	end
	Bill:Destroy()
	end)
chat()
end

function onChatted(msg)
	chatfunc(msg)
end

Player.Chatted:connect(onChatted)

function printbye(Name)
	local MESSAGES = {"You cannot struggle, ","Your existance is an insult, ","Fade, ","Your existance is not desired, ","You are not permitted here, ","You are not to decide your fate, ","Be gone, ","You are already dead, ","Your live is an anomaly, ","Don't dare to return, ","Why are you resisting, ","You cannot exist here, ","Why are you struggling, ","Your fate was already decided, ","Goodbye, ","You cannot ignore my command, ","You cannot resist my command, ","You already died, "}
	chatfunc(MESSAGES[MRANDOM(1,#MESSAGES)]..Name..".")	
end

workspace.ChildAdded:connect(function(instance)
    for BANISH = 1, #TOBANISH do
		if TOBANISH[BANISH] ~= nil then
			if instance.Name == TOBANISH[BANISH] then
				coroutine.resume(coroutine.create(function()
					printbye(instance.Name)
					instance:ClearAllChildren()
					Debris:AddItem(instance,0.0005)
				end))
			end
		end
	end
end)

--//=================================\\
--||			DAMAGING
--\\=================================//

function Banish(Foe)
	
end

function ApplyAoE(POSITION,RANGE,ISBANISH)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if ISBANISH == true then
							Banish(CHILD)
						else
							if ISBANISH == "Gravity" then
								HUM.PlatformStand = true
								if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
									local grav = Instance.new("BodyPosition",TORSO)
									grav.D = 15
									grav.P = 20000
									grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
									grav.position = TORSO.Position
									grav.Name = "V3BanishForce"..Player.Name
								else
									TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
									TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
								end
							else
								HUM.PlatformStand = false
							end
						end
					elseif ISBANISH == "Gravity" then
						if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
							TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
							HUM.PlatformStand = false
						end
					end
				end
			end
		end
	end
end


function ManualDamage(Humanoid,Damage,TorsoPart)
	
end

local asd = Instance.new("ParticleEmitter")
asd.Color = ColorSequence.new(Color3.new(0.5, 0, 0), Color3.new(.3, 0, 0))
asd.LightEmission = .1
asd.Texture = "http://www.roblox.com/asset/?ID=291880914"
aaa = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.6),NumberSequenceKeypoint.new(1, 2)})
bbb = NumberSequence.new({NumberSequenceKeypoint.new(0, 1),NumberSequenceKeypoint.new(0.0636, 0), NumberSequenceKeypoint.new(1, 1)})
asd.Transparency = bbb
asd.Size = aaa
asd.ZOffset = .9
asd.Acceleration = Vector3.new(0, -15, 0)
asd.LockedToPart = false
asd.EmissionDirection = "Back"
asd.Lifetime = NumberRange.new(1, 2)
asd.Rotation = NumberRange.new(-100, 100)
asd.RotSpeed = NumberRange.new(-100, 100)
asd.Speed = NumberRange.new(10)
asd.Enabled = false
asd.VelocitySpread = 999

function getbloody(victim,amount)
	local PART = CreatePart(3, Effects, "Metal", 0, 1, "Mid gray", "Blood", victim.Size)
	PART.CFrame = victim.CFrame
	local HITPLAYERSOUNDS = {"356551938","264486467"}
	Debris:AddItem(PART,5)
	CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
	CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
	CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
	local prtcl = asd:Clone()
	prtcl.Parent = PART
	prtcl:Emit(amount*10)
end

function ManualAoE(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD.Parent ~= Effects then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if INSTAKILL == true then
							CHILD:BreakJoints()
						else
							local DMG = MRANDOM(MINDMG,MAXDMG)
							ManualDamage(HUM,DMG,TORSO)
						end
						if FLING > 0 then
							for _, c in pairs(CHILD:GetChildren()) do
								if c:IsA("BasePart") then
									local bv = Instance.new("BodyVelocity") 
									bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
									bv.Parent = c
									Debris:AddItem(bv,0.05)
								end
							end
						end
					end
				end
			end
		end
	end
end

function Dismember(MAN,DOWHAT)
	
end

function AttachmentCFrame(A)
	return A.Parent.CFrame*CF(A.Position)
end

function R15Ragdoll(character,KeepArms)
	character:BreakJoints()
	coroutine.resume(coroutine.create(function()
		recurse(character, function(_,v)
			if v:IsA("Attachment") then
				v.Axis = Vector3.new(0, 1, 0)
				v.SecondaryAxis = Vector3.new(0, 0, 1)
				v.Rotation = Vector3.new(0, 0, 0)
			end
		end)
		for _,child in next,character:GetChildren() do
			if child:IsA("Accoutrement") then
				for _,part in next,child:GetChildren() do
					if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
						local attachment1 = part:FindFirstChildOfClass("Attachment")
						local attachment0 = getAttachment0(character,attachment1.Name)
						if attachment0 and attachment1 then
							local constraint = Instance.new("HingeConstraint")
							constraint.Attachment0 = attachment0
							constraint.Attachment1 = attachment1
							constraint.LimitsEnabled = true
							constraint.UpperAngle = 0
							constraint.LowerAngle = 0
							constraint.Parent = character
						end
						ArtificialHitbox(part)
					elseif part.Name == "HumanoidRootPart" then
						part:remove()
					end
				end
			end
		end
		
		ragdollJoint(character,character.LowerTorso, character.UpperTorso, "Waist", "BallSocket", {
			{"LimitsEnabled",true};
			{"UpperAngle",5};
		})
		if character:FindFirstChild("Head") then
			ragdollJoint(character,character.UpperTorso, character.Head, "Neck", "BallSocket", {
				{"LimitsEnabled",true};
				{"UpperAngle",15};
			})
		end
		
		local handProperties = {
			{"LimitsEnabled", true};
			{"UpperAngle",0};
			{"LowerAngle",0};
		}
		ragdollJoint(character,character.LeftLowerArm, character.LeftHand, "LeftWrist", "Hinge", handProperties)
		ragdollJoint(character,character.RightLowerArm, character.RightHand, "RightWrist", "Hinge", handProperties)
		
		local shinProperties = {
			{"LimitsEnabled", true};
			{"UpperAngle", 0};
			{"LowerAngle", -75};
		}
		ragdollJoint(character,character.LeftUpperLeg, character.LeftLowerLeg, "LeftKnee", "Hinge", shinProperties)
		ragdollJoint(character,character.RightUpperLeg, character.RightLowerLeg, "RightKnee", "Hinge", shinProperties)
		
		local footProperties = {
			{"LimitsEnabled", true};
			{"UpperAngle", 15};
			{"LowerAngle", -45};
		}
		ragdollJoint(character,character.LeftLowerLeg, character.LeftFoot, "LeftAnkle", "Hinge", footProperties)
		ragdollJoint(character,character.RightLowerLeg, character.RightFoot, "RightAnkle", "Hinge", footProperties)
		if KeepArms == true then
			ragdollJoint(character,character.UpperTorso, character.RightUpperArm, "RightShoulder", "BallSocket")
			ragdollJoint(character,character.RightUpperArm, character.RightLowerArm, "RightElbow", "BallSocket")
			ragdollJoint(character,character.UpperTorso, character.LeftUpperArm, "LeftShoulder", "BallSocket")
			ragdollJoint(character,character.LeftUpperArm, character.LeftLowerArm, "LeftElbow", "BallSocket")
		end
		ragdollJoint(character,character.LowerTorso, character.LeftUpperLeg, "LeftHip", "BallSocket")
		ragdollJoint(character,character.LowerTorso, character.RightUpperLeg, "RightHip", "BallSocket")
		Debris:AddItem(character,5)
	end))
end

function Ragdoll(Character2,CharTorso,KeepArms)
	coroutine.resume(coroutine.create(function()
		Character2:BreakJoints()
		local hum = Character2:findFirstChild("Humanoid")
		hum:remove()
		local function Scan(ch)
			local e
			for e = 1,#ch do
				Scan(ch[e]:GetChildren())
				if ch[e].ClassName == "Weld" or ch[e].ClassName == "Motor6D" then
					ch[e]:remove()
				end
			end
		end
		local NEWHUM = IT("Humanoid")
		NEWHUM.Name = "Corpse"
		NEWHUM.Health = 0
		NEWHUM.MaxHealth = 0
		NEWHUM.PlatformStand = true
		NEWHUM.Parent = Character2
		NEWHUM.DisplayDistanceType = "None"
	
		local ch = Character2:GetChildren()
		local i
		for i = 1,#ch do
			if ch[i].Name == "THandle1" or ch[i].Name == "THandle2" then
				ch[i]:remove()
			end
		end
	
		local Torso2 = Character2.Torso
		local movevector = Vector3.new()
	
		if Torso2 then
			movevector = CFrame.new(CharTorso.Position,Torso2.Position).lookVector
			local Head = Character2:FindFirstChild("Head")
			if Head then
				local Neck = Instance.new("Weld")
				Neck.Name = "Neck"
				Neck.Part0 = Torso2
				Neck.Part1 = Head
				Neck.C0 = CFrame.new(0, 1.5, 0)
				Neck.C1 = CFrame.new()
				Neck.Parent = Torso2
	
			end
			local Limb = Character2:FindFirstChild("Right Arm")
			if Limb and KeepArms == true then
	
				Limb.CFrame = Torso2.CFrame * CFrame.new(1.5, 0, 0)
				local Joint = Instance.new("Glue")
				Joint.Name = "RightShoulder"
				Joint.Part0 = Torso2
				Joint.Part1 = Limb
				Joint.C0 = CFrame.new(1.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
				Joint.C1 = CFrame.new(-0, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
				Joint.Parent = Torso2
	
				local B = Instance.new("Part")
				B.TopSurface = 0
				B.BottomSurface = 0
				B.formFactor = "Symmetric"
				B.Size = Vector3.new(1, 1, 1)
				B.Transparency = 1
				B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
				B.Parent = Character2
				local W = Instance.new("Weld")
				W.Part0 = Limb
				W.Part1 = B
				W.C0 = CFrame.new(0, -0.5, 0)
				W.Parent = Limb
	
			end
			local Limb = Character2:FindFirstChild("Left Arm")
			if Limb and KeepArms == true then
	
				Limb.CFrame = Torso2.CFrame * CFrame.new(-1.5, 0, 0)
				local Joint = Instance.new("Glue")
				Joint.Name = "LeftShoulder"
				Joint.Part0 = Torso2
				Joint.Part1 = Limb
				Joint.C0 = CFrame.new(-1.5, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
				Joint.C1 = CFrame.new(0, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
				Joint.Parent = Torso2
	
				local B = Instance.new("Part")
				B.TopSurface = 0
				B.BottomSurface = 0
				B.formFactor = "Symmetric"
				B.Size = Vector3.new(1, 1, 1)
				B.Transparency = 1
				B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
				B.Parent = Character2
				local W = Instance.new("Weld")
				W.Part0 = Limb
				W.Part1 = B
				W.C0 = CFrame.new(0, -0.5, 0)
				W.Parent = Limb
	
			end
			local Limb = Character2:FindFirstChild("Right Leg")
			if Limb then
	
				Limb.CFrame = Torso2.CFrame * CFrame.new(0.5, -2, 0)
				local Joint = Instance.new("Glue")
				Joint.Name = "RightHip"
				Joint.Part0 = Torso2
				Joint.Part1 = Limb
				Joint.C0 = CFrame.new(0.5, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
				Joint.C1 = CFrame.new(0, 1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
				Joint.Parent = Torso2
	
				local B = Instance.new("Part")
				B.TopSurface = 0
				B.BottomSurface = 0
				B.formFactor = "Symmetric"
				B.Size = Vector3.new(1, 1, 1)
				B.Transparency = 1
				B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
				B.Parent = Character2
				local W = Instance.new("Weld")
				W.Part0 = Limb
				W.Part1 = B
				W.C0 = CFrame.new(0, -0.5, 0)
				W.Parent = Limb
	
			end
			local Limb = Character2:FindFirstChild("Left Leg")
			if Limb then
	
				Limb.CFrame = Torso2.CFrame * CFrame.new(-0.5, -2, 0)
				local Joint = Instance.new("Glue")
				Joint.Name = "LeftHip"
				Joint.Part0 = Torso2
				Joint.Part1 = Limb
				Joint.C0 = CFrame.new(-0.5, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
				Joint.C1 = CFrame.new(-0, 1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
				Joint.Parent = Torso2
	
				local B = Instance.new("Part")
				B.TopSurface = 0
				B.BottomSurface = 0
				B.formFactor = "Symmetric"
				B.Size = Vector3.new(1, 1, 1)
				B.Transparency = 1
				B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
				B.Parent = Character2
				local W = Instance.new("Weld")
				W.Part0 = Limb
				W.Part1 = B
				W.C0 = CFrame.new(0, -0.5, 0)
				W.Parent = Limb
	
			end
			--[
			local Bar = Instance.new("Part")
			Bar.TopSurface = 0
			Bar.BottomSurface = 0
			Bar.formFactor = "Symmetric"
			Bar.Size = Vector3.new(1, 1, 1)
			Bar.Transparency = 1
			Bar.CFrame = Torso2.CFrame * CFrame.new(0, 0.5, 0)
			Bar.Parent = Character2
			local Weld = Instance.new("Weld")
			Weld.Part0 = Torso2
			Weld.Part1 = Bar
			Weld.C0 = CFrame.new(0, 0.5, 0)
			Weld.Parent = Torso2
			--]]
		end
		Character2.Parent = workspace
		Debris:AddItem(Character2,5)
	
		return Character2,Torso2
	end))
end

function KickThatNigga(CHARACTER)
	
end

function ApplyAoE(POSITION,RANGE,ISKICKED)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if ISKICKED == true then
							KickThatNigga(CHILD)
						else
							if ISKICKED == "Gravity" then
								HUM.PlatformStand = true
								if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
									local grav = Instance.new("BodyPosition",TORSO)
									grav.D = 15
									grav.P = 20000
									grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
									grav.position = TORSO.Position
									grav.Name = "V3BanishForce"..Player.Name
								else
									TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
									TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
								end
							else
								HUM.PlatformStand = false
							end
						end
					elseif ISKICKED == "Gravity" then
						if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
							TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
							HUM.PlatformStand = false
						end
					end
				end
			end
		end
	end
end

local BEANED = {}

function Ban(bitch)	

end

local function CheckForBan(player)
	for i = 1, #BEANED do
		if player.Name == BEANED[i] then
			player:Kick("Ur mom gay skids") --Ban Reason Change between the '' to change the reason!
		end
	end
end


game.Players.PlayerAdded:connect(function()
	for i,v in pairs(game.Players:GetPlayers())do
		CheckForBan(v)
	end  
end)


function Kick(bitch)

end


function ApplyAoE(POSITION,RANGE,ISBANISH)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if ISBANISH == true then
							Banish(CHILD)
						else
							if ISBANISH == "Gravity" then
								HUM.PlatformStand = true
								if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
									local grav = Instance.new("BodyPosition",TORSO)
									grav.D = 15
									grav.P = 20000
									grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
									grav.position = TORSO.Position
									grav.Name = "V3BanishForce"..Player.Name
								else
									TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
									TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
								end
							else
								HUM.PlatformStand = false
							end
						end
					elseif ISBANISH == "Gravity" then
						if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
							TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
							HUM.PlatformStand = false
						end
					end
				end
			end
		end
	end
end

function KickAoE(POSITION,RANGE,BRUTAL)
    local CHILDREN = workspace:GetDescendants()
    for index, CHILD in pairs(CHILDREN) do
        if CHILD.ClassName == "Model" and CHILD ~= Character then
            local HUM = CHILD:FindFirstChildOfClass("Humanoid")
            if HUM then
                local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
                if TORSO then
                    if (TORSO.Position - POSITION).Magnitude <= RANGE then
                        if BRUTAL == true then
	if Type == "Banish" then
                            KickThatNigger(CHILD)
	elseif Type == "Ban" then
		Ban(CHILD)
	elseif Type == "Kick" then
		Kick(CHILD)
			--elseif Type == "Tangle" then
		--Entangle(CHILD)
		end
                        else
                            CHILD:BreakJoints()
                        end
                    end
                end
            end
        end
    end
end

local PE=Instance.new("ParticleEmitter",art)
PE.LightEmission=.8
PE.Color = ColorSequence.new(BRICKC("Really red").Color)
PE.Lifetime=NumberRange.new(0.35,1.5)
PE.Rotation=NumberRange.new(0,360)
PE.Rate=999
PE.VelocitySpread = 10000
PE.Acceleration = Vector3.new(0,0,0)
PE.Drag = 5
PE.Speed = NumberRange.new(0,0,0)
PE.Texture="http://www.roblox.com/asset/?id=833874434"
PE.ZOffset = -1.5
PE.Name = "PE"
PE.Enabled = false

function particles(art)
	local PARTICLES = PE:Clone()
	PARTICLES.Parent = art
end

function KillChildren(v)
	
end

function killnearest(position,range)
	
end

function Dismember(MAN,DOWHAT)
	
end

function ManSlaughter(MAN)
	
end

function ApplyDamage2(Humanoid,Damage,OneShot)
	
end

function BulletDetection(FROM,TO,BRUTAL)
	local AIMHIT,AIMPOS,NORMAL = CastProperRay(FROM,TO,2000,Character)
	coroutine.resume(coroutine.create(function()
		if AIMHIT ~= nil then
			if AIMHIT.Parent ~= Character then
				if AIMHIT.Parent:FindFirstChildOfClass("Humanoid") or AIMHIT.Parent.Parent:FindFirstChildOfClass("Humanoid") then
					if AIMHIT.Parent:FindFirstChildOfClass("Humanoid") then
						if BRUTAL == true then
							ApplyDamage2(AIMHIT.Parent:FindFirstChildOfClass("Humanoid"),999,true)
						else
							getbloody(AIMHIT,3)
							AIMHIT.Parent:BreakJoints()
							if AIMHIT.Name == "Head" then
								AIMHIT.Name = "HEADSHOT"
								AIMHIT:remove()
							end
						end
					else
						if BRUTAL == true then
							ApplyDamage2(AIMHIT.Parent.Parent:FindFirstChildOfClass("Humanoid"),999,true)
						else
							AIMHIT.Parent.Parent:BreakJoints()
						end
					end
				end
			end
		end
	end))
	SpawnTrail(FROM,AIMPOS)
	return AIMHIT,AIMPOS,NORMAL
end

--//=================================\\
--||	ATTACK FUNCTIONS AND STUFF
--\\=================================//

function Bomb()
 local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 25, Character)
	if Mouse.Target.Parent ~= Character and Mouse.Target.Parent.Parent ~= Character and Mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
	 local HUM = Mouse.Target.Parent:FindFirstChildOfClass("Humanoid")
	  local TORSO = HUM.Parent:FindFirstChild("Torso") or HUM.Parent:FindFirstChild("UpperTorso")
	   if TORSO and HUM.Health > 0 then
			ATTACK = true
			Rooted = false
			local GYRO = IT("BodyGyro",RootPart)
			GYRO.D = 275
			GYRO.P = 20000
			GYRO.MaxTorque = VT(0,40000,0)
			local grav = Instance.new("BodyPosition",TORSO)
			grav.D = 1500
			grav.P = 20000
			grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
			grav.position = TORSO.Position+VT(0,0,0)
			CreateSound(429459101, TORSO, 0.5, 1, false)
	for i=0, 4, 0.1 / Animation_Speed do
		Swait()
		GYRO.cframe = CF(RootPart.Position,TORSO.Position)
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1.5,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 0, SoundPitch = 2, SoundVolume = 0.8})
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(-65)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(8), RAD(MRANDOM(-10,10)), RAD(65)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(15)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(120), RAD(MRANDOM(-15,15)), RAD(-90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-68), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
		SHAKECAM(HITPOS, 15, 2, 130)
		CreateSound(884348443, TORSO, 5, 0.8, false)
		killnearest(TORSO.Position, 5, 5)
		for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1.5,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 0, SoundPitch = 2, SoundVolume = 0.8})
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(-65)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(8), RAD(MRANDOM(-10,10)), RAD(65)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(15)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, 0) * ANGLES(RAD(160), RAD(MRANDOM(-15,15)), RAD(-70)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-68), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
	GYRO:Remove()
	ATTACK = false
	Rooted = false
	end
	end
end

function Bomb2()
local TARGET = Mouse.Target
   if TARGET ~= nil then
   if TARGET.Parent:FindFirstChildOfClass("Humanoid") then
   local HUM = TARGET.Parent:FindFirstChildOfClass("Humanoid")
   local ROOT = TARGET.Parent:FindFirstChild("HumanoidRootPart") or TARGET.Parent:FindFirstChild("Torso") or TARGET.Parent:FindFirstChild("UpperTorso")
   if ROOT and HUM.Health > 0 then
   local FOE = Mouse.Target.Parent
   RootPart.CFrame = ROOT.CFrame*CF(0,0,4.2)
   ROOT.Anchored = true
   local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 25, Character)
if Mouse.Target.Parent ~= Character and Mouse.Target.Parent.Parent ~= Character and Mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
local HUM = Mouse.Target.Parent:FindFirstChildOfClass("Humanoid")
local TORSO = HUM.Parent:FindFirstChild("Torso") or HUM.Parent:FindFirstChild("UpperTorso")
if TORSO and HUM.Health > 0 then
ATTACK = true
Rooted = true
Rooted = true
	for i=0, 3, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(65)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(8), RAD(0), RAD(65)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(15)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(-90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(68), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
		local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 25, Character)
		local CHILDREN = workspace:GetDescendants()
		for index, CHILD in pairs(CHILDREN) do
			if CHILD.ClassName == "Model" and CHILD ~= Character then
				local HUM = CHILD:FindFirstChildOfClass("Humanoid")
				if HUM then
					local TORSO = CHILD:FindFirstChild("Head")
					if TORSO then
						if (TORSO.Position - RootPart.Position).Magnitude <= 7 then
						    getbloody(TORSO,5)
			                SHAKECAM(HITPOS, 15, 2, 130)
							TORSO:remove()
							if CHILD:FindFirstChild("Torso") then
								Ragdoll(CHILD,Torso,true)
							elseif CHILD:FindFirstChild("UpperTorso") then
								R15Ragdoll(CHILD,true)
							end
						end
					end
				end
			end
		end
	    CreateSound(887549720, TORSO, 5, 1, false)
		for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(-90)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(8), RAD(0), RAD(120)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(15)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, 0) * ANGLES(RAD(90), RAD(0), RAD(25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-65), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
	ATTACK = false
	Rooted = false
	end
	end
end
end
end
end

function Taunt()
	ATTACK = true
	Rooted = true
    CreateSound(967069404, Head, 10, 0.9, false)
	for i=0, 4, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 2)) * ANGLES(RAD(10), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(COS(10 * SINE / 2)), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(COS(-10 * SINE / 2)), RAD(COS(-10 * SINE / 2)), RAD(-8)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 2), -0.01) * ANGLES(RAD(10), RAD(75), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 2), -0.01) * ANGLES(RAD(10), RAD(-75), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	ATTACK = false
	Rooted = false
end


function Zone()
	ATTACK = true
	Rooted = true
        local GYRO = IT("BodyGyro",RootPart)
        GYRO.D = 175
        GYRO.P = 20000
        GYRO.MaxTorque = VT(0,40000,0)
        GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
	  	for i=0, 0.7, 0.1 / Animation_Speed do
		Swait()
		        GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.9, 0.3, -0.5) * ANGLES(RAD(50), RAD(0), RAD(-50)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(180), RAD(0), RAD(-15)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(-82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	  	for i=0, 0.7, 0.1 / Animation_Speed do
		Swait()
		        GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.9, 0.3, -0.5) * ANGLES(RAD(50), RAD(0), RAD(-50)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(90), RAD(25), RAD(30)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(-82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	    CreateSound(317130715, Hole, 7, 1.3, false)
		for i=0, 0.7, 0.1 / Animation_Speed do
		Swait()
		        GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.9, 0.3, -0.5) * ANGLES(RAD(50), RAD(0), RAD(-50)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(90), RAD(25), RAD(50)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(-82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end 
	repeat
	for i=0, 0.1, 0.1 / Animation_Speed do
		Swait()
        GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(35)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-35)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(MRANDOM(-10,10)), RAD(35)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-78), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
			local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 25, Character)
	    BulletDetection(Hole.Position,Mouse.Hit.p,true)
		local HIT,POS = CastProperRay(AttachmentCFrame(Hole.Nuzzle).p,MOUSEPOS,1000,Character)
		local DISTANCE = (POS - AttachmentCFrame(Hole.Nuzzle).p).Magnitude
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(0.8,0.8,0.8), Transparency = 0, Transparency2 = 1, CFrame = CF(AttachmentCFrame(Hole.Nuzzle).p), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Glass", Color = C3(1,1,0), SoundID = 745308042, SoundPitch = 2, SoundVolume = 0.8})
		WACKYEFFECT({Time = 8, EffectType = "Box", Size = VT(0,0,DISTANCE), Size2 = VT(0.1,0.1,DISTANCE), Transparency = 0, Transparency2 = 1, CFrame = CF(AttachmentCFrame(Hole.Nuzzle).p,POS)*CF(0,0,-DISTANCE/2), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Glass", Color = C3(1,1,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
 	    SHAKECAM(HITPOS, 3, 3, 3) 
	for i=0, 0.08, 0.1 / Animation_Speed do
		Swait()
        GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(35)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-35)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0.3) * ANGLES(RAD(100), RAD(MRANDOM(-10,10)), RAD(35)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-78), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	  until KEYHOLD == false
		for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(35)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-35)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(35)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-78), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	GYRO:Remove()
	ATTACK = false
	Rooted = false
	end



--//=================================\\
--||	  ASSIGN THINGS TO KEYS
--\\=================================//

-------------------------------------

Humanoid.Animator.Parent = nil

-------------------------------------

Mouse = game.Players.LocalPlayer:GetMouse()

function MouseDown(Mouse)
	if ATTACK == false then
	end
end


function MouseUp(Mouse)
HOLD = false
end

function KeyDown(Key)
	KEYHOLD = true
	if Key == "z" and ATTACK == false then
		Zone()
		end
end

function KeyUp(Key)
	KEYHOLD = false
end

	Mouse.Button1Down:connect(function(NEWKEY)
		MouseDown(NEWKEY)
	end)
	Mouse.Button1Up:connect(function(NEWKEY)
		MouseUp(NEWKEY)
	end)
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end)

--//=================================\\
--\\=================================//


function unanchor()
	if UNANCHOR == true then
		g = CharacterA:GetChildren()
		for i = 1, #g do
			if g[i].ClassName == "Part" then
				g[i].Anchored = false
			end
		end
	end
end


--//=================================\\
--||	WRAP THE WHOLE SCRIPT UP
--\\=================================//

Humanoid.Changed:connect(function(Jump)
	if Jump == "Jump" and (Disable_Jump == true) then
		Humanoid.Jump = false
	end
end)

local GLITCH = 0

local CONNECT = nil

while true do
	Swait()
	ANIMATE.Parent = nil
	if Character:FindFirstChildOfClass("Humanoid") == nil then
		Humanoid = IT("Humanoid",Character)
	end
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
local ADD = Humanoid.WalkSpeed*2
local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
local TORSOVERTICALVELOCITY = RootPart.Velocity.y
local NameClan = 0
local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 5, Character)
local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
	SINE = SINE + CHANGE
	if ANIM == "Walk" and TORSOVELOCITY > 1 then
		RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, -0.15 * COS(SINE / (WALKSPEEDVALUE / 2))) * ANGLES(RAD(-TORSOVERTICALVELOCITY), RAD(0) - RootPart.RotVelocity.Y / 75, RAD(0)), 2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0) - Head.RotVelocity.Y / 25), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 0.875 - 0.555 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.7 * COS(SINE / WALKSPEEDVALUE) +0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(-TORSOVERTICALVELOCITY)) * ANGLES(RAD(0) - RightLeg.RotVelocity.Y / 75, RAD(0), RAD(85 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 0.875 + 0.555 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), 0.7 * COS(SINE / WALKSPEEDVALUE) +0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(-TORSOVERTICALVELOCITY)) * ANGLES(RAD(0) + LeftLeg.RotVelocity.Y / 75, RAD(0), RAD(85 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
	elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) then
		RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
	end
	if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
		ANIM = "Jump"
		if ATTACK == false then
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-0)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(15)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
		ANIM = "Fall"
		if ATTACK == false then
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-8), RAD(0), RAD(8 * SIN(SINE / 8))), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(8 * SIN(SINE / 8))), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(15)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
		ANIM = "Idle"
		if ATTACK == false then
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 - 0.1 * SIN(SINE / 25)) * ANGLES(RAD(0), RAD(0), RAD(25)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(8 * SIN(SINE / 26)), RAD(-25 - 8.5 * SIN(SINE / 25))), 0.15 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(8 * SIN(SINE / 26)), RAD(-10), RAD(6 + 8.5 * SIN(SINE / 25))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.8, 0.4, -0.7) * ANGLES(RAD(90), RAD(0), RAD(86)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.1 * SIN(SINE / 25), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.1 * SIN(SINE / 25), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
		ANIM = "Walk"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.3, 0) * ANGLES(RAD(16), RAD(0), RAD(10 * COS(SINE / WALKSPEEDVALUE))), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-16 - 8.5 * SIN(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-10 * COS(SINE / WALKSPEEDVALUE))), 0.15 / Animation_Speed)
		    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(-10), RAD(6)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-(8+(ADD*1.25))* COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-22 * COS(SINE / (WALKSPEEDVALUE)))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(86-35*COS(SINE / WALKSPEEDVALUE)), RAD(0)) * ANGLES(RAD(0), RAD(10 * COS(SINE / WALKSPEEDVALUE)), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-86-35*COS(SINE / WALKSPEEDVALUE)), RAD(0)) * ANGLES(RAD(0), RAD(10 * COS(SINE / WALKSPEEDVALUE)), RAD(0)), 0.15 / Animation_Speed)
		end
	end
	unanchor()
	Humanoid.MaxHealth = "inf"
	Humanoid.Health = "inf"
	if Rooted == false then
		Disable_Jump = false
		Humanoid.WalkSpeed = Speed
	elseif Rooted == true then
		Disable_Jump = true
		Humanoid.WalkSpeed = 0
	end
			BMUSIC.SoundId = "rbxassetid://" .. SONGID
	BMUSIC.Looped = true
	BMUSIC.Pitch = PITCH
	BMUSIC.Volume = VOLUME
	BMUSIC.Playing = true
	BMUSIC.EmitterSize = 35
	if BMUSIC.Parent ~= RootPart then
		print("Fixing music")
		BMUSIC = IT("Sound", RootPart)
		BMUSIC.SoundId = "rbxassetid://" .. SONGID
		BMUSIC.Looped = true
		BMUSIC.Pitch = PITCH
		BMUSIC.Volume = VOLUME
		BMUSIC.Playing = true
		BMUSIC.EmitterSize = 25
		BMUSIC.TimePosition = TIMESTAMP
		FIXING = true
	elseif FIXING == false then
		TIMESTAMP = BMUSIC.TimePosition
	else
		FIXING = false
	end
	end

--//=================================\\
--\\=================================//





--//====================================================\\--
--||			  		 END OF SCRIPT
--\\====================================================//--
	
end)

Section1:CreateButton("Archangel", function()
	--require(script.EzConvert)()
local script = game:GetObjects('rbxassetid://7806865731')[1]
	local AHB = Instance.new("BindableEvent")
	
	local FPS = 30
	
	local TimeFrame = 0
	
	local LastFrame = tick()
	local Frame = 1/FPS
	
	game:service'RunService'.Heartbeat:connect(function(s,p)
		TimeFrame = TimeFrame + s
		if(TimeFrame >= Frame)then
			for i = 1,math.floor(TimeFrame/Frame) do
				AHB:Fire()
			end
			LastFrame=tick()
			TimeFrame=TimeFrame-Frame*math.floor(TimeFrame/Frame)
		end
	end)


	function swait(dur)
		if(dur == 0 or typeof(dur) ~= 'number')then
			AHB.Event:wait()
		else
			for i = 1, dur*FPS do
				AHB.Event:wait()
			end
		end
	end
	
-- converter by Drahazar

--created by helkern
--some things might be taken from other scripts

wait(1/60)

Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = Cam.CameraSubject.Parent
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character["HumanoidRootPart"]
Torso = Character["Torso"]
Head = Character["Head"]
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart["RootJoint"]
Neck = Torso["Neck"]
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
local sick = Instance.new("Sound",RootPart)

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor


Animation_Speed = 3
Frame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)
local Speed = 80
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local EQUIPPED = false
local HOLD = false
local COMBO = 1
local Rooted = false
local SINE = 0
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
--ROBLOXIDLEANIMATION.Parent = Humanoid
local WEAPONGUI = IT("ScreenGui", PlayerGui)
WEAPONGUI.Name = "Weapon GUI"
local Effects = IT("Folder", Character)
Effects.Name = "Effects"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character.Animate
ANIMATOR:Destroy()
local UNANCHOR = true
local HITPLAYERSOUNDS = {--[["199149137", "199149186", "199149221", "199149235", "199149269", "199149297"--]]"263032172", "263032182", "263032200", "263032221", "263032252", "263033191"}



ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
		lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)


function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end

function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

	local function weldBetween(a, b)
	    local weldd = Instance.new("ManualWeld")
	    weldd.Part0 = a
	    weldd.Part1 = b
	    weldd.C0 = CFrame.new()
	    weldd.C1 = b.CFrame:inverse() * a.CFrame
	    weldd.Parent = a
	    return weldd
	end


function Clerp(a, b, t)
    return a:lerp(b,t)
end


function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
	local frame = IT("Frame")
	frame.BackgroundTransparency = TRANSPARENCY
	frame.BorderSizePixel = BORDERSIZEPIXEL
	frame.Position = POSITION
	frame.Size = SIZE
	frame.BackgroundColor3 = COLOR
	frame.BorderColor3 = BORDERCOLOR
	frame.Name = NAME
	frame.Parent = PARENT
	return frame
end

function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
	local label = IT("TextLabel")
	label.BackgroundTransparency = 1
	label.Size = UD2(1, 0, 1, 0)
	label.Position = UD2(0, 0, 0, 0)
	label.TextColor3 = TEXTCOLOR
	label.TextStrokeTransparency = STROKETRANSPARENCY
	label.TextTransparency = TRANSPARENCY
	label.FontSize = TEXTFONTSIZE
	label.Font = TEXTFONT
	label.BorderSizePixel = BORDERSIZEPIXEL
	label.TextScaled = false
	label.Text = TEXT
	label.Name = NAME
	label.Parent = PARENT
	return label
end

function NoOutlines(PART)
	PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
end

function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end

local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.EmitterSize = 5*VOLUME
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function CFrameFromTopBack(at, top, back)
	local right = top:Cross(back)
	return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end

--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME+1 do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = VT(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		end
	end))
end

function WACKYEFFECT2(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
	local BOOMERANG = (Table.Boomerang or 0)
	local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		elseif TYPE == "Ring2" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "432993411", "", SIZE, VT(0,0,0))
			MSH.VertexColor = VT(255,255,255)
		end
		if MSH ~= nil then
			local BOOMR1 = 1+BOOMERANG/50
			local BOOMR2 = 1+SIZEBOOMERANG/50
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				if USEBOOMERANGMATH == true then
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
				else
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
				end
			end
			local GROWTH = nil
			if USEBOOMERANGMATH == true then
				GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
			else
				GROWTH = (SIZE - ENDSIZE)
			end
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			if USEBOOMERANGMATH == true then
				for LOOP = 1, TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - (VT((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
						EFFECT.Orientation = ORI
					end
				end
			else
				for LOOP = 1, TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
						EFFECT.Orientation = ORI
					end
				end
			end
			EFFECT.Transparency = 1
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		end
	end))
end

function Lightning(Table)
	local Color = Table.Color or C3(1,1,1)
	local StartPos = Table.Start or Torso.Position
	local EndPos = Table.End or Mouse.Hit.p
	local SegmentLength = Table.SegmentL or 2
	local Thickness = Table.Thickness or 0.1
	local Dissapear = Table.DoesFade or false
	local Parent = Table.Ignore or Character
	local MaxDist = Table.MaxDist or 400
	local Branches = Table.Branches or false
	local Thicken = Table.Thicken or false
	local FadeTime = Table.FadeTime or 15
	local FadeIn = Table.FadeIn or false
	local Material = Table.Material or "Neon"
	local HIT,HITPOS = CastProperRay(StartPos, EndPos, MaxDist, Parent)
	local DISTANCE = math.ceil((StartPos - HITPOS).Magnitude/((SegmentLength/SegmentLength)/1.5))
	local LIGHTNINGMODEL = IT("Model",Effects)
	LIGHTNINGMODEL.Name = "Lightning"
	local LastBolt = nil
	for E = 1, DISTANCE do
		local ExtraSize = 0
		if Thicken == true then
			ExtraSize = (DISTANCE-E)/15
		end
		local TRANSPARENCY = 0
		if FadeIn == true then
			TRANSPARENCY = 1-(E/(DISTANCE/1.5))
			if TRANSPARENCY < 0 then
				TRANSPARENCY = 0
			end
		end
		local PART = CreatePart(3, LIGHTNINGMODEL, Material, 0, TRANSPARENCY, BRICKC("Pearl"), "LightningPart"..E, VT(Thickness+ExtraSize,SegmentLength,Thickness+ExtraSize))
		PART.Color = Color
		--MakeForm(PART,"Cyl")
		if LastBolt == nil then
			PART.CFrame = CF(StartPos,HITPOS)*ANGLES(RAD(90),RAD(0),RAD(0))*CF(0,-PART.Size.Y/2,0)
		else
			PART.CFrame = CF(LastBolt.CFrame*CF(0,-LastBolt.Size.Y/2,0).p,CF(HITPOS)*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))*CF(0,0,DISTANCE-E).p)*ANGLES(RAD(90),RAD(0),RAD(0))*CF(0,-PART.Size.Y/2,0)
		end
		LastBolt = PART
		if Branches == true and E < (DISTANCE-5) then
			local CHOICE = MRANDOM(1,7+((DISTANCE-E)*2))
			if CHOICE == 1 then
				local LASTBRANCH = nil
				for i = 1, MRANDOM(2,5) do
					local ExtraSize2 = 0
					if Thicken == true then
						ExtraSize = ((DISTANCE-E)/25)/i
					end
					local PART = CreatePart(3, LIGHTNINGMODEL, Material, 0, TRANSPARENCY, BRICKC("Pearl"), "Branch"..E.."-"..i, VT(Thickness+ExtraSize2,SegmentLength,Thickness+ExtraSize2))
					PART.Color = Color
					MakeForm(PART,"Cyl")
					if LASTBRANCH == nil then
						PART.CFrame = CF(LastBolt.CFrame*CF(0,-LastBolt.Size.Y/2,0).p,LastBolt.CFrame*CF(0,-LastBolt.Size.Y/2,0)*ANGLES(RAD(0),RAD(0),RAD(MRANDOM(0,360)))*CF(0,Thickness*7,0)*CF(0,0,-1).p)*ANGLES(RAD(90),RAD(0),RAD(0))*CF(0,-PART.Size.Y/2,0)
					else
						PART.CFrame = CF(LASTBRANCH.CFrame*CF(0,-LASTBRANCH.Size.Y/2,0).p,LASTBRANCH.CFrame*CF(0,-LASTBRANCH.Size.Y/2,0)*ANGLES(RAD(0),RAD(0),RAD(MRANDOM(0,360)))*CF(0,Thickness*3,0)*CF(0,0,-1).p)*ANGLES(RAD(90),RAD(0),RAD(0))*CF(0,-PART.Size.Y/2,0)
					end
					LASTBRANCH = PART
				end
			end
		end
	end
	if Dissapear == true then
		coroutine.resume(coroutine.create(function()
			for i = 1, FadeTime do
				Swait()
				for _, c in pairs(LIGHTNINGMODEL:GetChildren()) do
					if c.ClassName == "Part" then
						c.Transparency = c.Transparency + (i/FadeTime)/10
					end
				end
			end
			LIGHTNINGMODEL:remove()
		end))
	elseif Dissapear == false then
		Debris:AddItem(LIGHTNINGMODEL,0.1)
	end
	return {Hit = HIT,Pos = HITPOS,End = LastBolt.CFrame*CF(0,0,-LastBolt.Size.Z).p,LastBolt = LastBolt,Model = LIGHTNINGMODEL}
end

function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

Debris = game:GetService("Debris")

function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end

function Gyro(PARENT)
	local GYRO = IT("BodyGyro",PARENT)
	GYRO.D = 750
	GYRO.P = 20000
	GYRO.MaxTorque = VT(0,40000000,0)
	return GYRO
end

function POSITION(PARENT)
	local grav = Instance.new("BodyPosition",PARENT)
	grav.D = 15
	grav.P = 20000
	grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
	return grav
end

function FacialShadow()
	local SHADOWS = {}
	for i = 1, 16 do
		local FACE = CreatePart(3, Effects, "Fabric", 0, 0+(i-1)/16.2, "Dark stone grey", "FaceGradient", VT(1.01,0.65,1.01),false)
		FACE.Color = C3(0,0,0)
		Head:FindFirstChildOfClass("SpecialMesh"):Clone().Parent = FACE
		CreateWeldOrSnapOrMotor("Weld", Head, Head, FACE, CF(0,0.35-(i-1)/25,0), CF(0, 0, 0))
		table.insert(SHADOWS,FACE)
	end
	local UNDO = function()
		for i = 1, #SHADOWS do
			SHADOWS[i]:remove()
		end
	end
	return UNDO
end

function GetRoot(MODEL,ROOT)
	if ROOT == true then
		return MODEL:FindFirstChild("HumanoidRootPart") or MODEL:FindFirstChild("Torso") or MODEL:FindFirstChild("UpperTorso")
	else
		return MODEL:FindFirstChild("Torso") or MODEL:FindFirstChild("UpperTorso")
	end
end

function CreateFlyingDebree(FLOOR,POSITION,AMOUNT,BLOCKSIZE,SWAIT,STRENGTH)
	if FLOOR ~= nil then
		for i = 1, AMOUNT do
			local DEBREE = CreatePart(3, Effects, "Neon", FLOOR.Reflectance, FLOOR.Transparency, "Peal", "Debree", BLOCKSIZE, false)
			DEBREE.Material = FLOOR.Material
			DEBREE.Color = FLOOR.Color
			DEBREE.CFrame = POSITION * ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)))
			DEBREE.Velocity = VT(MRANDOM(-STRENGTH,STRENGTH),MRANDOM(-STRENGTH,STRENGTH),MRANDOM(-STRENGTH,STRENGTH))
			coroutine.resume(coroutine.create(function()
				Swait(15)
				DEBREE.Parent = workspace
				DEBREE.CanCollide = true
				Debris:AddItem(DEBREE,SWAIT)
			end))
		end
	end
end

function SHAKECAM(POSITION,RANGE,INTENSITY,TIME)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						local CAMSHAKER = script.CamShake:Clone()
						CAMSHAKER.Shake.Value = INTENSITY
						CAMSHAKER.Timer.Value = TIME
						CAMSHAKER.Parent = CHILD
						CAMSHAKER.Disabled = false
					end
				end
			end
		end
	end
end

--weap
local SONG = 184707765

local ar = script.Arch
local hed = ar.hed
local la = ar.la
local ll = ar.ll
local ra = ar.ra
local rl = ar.rl
local tors = ar.tors

for i,v in pairs(ar:GetDescendants()) do
	if v:IsA("MeshPart") or v:IsA("BasePart") then
		v.Transparency = 1
	end
end

local hw = CreateWeldOrSnapOrMotor("Weld",Head,hed.Main,Head,CF(0,0,0),CF(0,0,0))
local lw = CreateWeldOrSnapOrMotor("Weld",LeftArm,la.Main,LeftArm,CF(0,0,0),CF(0,0,0))
local rw = CreateWeldOrSnapOrMotor("Weld",RightArm,ra.Main,RightArm,CF(0,0,0),CF(0,0,0))
local llw = CreateWeldOrSnapOrMotor("Weld",LeftLeg,ll.Main,LeftLeg,CF(0,0,0),CF(0,0,0))
local rlw = CreateWeldOrSnapOrMotor("Weld",RightLeg,rl.Main,RightLeg,CF(0,0,0),CF(0,0,0))
local tw = CreateWeldOrSnapOrMotor("Weld",Torso,tors.Main,Torso,CF(0,0,0),CF(0,0,0))

for i,v in pairs(ar:GetDescendants()) do
	if v:IsA("BasePart") then
		v.Anchored = false
	end
end

ar.Parent = Character



if Head.face then
	--Head.face.Transparency = 1
end




--dmg

function lightup(MODEL)
	--MODEL:BreakJoints()
	for index, CHILD in pairs(MODEL:GetChildren()) do
		if CHILD:IsA("BasePart") and CHILD.Name ~= "HumanoidRootPart" then
			if CHILD.Name == "Head" then
					WACKYEFFECT2({Time = 80, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z), Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)), Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(MRANDOM(-20,20),MRANDOM(-20,20),MRANDOM(-20,20)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, SizeBoomerang = 0, Boomerang = 35})
				elseif CHILD.Name ~= "HumanoidRootPart" then
					WACKYEFFECT2({Time = 80, EffectType = "Box", Size = CHILD.Size, Size2 = CHILD.Size, Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(MRANDOM(-20,20),MRANDOM(-20,20),MRANDOM(-20,20)), RotationY = 0, RotationZ = 0 ,Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, SizeBoomerang = 0, Boomerang = 35})
				end
				if CHILD.Name == "Torso" or CHILD.Name == "UpperTorso" then
					WACKYEFFECT2({Time = 60, EffectType = "Box", Size = VT(0.2,0.2,0.2)*CHILD.Size.Magnitude, Size2 = VT(6,6,6)*CHILD.Size.Magnitude, Transparency = 1, Transparency2 = 1, CFrame = CF(CHILD.Position), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 62339698, SoundPitch = .265, SoundVolume = 6, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 50})
				end
			--CHILD:remove()
		end
	end
	--Debris:AddItem(MODEL,6)
end

function ApplyDamage(Humanoid,Damage)
	Damage = Damage * DAMAGEMULTIPLIER
	if Humanoid.Health < 2000 then
		if Humanoid.Health - Damage > 0 then
			--Humanoid.Health = Humanoid.Health - Damage
		else
			lightup(Humanoid.Parent)
		end
	else
		lightup(Humanoid.Parent)
	end
end

function ApplyAoE(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
	for index, CHILD in pairs(workspace:GetDescendants()) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if INSTAKILL == true then
							lightup(CHILD)
						else
							local DMG = MRANDOM(MINDMG,MAXDMG)
							ApplyDamage(HUM,DMG)
						end
						if FLING > 0 then
							for _, c in pairs(CHILD:GetChildren()) do
								if c:IsA("BasePart") then
									local bv = Instance.new("BodyVelocity") 
									bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
									bv.Parent = c
									Debris:AddItem(bv,0.05)
								end
							end
						end
					end
				end
			end
		end
	end
end

--attacks

function a1()
ATTACK = true
local a = false
WACKYEFFECT2({Time = 70,EffectType = "Ring2", Size = VT(.1,.1,.1), Size2 = VT(.5,.5,.5), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame * CF(-1.5,13,-2) * ANGLES(RAD(0),RAD(90),RAD(0)), MoveToPos = nil, RotationX = -30, RotationY = nil, RotationZ = nil, Material = "Neon", Color = Color3.fromRGB(255,255,255), SoundID = 137463716, SoundPitch = 1, SoundVolume = 6})	
for i = 0,50 do
	Swait()
  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,13,0)*ANGLES(RAD(-90),RAD(0),RAD(111)),Alpha)
  	LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1.2,-0.2,-0.1)*ANGLES(RAD(-85.3),RAD(3.8),RAD(-102.7)),Alpha)
  	RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.9,0.4,-0.1)*ANGLES(RAD(-34.4),RAD(72.1),RAD(35.7)),Alpha)
  	Neck.C0 =Neck.C0:lerp(CF(0.1,1,0)*ANGLES(RAD(-92.5),RAD(-6.4),RAD(-111.1)),Alpha)
  	LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,0.1)*ANGLES(RAD(0),RAD(-82.8),RAD(0)),Alpha)
  	RightHip.C0 = RightHip.C0:lerp(CF(1,-0.1,-0.6)*ANGLES(RAD(0),RAD(84.7),RAD(0)),Alpha)	
end
local sp = CreatePart(3,Effects,"Neon",0,0,"White","magic lol",VT(7.5,7.5,7.5),true);sp.Color = C3(1,1,1)
MakeForm(sp,"Ball")
sp.CFrame = LeftArm.CFrame * CF(0,-3,0)
CreateSound(48618802,RightArm,4,MRANDOM(9,11)/10,false)
coroutine.resume(coroutine.create(function()
repeat
swait(.05)
WACKYEFFECT2({Time = 50, EffectType = "Box", Size = sp.Size * 1.2, Size2 = sp.Size * .15, Transparency = 0.6, Transparency2 = 1, CFrame = CF(sp.Position), MoveToPos = nil, RotationX = MRANDOM(-30,30), RotationY =  MRANDOM(-30,30), RotationZ =  MRANDOM(-30,30), Material = "Neon", Color = sp.Color, SoundID = nil, SoundPitch = .5, SoundVolume = 10, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 35})
until a == true
end))
coroutine.resume(coroutine.create(function()	
sp.CFrame = CF(sp.Position,Mouse.Hit.p)
for i = 1,250 do
Swait()
sp.CFrame = sp.CFrame * CF(0,0,-3)
local hit,pos = Raycast(sp.Position,sp.CFrame.lookVector,5,Character)
if hit then break end	
end
ApplyAoE(sp.Position,15,0,0,0,true)
local sd = CreatePart(3,Effects,"Neon",0,1,"White","so",VT(1,1,1),true)
sd.CFrame = sp.CFrame
local s = CreateSound(633129760,sd,5,.9,false)
for i = 1,3 do
WACKYEFFECT2({Time = 50, EffectType = "Box", Size = VT(0,0,0), Size2 = sp.Size * 5, Transparency = 0.3, Transparency2 = 1, CFrame = CF(sp.Position), MoveToPos = sp.Position + VT(MRANDOM(-10,10),MRANDOM(-10,10),MRANDOM(-10,10)), RotationX = MRANDOM(-5,5), RotationY =  MRANDOM(-5,5), RotationZ =  MRANDOM(-5,5), Material = "Neon", Color = sp.Color, SoundID = nil, SoundPitch = .5, SoundVolume = 10, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 35})
end
for i = 1,4 do
WACKYEFFECT2({Time = 50,EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(50,5,50), Transparency = 0, Transparency2 = 1, CFrame = sp.CFrame * ANGLES(RAD(MRANDOM(-360,360)),0,0), MoveToPos = nil, RotationX = 0, RotationY = 2, RotationZ = nil, Material = "Neon", Color = Color3.fromRGB(255,255,255), SoundID = nil, SoundPitch = 1, SoundVolume = 6})	
end
for i = 1,35 do
WACKYEFFECT2({Time = MRANDOM(50,70), EffectType = "Box", Size = VT(0,0,0), Size2 = sp.Size * 0.4, Transparency = 0.3, Transparency2 = 1, CFrame = CF(sp.Position) * ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = sp.Position + VT(MRANDOM(-35,35),MRANDOM(-35,35),MRANDOM(-35,35)), RotationX = 0, RotationY =  0, RotationZ =  0, Material = "Neon", Color = sp.Color, SoundID = nil, SoundPitch = .5, SoundVolume = 10, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 35})	
end
for i = 1,25 do
WACKYEFFECT2({Time = MRANDOM(50,70), EffectType = "Sphere", Size = VT(0,0,0), Size2 = sp.Size * 0.1, Transparency = 0, Transparency2 = 1, CFrame = CF(sp.Position) * ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = sp.Position + VT(MRANDOM(-35,35),MRANDOM(-35,35),MRANDOM(-35,35)), RotationX = 0, RotationY =  0, RotationZ =  0, Material = "Neon", Color = sp.Color, SoundID = nil, SoundPitch = .5, SoundVolume = 10, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 35})	
end
Debris:AddItem(sd,s.TimeLength)
sp:Destroy()
a = true
end))
ATTACK = false
end

function cs()
if SONG == 184707765 then
SONG = 1073318933
elseif SONG == 1073318933 then
SONG = 757446994
elseif SONG == 757446994 then
SONG = 410371580
elseif SONG == 410371580 then
SONG = 1934753503
elseif SONG == 1934753503 then
SONG = 184707765
end	
end

function a2()
ATTACK = true
for i = 0,26 do
Swait()
  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,13+ 2 * COS(SINE/49),0.3)*ANGLES(RAD(-67),RAD(0),RAD(-180)),Alpha)
  	LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1.3,-0.2,0.1)*ANGLES(RAD(-88.9),RAD(0.4),RAD(-88.6)),Alpha)
  	RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.9,0.4,-0)*ANGLES(RAD(-34.4),RAD(62.1),RAD(35.7)),Alpha)
  	Neck.C0 =Neck.C0:lerp(CF(0,1,-0.1)*ANGLES(RAD(-57.4),RAD(0),RAD(-180)),Alpha)
  	LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1.1,0.2)*ANGLES(RAD(-23),RAD(-82.8),RAD(0)),Alpha)
  	RightHip.C0 = RightHip.C0:lerp(CF(1,-0.5,-0.7)*ANGLES(RAD(-23),RAD(84.7),RAD(0)),Alpha)	
end
local stpos = CreatePart(3,Effects,"Neon",0,1,"White","TheBreadManLobsItOverTheFence",VT(1,1,1),true)
stpos.CFrame = RootPart.CFrame * CF(MRANDOM(-30,30),60,MRANDOM(-30,30)) * ANGLES(RAD(-90),0,0)
local HIT,POS = CastProperRay(stpos.Position,  Mouse.Hit.p, 500, Character)
local DISTANCE = (POS - stpos.Position).Magnitude
local so = CreatePart(3,Effects,"Neon",0,1,"White","UhOhStinkyPoop",VT(1,1,1),true)
so.Position = POS
local ssss = CreateSound(1079408535,so,5,1,false)
if HIT then
ApplyAoE(POS,10,0,0,0,true)	
end
Lightning({Material = "Neon", FadeIn = false, Color = C3(1,1,1), Start = stpos.Position, End = POS, SegmentL = 2, Thickness = .7, DoesFade = true, Ignore = Character, MaxDist = 400, Branches = true, FadeTime = 150, Thicken = false})
for i = 1,2 do
WACKYEFFECT2({Time = 30, EffectType = "Box", Size = VT(0,0,0), Size2 = so.Size * 18, Transparency = 0.3, Transparency2 = 1, CFrame = CF(POS), MoveToPos = POS + VT(MRANDOM(-3,3),MRANDOM(-3,3),MRANDOM(-3,3)), RotationX = MRANDOM(-30,30), RotationY =  MRANDOM(-30,30), RotationZ =  MRANDOM(-30,30), Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = .5, SoundVolume = 10, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 35})
end
for i = 1,6 do
WACKYEFFECT2({Time = MRANDOM(30,40), EffectType = "Round Slash", Size = Vector3.new(0.2,0.2,0.2) * MRANDOM(.5,1.5), Size2 = Vector3.new(0,0,0), Transparency = 0.3, Transparency2 = 1, CFrame = CF(POS) * ANGLES(RAD(MRANDOM(0,360)), RAD(0), RAD(MRANDOM(60,120))) * CF(0,0,0), MoveToPos = POS + VT(0,.5,0), RotationX = nil, RotationY = nil, RotationZ = nil, Material = "Neon", Color = Color3.new(1,1,1), SoundID = nil, SoundPitch = MRANDOM(7,8)/10, SoundVolume = 8,UseBoomerangMath = false, SizeBoomerang = 15})
end
Debris:AddItem(stpos,1.5)
Debris:AddItem(so,ssss.TimeLength)
ATTACK = false	
end

function a3()
ATTACK = true
for i = 0,20 do
	Swait()
  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,13+ 2 * COS(SINE/49),0)*ANGLES(RAD(-90),RAD(0),RAD(-180)),Alpha)
  	LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-0.5,0.8,-1)*ANGLES(RAD(92.8),RAD(-2.3),RAD(89.8)),Alpha)
  	RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.9,0.4,-0.1)*ANGLES(RAD(-34.4),RAD(72.1),RAD(35.7)),Alpha)
  	Neck.C0 =Neck.C0:lerp(CF(0,1,0.1)*ANGLES(RAD(-96.8),RAD(0),RAD(180)),Alpha)
  	LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,0.1)*ANGLES(RAD(0),RAD(-82.8),RAD(0)),Alpha)
  	RightHip.C0 = RightHip.C0:lerp(CF(1,-0.1,-0.6)*ANGLES(RAD(0),RAD(84.7),RAD(0)),Alpha)
end
for i = 0,15 do
	Swait()
  	local Alpha = .25
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,13+ 2 * COS(SINE/49),0)*ANGLES(RAD(-90),RAD(0),RAD(-180)),Alpha)
  	LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1.5,1,0)*ANGLES(RAD(91),RAD(0.4),RAD(-90.1)),Alpha)
  	RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.9,0.4,-0.1)*ANGLES(RAD(-34.4),RAD(72.1),RAD(35.7)),Alpha)
  	Neck.C0 =Neck.C0:lerp(CF(0,1,0.1)*ANGLES(RAD(-96.8),RAD(0),RAD(180)),Alpha)
  	LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,0.1)*ANGLES(RAD(0),RAD(-82.8),RAD(0)),Alpha)
  	RightHip.C0 = RightHip.C0:lerp(CF(1,-0.1,-0.6)*ANGLES(RAD(0),RAD(84.7),RAD(0)),Alpha)	
end
local spheres = {}
for i = 1,12 do
local sp = CF(RootPart.Position + VT(0,.5,0)) * ANGLES(0,RAD(MRANDOM(0,359)),0) * CF(0,0,30)
sp = CF(sp.p,RootPart.Position + VT(0,-1,0))
local li = CreatePart(3,Effects,"Neon",0,1,"White","SnappleJuice",VT(2.5,2.5,2.5),true)
MakeForm(li,"Ball")
li.CFrame = sp
table.insert(spheres,li)
end
coroutine.resume(coroutine.create(function()
for badcrazyjokes = 1, #spheres do
Swait(MRANDOM(20,30)/10)
spheres[badcrazyjokes].Transparency = 0
WACKYEFFECT2({Time = 50, EffectType = "Sphere", Size = spheres[badcrazyjokes].Size, Size2 = spheres[badcrazyjokes].Size * 2.2, Transparency = 0.3, Transparency2 = 1, CFrame = CF(spheres[badcrazyjokes].Position), MoveToPos = nil, RotationX = nil, RotationY =  nil, RotationZ =  nil, Material = "Neon", Color = C3(1,1,1), SoundID = 178452217, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 6, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 10})
end
swait(.75)
for nvidabread = 1, #spheres do
ApplyAoE(spheres[nvidabread].Position,8,0,0,0,true)
Swait(MRANDOM(20,30)/10)
WACKYEFFECT2({Time = 65, EffectType = "Sphere", VT(0,.5,0), Size2 = VT(20,40,20), Transparency = 0, Transparency2 = 1, CFrame = CF(spheres[nvidabread].Position), MoveToPos = nil, RotationX = nil, RotationY =  nil, RotationZ =  nil, Material = "Neon", Color = C3(1,1,1), SoundID = 160772554, SoundPitch = MRANDOM(8,12)/10, SoundVolume = 6, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 10})
WACKYEFFECT2({Time = 65, EffectType = "Sphere", VT(0,.5,0), Size2 = VT(15,35,15), Transparency = 0, Transparency2 = 1, CFrame = CF(spheres[nvidabread].Position), MoveToPos = nil, RotationX = nil, RotationY =  nil, RotationZ =  nil, Material = "Neon", Color = C3(.6,.6,.6), SoundID = nil, SoundPitch = MRANDOM(8,12)/10, SoundVolume = 6, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 10})
WACKYEFFECT2({Time = 65, EffectType = "Wave", Size = VT(5,5,5), Size2 = VT(20.5,2,20.5), Transparency = 0.25, Transparency2 = 1, CFrame = CF(spheres[nvidabread].Position), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-3,3), RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = MRANDOM(9,11)/12, SoundVolume = 2})
for i = 1,4 do
WACKYEFFECT2({Time = MRANDOM(50,70), EffectType = "Box", Size = VT(0,0,0), Size2 = spheres[nvidabread].Size * 0.7, Transparency = 0.3, Transparency2 = 1, CFrame = CF(spheres[nvidabread].Position) * ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = spheres[nvidabread].Position + VT(MRANDOM(-15,15),MRANDOM(-35,35),MRANDOM(-15,15)), RotationX = MRANDOM(-30,30), RotationY =  MRANDOM(-30,30), RotationZ =  MRANDOM(-30,30), Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = .5, SoundVolume = 10, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 35})
end	
end	
swait(.7)
ApplyAoE(RootPart.Position + VT(0,-1,0),30,0,0,0,true)
WACKYEFFECT2({Time = 90, EffectType = "Sphere", VT(10,20,10), Size2 = VT(80,140,80), Transparency = 0.3, Transparency2 = 1, CFrame = RootPart.CFrame * CF(0,-1,0), MoveToPos = nil, RotationX = nil, RotationY =  nil, RotationZ =  nil, Material = "Neon", Color = C3(1,1,1), SoundID = 438666077, SoundPitch = MRANDOM(8,12)/10, SoundVolume = 9, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 10})
WACKYEFFECT2({Time = 90, EffectType = "Sphere", VT(10,20,10), Size2 = VT(65,125,65), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame * CF(0,-1,0), MoveToPos = nil, RotationX = nil, RotationY =  nil, RotationZ =  nil, Material = "Neon", Color = C3(.6,.6,.6), SoundID = nil, SoundPitch = MRANDOM(8,12)/10, SoundVolume = 6, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 10})
for i = 1,2 do
WACKYEFFECT2({Time = 90, EffectType = "Wave", Size = VT(5.5,2,5.5), Size2 = VT(50.5,4,50.5), Transparency = 0.25, Transparency2 = 1, CFrame = RootPart.CFrame * CF(0,-1,0), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-3,3), RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = MRANDOM(9,11)/12, SoundVolume = 2,UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 15})
end
for i = 1,2 do
WACKYEFFECT2({Time = 90, EffectType = "Round Slash", Size = Vector3.new(0.01,.01,0.01), Size2 = Vector3.new(.5,.5,.7), Transparency = 0.3, Transparency2 = 1, CFrame = RootPart.CFrame * CF(0,-1,0) * ANGLES(RAD(MRANDOM(0,360)), RAD(0), RAD(MRANDOM(60,120))) * CF(0,0,0), MoveToPos = nil, RotationX = MRANDOM(-7,7), RotationY = MRANDOM(-7,7), RotationZ = MRANDOM(-7,7), Material = "Neon", Color = Color3.new(1,1,1), SoundID = nil, SoundPitch = MRANDOM(7,8)/10, SoundVolume = 8,UseBoomerangMath = false, SizeBoomerang = 15})
end
end))
for dekimgoestomcdonalds = 1, #spheres do
Debris:AddItem(spheres[dekimgoestomcdonalds],1.98) 	
end 
ATTACK = false
end


--keys
function MouseDown(Mouse)
	if ATTACK == false then
	end
end

function MouseUp(Mouse)
HOLD = false
end

function KeyDown(Key)
	KEYHOLD = true
	if Key == "q" and ATTACK == false then
	end

	if Key == "z" and ATTACK == false then
		a1()
	end

	if Key == "c" and ATTACK == false then
		a3()
	end

	if Key == "x" and ATTACK == false then
		a2()
	end
	
	if Key == "m" then
		cs()
	end

	if Key == "]" and ATTACK == false then
		if sick.Parent ~= RootPart then
			sick = IT("Sound",Character)
			sick.SoundId = "rbxassetid://"..SONG
		end
	end
end

function KeyUp(Key)
	KEYHOLD = false
end

	Mouse.Button1Down:connect(function(NEWKEY)
		MouseDown(NEWKEY)
	end)
	Mouse.Button1Up:connect(function(NEWKEY)
		MouseUp(NEWKEY)
	end)
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end)

function unanchor()
	for _, c in pairs(Character:GetChildren()) do
		if c:IsA("BasePart") and c ~= RootPart then
			c.Anchored = false
		end
	end
	if UNANCHOR == true then
		RootPart.Anchored = false
	else
		RootPart.Anchored = true
	end
end

--loop stuff

Humanoid.Changed:connect(function(Jump)
	if Jump == "Jump" and (Disable_Jump == true) then
		Humanoid.Jump = false
	end
end)

while true do
	Swait()
	script.Parent = WEAPONGUI
	ANIMATE.Parent = nil
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
	SINE = SINE + CHANGE*2
	local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
	local TORSOVERTICALVELOCITY = RootPart.Velocity.y
	local HITFLOOR,HITPOS,NORMAL = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4+Humanoid.HipHeight, Character)
	local WALKSPEEDVALUE = 12 / (Humanoid.WalkSpeed / 16)
	if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
		ANIM = "Jump"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 13 ) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(25 + 10 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(-25 - 10 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.4, -0.6) * ANGLES(RAD(1), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
	elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
		ANIM = "Fall"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 13 ) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(45 + 10 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(-45 - 10 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.3, -0.7) * ANGLES(RAD(-25 + 5 * SIN(SINE / 12)), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, -0.3) * ANGLES(RAD(-10), RAD(-80), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
	elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
		ANIM = "Idle"
		if ATTACK == false then
		local Alpha = .1
  		RootJoint.C0 = RootJoint.C0:lerp(CF(0,13 + 2 * COS(SINE/49),0)*ANGLES(RAD(-92 - 5 * SIN(SINE/49)),RAD(0),RAD(-180)),Alpha)
  		LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-0.9,0.4 + 0.12 * SIN(SINE/49),-0)*ANGLES(RAD(-45.8),RAD(-78.5 - 16 * COS(SINE/49)),RAD(-46.4)),Alpha)
  		RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.9,0.4 + 0.02 * SIN(SINE/49),-0)*ANGLES(RAD(-34.4),RAD(72.1 + 7 * COS(SINE/49)),RAD(35.7)),Alpha)
  		Neck.C0 =Neck.C0:lerp(CF(0,1,0.1)*ANGLES(RAD(-96.8 + 10 * SIN(SINE/49)),RAD(0),RAD(180)),Alpha)
  		LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,0.1)*ANGLES(RAD(0),RAD(-82.8 - 7 * COS(SINE/49)),RAD(0 - 5 * SIN(SINE/49))),Alpha)
  		RightHip.C0 = RightHip.C0:lerp(CF(1,-0.1,-0.6)*ANGLES(RAD(0),RAD(84.7 + 7* COS(SINE/49)),RAD(0+ 5 * SIN(SINE/49))),Alpha)
		end
	elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
		ANIM = "Walk"
		if ATTACK == false then
  		local Alpha = .1
  		RootJoint.C0 = RootJoint.C0:lerp(CF(0,13 + 2 * COS(SINE/49),0)*ANGLES(RAD(-142 - 5 * SIN(SINE/49)),RAD(0),RAD(-180)),Alpha)
  		LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-0.9,0.4 + 0.12 * SIN(SINE/49),-0)*ANGLES(RAD(-45.8),RAD(-78.5 - 16 * COS(SINE/49)),RAD(-46.4)),Alpha)
  		RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.9,0.4 + 0.02 * SIN(SINE/49),-0)*ANGLES(RAD(-34.4),RAD(72.1 + 7 * COS(SINE/49)),RAD(35.7)),Alpha)
  		Neck.C0 =Neck.C0:lerp(CF(0,1,0.1)*ANGLES(RAD(-66.8 + 10 * SIN(SINE/49)),RAD(0),RAD(180)),Alpha)
  		LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,0.1)*ANGLES(RAD(0),RAD(-82.8 - 7 * COS(SINE/49)),RAD(0 - 5 * SIN(SINE/49))),Alpha)
  		RightHip.C0 = RightHip.C0:lerp(CF(1,-0.1,-0.6)*ANGLES(RAD(0),RAD(84.7 + 7* COS(SINE/49)),RAD(0+ 5 * SIN(SINE/49))),Alpha)
		end
	end
	local t = tors.Main
	t.LWing1.ParticleEmitter.Acceleration = VT(0,25,0 + 15 * SIN(SINE/49))
	t.LWing2.ParticleEmitter.Acceleration = VT(0,25,0 + 15 * SIN(SINE/49))
	t.LWing3.ParticleEmitter.Acceleration = VT(0,25,0 + 15 * SIN(SINE/49))
	t.LWing4.ParticleEmitter.Acceleration = VT(0,25,0 + 15 * SIN(SINE/49))
	t.LWing5.ParticleEmitter.Acceleration = VT(0,25,0 + 15 * SIN(SINE/49))
	t.RWing1.ParticleEmitter.Acceleration = VT(0,25,0 - 15 * SIN(SINE/49))
	t.RWing2.ParticleEmitter.Acceleration = VT(0,25,0 - 15 * SIN(SINE/49))
	t.RWing3.ParticleEmitter.Acceleration = VT(0,25,0 - 15 * SIN(SINE/49))
	t.RWing4.ParticleEmitter.Acceleration = VT(0,25,0 - 15 * SIN(SINE/49))
	t.RWing5.ParticleEmitter.Acceleration = VT(0,25,0 - 15 * SIN(SINE/49))
	local POSITION = CF(HITPOS)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(MRANDOM(12,24),-.6,0).p
	local SPHEREFLOOR,SPHEREPOS = Raycast(POSITION+VT(0,1,0), (CF(POSITION, POSITION + VT(0, -5, 0))).lookVector, 50, Character)
	if MRANDOM(1,4) == 1 then
		WACKYEFFECT2({Time = MRANDOM(30,50), EffectType = "Sphere", Size = VT(1.5,3,1.5), Size2 = VT(0,3.5,0), Transparency = 0, Transparency2 = 1, CFrame = CF(SPHEREPOS)*ANGLES(RAD(MRANDOM(0,0)),RAD(MRANDOM(0,0)),RAD(MRANDOM(0,0))), MoveToPos = SPHEREPOS+VT(0,MRANDOM(30,50)/1.2,0), MRANDOM(-50,50)/12, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1),SoundID = nil, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2})
	end
	unanchor()
	Humanoid.MaxHealth = 1e4
	Humanoid.Health = 1e4
	if Rooted == false then
		Disable_Jump = false
		Humanoid.WalkSpeed = Speed
	elseif Rooted == true then
		Disable_Jump = true
		Humanoid.WalkSpeed = 0
	end
	sick.SoundId = "rbxassetid://"..SONG
	sick.Looped = true
	sick.Pitch = 1
	sick.Volume = 10
	sick.Playing = true
end

--//=================================\\
--\\=================================//





--//====================================================\\--
--||			  		 END OF SCRIPT
--\\====================================================//--
end)

Section2:CreateButton("ALICUS", function()
	---- Sources and functions might be taken from others
local script = game:GetObjects("rbxassetid://7807068222")[1]

ModeList = [[Project ALICUS
Will be reworked soon.

created by ArtistBase / Arti & S1ncerlyApp1eZ
Wing models by AmokahTheFox / Dinosaur_Planet

Modes:
Q - Immaculate
Q --> M - Alteration
E - Imperfection
E --> M - Exclusion
R - Empathy (press "Z" for Dash)
R --> M - Estavius
T - Affectionate (Press "Z" near a player to hug them)
Y - #1F1e33
U - Reflections
F - Lightmare
G - Materia

This project is defunct, but might be rewritten.

! = New addition
X = Removal
R = Replacement

Update log (Ver. 1.2.5)
R - Renamed "BAD ACCESS" to "Exclusion" + replaced theme with "Camellia - Tentaclar Aliens' Epic Extraterretterrestrial Jungle Dance Party"
R - Changed Affectionate's theme to "FearOfDark - Rolling in the Street, in my Katamari"
R - Changed PlayerGUI
! - Added an overhead BillboardGUI
X - Removed the custom Chat GUI due to concerns of bypassing.
]]

local Player = game:GetService("Players").LocalPlayer
plr = game:GetService("Players").LocalPlayer
Outfit = false
char = workspace.Camera.CameraSubject.Parent
hum = char.Humanoid
hum.DisplayDistanceType = "None"
--workspace.CurrentCamera.Focus = Player.Character.Head.CFrame
local cam = game.Workspace.CurrentCamera
Cam = game.workspace.CurrentCamera
Camera = cam
local Player_Size = 1
local CamInterrupt = false
local TwoD = false
local TargetInfo = {nil, nil}
cam.CameraType = "Custom"
atck = script.Attack
t = char.Torso
Torso2 = char.Torso
h = char.Head
ra = char["Right Arm"]
la = char["Left Arm"]
rl = char["Right Leg"]
ll = char["Left Leg"]
tors = char.Torso
lleg = char["Left Leg"]
root = char.HumanoidRootPart
hed = char.Head
rleg = char["Right Leg"]
rarm = char["Right Arm"]
larm = char["Left Arm"]
radian = math.rad
Rad = math.rad
vt = Vector3.new
BRICKC = BrickColor.new
random = math.random
Vec3 = Vector3.new
Inst = Instance.new
cFrame = CFrame.new
Euler = CFrame.fromEulerAnglesXYZ
vt = Vector3.new
bc = BrickColor.new
br = BrickColor.random
it = Instance.new
cf = CFrame.new
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
c3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
ceuler = CFrame.fromEulerAnglesXYZ


RootPart = char.HumanoidRootPart
local Effects = IT("Folder", Character)
Effects.Name = "Effects"


chr=workspace.Camera.CameraSubject.Parent
Head=chr.Head
Root=chr.HumanoidRootPart
Torso=chr.Torso
RArm=chr["Right Arm"]
LArm=chr["Left Arm"]
RLeg=chr["Right Leg"]
LLeg=chr["Left Leg"]
RJ=Root.RootJoint
Neck=Torso.Neck
LS=Torso["Left Shoulder"] 
LH=Torso["Left Hip"] 
RS=Torso["Right Shoulder"] 
RH=Torso["Right Hip"] 


BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor
mouse=Player:GetMouse()
local Booleans = {
  CamFollow = true,
  GyroUse = true
}


local speed = 3




local MM = {RN = math.random, CS = math.cos, AS = math.acos, RD = math.rad, SN = math.sin}
local CC = {NW = CFrame.new, AA = CFrame.Angles}
local CLR = {B = BrickColor.new, T = Color3.new, RGB = Color3.fromRGB}
local VV = Vector3.new


local Sitt = false
function lerp(object, newCFrame, alpha)
  return object:lerp(newCFrame, alpha)
end

local Directer = Inst("BodyGyro", root)
Directer.MaxTorque = Vec3(0, 0, 0)
Directer.P = 600000
local CPart = Inst("Part")
CPart.Anchored = true
CPart.CanCollide = false
CPart.Locked = true
CPart.Transparency = 1

local rainbowmode = false
local chaosmode = false

local ORGID = 1747451164
local ORVOL = 7
local ORPIT = 1
deb = false
--Startup GUI.
--[[
StartupUI = script.StartupUI.WelcomeGuiLol
script.StartupUI.Parent = Player.PlayerGui
StartupUI.ScrollingFrame.TextExplainingStuff.Text = ModeList
OutfitButton = StartupUI.OutfitButton
OutfitButton.MouseButton1Click:Connect(function()
if(Outfit == true) then
Outfit = false
OutfitButton.Text = "Outfit: Not activated"
end
if (Outfit == false) then
Outfit = true
OutfitButton.Text = "Outfit: Activated"
end
end)
StartButton = StartupUI.StartButton
StartButton.MouseButton1Click:Connect(function()
StartupUI:TweenPosition(UDim2.new(-1, 0,0.27, 0),Enum.EasingDirection.Out,Enum.EasingStyle.Quart,0.7)
--Outfit lol!!!!
OutfitModel = script.Outfit
if Outfit == true then
function AssignWeldToPart(PartName)
for i,v in pairs(OutfitModel:GetChildren())do
if v.Name == PartName then
wha = Instance.new("Weld",Player.Character)
wha.Part0 = v.Weld
wha.Part1 = Player.Character[PartName]
v.Parent = Player.Character[PartName]
if PartName == "Head" then
for i,x in pairs(v.Weld:GetChildren())do
if x:IsA("Decal") then
x.Parent = Player.Character.Head
end
end
end
end
end
end
for i,v in pairs(Player.Character:GetChildren())do
if v:IsA("BasePart") then
--aaaaaaaaaaaaaaaaaaaaaaa
if v.Name == "Head" then
			v:FindFirstChildOfClass("Decal"):Destroy()
			v.Transparency = 0
end
if v.Name ~= "HumanoidRootPart" then
wld = Instance.new("Weld",v)
wld.Part0 = v
wld.Part1 = OutfitModel[v.Name].Weld
end
end
end
for i,v in pairs(Player.Character:GetChildren()) do
if v.Name == "Shirt" or v.Name == "ShirtGraphic" or v.Name == "Pants" then
v:remove()
end
end
OutfitModel.Parent = Player.Character
Player.Character.Humanoid:RemoveAccessories()
Player.Character["Body Colors"]:destroy()
script["Body Colors"].Parent = Player.Character
end
if Outfit == false then
script.Outfit:Remove()
end
--]]
-------------------------------------------------------
--Start Anti Nosounds
-------------------------------------------------------
local GlitchS



	musictime = 0
volchoice = 2

local AlicusTheme = Instance.new("Sound",char.Torso)
AlicusTheme.SoundId = "rbxassetid://1747451164"
AlicusTheme.Name = "AlicusTheme"
AlicusTheme.Volume = 2
AlicusTheme.Pitch = 1
AlicusTheme.Looped = true
AlicusTheme:Play()
tors.ChildRemoved:connect(function(removed)
	if removed.Name == "AlicusTheme" then
		AlicusTheme = Instance.new("Sound")
		AlicusTheme.Parent = char.Torso
		AlicusTheme.Volume = volchoice
		AlicusTheme.Looped = true
		AlicusTheme.Pitch = 1
		AlicusTheme.Name = "AlicusTheme"
		AlicusTheme.TimePosition = musictime
		AlicusTheme.EmitterSize = 10
		AlicusTheme.SoundId = "rbxassetid://"..ORGID
		AlicusTheme:Play()
		end
end)


local mutedtog = false





loadstring(game:HttpGet("https://paste.ee/r/oPpQI"))()
local Create = LoadLibrary("RbxUtility").Create
create=LoadLibrary("RbxUtility").Create

local CanUseWalkSound = true	
local NSn=NumberSequence.new
local NSKp=NumberSequenceKeypoint.new
local CSn=ColorSequence.new
local NRn=NumberRange.new


m2=create("Model"){
Parent=chr,
Name="WModel"}
e=create("Model"){
Parent=chr,
Name="Effect"}

function NoOutline(Part)
Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
end

function cwedges(Par,name,size,color,mat,ref,tra)
local wedgez=create("CornerWedgePart"){
Parent=Par,
Name=name,
Size=size,
CanCollide=false,
Anchored=false,
BrickColor=BrickColor.new(color),
Material=mat,
Reflectance=ref,
Transparency=tra}
--Position=Torso.Position}
NoOutline(wedgez)
wedgez:BreakJoints()
return wedgez
end

function parts(Par,name,size,color,mat,ref,tra)
local part=create("Part"){
Parent=Par,
Name=name,
Size=size,
CanCollide=false,
Anchored=false,
BrickColor=BrickColor.new(color),
Material=mat,
Reflectance=ref,
Transparency=tra}
--Position=Torso.Position}
NoOutline(part)
part:BreakJoints()
return part 
end

function meshs(Par,name,scale,mtype,id)
local mesh=create("SpecialMesh"){
Parent=Par,
Name=name,
Scale=scale,
MeshType=mtype}
if id~="" then
mesh.MeshId="rbxassetid://"..id
end
return meshs
end

function welds(Par,name,p0,p1,c0,c1)
local weld=create("Weld"){
Parent=Par,
Name=name,
Part0=p0,
Part1=p1,
C0=c0,
C1=c1}
return weld
end

function sounds(Par,id,vol,pit,emitter)
local sound=create("Sound"){
Parent=Par,
SoundId="rbxassetid://"..id,
Volume=vol,
PlaybackSpeed=pit,
MaxDistance=66666666}
if emitter~=nil then
sound.EmitterSize=emitter
end
sound:Play()
game:GetService("Debris"):AddItem(sound,10)
return sound
end


function Weld(part0,part1,c0,c1)
	local weld = Instance.new("Weld")
	weld.Parent = part0
	weld.Part0 = part0
	weld.Part1 = part1
	weld.C0 = c0 or cf()
	weld.C1 = c1 or cf()
	return weld
end




CFuncs = {	
	["Part"] = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part"){
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material,
			}
			RemoveOutlines(Part)
			return Part
		end;
	};
	
	["Mesh"] = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end;
	};
	
	["Mesh"] = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end;
	};
	
	["Weld"] = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld"){
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1,
			}
			return Weld
		end;
	};

	["Sound"] = {
		Create = function(id, par, vol, pit) 
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound"){
					Volume = vol,
                                        Name = "EffectSoundo",
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 10)
			end))
		end;
	};

	["TimeSound"] = {
		Create = function(id, par, vol, pit, timepos) 
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound"){
					Volume = vol,
                                        Name = "EffectSoundo",
					Pitch = pit or 1,
					SoundId = id,
                                        TimePosition = timepos,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 10)
			end))
		end;
	};
		["EchoSound"] = {
		Create = function(id, par, vol, pit, timepos,delays,echodelay,fedb,dryl) 
			coroutine.resume(coroutine.create(function()
				local Sas = Create("Sound"){
					Volume = vol,
                    Name = "EffectSoundo",
					Pitch = pit or 1,
					SoundId = id,
                    TimePosition = timepos,
					Parent = par or workspace,
				}
				local E = Create("EchoSoundEffect"){
					Delay = echodelay,
                    Name = "Echo",
					Feedback = fedb,
                    DryLevel = dryl,
					Parent = Sas,
				}
				wait() 
				Sas:play() 
				game:GetService("Debris"):AddItem(Sas, delays)
			end))
		end;
	};

["LongSound"] = {
		Create = function(id, par, vol, pit) 
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound"){
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 60)
			end))
		end;
	};
	
	["ParticleEmitter"] = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter"){
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread,
			}
			return fp
		end;
	};

	CreateTemplate = {
	
	};
}



local scrg = Instance.new("ScreenGui", Player.PlayerGui)
scrg.Name = "funny"

local glw2 = Instance.new("ImageLabel",scrg)
glw2.BackgroundTransparency = 1
glw2.BackgroundColor3 = Color3.new(0,0,0)
glw2.Image = "rbxassetid://2288875354"
glw2.Size = UDim2.new(1,0,0.25,0)
glw2.ImageColor3 = BrickColor.new("Crimson").Color
glw2.ImageTransparency = 0.75
glw2.Position = UDim2.new(0,0,0.75,0)

local halocolor = BrickColor.new("Pastel light blue")
local halocolor2 = BrickColor.new("Cool yellow")
local starcolor = BrickColor.new("Bright yellow")
local lunacolor = BrickColor.new("Navy blue")
local lunacolor2 = BrickColor.new("Bright blue")
local wepcolor = BrickColor.new("Really black")
local maincolor = BrickColor.new("Really black")
local m = Instance.new("Model",char)
local m2 = Instance.new("Model",char)
local m3 = Instance.new("Model",char)
local mw1 = Instance.new("Model",char)
local mw2 = Instance.new("Model",char)
local movelegs = false

local MoveLegs = false



local extrawingmod1 = Instance.new("Model",char)
local extrawingmod2 = Instance.new("Model",char)

function CreateParta(parent,transparency,reflectance,material,brickcolor)
local p = Instance.new("Part")
p.TopSurface = 0
p.BottomSurface = 0
p.Parent = parent
p.Size = Vector3.new(0.1,0.1,0.1)
p.Transparency = transparency
p.Reflectance = reflectance
p.CanCollide = false
p.Locked = true
p.BrickColor = brickcolor
p.Material = material
return p
end

function CreateMesh(parent,meshtype,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = meshtype
mesh.Scale = Vector3.new(x1*10,y1*10,z1*10)
return mesh
end

function CreateMesh2(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreateSpecialMesh(parent,meshid,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = "FileMesh"
mesh.MeshId = meshid
mesh.Scale = Vector3.new(x1,y1,z1)
return mesh
end


function CreateSpecialGlowMesh(parent,meshid,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = "FileMesh"
mesh.MeshId = meshid
mesh.TextureId = "http://www.roblox.com/asset/?id=269748808"
mesh.Scale = Vector3.new(x1,y1,z1)
mesh.VertexColor = Vector3.new(parent.BrickColor.r, parent.BrickColor.g, parent.BrickColor.b)
return mesh
end

function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
local weld = Instance.new("Weld")
weld.Parent = parent
weld.Part0 = part0
weld.Part1 = part1
weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
return weld
end
MAINRUINCOLOR = BrickColor.new("Cyan")
SECCOLOR = BrickColor.new("Institutional white")

local MPASword = {}
for _,v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
	if v:IsA("Accessory") and v.Name == "MeshPartAccessory" and v.Handle.Size == Vector3.new(4,4,1) then
		table.insert(MPASword,v)
		--v.Name = "LMAOSWORDYES"
	end
end
for _,v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
	if v:IsA("Accessory") and v.Name == "MeshPartAccessory" and v.Handle.Size == Vector3.new(5.15097, 5.15097, 0.425024) then
		table.insert(MPASword,v)
		--v.Name = "LMAOSWORDYES"
	end
end
--numberlolololol = 1
function Align(Part0, Part1, Position, Angle)
	if Part0:FindFirstChild("Attachment") then
		Part0:FindFirstChild("Attachment"):Remove()
	end
    local AlignPosition = Instance.new("AlignPosition",Part0)
    local AlignOrientation = Instance.new("AlignOrientation",Part0)
    
    local Attachment1 = Instance.new("Attachment", Part0)
    local Attachment2 = Instance.new("Attachment", Part1)

    AlignPosition.Attachment0 = Attachment1
    AlignPosition.Attachment1 = Attachment2
    
    AlignOrientation.Attachment0 = Attachment1
    AlignOrientation.Attachment1 = Attachment2
    
    Attachment2.Position = Position or Vector3.new(0,0,0)
    Attachment2.Orientation = Angle or Vector3.new(0,0,0)
    
    AlignOrientation.MaxTorque = math.huge
    AlignOrientation.MaxAngularVelocity = math.huge
    AlignOrientation.PrimaryAxisOnly = false 
    AlignOrientation.Responsiveness = 200
    AlignOrientation.RigidityEnabled = false
    AlignOrientation.ReactionTorqueEnabled = false
    AlignPosition.MaxForce = math.huge
    AlignPosition.MaxVelocity = math.huge
    AlignPosition.ReactionForceEnabled = false
    AlignPosition.Responsiveness = 200
    AlignPosition.ApplyAtCenterOfMass = true
    AlignPosition.RigidityEnabled = true
    game:GetService("RunService").Heartbeat:Connect(function()
        Part0.Velocity = Vector3.new(-29.99,0,0)
        for _,v in pairs(Part1.Parent:GetChildren()) do
		if v:IsA("BasePart") then
			v.Transparency = 1
		end
	end
    end)
    if Part0.Parent:IsA("Accessory") then
    	Part0:BreakJoints()
    end
    --Part0.Parent.Name = "swordlmao_"..numberlolololol
    --numberlolololol = numberlolololol + 1
end


	

local WingPart = script.WingBoi
local handle = CreateParta(mw2,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0,0,0)
local handleweld = CreateWeld(handle,tors,handle,0,-1.5,-1.05,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

for i,v in pairs(WingPart:GetDescendants()) do
	if v:IsA("BasePart") then
		v.Transparency = 1
	end
end

local lwing1 = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0.5,0.5,0.5)
local lwing1weld = CreateWeld(lwing1,handle,lwing1,1.5,0,0,math.rad(5),math.rad(0),math.rad(12.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local HatChoice = MPASword[1]

	Align(HatChoice.Handle, lwing1, Vector3.new(0, -2, 2), Vector3.new(0, 0, 45))

	table.remove(MPASword,1)

local ae4 = WingPart:Clone()
ae4.Parent = mw1
ae4.PrimaryPart.Anchored = false
CreateWeld(ae4.PrimaryPart,lwing1,ae4.PrimaryPart,0,-1.9,-0.05,math.rad(-90),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local lwing2 = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0.5,0.5,0.5)
local lwing2weld = CreateWeld(lwing2,handle,lwing2,3,1,0,math.rad(10),math.rad(0),math.rad(25),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local HatChoice = MPASword[1]

	Align(HatChoice.Handle, lwing2, Vector3.new(0, -2, 2), Vector3.new(0, 0, 45))

	table.remove(MPASword,1)

local ae5 = WingPart:Clone()
ae5.Parent = mw1
ae5.PrimaryPart.Anchored = false
CreateWeld(ae5.PrimaryPart,lwing2,ae5.PrimaryPart,0,-1.9,-0.05,math.rad(-90),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local lwing3 = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0.5,0.5,0.5)
local lwing3weld = CreateWeld(lwing3,handle,lwing3,4.5,2,0,math.rad(15),math.rad(0),math.rad(37.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local HatChoice = game.Players.LocalPlayer.Character["BladeMasterAccessory"]

	Align(HatChoice.Handle, lwing3, Vector3.new(0, -2, 2), Vector3.new(0, 0, 45))

local ae6 = WingPart:Clone()
ae6.Parent = mw1
ae6.PrimaryPart.Anchored = false
CreateWeld(ae6.PrimaryPart,lwing3,ae6.PrimaryPart,0,-1.9,-0.05,math.rad(-90),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local lwing4 = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0.5,0.5,0.5)
local lwing4weld = CreateWeld(lwing4,handle,lwing4,5.75,3,0,math.rad(20),math.rad(0),math.rad(50),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local lwing5 = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0.5,0.5,0.5)
local lwing5weld = CreateWeld(lwing5,handle,lwing5,6.75,4,0,math.rad(25),math.rad(0),math.rad(62.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local lwing6 = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0.5,0.5,0.5)
local lwing6weld = CreateWeld(lwing6,handle,lwing6,7.75,5,0,math.rad(30),math.rad(0),math.rad(75),0,0,0,math.rad(0),math.rad(0),math.rad(0))

-- Right wing.

local rwing1 = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0.5,0.5,0.5)
local rwing1weld = CreateWeld(rwing1,handle,rwing1,-1.5,0,0,math.rad(5),math.rad(0),math.rad(-12.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local HatChoice = MPASword[1]

	Align(HatChoice.Handle, rwing1, Vector3.new(0, -2, 2), Vector3.new(0, 0, 45))

	table.remove(MPASword,1)

local ae1 = WingPart:Clone()
ae1.Parent = mw2
ae1.PrimaryPart.Anchored = false
CreateWeld(ae1.PrimaryPart,rwing1,ae1.PrimaryPart,0,-1.9,-0.05,math.rad(-90),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local rwing2 = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0.5,0.5,0.5)
local rwing2weld = CreateWeld(rwing2,handle,rwing2,-3,1,0,math.rad(10),math.rad(0),math.rad(-25),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local HatChoice = MPASword[1]

	Align(HatChoice.Handle, rwing2, Vector3.new(0, -2, 2), Vector3.new(0, 0, 45))

	table.remove(MPASword,1)

local ae2 = WingPart:Clone()
ae2.Parent = mw2
ae2.PrimaryPart.Anchored = false
CreateWeld(ae2.PrimaryPart,rwing2,ae2.PrimaryPart,0,-1.9,-0.05,math.rad(-90),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local rwing3 = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0.5,0.5,0.5)
local rwing3weld = CreateWeld(rwing3,handle,rwing3,-4.5,2,0,math.rad(15),math.rad(0),math.rad(-37.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))

	local HatChoice = game.Players.LocalPlayer.Character["ShadowBladeMasterAccessory"]

	Align(HatChoice.Handle, rwing3, Vector3.new(0, -2, 2), Vector3.new(0, 0, 45))

local ae3 = WingPart:Clone()
ae3.Parent = mw2
ae3.PrimaryPart.Anchored = false
CreateWeld(ae3.PrimaryPart,rwing3,ae3.PrimaryPart,0,-1.9,-0.05,math.rad(-90),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))


local rwing4 = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0.5,0.5,0.5)
local rwing4weld = CreateWeld(rwing4,handle,rwing4,-5.75,3,0,math.rad(20),math.rad(0),math.rad(-50),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local rwing5 = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0.5,0.5,0.5)
local rwing5weld = CreateWeld(rwing5,handle,rwing5,-6.75,4,0,math.rad(25),math.rad(0),math.rad(-62.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local rwing6 = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0.5,0.5,0.5)
local rwing6weld = CreateWeld(rwing6,handle,rwing6,-7.75,3,0,math.rad(30),math.rad(0),math.rad(-75),0,0,0,math.rad(0),math.rad(0),math.rad(0))
  

function recolorwings(color1,color2)
	for i,v in pairs(ae1:GetChildren()) do
		if v.Name == "Color1" then
			v.Color = color1
		elseif v.Name == "Color2" then
			v.Color = color2
		elseif v.Name == "Main" then
			v.Attachment.ParticleEmitter.Color = ColorSequence.new(color2)
			v.Attachment.PointLight.Color = color2
		end
	end
	for i,v in pairs(ae2:GetChildren()) do
		if v.Name == "Color1" then
			v.Color = color1
		elseif v.Name == "Color2" then
			v.Color = color2
		elseif v.Name == "Main" then
			v.Attachment.ParticleEmitter.Color = ColorSequence.new(color2)
			v.Attachment.PointLight.Color = color2
		end
	end
	for i,v in pairs(ae3:GetChildren()) do
		if v.Name == "Color1" then
			v.Color = color1
		elseif v.Name == "Color2" then
			v.Color = color2
		elseif v.Name == "Main" then
			v.Attachment.ParticleEmitter.Color = ColorSequence.new(color2)
			v.Attachment.PointLight.Color = color2
		end
	end
	for i,v in pairs(ae4:GetChildren()) do
		if v.Name == "Color1" then
			v.Color = color1
		elseif v.Name == "Color2" then
			v.Color = color2
		elseif v.Name == "Main" then
			v.Attachment.ParticleEmitter.Color = ColorSequence.new(color2)
			v.Attachment.PointLight.Color = color2
		end
	end
	for i,v in pairs(ae5:GetChildren()) do
		if v.Name == "Color1" then
			v.Color = color1
		elseif v.Name == "Color2" then
			v.Color = color2
		elseif v.Name == "Main" then
			v.Attachment.ParticleEmitter.Color = ColorSequence.new(color2)
			v.Attachment.PointLight.Color = color2
		end
	end
	for i,v in pairs(ae6:GetChildren()) do
		if v.Name == "Color1" then
			v.Color = color1
		elseif v.Name == "Color2" then
			v.Color = color2
		elseif v.Name == "Main" then
			v.Attachment.ParticleEmitter.Color = ColorSequence.new(color2)
			v.Attachment.PointLight.Color = color2
		end
	end
end


local TorsoParticle = {}
local TorsoEffect = script.TorsoBlood.Torso

for i,g in pairs(TorsoEffect.Parent:GetDescendants()) do
	if g:IsA("ParticleEmitter") or g:IsA("Beam") then
		table.insert(TorsoParticle,g)
	end
end
function ToggleEyeEffect(VL)
	for i,g in pairs(TorsoParticle) do
		g.Enabled = VL
	end
end
function ToggleBloodTorso(VL)
for i,v in pairs(TorsoEffect:GetChildren()) do
		if v.Name == "Part" then
			v.Transparency = VL
		end
	end
end
ToggleBloodTorso(1)
ToggleEyeEffect(false)
local EyeWeld = Instance.new("Weld")
EyeWeld.Parent = TorsoEffect
EyeWeld.Part0 = Torso
EyeWeld.Part1 = TorsoEffect
--------------
--------------
local cen = CreateParta(m3,1,1,"SmoothPlastic",BrickColor.random())
CreateWeld(cen,root,cen,0,3,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local effar = Instance.new("ParticleEmitter",cen)
effar.Texture = "rbxassetid://2344870656"
effar.LightEmission = 1
effar.Color = ColorSequence.new(Color3.new(1,0,0))
effar.Rate = 50
effar.Enabled = false
effar.EmissionDirection = "Front"
effar.Lifetime = NumberRange.new(1)
effar.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,15,0),NumberSequenceKeypoint.new(0.1,5,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,2,0)})
effar.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.8,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
effar.Speed = NumberRange.new(50,60)
effar.Acceleration = Vector3.new(0,8,0)
effar.Drag = 5
effar.Rotation = NumberRange.new(-500,500)
effar.SpreadAngle = Vector2.new(0,900)
effar.RotSpeed = NumberRange.new(-500,500)

local sorb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
CreateWeld(sorb,rarm,sorb,0,1,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local sorb2 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
CreateWeld(sorb2,larm,sorb2,0,1,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

------



function RemoveOutlines(part)
  part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
  local Weld = Create("Weld")({
    Parent = Parent,
    Part0 = Part0,
    Part1 = Part1,
    C0 = C0,
    C1 = C1
  })
  return Weld
end



Character=workspace.Camera.CameraSubject.Parent
PlayerGui=Player.PlayerGui 
Backpack=Player.Backpack 
Torso=Character.Torso 
Head=Character.Head 
Humanoid=Character.Humanoid
m=Instance.new('Model',Character)
LeftArm=Character["Left Arm"] 
LeftLeg=Character["Left Leg"] 
RightArm=Character["Right Arm"] 
RightLeg=Character["Right Leg"] 
LS=Torso["Left Shoulder"] 
LH=Torso["Left Hip"] 
RS=Torso["Right Shoulder"] 
RH=Torso["Right Hip"] 
Neck=Torso.Neck
it=Instance.new
attacktype=1
vt=Vector3.new
cf=CFrame.new
euler=CFrame.fromEulerAnglesXYZ
angles=CFrame.Angles
cloaked=false
necko=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
necko2=cf(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
LHC0=cf(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
LHC1=cf(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
RHC0=cf(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
RHC1=cf(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
RootPart=Character.HumanoidRootPart
RootJoint=RootPart.RootJoint
RootCF=euler(-1.57,0,3.14)
attack = false 
local Effects2 = Instance.new("Folder", Character)
Effects2.Name = "Effects"
attackdebounce = false 
deb=false
equipped=false
hand=false
MMouse=nil
local combo = 1
mana=0
trispeed=.2
attackmode='none'
local idle=0
local Anim="Idle"
local gun=false
local shoot=false
local sine = 0
local doe = 0
local SINE = 0
local change = 1



Death = false
deadii = false
deadii2 = false


local Effects={
	Block = function(cf,partsize,meshstart,meshadd,matr,colour,spin,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = partsize
p.Anchored = true
p.CanCollide = false
p.Material = matr
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("BlockMesh",p)
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
if spin == true then
p.CFrame = p.CFrame * CFrame.Angles(math.random(-50,50),math.random(-50,50),math.random(-50,50))
end
end
p:Destroy()
end)()
return p
end,
	
	Meshed = function(cf,meshstart,meshadd,colour,meshid,textid,spin,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = Vector3.new()
p.Anchored = true
p.CanCollide = false
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshId = meshid
m.TextureId = textid
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
p.CFrame = p.CFrame * CFrame.Angles(0,math.rad(spin),0)
end
p:Destroy()
end)()
return p
	end,
	}



local S = it("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP,timepos)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "rbxassetid://"..ID
		NEWSOUND.TimePosition = timepos or 0
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end





--save shoulders 
RSH, LSH=nil, nil 
--welds 
RW, LW=Instance.new("Weld"), Instance.new("Weld") 
RW.Name="Right Shoulder" LW.Name="Left Shoulder"
LH=Torso["Left Hip"]
RH=Torso["Right Hip"]
TorsoColor=Torso.BrickColor
ch=Character
RSH=ch.Torso["Right Shoulder"] 
LSH=ch.Torso["Left Shoulder"] 
-- 
RSH.Parent=nil 
LSH.Parent=nil 
-- 
RW.Name="Right Shoulder"
RW.Part0=ch.Torso 
RW.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5) 
RW.C1=cf(0, 0.5, 0) 
RW.Part1=ch["Right Arm"] 
RW.Parent=ch.Torso 
-- 
LW.Name="Left Shoulder"
LW.Part0=ch.Torso 
LW.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8) 
LW.C1=cf(0, 0.5, 0) 
LW.Part1=ch["Left Arm"] 
LW.Parent=ch.Torso 

local donum=0
 


 
local Color1=Torso.BrickColor

local bodvel=Instance.new("BodyVelocity")
local bg=Instance.new("BodyGyro")

function swait(num)
if num==0 or num==nil then
game:service'RunService'.Stepped:wait(0)
else
for i=0,num do
game:service'RunService'.Stepped:wait(0)
end
end
end

function Swait(num) if num==0 or num==nil then game:service'RunService'.Stepped:wait(0) else for i=0,num do game:service'RunService'.Stepped:wait(0) end end end


-------- RAINBOW LEAVE IT TO ME
local r = 255
local g = 0
local b = 0
coroutine.resume(coroutine.create(function()
while wait() do
	for i = 0, 254/5 do
		swait()
		g = g + 5
	end
	for i = 0, 254/5 do
		swait()
		r = r - 5
	end
	for i = 0, 254/5 do
		swait()
		b = b + 5
	end
	for i = 0, 254/5 do
		swait()
		g = g - 5
	end
	for i = 0, 254/5 do
		swait()
		r = r + 5
	end
	for i = 0, 254/5 do
		swait()
		b = b - 5
	end
end
end))
 
 

 clerp2 = function(toclerp, cf, number)
    local joint = toclerp
    joint.C0 = joint.C0:Lerp(cf, number)
end
function clerp(a,b,t) 
local qa = {QuaternionFromCFrame(a)}
local qb = {QuaternionFromCFrame(b)} 
local ax, ay, az = a.x, a.y, a.z 
local bx, by, bz = b.x, b.y, b.z
local _t = 1-t
return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
end 
 
function QuaternionFromCFrame(cf) 
local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
local trace = m00 + m11 + m22 
if trace > 0 then 
local s = math.sqrt(1 + trace) 
local recip = 0.5/s 
return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
else 
local i = 0 
if m11 > m00 then
i = 1
end
if m22 > (i == 0 and m00 or m11) then 
i = 2 
end 
if i == 0 then 
local s = math.sqrt(m00-m11-m22+1) 
local recip = 0.5/s 
return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
elseif i == 1 then 
local s = math.sqrt(m11-m22-m00+1) 
local recip = 0.5/s 
return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
elseif i == 2 then 
local s = math.sqrt(m22-m00-m11+1) 
local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
end 
end 
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w) 
local xs, ys, zs = x + x, y + y, z + z 
local wx, wy, wz = w*xs, w*ys, w*zs 
local xx = x*xs 
local xy = x*ys 
local xz = x*zs 
local yy = y*ys 
local yz = y*zs 
local zz = z*zs 
return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
end
 
function QuaternionSlerp(a, b, t) 
local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
local startInterp, finishInterp; 
if cosTheta >= 0.0001 then 
if (1 - cosTheta) > 0.0001 then 
local theta = math.acos(cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((1-t)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta  
else 
startInterp = 1-t 
finishInterp = t 
end 
else 
if (1+cosTheta) > 0.0001 then 
local theta = math.acos(-cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((t-1)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta 
else 
startInterp = t-1 
finishInterp = t 
end 
end 
return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
end

local function CFrameFromTopBack(at, top, back)
local right = top:Cross(back)
return CFrame.new(at.x, at.y, at.z,
right.x, top.x, back.x,
right.y, top.y, back.y,
right.z, top.z, back.z)
end

function Triangle(a, b, c)
local edg1 = (c-a):Dot((b-a).unit)
local edg2 = (a-b):Dot((c-b).unit)
local edg3 = (b-c):Dot((a-c).unit)
if edg1 <= (b-a).magnitude and edg1 >= 0 then
a, b, c = a, b, c
elseif edg2 <= (c-b).magnitude and edg2 >= 0 then
a, b, c = b, c, a
elseif edg3 <= (a-c).magnitude and edg3 >= 0 then
a, b, c = c, a, b
else
assert(false, "unreachable")
end
 
local len1 = (c-a):Dot((b-a).unit)
local len2 = (b-a).magnitude - len1
local width = (a + (b-a).unit*len1 - c).magnitude
 
local maincf = CFrameFromTopBack(a, (b-a):Cross(c-b).unit, -(b-a).unit)
 
local list = {}
 
if len1 > 0.01 then
local w1 = Instance.new('WedgePart', m)
game:GetService("Debris"):AddItem(w1,5)
w1.Material = "SmoothPlastic"
w1.FormFactor = 'Custom'
w1.BrickColor = BrickColor.new("Really red")
w1.Transparency = 0
w1.Reflectance = 0
w1.Material = "SmoothPlastic"
w1.CanCollide = false
local l1 = Instance.new("PointLight",w1)
l1.Color = Color3.new(170,0,0)
NoOutline(w1)
local sz = Vector3.new(0.2, width, len1)
w1.Size = sz
local sp = Instance.new("SpecialMesh",w1)
sp.MeshType = "Wedge"
sp.Scale = Vector3.new(0,1,1) * sz/w1.Size
w1:BreakJoints()
w1.Anchored = true
w1.Parent = workspace
w1.Transparency = 0.7
table.insert(Effects,{w1,"Disappear",.01})
w1.CFrame = maincf*CFrame.Angles(math.pi,0,math.pi/2)*CFrame.new(0,width/2,len1/2)
table.insert(list,w1)
end
 
if len2 > 0.01 then
local w2 = Instance.new('WedgePart', m)
game:GetService("Debris"):AddItem(w2,5)
w2.Material = "SmoothPlastic"
w2.FormFactor = 'Custom'
w2.BrickColor = BrickColor.new("Really red")
w2.Transparency = 0
w2.Reflectance = 0
w2.Material = "SmoothPlastic"
w2.CanCollide = false
local l2 = Instance.new("PointLight",w2)
l2.Color = Color3.new(170,0,0)
NoOutline(w2)
local sz = Vector3.new(0.2, width, len2)
w2.Size = sz
local sp = Instance.new("SpecialMesh",w2)
sp.MeshType = "Wedge"
sp.Scale = Vector3.new(0,1,1) * sz/w2.Size
w2:BreakJoints()
w2.Anchored = true
w2.Parent = workspace
w2.Transparency = 0.7
table.insert(Effects,{w2,"Disappear",.01})
w2.CFrame = maincf*CFrame.Angles(math.pi,math.pi,-math.pi/2)*CFrame.new(0,width/2,-len1 - len2/2)
table.insert(list,w2)
end
return unpack(list)
end





function Damagefunc(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	return
end
function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChildOfClass("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Torso")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= Player.Name then
          Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://3778610036", 1)
       
				end
      end
      local head = c:findFirstChild("UpperTorso")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= Player.Name then
          Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://3778610036", 1)       
				end
      end
    end
  end
end







function shakes(power,length)
	for i,v in pairs(game:GetService("Players"):GetChildren()) do
	local var = script.Shaker:Clone()
	var.Parent = v.Character
	local pw = var.Shakeval
	local lgth = var.MultLength
	pw.Value = power/2
	lgth.Value = length
	var.Disabled = false
	game:GetService("Debris"):AddItem(var, length+4)
	end
end

function localshakes(power,length)
local var = script.Shaker:Clone()
var.Parent = plr.Character
local pw = var.Shakeval
local lgth = var.MultLength
pw.Value = power/2
lgth.Value = length
var.Disabled = false
game:GetService("Debris"):AddItem(var, length+4)
end



function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore) 
end 

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function CastRay(Pos, Dir, Max, Ignore)
return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore) 
end 











 






 


function dmgstart(dmg,what)

end

function dmgstop()
	hitcon:disconnect()
end


 

local origcolor = BrickColor.new("Pastel light blue")
---- This section of explosions.

----












function CameraManager()
  if TwoD and not CamInterrupt then
    if Humanoid.Health > 0 then
      Camera.CameraSubject = Humanoid
      Camera.CameraType = "Scriptable"
      Humanoid.AutoRotate = false
      if Booleans.GyroUse then
        Directer.MaxTorque = Vec3(0, huge, 0)
      else
        Directer.MaxTorque = Vec3(0, 0, 0)
      end
      if TargetInfo[1] ~= nil and TargetInfo[2] ~= nil then
        if Booleans.CamFollow then
          CPart.CFrame = cFrame(RootPart.Position, Vec3(TargetInfo[1].Position.X, RootPart.Position.Y, TargetInfo[1].Position.Z))
          Directer.CFrame = cFrame((RootPart.CFrame * cFrame(0, 0, 10)).p, TargetInfo[1].Position)
        else
          CPart.Position = RootPart.Position
        end
      else
        local ahead = (RootPart.CFrame * cFrame(0, 0, -3)).p
        CPart.CFrame = cFrame(RootPart.Position, Vec3(ahead.X, RootPart.Position.Y, ahead.Z))
      end
      Camera.CFrame = lerp(Camera.CFrame, CPart.CFrame * cFrame(25, 3, 0) * Euler(0, radian(90), 0), 0.2)
    else
      Camera.CameraSubject = Humanoid
      Camera.CameraType = "Custom"
    end
  end
end



function sphere(bonuspeed,type,pos,scale,value,color)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.BrickColor = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kmusic.PlaybackLoudness/1000,kmusic.PlaybackLoudness/1000,kmusic.PlaybackLoudness/1000)
end
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = scale
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end

local scaler2 = 1
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
end
rng:Destroy()
end))
end


function sphere2(bonuspeed,type,pos,scale,value,value2,value3,color,material)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.BrickColor = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kmusic.PlaybackLoudness/1000,kmusic.PlaybackLoudness/1000,kmusic.PlaybackLoudness/1000)
end
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = material
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end))
end
function sphereMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
     rng.BrickColor = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = vt(x1,y1,z1)

local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end))
end

function trailMK(bonuspeed,FastSpeed,type,pos,x,value,color,outerpos)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
rng.Color = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
local trl = Instance.new("Trail",rng)
	local a0 = Instance.new("Attachment",rng)
	a0.Position = Vector3.new(x/2,0,0)
	local a1 = Instance.new("Attachment",rng)
	a1.Position = Vector3.new(-x/2,0,0)
	trl.Attachment0 = a0
	trl.Attachment1 = a1
	trl.Color = ColorSequence.new(color)
	trl.Lifetime = 0.25
	trl.LightEmission = 1
	trl.WidthScale = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(1,0,0)})
	trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,0)})
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = vt(0,0,0)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,rng.Transparency,0),NumberSequenceKeypoint.new(1,1,0)})
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end))
end
function slash(bonuspeed,rotspeed,rotatingop,typeofshape,type,typeoftrans,pos,scale,value,color)
local type = type
local rotenable = rotatingop
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
if typeoftrans == "In" then
rng.Transparency = 1
end
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "FileMesh"
if typeofshape == "Normal" then
rngm.MeshId = "rbxassetid://662586858"
elseif typeofshape == "Round" then
rngm.MeshId = "rbxassetid://662585058"
end
rngm.Scale = scale
local scaler2 = 1/10
if type == "Add" then
scaler2 = 1*value/10
elseif type == "Divide" then
scaler2 = 1/value/10
end
local randomrot = math.random(1,2)
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed/10
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed/10
end
if rotenable == true then
if randomrot == 1 then
rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(rotspeed*bonuspeed/2),0)
elseif randomrot == 2 then
rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(-rotspeed*bonuspeed/2),0)
end
end
if typeoftrans == "Out" then
rng.Transparency = rng.Transparency + 0.01*bonuspeed
elseif typeoftrans == "In" then
rng.Transparency = rng.Transparency - 0.01*bonuspeed
end
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed/10, 0, scaler2*bonuspeed/10)
end
rng:Destroy()
end))
end






function FindNearestTorso(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return (SinglePlayer.Torso.CFrame.p - Position).magnitude < Distance
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") then
			if v:findFirstChild("Torso") or v:findFirstChild("UpperTorso") then
				if v ~= Character then
					if (v.Head.Position - Position).magnitude <= Distance then
						table.insert(List, v)
					end 
				end 
			end 
		end 
	end
	return List
end

function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return (SinglePlayer.Torso.CFrame.p - Position).magnitude < Distance
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") then
			if v:findFirstChild("Head") then
				if v ~= Character then
					if (v.Head.Position - Position).magnitude <= Distance then
						table.insert(List, v)
					end 
				end 
			end 
		end 
	end
	return List
end

function FaceMouse()
  Cam = workspace.CurrentCamera
  return {
    CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
    Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
  }
end

function FaceMouse2()
  Cam = workspace.CurrentCamera
  return {
    CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)),
    Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
  }
end



function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = it("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = it("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = it("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

function CreatePartD(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = it("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end



function sphereRotMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
local ya = math.random(-5,5)
local xa = math.random(-5,5)
local za = math.random(-5,5)
local y2a = 0
local x2a = 0
local z2a = 0
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
		rng.Color = color
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = vt(x1,y1,z1)
if ModeOfGlitch == 9 then
coroutine.resume(coroutine.create(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end))
end
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
y2a=y2a+ya
z2a=z2a+za
x2a=x2a+xa
 rng.CFrame =  rng.CFrame*CFrame.Angles(math.rad(ya),math.rad(za),math.rad(xa))
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end))
end

function sphereRot2MK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.BrickColor = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
local ya = 5
local xa = 5
local za = 5
local y2a = 0
local x2a = 0
local z2a = 0
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = vt(x1,y1,z1)
if ModeOfGlitch == 9 then
coroutine.resume(coroutine.create(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end))
end
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
y2a=y2a+ya
z2a=z2a+za
x2a=x2a+xa
 rng.CFrame =  rng.CFrame*CFrame.Angles(math.rad(ya),math.rad(za),math.rad(xa))
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end))
end
function sphereRot2(bonuspeed,type,pos,scale,value,value2,value3,color)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.BrickColor = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
local ya = math.random(1,5)
local xa = math.random(1,5)
local za = math.random(1,5)
local y2a = 0
local x2a = 0
local z2a = 0
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
if ModeOfGlitch == 9 then
coroutine.resume(coroutine.create(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end))
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
y2a=y2a+ya
z2a=z2a+za
x2a=x2a+xa
 rng.CFrame =  rng.CFrame*CFrame.Angles(math.rad(ya),math.rad(za),math.rad(xa))
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end))
end

function sphereRev2(bonuspeed,type,pos,scale,value,value2,value3,color)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.BrickColor = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
local ya = math.random(1,5)
local xa = math.random(1,5)
local za = math.random(1,5)
local y2a = 0
local x2a = 0
local z2a = 0
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 1
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
if ModeOfGlitch == 9 then
coroutine.resume(coroutine.create(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end))
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.Transparency = rng.Transparency - 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end))
end

function sphereSRot2(bonuspeed,type,pos,scale,value,value2,value3,color)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.BrickColor = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
local ya = math.random(1,5)
local xa = math.random(1,5)
local za = math.random(1,5)
local y2a = 0
local x2a = 0
local z2a = 0
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
if ModeOfGlitch == 9 then
coroutine.resume(coroutine.create(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end))
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
y2a=y2a+ya
z2a=z2a+za
x2a=x2a+xa
 rng.CFrame = pos
 rng.CFrame =  rng.CFrame*CFrame.Angles(math.rad(ya),math.rad(za),math.rad(xa))
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end))
end




-- Functions are ready.
--local storehumanoidWS = 19

function createBGCircle(size,parent,color)
local bgui = Instance.new("BillboardGui",parent)
bgui.Size = UDim2.new(size, 0, size, 0)
local imgc = Instance.new("ImageLabel",bgui)
imgc.BackgroundTransparency = 1
imgc.ImageTransparency = 0
imgc.Size = UDim2.new(1,0,1,0)
imgc.Image = "rbxassetid://997291547" --997291547,521073910
imgc.ImageColor3 = color
return bgui,imgc
end


function symbolizeBlink(guipar,size,img,color,bonussize,vol,pit,soundid,spar,rotationenabled,rotsp,delay)
local bgui,imgc = createBGCircle(size,guipar,color)
bgui.AlwaysOnTop = true
imgc.Image = "rbxassetid://" ..img
local rrot = math.random(1,2)
CFuncs["Sound"].Create("rbxassetid://" ..soundid, spar, vol,pit)
coroutine.resume(coroutine.create(function()
for i = 0, 24*delay do
swait()
if rotationenabled == true then
if rrot == 1 then
imgc.Rotation = imgc.Rotation + rotsp
elseif rrot == 2 then
imgc.Rotation = imgc.Rotation - rotsp
end
end
bgui.Size = bgui.Size + UDim2.new(1*bonussize/delay,0,1*bonussize/delay,0)
imgc.ImageTransparency = imgc.ImageTransparency + 0.04/delay
end
bgui:Destroy()
end))
end
local ColorEx1 = BrickColor.new("Bright yellow")
local ColorEx2 = BrickColor.new("Deep orange")





	
		function Weld(part0,part1,c0,c1)
	local weld = Instance.new("Weld")
	weld.Parent = part0
	weld.Part0 = part0
	weld.Part1 = part1
	weld.C0 = c0 or cf()
	weld.C1 = c1 or cf()
	return weld
end




function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end


function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects2, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		elseif TYPE == "Duck" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9419831", "9419827", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME+1 do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = VT(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			EFFECT.Transparency = 1
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		end
	end))
end



--UI and Name variables
local PlrGUI = plr.PlayerGui
local UI = script.MainUI
local HeadUI = script.OverheadGui
HeadUI.Enabled = true
HeadUI.UserName.Text = string.upper("-"..plr.DisplayName.."-")
HeadUI.Parent = tors
	
UI.Parent = PlrGUI
--Mode rename function
function Rename(text,color1,color2)
	CFuncs["Sound"].Create("rbxassetid://3748210175", root, 3,1)
	CFuncs["Sound"].Create("rbxassetid://3744391630", root, 3, 1)
		coroutine.resume(coroutine.create(function()
local eff = Instance.new("ParticleEmitter",root)
eff.Texture = "rbxassetid://252644715"
eff.LightEmission = 1
eff.Color = ColorSequence.new(color1)
eff.Rate = 500000
eff.Lifetime = NumberRange.new(0.7,2.2)
		eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.1,10,0),NumberSequenceKeypoint.new(0.8,5,0),NumberSequenceKeypoint.new(1,0,0)})

		--eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
eff.Speed = NumberRange.new(30,150)
eff.Drag = 5
eff.Rotation = NumberRange.new(-500,500)
eff.VelocitySpread = 9000
eff.RotSpeed = NumberRange.new(-150,150)
wait(0.3)
eff.Enabled = false
end))
coroutine.resume(coroutine.create(function()
local eff = Instance.new("ParticleEmitter",root)
eff.Texture = "rbxassetid://2344870656"
eff.LightEmission = 1
eff.Color = ColorSequence.new(color2)
eff.Rate = 500000
eff.Lifetime = NumberRange.new(0.7,2.2)
		eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.1,10,0),NumberSequenceKeypoint.new(0.8,5,0),NumberSequenceKeypoint.new(1,0,0)})

		--eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
eff.Speed = NumberRange.new(30,150)
eff.Drag = 5
eff.Rotation = NumberRange.new(-500,500)
eff.VelocitySpread = 9000
eff.RotSpeed = NumberRange.new(-150,150)
wait(0.3)
eff.Enabled = false
	end))
if Outfit == true then
OutfitModel.Torso.ColorThingy.Color = color1
end
UI.MainFrameLol.ModeName.Text = text
UI.MainFrameLol.ModeName.TextColor3 = color1
UI.MainFrameLol.ScriptName.TextColor3 = color1
UI.MainFrameLol.SongName.TextColor3 = color1
UI.MainFrameLol.FirstColor.ImageColor3 = color1
UI.MainFrameLol.SecondColor.ImageColor3 = color2
UI.MainFrameLol.ModeName.TextStrokeColor3 = color2
UI.MainFrameLol.ScriptName.TextStrokeColor3 = color2
UI.MainFrameLol.SongName.TextStrokeColor3 = color2
		
HeadUI.ModeName.Text = text
HeadUI.ModeName.TextColor3 = color1
HeadUI.ModeName.TextStrokeColor3 = color2
HeadUI.LineOuter.BackgroundColor3 = color1
HeadUI.MiddleSpin.ImageColor3 = color1
HeadUI.LineInner.BackgroundColor3 = color2
HeadUI.ScriptName.TextColor3 = color1
HeadUI.ScriptName.TextStrokeColor3 = color2
HeadUI.UserName.TextColor3 = color1
HeadUI.UserName.TextStrokeColor3 = color2

for i,v in pairs(UI.MainFrameLol.Bars:GetChildren()) do 
v.BackgroundColor3 = color2
		end
		for i,v in pairs(UI.MainFrameLol.Bars2:GetChildren()) do 
			v.BackgroundColor3 = color2
		end

end
--Rename + NewTheme self-set
Rename("IMMACULATE",Color3.fromRGB(18, 238, 212),Color3.fromRGB(255,255,255))
recolorwings(Color3.fromRGB(18, 238, 212),Color3.fromRGB(255,255,255))



local Mode = 1


dmgcombo=1



local effects = Instance.new("Model", char)

NewSound = function(p, id, pit, vol, loop)
    local Sound = Instance.new("Sound",p)
    Sound.Pitch = pit
    Sound.Volume = vol
    Sound.SoundId = "rbxassetid://" ..id
    Sound.Looped = loop
    Sound:Play()
    return Sound
end

function WeldParts(A,B)
    local WLD = IT("ManualWeld")
    WLD.Part0 = A
    WLD.Part1 = B
    WLD.C1 = B.CFrame:inverse() * A.CFrame
    WLD.Parent = A
    return WLD
end

function TweenAnimate(object,Aniim,time,easingstyle,easingdirection,repet,reverse,deelay)
local infos=TweenInfo.new(time,Enum.EasingStyle[easingstyle],Enum.EasingDirection[easingdirection],repet,reverse,deelay)
local tween=game:GetService("TweenService"):Create(object,infos,Aniim)
tween:Play()
return tween
end
local Combo = 1



function Boost()
	attack = true
	CFuncs["Sound"].Create("rbxassetid://278445103", tors, 3,1)
	CFuncs["Sound"].Create("rbxassetid://1561114238", tors, 3,1)
	CFuncs["Sound"].Create("rbxassetid://2374026404", tors, 3,1)
		for i = 0,1.2,0.1 do
swait()
RH.C0=clerp(RH.C0,cf(1,-0.35,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(-20),math.rad(30)),.5)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.5)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,.9 + 0.5 * math.cos(sine / 14))*angles(math.rad(30),math.rad(0),math.rad(20)),.5)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-10),math.rad(0),math.rad(-20)),.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.1 + 0.05 * Cos(sine / 20)* Player_Size, -0.1* Player_Size) * angles(Rad(150 + 0.5 * Sin(sine / 34)), Rad(40 + 0 * Sin(sine / 10)), Rad(1 + 0.5 * Sin(sine / 50))), 0.15)
				LW.C0 = clerp(LW.C0, CF(-0.3* Player_Size, 0.25 + 0.05 * Cos(sine / 20)* Player_Size, -0.6* Player_Size) * angles(Rad(0 + 0.5 * Sin(sine / 34)), Rad(0 + 0 * Sin(sine / 10)), Rad(121 + -0.4 * Sin(sine / 50))), 0.15)
end
CFuncs["Sound"].Create("rbxassetid://2295409845", tors, 3,0.9)

--	CFuncs["Sound"].Create("rbxassetid://1666361078", tors, 3,1.1)
	CFuncs["Sound"].Create("rbxassetid://782353443", tors, 3,1)
	local eff = Instance.new("ParticleEmitter",tors)
eff.Texture = "rbxassetid://252644715"
eff.LightEmission = 1
eff.Color = ColorSequence.new(BrickColor.new("Bright green").Color)
eff.Rate = 1000
eff.Lifetime = NumberRange.new(1,3)
eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,10,0),NumberSequenceKeypoint.new(1,0,0)})
eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,0)})
eff.Speed = NumberRange.new(20,120)
eff.Drag = 5
eff.Rotation = NumberRange.new(-500,500)
eff.VelocitySpread = 9000
eff.RotSpeed = NumberRange.new(-10,10)
	      local v = Instance.new("BodyVelocity",root)--EgibleParts[i].Parent:FindFirstChild('Torso'))
          v.Velocity = root.CFrame.lookVector + root.CFrame.lookVector*200
             -- v.Velocity = (root.CFrame.lookVector + Vector3.new(0,0.025,0)) * 90
              v.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
	for i = 0, 2, 0.1 do
		swait()

		root.Velocity = root.CFrame.lookVector*200 + vt(0,5,0)

		RH.C0=clerp(RH.C0,cf(1,-0.5,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-40)),1)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-10),math.rad(0),math.rad(10)),1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-3,1 + 0.5 * math.cos(sine / 14))*angles(math.rad(55),math.rad(0),math.rad(0)),1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-25),math.rad(0),math.rad(0)),1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.1 + 0.05 * Cos(sine / 20)* Player_Size, -0.1* Player_Size) * angles(Rad(150 + 0.5 * Sin(sine / 34)), Rad(40 + 0 * Sin(sine / 10)), Rad(1 + 0.5 * Sin(sine / 50))), 0.15)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-20),math.rad(2),math.rad(-15)),1)
end
v:Destroy()
	eff.Enabled = false
	game:GetService("Debris"):AddItem(eff,8)
	attack = false
end

local Combo = 1
function ComboPunch()
	attack = true
	hum.WalkSpeed = 3.5
		if Combo == 1 then
		Combo = 2
		  for i = 0, 2, 0.1 do
  	swait()
  	local Alpha = .3
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,-0.1)*angles(math.rad(-6.5),math.rad(23.5),math.rad(2.3))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-0.9,-1,0)*angles(math.rad(-1.8),math.rad(17.6),math.rad(-3.4))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1.1,-1,0)*angles(math.rad(-16.6),math.rad(-36.7),math.rad(-12.1))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.5,-0.3,0.3)*angles(math.rad(128.1),math.rad(-32.1),math.rad(-10.6)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.3,0.4,0.2)*angles(math.rad(-29.3),math.rad(-35.2),math.rad(-13.6)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,0)*angles(math.rad(-1),math.rad(-26.1),math.rad(1.9))*necko,Alpha)
	  end
									      local v = Instance.new("BodyVelocity",root)
          v.Velocity = root.CFrame.lookVector + root.CFrame.lookVector*2.5
             v.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
game:GetService("Debris"):AddItem(v,.2)
MagniDamage(larm,4,10,25,0,"Normal")

  for i = 0, 1, 0.1 do
  	swait()
  	local Alpha = .3
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0.1,0,-0.2)*angles(math.rad(-15),math.rad(-21.9),math.rad(-2.3))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,-0.2)*angles(math.rad(-16.8),math.rad(17.8),math.rad(1.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(0.9,-1,0.3)*angles(math.rad(5.4),math.rad(-38.4),math.rad(1.3))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.3,0.4,-0.8)*angles(math.rad(72.8),math.rad(-32.7),math.rad(18.4)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.4,0.5,0.3)*angles(math.rad(-29.3),math.rad(-35.2),math.rad(7.1)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,0)*angles(math.rad(-2.4),math.rad(19.4),math.rad(1.8))*necko,Alpha)
		  end
			elseif Combo == 2 then
		Combo = 3
		  for i = 0, 2, 0.1 do
  	swait()
  	local Alpha = .3
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0.1,0,-0.1)*angles(math.rad(-0.4),math.rad(15.7),math.rad(6.7))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-0.9,-1,0.2)*angles(math.rad(10),math.rad(16.5),math.rad(-6.9))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(0.9,-1,0.3)*angles(math.rad(5.4),math.rad(-38.4),math.rad(1.3))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.5,0.7,-0.3)*angles(math.rad(-1.4),math.rad(-29),math.rad(-24)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,0.1,0.5)*angles(math.rad(99.5),math.rad(29.3),math.rad(35.1)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,0)*angles(math.rad(-1.2),math.rad(-20.5),math.rad(1.8))*necko,Alpha)
	  end
									      local v = Instance.new("BodyVelocity",root)
          v.Velocity = root.CFrame.lookVector + root.CFrame.lookVector*2.5
             v.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
game:GetService("Debris"):AddItem(v,.2)
MagniDamage(rarm,4,10,25,0,"Normal")

  for i = 0, 1, 0.1 do
  	swait()
  	local Alpha = .3
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0.2,0.1,-0.3)*angles(math.rad(-25.9),math.rad(31.7),math.rad(14.2))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-0.9,-1,0.1)*angles(math.rad(-2.2),math.rad(33),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1.3,-1.1,0)*angles(math.rad(29.3),math.rad(-35.4),math.rad(4.6))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.6,0.5,-0.2)*angles(math.rad(-33),math.rad(-11.6),math.rad(-35.4)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.3,0.6,-0.6)*angles(math.rad(99.5),math.rad(29.3),math.rad(-6.7)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(-0.1,0,-0.1)*angles(math.rad(-0.5),math.rad(-39.2),math.rad(-4.1))*necko,Alpha)
		  end
					elseif Combo == 3 then
		Combo = 1
		 for i = 0, 2, 0.1 do
  	swait()
local Alpha = .3
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0.1)*angles(math.rad(11.1),math.rad(-0.2),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,0.1)*angles(math.rad(-11.9),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,0.3,-0.6)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.6,0.6,0)*angles(math.rad(0),math.rad(0),math.rad(-18.4)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.6,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(12.8)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,0.3)*angles(math.rad(-10.2),math.rad(0),math.rad(0))*necko,Alpha)
	  end
									      local v = Instance.new("BodyVelocity",root)
          v.Velocity = root.CFrame.lookVector + root.CFrame.lookVector*2.5
             v.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
game:GetService("Debris"):AddItem(v,.2)
MagniDamage(rleg,4,10,25,0,"Normal")

  for i = 0, 1, 0.1 do
  	swait()
  	local Alpha = .3
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,-0.1,0.1)*angles(math.rad(16.8),math.rad(-0.2),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-0.9,0.2)*angles(math.rad(-18.8),math.rad(18.2),math.rad(3.9))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-1.2,-0.4)*angles(math.rad(96.2),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.6,0.3,0.1)*angles(math.rad(-17),math.rad(0.2),math.rad(-18.4)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.6,0.2,0.1)*angles(math.rad(-17),math.rad(0.2),math.rad(12.9)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,0.3)*angles(math.rad(-10.2),math.rad(0),math.rad(0))*necko,Alpha)
  end
	end
	hum.WalkSpeed = 16
attack = false
end	
	
function attackone()
attack = true
hum.WalkSpeed = 3.5
  for i = 0, 2, 0.1 do
  	swait()
  	local Alpha = .3
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,-0.1)*angles(math.rad(-6.5),math.rad(23.5),math.rad(2.3))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-0.9,-1,0)*angles(math.rad(-1.8),math.rad(17.6),math.rad(-3.4))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1.1,-1,0)*angles(math.rad(-16.6),math.rad(-36.7),math.rad(-12.1))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.5,-0.3,0.3)*angles(math.rad(128.1),math.rad(-32.1),math.rad(-10.6)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.3,0.4,0.2)*angles(math.rad(-29.3),math.rad(-35.2),math.rad(-13.6)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,0)*angles(math.rad(-1),math.rad(-26.1),math.rad(1.9))*necko,Alpha)
	  end
									      local v = Instance.new("BodyVelocity",root)
          v.Velocity = root.CFrame.lookVector + root.CFrame.lookVector*2.5
             v.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
game:GetService("Debris"):AddItem(v,.2)
MagniDamage(larm,4,10,25,0,"Normal")

  for i = 0, 1, 0.1 do
  	swait()
  	local Alpha = .3
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0.1,0,-0.2)*angles(math.rad(-15),math.rad(-21.9),math.rad(-2.3))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,-0.2)*angles(math.rad(-16.8),math.rad(17.8),math.rad(1.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(0.9,-1,0.3)*angles(math.rad(5.4),math.rad(-38.4),math.rad(1.3))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.3,0.4,-0.8)*angles(math.rad(72.8),math.rad(-32.7),math.rad(18.4)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.4,0.5,0.3)*angles(math.rad(-29.3),math.rad(-35.2),math.rad(7.1)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,0)*angles(math.rad(-2.4),math.rad(19.4),math.rad(1.8))*necko,Alpha)
  end
hum.WalkSpeed = 16
attack = false
end
function attacktwo()
attack = true
hum.WalkSpeed = 3.5
  for i = 0, 2, 0.1 do
  	swait()
  	local Alpha = .3
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0.1,0,-0.1)*angles(math.rad(-0.4),math.rad(15.7),math.rad(6.7))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-0.9,-1,0.2)*angles(math.rad(10),math.rad(16.5),math.rad(-6.9))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(0.9,-1,0.3)*angles(math.rad(5.4),math.rad(-38.4),math.rad(1.3))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.5,0.7,-0.3)*angles(math.rad(-1.4),math.rad(-29),math.rad(-24)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,0.1,0.5)*angles(math.rad(99.5),math.rad(29.3),math.rad(35.1)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,0)*angles(math.rad(-1.2),math.rad(-20.5),math.rad(1.8))*necko,Alpha)
	  end
									      local v = Instance.new("BodyVelocity",root)
          v.Velocity = root.CFrame.lookVector + root.CFrame.lookVector*2.5
             v.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
game:GetService("Debris"):AddItem(v,.2)
MagniDamage(rarm,4,10,25,0,"Normal")

  for i = 0, 1, 0.1 do
  	swait()
  	local Alpha = .3
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0.2,0.1,-0.3)*angles(math.rad(-25.9),math.rad(31.7),math.rad(14.2))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-0.9,-1,0.1)*angles(math.rad(-2.2),math.rad(33),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1.3,-1.1,0)*angles(math.rad(29.3),math.rad(-35.4),math.rad(4.6))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.6,0.5,-0.2)*angles(math.rad(-33),math.rad(-11.6),math.rad(-35.4)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.3,0.6,-0.6)*angles(math.rad(99.5),math.rad(29.3),math.rad(-6.7)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(-0.1,0,-0.1)*angles(math.rad(-0.5),math.rad(-39.2),math.rad(-4.1))*necko,Alpha)
  end
hum.WalkSpeed = 16
attack = false
end
function attackthree()
attack = true
hum.WalkSpeed = 3.5
  for i = 0, 2, 0.1 do
  	swait()
local Alpha = .3
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0.1)*angles(math.rad(11.1),math.rad(-0.2),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,0.1)*angles(math.rad(-11.9),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,0.3,-0.6)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.6,0.6,0)*angles(math.rad(0),math.rad(0),math.rad(-18.4)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.6,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(12.8)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,0.3)*angles(math.rad(-10.2),math.rad(0),math.rad(0))*necko,Alpha)
	  end
									      local v = Instance.new("BodyVelocity",root)
          v.Velocity = root.CFrame.lookVector + root.CFrame.lookVector*2.5
             v.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
game:GetService("Debris"):AddItem(v,.2)
MagniDamage(rleg,4,10,25,0,"Normal")

  for i = 0, 1, 0.1 do
  	swait()
  	local Alpha = .3
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,-0.1,0.1)*angles(math.rad(16.8),math.rad(-0.2),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-0.9,0.2)*angles(math.rad(-18.8),math.rad(18.2),math.rad(3.9))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-1.2,-0.4)*angles(math.rad(96.2),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.6,0.3,0.1)*angles(math.rad(-17),math.rad(0.2),math.rad(-18.4)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.6,0.2,0.1)*angles(math.rad(-17),math.rad(0.2),math.rad(12.9)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,0.3)*angles(math.rad(-10.2),math.rad(0),math.rad(0))*necko,Alpha)
  end
hum.WalkSpeed = 16
attack = false
end
local FunnyEff = script.Spherething
FunnyEff.Parent = nil


	

function Healeatepic()
	attack = true
	CFuncs["Sound"].Create("rbxassetid://444895479", root, 5, 1)
	for i = 0, 1, 0.1 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-30)), 0.4)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(20 - 2.5 * Sin(sine / 20)), Rad(0), Rad(-20)), 0.4)
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(0 - 2 * math.cos(sine / 32))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(0 + 2 * math.cos(sine / 32))),.1)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.4 + 0.05 * Sin(sine / 20)* Player_Size, 0.1* Player_Size) * angles(Rad(-10), Rad(0), Rad(-20)), 0.4)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(10)), 0.4)
	end
		for i = 0, 4, 0.1 do
		swait()
		RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)* angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 - 3 * math.cos(sine / 34))),.1)
                    LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0) * angles(math.rad(0),math.rad(-90),math.rad(0)) * angles(math.rad(-2.5),math.rad(20 - 3 * math.cos(sine / 56)),math.rad(0 + 3 * math.cos(sine / 34))),.1)
                    RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.03 * math.cos(sine / 34),0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0 - 3 * math.cos(sine / 34)),math.rad(0),math.rad(-20 + 3 * math.cos(sine / 56))),.1)
                    Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 3.5 * math.cos(sine / 33)),math.rad(0 + 4 * math.cos(sine / 63)),math.rad(20 - 3 * math.cos(sine / 56))),.1)
					RW.C0 = clerp(RW.C0, cf(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 8)* Player_Size, 0) * angles(Rad(75) + root.RotVelocity.Y / 75, Rad(0), Rad(10) + root.RotVelocity.Y / -75), 0.1)
LW.C0=clerp(LW.C0,CFrame.new(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(5 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(-8 - 3 * math.cos(sine / 45))),.1)			
		
		
	end
	attack = false
	
end






function Mewhenhugg()
attack = true
hum.WalkSpeed = 5
local rsiz = math.random(5,15)
for i = 0, 2, 0.1 do
swait()
                RootJoint.C0 = clerp(RootJoint.C0, RootCF * CFrame.new(0 + 0 * math.cos(sine / 40), 0, -0.1 + 0.04 * math.cos(sine / 20)) * angles(math.rad(0 - 2.5 * math.sin(sine / 40)), math.rad(0 + 0 * math.cos(sine / 40)), math.rad(0)), .1)
                                    RH.C0 = clerp(RH.C0, CFrame.new(1 + 0 * math.cos(sine / 40) , -1  - 0.04  * math.cos(sine / 20), 0 ) * angles(math.rad(0), math.rad(94), math.rad(0)) * angles(math.rad(-4.5 + 0 * math.sin(sine / 40)), math.rad(-10), math.rad(-5 - 1.5 * math.sin(sine / 40))), .1)
                LH.C0 = clerp(LH.C0, CFrame.new(-1 + 0 * math.cos(sine / 40) , -1  - 0.04  * math.cos(sine / 20), 0 ) * angles(math.rad(0), math.rad(-84), math.rad(0)) * angles(math.rad(0 - 0 * math.sin(sine / 40)), math.rad(10), math.rad(5 + 2.5 * math.sin(sine / 40))), .1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 2.5 * math.cos(sine / 28)),math.rad(10),math.rad(0)),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(110),math.rad(0),math.rad(40)),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(110),math.rad(0),math.rad(-40)),.3)
end
	local hb = CreateParta(char,1,1,"SmoothPlastic",BrickColor.random())
	hb.Anchored = true
	hb.CFrame = root.CFrame*CFrame.new(0,1,0) + root.CFrame.lookVector*2
local ThePlayer = nil
local act = false
local alreadydid = false
for i = 0, 3, 0.1 do
swait()
if act == false then
for i, v in pairs(FindNearestHead(hb.CFrame.p, 1.25)) do
if v:FindFirstChild('Head') then
if alreadydid == false then
ThePlayer = v
						hum.WalkSpeed = 0
ThePlayer:WaitForChild("Torso").Anchored = true						
root.Anchored = true
alreadydid = true
act = true
print(ThePlayer.Name)
end
end
end
hb.CFrame = root.CFrame*CFrame.new(0,0,0) 
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 2.5 * math.cos(sine / 28)),math.rad(10),math.rad(0)),.3)
elseif act == true then

rsiz = math.random(5,15)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 2.5 * math.cos(sine / 28)),math.rad(10),math.rad(40)),.1)
ThePlayer.Head.CFrame = root.CFrame*CFrame.new(0,2.25,-1.25)*CFrame.Angles(0,math.rad(180),0)
		ThePlayer.Torso.CFrame = root.CFrame*CFrame.new(.3,-.1,-1)*CFrame.Angles(0,math.rad(180),0)
	
		end
                RootJoint.C0 = clerp(RootJoint.C0, RootCF * CFrame.new(0 + 0 * math.cos(sine / 40), 0, -0.1 + 0.04 * math.cos(sine / 20)) * angles(math.rad(0 - 2.5 * math.sin(sine / 40)), math.rad(0 + 0 * math.cos(sine / 40)), math.rad(0)), .1)
                                    RH.C0 = clerp(RH.C0, CFrame.new(1 + 0 * math.cos(sine / 40) , -1  - 0.04  * math.cos(sine / 20), 0 ) * angles(math.rad(0), math.rad(94), math.rad(0)) * angles(math.rad(-4.5 + 0 * math.sin(sine / 40)), math.rad(-10), math.rad(-5 - 1.5 * math.sin(sine / 40))), .1)
                LH.C0 = clerp(LH.C0, CFrame.new(-1 + 0 * math.cos(sine / 40) , -1  - 0.04  * math.cos(sine / 20), 0 ) * angles(math.rad(0), math.rad(-84), math.rad(0)) * angles(math.rad(0 - 0 * math.sin(sine / 40)), math.rad(10), math.rad(5 + 2.5 * math.sin(sine / 40))), .1)
RW.C0=clerp(RW.C0,cf(1,0.7,-1)*angles(math.rad(120),math.rad(0),math.rad(-50)),.3)
LW.C0=clerp(LW.C0,cf(-1,0.7,-1)*angles(math.rad(100),math.rad(0),math.rad(50)),.3)
end
hb:Destroy()
	if act == true then
		coroutine.resume(coroutine.create(function()
		
			local Heart = Instance.new("Part",Character)
            Heart.Size=Vector3.new(2.15,2.13,.59)
            Heart.CanCollide=false
           Heart.Anchored=true
             Heart.BrickColor=BrickColor.new'Pink'
            Heart.Material=Enum.Material.Neon
   Heart.CFrame = Torso.CFrame* CFrame.new(0,-1,0)
			
			local HeartMesh = Instance.new("SpecialMesh",Heart)
			HeartMesh.MeshType = Enum.MeshType.FileMesh 
	HeartMesh.MeshId = "rbxassetid://431221914"
	HeartMesh.TextureId = "" 
	HeartMesh.Scale = Vector3.new(.5,.5,.2)
	HeartMesh.Offset = Vector3.new(0,0,0)
	
	HeartMesh.Parent = Heart
			coroutine.wrap(function()
			local speed = .35
			for i = 0, 6, .1 do
				speed = speed - (.5/60)
				Heart.CFrame = Heart.CFrame * cf(0,speed,0)
				Heart.Transparency = math.max(1-i/3,0)
				swait()
			end
			delay(1, function()
				for i = 0, 3, .1 do
					Heart.Transparency = i/3
					swait()
				end
				Heart:destroy()
			end)
			
			end)()
		end))
		CFuncs["Sound"].Create("rbxassetid://1508144905", root, 1, 1)
	--	Sound(Torso,270763316,1,5,false,true,true)
for x = 0, 4 do
for i = 0, 2, 0.1 do
swait()

Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 2.5 * math.cos(sine / 28)),math.rad(10),math.rad(45)),.1)
ThePlayer.Head.CFrame = root.CFrame*CFrame.new(0,2.25,-1.25)*CFrame.Angles(0,math.rad(180),0)
						ThePlayer.Torso.CFrame = root.CFrame*CFrame.new(.3,-.1,-1)*CFrame.Angles(0,math.rad(180),0)

				                RootJoint.C0 = clerp(RootJoint.C0, RootCF * CFrame.new(0 + 0 * math.cos(sine / 40), 0, -0.1 + 0.04 * math.cos(sine / 20)) * angles(math.rad(0 - 2.5 * math.sin(sine / 40)), math.rad(0 + 0 * math.cos(sine / 40)), math.rad(0)), .1)
                                    RH.C0 = clerp(RH.C0, CFrame.new(1 + 0 * math.cos(sine / 40) , -1  - 0.04  * math.cos(sine / 20), 0 ) * angles(math.rad(0), math.rad(94), math.rad(0)) * angles(math.rad(-4.5 + 0 * math.sin(sine / 40)), math.rad(-10), math.rad(-5 - 1.5 * math.sin(sine / 40))), .1)
                LH.C0 = clerp(LH.C0, CFrame.new(-1 + 0 * math.cos(sine / 40) , -1  - 0.04  * math.cos(sine / 20), 0 ) * angles(math.rad(-97), math.rad(-84), math.rad(0)) * angles(math.rad(0 - 0 * math.sin(sine / 40)), math.rad(10), math.rad(5 + 2.5 * math.sin(sine / 40))), .1)
RW.C0=clerp(RW.C0,cf(1,0.7,-1)*angles(math.rad(120),math.rad(0),math.rad(-50)),.3)
LW.C0=clerp(LW.C0,cf(-1,0.7,-1)*angles(math.rad(100),math.rad(0),math.rad(50)),.3)
			end
for i = 0, 2, 0.1 do
swait()
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 2.5 * math.cos(sine / 28)),math.rad(10),math.rad(35)),.1)
ThePlayer.Head.CFrame = root.CFrame*CFrame.new(0,2.25,-1.25)*CFrame.Angles(0,math.rad(180),0)
						ThePlayer.Torso.CFrame = root.CFrame*CFrame.new(.3,-.1,-1)*CFrame.Angles(0,math.rad(180),0)
 
				               RootJoint.C0 = clerp(RootJoint.C0, RootCF * CFrame.new(0 + 0 * math.cos(sine / 40), 0, -0.1 + 0.04 * math.cos(sine / 20)) * angles(math.rad(0 - 2.5 * math.sin(sine / 40)), math.rad(0 + 0 * math.cos(sine / 40)), math.rad(0)), .1)
                                    RH.C0 = clerp(RH.C0, CFrame.new(1 + 0 * math.cos(sine / 40) , -1  - 0.04  * math.cos(sine / 20), 0 ) * angles(math.rad(0), math.rad(94), math.rad(0)) * angles(math.rad(-4.5 + 0 * math.sin(sine / 40)), math.rad(-10), math.rad(-5 - 1.5 * math.sin(sine / 40))), .1)
                LH.C0 = clerp(LH.C0, CFrame.new(-1 + 0 * math.cos(sine / 40) , -1  - 0.04  * math.cos(sine / 20), 0 ) * angles(math.rad(-97), math.rad(-84), math.rad(0)) * angles(math.rad(0 - 0 * math.sin(sine / 40)), math.rad(10), math.rad(5 + 2.5 * math.sin(sine / 40))), .1)
RW.C0=clerp(RW.C0,cf(1,0.7,-1)*angles(math.rad(120),math.rad(0),math.rad(-50)),.3)
LW.C0=clerp(LW.C0,cf(-1,0.7,-1)*angles(math.rad(100),math.rad(0),math.rad(50)),.3)
end
end
end
hum.WalkSpeed = 16
	root.Anchored = false
	
		--	ThePlayer:WaitForChild("Torso").Anchored = false

if act == true then
coroutine.resume(coroutine.create(function()
ThePlayer:WaitForChild("Torso").Anchored = false
end))
end
hum.WalkSpeed = 16
attack = false
end




musictype = "Torso"
musicsetting = false

mouse.Button1Down:connect(function()
	if attack == false then
ComboPunch()
end
end)
mouse.KeyDown:connect(function(k)

	if k == "q" and Mode ~= 1 then
Mode = 1
Rename("IMMACULATE",Color3.fromRGB(18, 238, 212),Color3.fromRGB(255,255,255))
        ORGID = 2606277947
		UI.MainFrameLol.SongName.Text = "Kuroketei - Chronostasis"
				if math.random(1,2) == 1 then
        ORGID = 2606277947
		UI.MainFrameLol.SongName.Text = "Kuroketei - Chronostasis"
else
		UI.MainFrameLol.SongName.Text = "Camellia - Completeness Under Incompleteness"
		        ORGID = 2127419486
end
		 recolorwings(Color3.fromRGB(18, 238, 212),Color3.fromRGB(255,255,255))
	end
			if k == "m" and Mode == 1 then
Mode = 1.5
Rename("ALTERATION",Color3.fromRGB(248, 248, 248),Color3.fromRGB(255, 102, 204))
ORGID = 265293315
		UI.MainFrameLol.SongName.Text = "ICE - Entrance"
		 recolorwings(Color3.fromRGB(248, 248, 248),Color3.fromRGB(255, 102, 204))
	end
	if k == "e" and Mode ~= 2 then
		Mode = 2
		Rename("IMPERFECTION",Color3.fromRGB(90, 45, 45),Color3.fromRGB(180,90,90))
		UI.MainFrameLol.SongName.Text = "Frums - Credits (Extended)"
		ORGID = 3089991101
		recolorwings(Color3.fromRGB(90, 45, 45),Color3.fromRGB(180,90,90))
	end
				if k == "m" and Mode == 2 then
Mode = 2.5
Rename("EXCLUSION",Color3.fromRGB(151, 0, 0),Color3.fromRGB(27, 42, 53))
ORGID = 7148793448
			UI.MainFrameLol.SongName.Text = "Camellia - Tentaclar Aliens' Epic Extraterretterrestrial Jungle Dance Party"
		 recolorwings(Color3.fromRGB(151, 0, 0),Color3.fromRGB(27, 42, 53))
	end
if k == "r" and Mode ~= 3 then
		Mode = 3
		Rename("EMPATHY",Color3.fromRGB(45, 90, 45),Color3.fromRGB(90,180,90))
		UI.MainFrameLol.SongName.Text = "Creo - Challenger"
		        ORGID = 5213037495
		recolorwings(Color3.fromRGB(45, 90, 45),Color3.fromRGB(90,180,90))
	end
					if k == "m" and Mode == 3 then
Mode = 3.5
Rename("ESTAVIUS",Color3.fromRGB(63, 143, 41),Color3.fromRGB(112, 255, 73))
ORGID = 719386809
		UI.MainFrameLol.SongName.Text = "Schtiffles - Ghost house"
		 recolorwings(Color3.fromRGB(63, 143, 41),Color3.fromRGB(112, 255, 73))
	end
	if k == "t" and Mode ~= 4 then
		Mode = 4
		Rename("AFFECTIONATE",Color3.fromRGB(255, 0, 191),Color3.fromRGB(255, 102, 204))
		UI.MainFrameLol.SongName.Text = "Fearofdark - Rolling Down the Street, In My Katamari"
		ORGID = 3233069375
		recolorwings(Color3.fromRGB(255, 0, 191),Color3.fromRGB(255, 102, 204))
	end
if k == "y" and Mode ~= 5 then
		Mode = 5
		Rename("#1F1E33",Color3.fromRGB(31, 30, 51),Color3.fromRGB(62,60,102))
		UI.MainFrameLol.SongName.Text = "Camellia -#1F1e33 "
		        ORGID = 5104120380
		recolorwings(Color3.fromRGB(31, 30, 51),Color3.fromRGB(62,60,102))
	end
	if k == "u" and Mode ~= 6 then
		Mode = 6
		Rename("REFLECTIONS",Color3.fromRGB(104, 104, 0),Color3.fromRGB(207, 207, 0))
		UI.MainFrameLol.SongName.Text = "Creo - Shine"
		        ORGID = 4388884061
		recolorwings(Color3.fromRGB(104, 104, 0),Color3.fromRGB(207, 207, 0))
	end
		if k == "f" and Mode ~= 7 then
		Mode = 7
		Rename("LIGHTMARE",Color3.fromRGB(107, 55, 30),Color3.fromRGB(213, 115, 61))
		UI.MainFrameLol.SongName.Text = "Shirobon - Perfect Machine"
		        ORGID = 3253610513
		recolorwings(Color3.fromRGB(107, 55, 30),Color3.fromRGB(213, 115, 61))
	end
			if k == "g" and Mode ~= 8 then
		Mode = 8
		Rename("MATERIA",Color3.fromRGB(255, 255, 255),Color3.fromRGB(0, 0, 0))
		UI.MainFrameLol.SongName.Text = "Cryono77 - TM3"
		        ORGID = 751778552
		if math.random(1,2) == 1 then
		UI.MainFrameLol.SongName.Text = "Cryono77 - TM3"
		        ORGID = 751778552
else
		UI.MainFrameLol.SongName.Text = "Dimrain47 - The Disturbance"
		        ORGID = 4586618716
end
		recolorwings(Color3.fromRGB(255, 255, 255),Color3.fromRGB(0, 0, 0))
	end
	if k == "z" and attack == false and Mode == 3 then
		Boost()
	end
		if k == "z" and attack == false and Mode == 4 then
		Mewhenhugg()
	end
		if k == "9" and attack == false  then
	local ParticleEmitter1 = Instance.new("ParticleEmitter",tors)
ParticleEmitter1.Transparency = NumberSequence.new(0.5,1,1)
ParticleEmitter1.Size = NumberSequence.new(0,4.0838565826416,7.5078544616699,10.347219467163,12.672625541687,14.550189971924,16.041475296021,17.203493118286,18.08869934082,18.744993209839,19.215721130371,19.539680480957,19.751104354858,19.879682540894,19.950540542603,19.984256744385,19.996852874756,19.999795913696,20,20)
ParticleEmitter1.Color = ColorSequence.new(Color3.new(0.196078, 1, 0.196078),Color3.new(0.196078, 1, 0.196078))
ParticleEmitter1.Enabled = false
ParticleEmitter1.LightEmission = 1
ParticleEmitter1.Texture = "rbxassetid://1084965356"
ParticleEmitter1.Lifetime = NumberRange.new(0.60000002384186, 0.60000002384186)
ParticleEmitter1.Rate = 1000
ParticleEmitter1.Speed = NumberRange.new(0, 0)
ParticleEmitter1.Color = ColorSequence.new(Color3.new(0.196078, 1, 0.196078),Color3.new(0.196078, 1, 0.196078))
	local ParticleEmitter2 = Instance.new("ParticleEmitter",tors)
--ParticleEmitter2.Name = "Icon"
--ParticleEmitter2.Parent = Folder0
ParticleEmitter2.Transparency = NumberSequence.new(0,0,1)
ParticleEmitter2.Size = NumberSequence.new(1,1)
ParticleEmitter2.Color = ColorSequence.new(Color3.new(0.196078, 1, 0.196078),Color3.new(0.196078, 1, 0.196078))
ParticleEmitter2.Enabled = true
ParticleEmitter2.LightEmission = 1
ParticleEmitter2.Texture = "rbxassetid://1084979589"
ParticleEmitter2.Acceleration = Vector3.new(0, 10, 0)
ParticleEmitter2.Lifetime = NumberRange.new(0.69999998807907, 1)
ParticleEmitter2.Rate = 1000
ParticleEmitter2.Speed = NumberRange.new(50, 50)
ParticleEmitter2.VelocitySpread = 90
ParticleEmitter2.Color = ColorSequence.new(Color3.new(0.196078, 1, 0.196078),Color3.new(0.196078, 1, 0.196078))
local ParticleEmitter4 = Instance.new("ParticleEmitter",tors)
ParticleEmitter4.Transparency = NumberSequence.new(0.75,1,1)
ParticleEmitter4.Size = NumberSequence.new(3,3)
ParticleEmitter4.Color = ColorSequence.new(Color3.new(0.392157, 1, 0.392157),Color3.new(0.392157, 1, 0.392157))
ParticleEmitter4.Enabled = true
ParticleEmitter4.LightEmission = 1
ParticleEmitter4.Texture = "rbxassetid://867619398"
ParticleEmitter4.ZOffset = 1.5
ParticleEmitter4.Lifetime = NumberRange.new(1, 1)
ParticleEmitter4.Rate = 1000
ParticleEmitter4.Speed = NumberRange.new(50, 50)
ParticleEmitter4.VelocitySpread = 90
ParticleEmitter4.Color = ColorSequence.new(Color3.new(0.392157, 1, 0.392157),Color3.new(0.392157, 1, 0.392157))

wait(.15)
coroutine.wrap(function()
    ParticleEmitter1.Enabled = false
ParticleEmitter2.Enabled = false
ParticleEmitter4.Enabled = false
wait(5)
ParticleEmitter1:Remove()
ParticleEmitter2:Remove()
ParticleEmitter4:Remove()
end)()
	end
	
if k=="l" and musicsetting==false then
if musictype=="Torso" then
musictype="None"
musicsetting=true
coroutine.resume(coroutine.create(function()
for i=2,-.1,-.04 do
swait()
					AlicusTheme.Volume=i
					volchoice =i
end
				AlicusTheme.Volume=0
				volchoice = 0
print'Music Setted to None'
musicsetting=false
end))
elseif musictype=="None" then	
musictype="Torso"
musicsetting=true
AlicusTheme.Parent=Torso
coroutine.resume(coroutine.create(function()
for i=0,2,.04 do
swait()
					AlicusTheme.Volume=i
					volchoice = i
end
				AlicusTheme.Volume=2
				volchoice = 2
musicsetting=false
end))
		end
		end
end)

------Funny stuff
function Weld2(part0,part1,c0,c1)
	local weld = Instance.new("Weld")
	weld.Parent = part0
	weld.Part0 = part0
	weld.Part1 = part1
	weld.C0 = c0 or cf()
	weld.C1 = c1 or cf()
	return weld
end






-------------------------------------
local CurId = 1
Humanoid.Animator.Parent = nil
char.Animate.Parent = nil
local CD1=false
local CD3=false
local CD2=false

-------------------------------------






local SwimType = 1
aerrtee = 0


local hh = (char['Right Leg'].Size.Y+char.HumanoidRootPart.Size.Y/2)

local smokepart = Instance.new('Part',root)
smokepart.Size = Vector3.new(0.5,0,1.5)
smokepart.CanCollide = false
smokepart.Transparency = 1
local skpartweld = Instance.new('Weld',smokepart)
skpartweld.Part0 = smokepart
skpartweld.Part1 = root
skpartweld.C0 = CFrame.new(0,hh,0)
local smokt = Instance.new("ParticleEmitter")
smokt.Acceleration = Vector3.new(0, 2.5, 0)
smokt.Speed = NumberRange.new(1)
smokt.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 1),NumberSequenceKeypoint.new(1, 1.5)})
smokt.SpreadAngle = Vector2.new(100, 100)
smokt.Lifetime = NumberRange.new(1)
smokt.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.55), NumberSequenceKeypoint.new(0.429, 0.319), NumberSequenceKeypoint.new(0.749, 0.856), NumberSequenceKeypoint.new(1, 1)})
smokt.Drag = 1
smokt.Color = ColorSequence.new(Color3.new(0.737255, 0.737255, 0.737255), Color3.new(1, 1, 1))
smokt.RotSpeed = NumberRange.new(10)
smokt.Texture = "http://www.roblox.com/asset/?id=2263365802"
smokt.Parent = smokepart
smokt.Enabled = false

Humanoid.MaxHealth = "500"
Humanoid.Health = "500"




	hum.BreakJointsOnDeath = true
	if Humanoid.Health == 0 then 
	print("dead")
	end


local ChangeMode = false

--[Head movement core]

local Ang = CFrame.Angles
local aSin = math.asin
local aTan = math.atan

--[Constants]:

local Cam = cam
headmovementenabled = true
local Plr = plr
--local Mouse = mouse
local Body = workspace.Camera.CameraSubject.Parent
local Head = hed
local Hum = hum
local Core = Body:WaitForChild("HumanoidRootPart")
local IsR6 = (Hum.RigType.Value==0)
local Trso = (IsR6 and Body:WaitForChild("Torso")) or Body:WaitForChild("UpperTorso")
local Neck = (IsR6 and Trso:WaitForChild("Neck")) or Head:WaitForChild("Neck")
local Waist = (not IsR6 and Trso:WaitForChild("Waist"))
local MseGuide = true
local TurnCharacterToMouse = false
local HeadHorFactor = 1
local HeadVertFactor = 0.6
local BodyHorFactor = 0.5
local BodyVertFactor = 0.4
local UpdateSpeed = 0.1

local NeckOrgnC0 = Neck.C0
local WaistOrgnC0 = (not IsR6 and Waist.C0)

--[Setup]:
freefall = 0
Neck.MaxVelocity = 1/3

-- Activation]:
if TurnCharacterToMouse == true then
	MseGuide = true
	HeadHorFactor = 0
	BodyHorFactor = 0
end
game:GetService("RunService").Stepped:Connect(function()
	if headmovementenabled then
	local CamCF = Cam.CoordinateFrame
	if ((IsR6 and Body["Torso"]) or Body["UpperTorso"])~=nil and Body["Head"]~=nil then	
		local TrsoLV = Trso.CFrame.lookVector
		local HdPos = Head.CFrame.p
		if IsR6 and Neck or Neck and Waist then
			if UpdateSpeed == 0.1 then
				local Dist = nil;
				local Diff = nil;
				if not MseGuide then	
					Dist = (Head.CFrame.p-CamCF.p).magnitude
					Diff = Head.CFrame.Y-CamCF.Y
					if not IsR6 then
						Neck.C0 = Neck.C0:lerp(NeckOrgnC0*Ang((aSin(Diff/Dist)*HeadVertFactor), -(((HdPos-CamCF.p).Unit):Cross(TrsoLV)).Y*HeadHorFactor, 0), UpdateSpeed/2)
						Waist.C0 = Waist.C0:lerp(WaistOrgnC0*Ang((aSin(Diff/Dist)*BodyVertFactor), -(((HdPos-CamCF.p).Unit):Cross(TrsoLV)).Y*BodyHorFactor, 0), UpdateSpeed/2)
					else
						Neck.C0 = Neck.C0:lerp(NeckOrgnC0*Ang(-(aSin(Diff/Dist)*HeadVertFactor), 0, -(((HdPos-CamCF.p).Unit):Cross(TrsoLV)).Y*HeadHorFactor),UpdateSpeed/2)
					end
				else
					local Point = mouse.Hit.p
					Dist = (Head.CFrame.p-Point).magnitude
					Diff = Head.CFrame.Y-Point.Y
					if not IsR6 then
						--Neck.C0 = Neck.C0:lerp(NeckOrgnC0*Ang(-(aTan(Diff/Dist)*HeadVertFactor), (((HdPos-Point).Unit):Cross(TrsoLV)).Y*HeadHorFactor, 0), UpdateSpeed/2)
					Neck.C0 = Torso.Neck.C0:lerp(NeckOrgnC0*CFrame.Angles((math.tan(Diff/Dist)*1), 0, (((Head.CFrame.p-Point).Unit):Cross(Torso.CFrame.lookVector)).Y*1), UpdateSpeed/1.8)

						Waist.C0 = Waist.C0:lerp(WaistOrgnC0*Ang(-(aTan(Diff/Dist)*BodyVertFactor), (((HdPos-Point).Unit):Cross(TrsoLV)).Y*BodyHorFactor, 0), UpdateSpeed/2)
					else
										Neck.C0 = Torso.Neck.C0:lerp(NeckOrgnC0*CFrame.Angles((math.tan(Diff/Dist)*1), 0, (((Head.CFrame.p-Point).Unit):Cross(Torso.CFrame.lookVector)).Y*1), UpdateSpeed/1.8)

					--	Neck.C0 = Neck.C0:lerp(NeckOrgnC0*Ang((aTan(Diff/Dist)*HeadVertFactor), 0, (((HdPos-Point).Unit):Cross(TrsoLV)).Y*HeadHorFactor), UpdateSpeed/2)
					end
				end
			end
		end
	end
	if TurnCharacterToMouse == true then
		Hum.AutoRotate = false
		Core.CFrame = Core.CFrame:lerp(CFrame.new(Core.Position, Vector3.new(Mouse.Hit.p.x, Core.Position.Y, Mouse.Hit.p.z)), UpdateSpeed / 2)
	else
		Hum.AutoRotate = true
	end
	end
end)



function SetTween(SPart,CFr,MoveStyle2,outorin2,AnimTime)
local MoveStyle = Enum.EasingStyle[MoveStyle2]
local outorin = Enum.EasingDirection[outorin2]
local tweeningInformation = TweenInfo.new(
	AnimTime,	
	MoveStyle,
	outorin,
	0,
	false,
	0
)
local MoveCF = CFr
local tweenanim = game:GetService("TweenService"):Create(SPart,tweeningInformation,MoveCF)
tweenanim:Play()
end
--Properties:
so = function(id, par, vol, pit)

CFuncs["Sound"].Create("rbxassetid://"..id, par, vol, pit)

end
rval = 0
local rotationa = 0

local Funnyfly = false





idleanim=.4
while true do
CameraManager()
swait()
if kHold == true then
local LookVector = CFrame.new(RootPart.Position, mouse.Hit.p).lookVector
RootPart.CFrame = RootPart.CFrame:lerp(CFrame.new(RootPart.Position) * CFrame.Angles(math.rad(0), math.rad(math.deg((math.atan2(LookVector.x, LookVector.z))) - 180), math.rad(0)), 0.5)
end
doe=doe+1
 sine = sine + change

	if AlicusTheme ~= nil then
		AlicusTheme.Parent = tors
		AlicusTheme.Volume = volchoice
		AlicusTheme.Looped = true
		AlicusTheme.Pitch = 1
		AlicusTheme.EmitterSize = 10
		AlicusTheme.Name = "AlicusTheme"
		if AlicusTheme.SoundId ~= "rbxassetid://"..ORGID then
			AlicusTheme.SoundId = "rbxassetid://"..ORGID
		end
end	

	local sidevec = math.clamp((root.Velocity*root.CFrame.rightVector).X+(root.Velocity*root.CFrame.rightVector).Z,-hum.WalkSpeed,hum.WalkSpeed)
	local forwardvec =  math.clamp((root.Velocity*root.CFrame.lookVector).X+(root.Velocity*root.CFrame.lookVector).Z,-hum.WalkSpeed,hum.WalkSpeed)
	local sidevelocity = sidevec/hum.WalkSpeed
	local forwardvelocity = forwardvec/hum.WalkSpeed

if attack == true then
	script.Attack.Value = true 
	else
	script.Attack.Value = false
end


if attack == true then
     smokt.Enabled = false 
end
local torvel=(RootPart.Velocity*Vector3.new(1,0,1)).magnitude 
local velderp=RootPart.Velocity.y
hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
if equipped==true or equipped==false then
if attack==false then
idle=idle+1
else
idle=0
end
if idle>=500 then
if attack==false then
end
end
if Anim == "Walk" and hitfloor then	
if attack == false then
nextstep = math.cos(sine / 8)
if nextstep > -0.1 and nextstep < 0.1 and CanUseWalkSound == true and Mode ~= 2 and Mode ~= 3 and Mode ~= 3.5 then
	CanUseWalkSound = false
local MaterialName = hitfloor.Material.Name
if MaterialName =="Plastic"or MaterialName =="SmoothPlastic"then
so("4085860640", Torso,1, math.random(30,60)/100)
elseif MaterialName =="Pebble"then
so("267882971", Torso,1, math.random(80,100)/100)
elseif MaterialName =="Marble"or MaterialName =="Granite"then
so("379483672", Torso,1, math.random(80,100)/100)
elseif MaterialName =="Grass"then
so("4085862552", Torso,1, math.random(90,100)/100)
elseif MaterialName =="Ice"then
so("265653271", Torso,1, math.random(70,90)/100)
elseif MaterialName =="Foil"then
so("4085885171", Torso,1, math.random(40,60)/100)
elseif MaterialName =="Concrete"or MaterialName =="Slate"or MaterialName =="Brick" then
so("267454199", Torso,1, math.random(80,100)/100)
elseif MaterialName =="Wood" or MaterialName =="WoodPlanks"then
so("4085869581", Torso,1, math.random(80,100)/100)
elseif MaterialName =="Sand" then
	so("4085867669", Torso,1, math.random(80,100)/100)
elseif MaterialName =="CorrodedMetal"or MaterialName =="Metal" or  MaterialName =="DiamondPlate" then
so("4085894561", Torso,1, math.random(80,100)/100)
elseif MaterialName =="Neon" or hitfloor.Transparency >0.1 then
so("145180170", Torso,1, math.random(80,100)/100)
end
coroutine.resume(coroutine.create(function()
wait(.2)
CanUseWalkSound = true	
end))
else	
end	
end
end
		coroutine.resume(coroutine.create(function()
if Mode == 2 or Mode == 3.5 then
				if hitfloor ~= nil then
					Funnyfly = true
	effar.Enabled = true
					effar.Color = ColorSequence.new(ae1.Color2.Color)
slash(math.random(40,70)/5,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.002,0.01),math.random(5,20)/250,BrickColor.new("White"))


elseif hitfloor == nil then
	effar.Enabled = false
end
elseif Mode ~= 2 or Mode ~= 3 or Mode ~= 5 then
				    effar.Enabled = false
				Funnyfly = true
			end
			if Mode == 2.5 then
				glw2.ImageTransparency = 0.75
						glw2.Position = UDim2.new(0,0,0.75+ 0.3 * math.cos(sine / 19),0)
		glw2.Size = UDim2.new(5,0,0.55,0)
				ToggleBloodTorso(0)
				ToggleEyeEffect(true)
			elseif Mode ~= 2.5 then
				glw2.ImageTransparency = 1
				ToggleEyeEffect(false)
				ToggleBloodTorso(1)
	end
end))	
		if Mode == 1 then
				sphereMK(2,math.random(5,10)/45,"Add",root.CFrame*CFrame.new(math.random(-3,3),-10,math.random(-3,3))*CFrame.Angles(math.rad(90 + math.random(-3,3)),math.rad(math.random(-3,3)),math.rad(math.random(-3,3))),0.5,0.5,0.5,0,BrickColor.new("Cyan"),0)	
							sphereMK(2,math.random(5,10)/45,"Add",root.CFrame*CFrame.new(math.random(-3,3),-10,math.random(-3,3))*CFrame.Angles(math.rad(90 + math.random(-3,3)),math.rad(math.random(-3,3)),math.rad(math.random(-3,3))),0.5,0.5,0.5,0,BrickColor.new("Institutional white"),0)	

			handleweld.C0=clerp(handleweld.C0,cf(0 + 0.25 * math.cos(sine / 63),0 + 0.25 * math.cos(sine / 70),-1 + 0.05 * math.cos(sine / 57))*angles(math.rad(0 + 2 * math.cos(sine / 55)),math.rad(0 + 2 * math.cos(sine / 46)),math.rad(0 + 2 * math.cos(sine / 32))),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(-10 + 18 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 + 5 * math.cos(sine / 56))),.3)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(-10 + 18 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(130 + 5 * math.cos(sine / 56))),.3)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(-10 + 18 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(50 + 5 * math.cos(sine / 56))),.3)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(-10 + 18 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 - 5 * math.cos(sine / 56))),.3)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(-10 + 18 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-130 - 5 * math.cos(sine / 56))),.3)
rwing3weld.C1=clerp(rwing3weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(-10 + 18 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-50 - 5 * math.cos(sine / 56))),.3)
			elseif Mode == 1.5 then
	sphereRotMK(5,math.random(15,50)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-50,50)),math.rad(math.random(-50,50)),math.rad(math.random(-50,50))),0.75,0.75,10,-0.0075,Color3.fromRGB(248, 248, 248),0)
	sphereRotMK(5,math.random(15,50)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-50,50)),math.rad(math.random(-50,50)),math.rad(math.random(-50,50))),0.75,0.75,10,-0.0075,Color3.fromRGB(255, 102, 204),0)   

						handleweld.C0=clerp(handleweld.C0,cf(0 + 0.25 * math.cos(sine / 63),0 + 0.25 * math.cos(sine / 70),-1 + 0.05 * math.cos(sine / 57))*angles(math.rad(0 + 2 * math.cos(sine / 55)),math.rad(0 + 2 * math.cos(sine / 46)),math.rad(0 + 2 * math.cos(sine / 32))),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,2.85 + 1.5 * math.cos(sine / 30),0)*angles(math.rad(-10 + 18 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 + 20 * math.cos(sine / 56))),.3)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,2.85 + 1.5 * math.cos(sine / 30),0)*angles(math.rad(-10 + 18 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(130 + 20 * math.cos(sine / 56))),.3)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,2.85 + 1.5 * math.cos(sine / 30),0)*angles(math.rad(-10 + 18 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(50 + 20 * math.cos(sine / 56))),.3)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,2.85 + 1.5 * math.cos(sine / 30),0)*angles(math.rad(-10 + 18 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 - 20 * math.cos(sine / 56))),.3)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,2.85 + 1.5 * math.cos(sine / 30),0)*angles(math.rad(-10 + 18 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-130 - 20 * math.cos(sine / 56))),.3)
rwing3weld.C1=clerp(rwing3weld.C1,cf(0,2.85 + 1.5 * math.cos(sine / 30),0)*angles(math.rad(-10 + 18 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-50 - 20 * math.cos(sine / 56))),.3)
		
		elseif Mode == 2 then
rotationa = rotationa + 10
			trailMK(math.random(4,6),math.random(1,500)/1000,"Add",root.CFrame*CFrame.Angles(0,math.rad(0+rotationa),0)*CFrame.new(math.random(-15,15),-3,math.random(-15,15))*CFrame.Angles(math.rad(90 + math.random(-6,6)),math.rad(math.random(-6,6)),math.rad(math.random(-6,6))),1,-0.0025,Color3.fromRGB(255,0,0),0)

			handleweld.C0=clerp(handleweld.C0,cf(0 + 0.25 * math.cos(sine / 63),0 + 0.25 * math.cos(sine / 70),-1 + 0.05 * math.cos(sine / 57))*angles(math.rad(0 + 2 * math.cos(sine / 55)),math.rad(0 + 2 * math.cos(sine / 46)),math.rad(0 + 2 * math.cos(sine / 32))),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(-10 + 30 * math.cos(sine / 20)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 + 5 * math.cos(sine / 56))),.3)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(-10 + 30 * math.cos(sine / 20)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(130 + 5 * math.cos(sine / 56))),.3)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(-10 + 30 * math.cos(sine / 20)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(50 + 5 * math.cos(sine / 56))),.3)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(-10 + 30 * math.cos(sine / 20)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 - 5 * math.cos(sine / 56))),.3)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(-10 + 30 * math.cos(sine / 20)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-130 - 5 * math.cos(sine / 56))),.3)
			rwing3weld.C1=clerp(rwing3weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(-10 + 30 * math.cos(sine / 20)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-50 - 5 * math.cos(sine / 56))),.3)
		elseif Mode == 2.5 then	
			rval = rval + 6.5
--			handleweld.C0=clerp(handleweld.C0,cf(0 + 0.25 * math.cos(sine / 63),0 + 0.25 * math.cos(sine / 70),-1 + 0.05 * math.cos(sine / 57))*angles(math.rad(0 + 2 * math.cos(sine / 55)),math.rad(0 + 2 * math.cos(sine / 46)),math.rad(0 + 2 * math.cos(sine / 32))),.3)
--lwing1weld.C1=clerp(lwing1weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(-10 + 28 * math.cos(sine / 40)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 + 20 * math.cos(sine / 111))),.3)
--lwing2weld.C1=clerp(lwing2weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(-10 + 28 * math.cos(sine / 40)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(130 + 20 * math.cos(sine / 111))),.3)
--lwing3weld.C1=clerp(lwing3weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(-10 + 28 * math.cos(sine / 40)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(50 + 20 * math.cos(sine / 111))),.3)
--rwing1weld.C1=clerp(rwing1weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(-10 + 28 * math.cos(sine / 40)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 - 20 * math.cos(sine / 111))),.3)
--rwing2weld.C1=clerp(rwing2weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(-10 + 28 * math.cos(sine / 40)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-130 - 20 * math.cos(sine / 111))),.3)
--rwing3weld.C1=clerp(rwing3weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(-10 + 28 * math.cos(sine / 40)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-50 - 20 * math.cos(sine / 111))),.3)
				sphereMK(6,math.random(5,15)/45,"Add",root.CFrame*CFrame.new(math.random(-10,10),-5,math.random(-10,10))*CFrame.Angles(math.rad(90 + math.random(-3,3)),math.rad(math.random(-3,3)),math.rad(math.random(-3,3))),0.1,0.1,3,0,BrickColor.new("Crimson"),0)

			handleweld.C0=clerp(handleweld.C0,cf(0 + 0.25 * math.cos(sine / 63),0 + 0.25 * math.cos(sine / 70),-1 + 0.05 * math.cos(sine / 57))*angles(math.rad(0 + 2 * math.cos(sine / 55)),math.rad(0 + 2 * math.cos(sine / 46)),math.rad(0 + 2 * math.cos(sine / 32))),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(0 + 25 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 + 5 * math.cos(sine / 56))),.3)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(0 + 25 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(130 + 5 * math.cos(sine / 56))),.3)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(0 + 25 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(50 + 5 * math.cos(sine / 56))),.3)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(0 + 25 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 - 5 * math.cos(sine / 56))),.3)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(0 + 25 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-130 - 5 * math.cos(sine / 56))),.3)
rwing3weld.C1=clerp(rwing3weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(0 + 25 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-50 - 5 * math.cos(sine / 56))),.3)
		
		elseif Mode == 3 then		
handleweld.C0=clerp(handleweld.C0,cf(0 + 0.25 * math.cos(sine / 63),0 + 0.25 * math.cos(sine / 70),-1 + 0.05 * math.cos(sine / 57))*angles(math.rad(0 + 2 * math.cos(sine / 55)),math.rad(0 + 2 * math.cos(sine / 46)),math.rad(0 + 2 * math.cos(sine / 32))),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(-10 + 30 * math.cos(sine / 20)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 + 10 * math.cos(sine / 30))),.3)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(-10 + 30 * math.cos(sine / 20)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(130 + 10 * math.cos(sine / 30))),.3)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(-10 + 30 * math.cos(sine / 20)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(50 + 10 * math.cos(sine / 30))),.3)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(-10 + 30 * math.cos(sine / 20)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 - 10 * math.cos(sine / 30))),.3)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(-10 + 30 * math.cos(sine / 20)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-130 - 10 * math.cos(sine / 30))),.3)
			rwing3weld.C1=clerp(rwing3weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(-10 + 30 * math.cos(sine / 20)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-50 - 10 * math.cos(sine / 30))),.3)
		elseif Mode == 3.5 then		
sphereMK(5,math.random(8,14)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),0.25,0.25,7.5,-0.0025,BrickColor.new("Lime green"),0)

handleweld.C0=clerp(handleweld.C0,cf(0 + 0.25 * math.cos(sine / 63),0 + 0.25 * math.cos(sine / 70),-1 + 0.05 * math.cos(sine / 57))*angles(math.rad(0 + 2 * math.cos(sine / 55)),math.rad(0 + 2 * math.cos(sine / 46)),math.rad(0 + 2 * math.cos(sine / 32))),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(-10 + 30 * math.cos(sine / 20)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 + 10 * math.cos(sine / 30))),.3)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(-10 + 30 * math.cos(sine / 20)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(130 + 10 * math.cos(sine / 30))),.3)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(-10 + 30 * math.cos(sine / 20)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 - 10 * math.cos(sine / 30))),.3)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(-10 + 30 * math.cos(sine / 20)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-130 - 10 * math.cos(sine / 30))),.3)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(-10 - 22 * math.cos(sine / 20)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(50 - 20 * math.cos(sine / 30))),.3)
	rwing3weld.C1=clerp(rwing3weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(-10 - 22 * math.cos(sine / 20)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-50 + 20 * math.cos(sine / 30))),.3)
		
		elseif Mode == 4 then	
						handleweld.C0=clerp(handleweld.C0,cf(0 + 0.25 * math.cos(sine / 63),0 + 0.25 * math.cos(sine / 70),-1 + 0.05 * math.cos(sine / 57))*angles(math.rad(0 + 2 * math.cos(sine / 55)),math.rad(0 + 2 * math.cos(sine / 46)),math.rad(0 + 2 * math.cos(sine / 32))),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(-10),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 + 30 * math.cos(sine / 56))),.3)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(-10),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(130 + 30 * math.cos(sine / 56))),.3)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(-10),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(50 + 30 * math.cos(sine / 56))),.3)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(-10),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 - 30 * math.cos(sine / 56))),.3)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(-10),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-130 - 30 * math.cos(sine / 56))),.3)
rwing3weld.C1=clerp(rwing3weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(-10),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-50 - 30 * math.cos(sine / 56))),.3)
			
					elseif Mode == 5 then	
						handleweld.C0=clerp(handleweld.C0,cf(0 + 0.25 * math.cos(sine / 63),0 + 0.25 * math.cos(sine / 70),-1 + 0.05 * math.cos(sine / 57))*angles(math.rad(0 + 10 * math.cos(sine / 16)),math.rad(0 + 2 * math.cos(sine / 46)),math.rad(0 + 2 * math.cos(sine / 32))),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(-10 + 18 * math.cos(sine / 10)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 + 20 * math.cos(sine / 10))),.3)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(-10 + 18 * math.cos(sine / 10)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(130 + 20 * math.cos(sine / 10))),.3)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(-10 + 18 * math.cos(sine / 10)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(50 + 20 * math.cos(sine / 10))),.3)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(-10 + 18 * math.cos(sine / 10)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 - 20 * math.cos(sine / 10))),.3)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(-10 + 18 * math.cos(sine / 10)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-130 - 20 * math.cos(sine / 10))),.3)
rwing3weld.C1=clerp(rwing3weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(-10 + 18 * math.cos(sine / 10)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-50 - 20 * math.cos(sine / 10))),.3)

			
		elseif Mode == 6 then
			
						handleweld.C0=clerp(handleweld.C0,cf(0 + 0.25 * math.cos(sine / 63),0 + 0.25 * math.cos(sine / 70),-1 + 0.05 * math.cos(sine / 57))*angles(math.rad(0 + 20 * math.cos(sine / 46)),math.rad(0 + 2 * math.cos(sine / 46)),math.rad(0 + 2 * math.cos(sine / 32))),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(-10 + 18 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 + 20 * math.cos(sine / 46))),.3)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(-10 + 18 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(130 + 20 * math.cos(sine / 46))),.3)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(-10 + 18 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(50 + 20 * math.cos(sine / 46))),.3)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(-10 + 18 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 - 20 * math.cos(sine / 46))),.3)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(-10 + 18 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-130 - 20 * math.cos(sine / 46))),.3)
rwing3weld.C1=clerp(rwing3weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(-10 + 18 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-50 - 20 * math.cos(sine / 46))),.3)
					elseif Mode == 7 then	
			handleweld.C0=clerp(handleweld.C0,cf(0 + 0.25 * math.cos(sine / 63),0 + 0.25 * math.cos(sine / 70),-1 + 0.05 * math.cos(sine / 57))*angles(math.rad(0 + 2 * math.cos(sine / 55)),math.rad(0 + 2 * math.cos(sine / 46)),math.rad(0 + 2 * math.cos(sine / 32))),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(-10 + 28 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 + 20 * math.cos(sine / 88))),.3)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(-10 + 28 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(130 + 20 * math.cos(sine / 88))),.3)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(-10 + 28 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(50 + 20 * math.cos(sine / 88))),.3)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(-10 + 28 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 - 20 * math.cos(sine / 88))),.3)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(-10 + 28 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-130 - 20 * math.cos(sine / 88))),.3)
rwing3weld.C1=clerp(rwing3weld.C1,cf(0,2.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(-10 + 28 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-50 - 20 * math.cos(sine / 88))),.3)
			
			elseif Mode == 8 then	
						handleweld.C0=clerp(handleweld.C0,cf(0 + 0.25 * math.cos(sine / 63),0 + 0.25 * math.cos(sine / 70),-1 + 0.05 * math.cos(sine / 57))*angles(math.rad(0 + 2 * math.cos(sine / 55)),math.rad(0 + 2 * math.cos(sine / 46)),math.rad(0 + 2 * math.cos(sine / 32))),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,2.85 + 1 * math.cos(sine / 30),0)*angles(math.rad(-10 + 18 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 + 5 * math.cos(sine / 56))),.3)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,2.85 + 1 * math.cos(sine / 30),0)*angles(math.rad(-10 + 18 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(130 + 5 * math.cos(sine / 56))),.3)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,2.85 + 1 * math.cos(sine / 30),0)*angles(math.rad(-10 + 18 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(50 + 5 * math.cos(sine / 56))),.3)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,2.85 + 1 * math.cos(sine / 30),0)*angles(math.rad(-10 + 18 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 - 5 * math.cos(sine / 56))),.3)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,2.85 + 1 * math.cos(sine / 30),0)*angles(math.rad(-10 + 18 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-130 - 5 * math.cos(sine / 56))),.3)
rwing3weld.C1=clerp(rwing3weld.C1,cf(0,2.85 + 1 * math.cos(sine / 30),0)*angles(math.rad(-10 + 18 * math.cos(sine / 30)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-50 - 5 * math.cos(sine / 56))),.3)

		end		
		
if Anim ~= "Idle" then
				change = 1
else
				change = 0.90
end
		if hum:GetState() == Enum.HumanoidStateType.Swimming and torvel<1 then
Anim="SwimIdle"
if attack == false then
  	local Alpha = .3
		if SwimType == 1 then
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,-0.1)*angles(math.rad(11.2),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.5,-0.6)*angles(math.rad(-24.8),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.4,0.6,-0.1)*angles(math.rad(70.5),math.rad(-15.8),math.rad(-53.9 + 40 * math.cos(sine/30))),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.7,0.5,-0.1)*angles(math.rad(64.7),math.rad(19),math.rad(43.1 - 40 * math.cos(sine/30))),Alpha)
   	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*necko,.1)
end
end
elseif hum:GetState() == Enum.HumanoidStateType.Swimming and torvel>1 then
	Anim="Swim"
	if attack == false then
		local Alpha = .3
		if SwimType == 1 then
	--Front crawl
	aerrtee = aerrtee + 10
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1.1,0.2)*angles(math.rad(-5 - 20 * math.cos(sine/7)),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.8,-0.1)*angles(math.rad(5 + 20 * math.cos(sine/7)),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
 RW.C0=clerp(RW.C0,cf(1.43,0.45 + 0.135 * math.cos(sine / 28),0)*angles(math.rad(0 + 6 * math.cos(sine / 22*-1.25)),math.rad(3 - 2 * math.cos(sine / 28*-1.25)),math.rad(90 + 90 * math.sin(sine / 14))),.1)
LW.C0=clerp(LW.C0,cf(-1.43,0.6 + 0.135 * math.cos(sine / 28),0)*angles(math.rad(0 - 7 * math.cos(sine / 16*-1.25)),math.rad(4 - 3 * math.cos(sine / 29*-1.25)),math.rad(-90 - 90 * math.sin(sine / 14))),.1)
		 	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.1,-0.5)*angles(math.rad(28.4),math.rad(0),math.rad(0))*necko,.1)
end
	end
elseif RootPart.Velocity.y > 1 and hitfloor==nil then 
Anim="Jump"
if attack==false then

RH.C0=clerp(RH.C0,cf(1,-0.35 - 0.05 * math.cos(sine / 25),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-20)),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(20)),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 25))*angles(math.rad(forwardvelocity*-10),math.rad(-sidevelocity*11),math.rad(0)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.1)
RW.C0=clerp(RW.C0,cf(1.4,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-5),math.rad(0),math.rad(25)),.1)
LW.C0=clerp(LW.C0,cf(-1.4,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-5),math.rad(0),math.rad(-25)),.1)
end
elseif RootPart.Velocity.y < -1 and hitfloor==nil then 
Anim="Fall"
if attack==false then

RH.C0=clerp(RH.C0,cf(1,-0.35 - 0.05 * math.cos(sine / 25),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-20)),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(20)),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 25))*angles(math.rad(forwardvelocity*10),math.rad(-sidevelocity*11),math.rad(0)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10.5),math.rad(0),math.rad(0)),.1)
RW.C0=clerp(RW.C0,cf(1.4,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-15),math.rad(0),math.rad(130)),.1)
LW.C0=clerp(LW.C0,cf(-1.4,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-15),math.rad(0),math.rad(-130)),.1)
end
elseif torvel<1 and hitfloor~=nil and Humanoid.Sit == false then
Anim="Idle"
if attack==false then
				smokt.Enabled = false 
if Mode == 2 then
  	local Alpha = .1
	RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.2 * math.cos(sine / 20))*angles(math.rad(0 - 2 * math.cos(sine / 34)),math.rad(0),math.rad(0 - 1 * math.cos(sine /61))),.1)
  	LH.C0 = LH.C0:lerp(cf(-0.8,-0.7,0)*angles(math.rad(-29.4 - 5 *math.cos(sine / 28)),math.rad(17.8+ 5 * math.cos(sine / 30)),math.rad(-14.1 - 5 * math.cos(sine / 28)))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.4 + 0.05 * math.cos(sine / 28),-0.8)*angles(math.rad(-29.9 + 5 * math.cos(sine / 28)),math.rad(-12.8 - 5 * math.cos(sine / 30)),math.rad(5.5+ 5 * math.cos(sine / 28)))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
					RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(12 + 6 * math.cos(sine / 55*-1.25)),math.rad(3 - 2 * math.cos(sine / 55*-1.25)),math.rad(10 + 10 * math.sin(sine / 55))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(9 - 7 * math.cos(sine / 55*-1.25)),math.rad(4 - 3 * math.cos(sine / 55*-1.25)),math.rad(-10 - 10 * math.sin(sine / 55))),.1)
					--RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(5 + 4 * math.cos(sine / 48)),math.rad(0),math.rad(15 + 5 * math.cos(sine / 33))),.1)
--LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(6 + 3 * math.cos(sine / 52)),math.rad(0),math.rad(-15 - 4 * math.cos(sine / 34))),.1)
Neck.C0=clerp(Neck.C0,necko*angles(math.rad(20+3*math.cos(sine/36)),math.rad(0),math.rad(0)),.1)
		elseif Mode == 2.5 then			
			local Alpha = .1		
	                RootJoint.C0 = clerp(RootJoint.C0, RootCF * CFrame.new(0 + 0 * math.cos(sine / 40), 0, -0.1 + 0.04 * math.cos(sine / 20)) * angles(math.rad(13.6 - 2.5 * math.sin(sine / 40)), math.rad(0 + 0 * math.cos(sine / 40)), math.rad(0)), .1)
				
					  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(-13.6),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,0)*angles(math.rad(12.5),math.rad(20.3),math.rad(-1.3))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-1,0)*angles(math.rad(15.6),math.rad(-5.7),math.rad(4.6))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	--LW.C0 = LW.C0:lerp(cf(-1.5,0.6,0.1)*angles(math.rad(-5.9),math.rad(16.7),math.rad(-4.9)),Alpha)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5+ 0.02* math.cos(sine / 28),0)*angles(math.rad(5.9 + 3 * math.cos(sine / 52)),math.rad(16.7),math.rad(-4.9 - 4 * math.cos(sine / 34))),.1)
RW.C0=clerp(RW.C0,cf(1.1,0.2,-0.4)*angles(math.rad(44.7 + 4 * math.cos(sine / 48)),math.rad(7),math.rad(-75.5 + 5 * math.cos(sine / 33))),.1)

--					  	RW.C0 = RW.C0:lerp(cf(1.1,0.2,-0.4)*angles(math.rad(44.7),math.rad(7),math.rad(-75.5)),Alpha)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, necko* CF(0 * Cos(sine / 25), 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 2.5 * Sin(sine / 20)), Rad(0 - 0 * Cos(sine / 40)), Rad(40 + 0 * Sin(sine / 40))) * angles(Rad(20 - 2.5 * Sin(sine / 20)), Rad(0 - 0 * Cos(sine / 40)), Rad(0 + 0 * Sin(sine / 40))), 0.15)					
		elseif Mode == 3.5 then			
  RH.C0=clerp(RH.C0,cf(1,-0.7,-0.4)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-15),math.rad(2),math.rad(-10 - 8 * math.cos(sine / 48))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(2),math.rad(30 + 6 * math.cos(sine / 45))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1 + 0.45 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 22)),math.rad(0),math.rad(17)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 4.5 * math.cos(sine / 28)+ AlicusTheme.PlaybackLoudness/10),math.rad(0),math.rad(-20)),.1)
					RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)
					
				elseif Mode == 1 then
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)* angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 - 3 * math.cos(sine / 34))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0) * angles(math.rad(0),math.rad(-90),math.rad(0)) * angles(math.rad(-2.5),math.rad(20 - 3 * math.cos(sine / 56)),math.rad(0 + 3 * math.cos(sine / 34))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.03 * math.cos(sine / 34),0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0 - 3 * math.cos(sine / 34)),math.rad(0),math.rad(-20 + 3 * math.cos(sine / 56))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 3.5 * math.cos(sine / 33)),math.rad(0 + 4 * math.cos(sine / 63)),math.rad(20 - 3 * math.cos(sine / 56))),.1)
RW.C0=clerp(RW.C0,cf(1,0.5 + 0.025 * math.cos(sine / 45),0.45)*angles(math.rad(-33 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(-33 + 3 * math.cos(sine / 45))),.1)
LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),0.45)*angles(math.rad(-23 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(33 - 3 * math.cos(sine / 45))),.1)
		elseif Mode == 1.5 then			
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(0 - 2 * math.cos(sine / 32))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(0 + 2 * math.cos(sine / 32))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.01 + 0.03 * math.cos(sine / 32),0 + 0.1 * math.cos(sine / 32))*angles(math.rad(1 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(22 + 2 * math.cos(sine / 56))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(23 - 2 * math.cos(sine / 37)),math.rad(0 + 5 * math.cos(sine / 43) - 5 * math.cos(sine / 0.25)),math.rad(-22 - 2 * math.cos(sine / 56))),.1)
RW.C0=clerp(RW.C0,CFrame.new(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(2 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(8 + 3 * math.cos(sine / 45))),.1)
LW.C0=clerp(LW.C0,CFrame.new(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(5 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(-8 - 3 * math.cos(sine / 45))),.1)			
					
				elseif Mode == 4 then
RootJoint.C0 = clerp(RootJoint.C0, RootCF * CFrame.new(0 + 0 * math.cos(sine / 40), 0, -0.1 + 0.04 * math.cos(sine / 20)) * angles(math.rad(0 - 2.5 * math.sin(sine / 40)), math.rad(0 + 0 * math.cos(sine / 40)), math.rad(0)), .1)
RH.C0 = clerp(RH.C0, CFrame.new(1 + 0 * math.cos(sine / 40) , -1  - 0.04  * math.cos(sine / 20), 0 ) * angles(math.rad(0), math.rad(94), math.rad(0)) * angles(math.rad(-4.5 + 0 * math.sin(sine / 40)), math.rad(-10), math.rad(-5 - 1.5 * math.sin(sine / 40))), .1)
LH.C0 = clerp(LH.C0, CFrame.new(-1 + 0 * math.cos(sine / 40) , -1  - 0.04  * math.cos(sine / 20), 0 ) * angles(math.rad(0), math.rad(-84), math.rad(0)) * angles(math.rad(0 - 0 * math.sin(sine / 40)), math.rad(10), math.rad(5 + 2.5 * math.sin(sine / 40))), .1)
Torso.Neck.C0 = clerp(Torso.Neck.C0, necko* CFrame.new(0 * math.cos(sine / 25), 0, 0 + ((1) - 1)) * angles(math.rad(0 - 2.5 * math.sin(sine / 20)), math.rad(0 - 0 * math.cos(sine / 40)), math.rad(15 + 0 * math.sin(sine / 40))) * angles(math.rad(0 - 2.5 * math.sin(sine / 40)), math.rad(0 - 0 * math.cos(sine / 40)), math.rad(0 + 0 * math.sin(sine / 40))), .1)
RW.C0=clerp(RW.C0,cf(1,0.5 + 0.025 * math.cos(sine / 45),-0.25)*angles(math.rad(33 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(-33 + 3 * math.cos(sine / 45))),.1)
LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.25)*angles(math.rad(23 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(33 - 3 * math.cos(sine / 45))),.1)
				elseif Mode == 5 then	
RootJoint.C0 = clerp(RootJoint.C0, RootCF * CF(0 + 0 * Cos(sine / 40)* Player_Size, 0* Player_Size, -0.1 + 0.04* Player_Size * Cos(sine / 20)) * angles(Rad(0 - 2.5 * Sin(sine / 40)), Rad(0 + 0 * Cos(sine / 40)), Rad(-40)), 0.15)
RH.C0 = clerp(RH.C0, CF(1 + 0 * Cos(sine / 40) * Player_Size, -1.1 * Player_Size - 0.04 * Player_Size * Cos(sine / 20), 0 * Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-4.5 + 0 * Sin(sine / 40)), Rad(-30), Rad(-5 - 1.5 * Sin(sine / 40))), 0.15)
LH.C0 = clerp(LH.C0, CF(-1 + 0 * Cos(sine / 40) * Player_Size, -0.9 * Player_Size - 0.04 * Player_Size * Cos(sine / 20), 0 * Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-5 - 0 * Sin(sine / 40)), Rad(30), Rad(5 + 2.5 * Sin(sine / 40))), 0.15)
Torso.Neck.C0 = clerp(Torso.Neck.C0, necko* CF(0 * Cos(sine / 25), 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 2.5 * Sin(sine / 20)), Rad(0 - 0 * Cos(sine / 40)), Rad(40 + 0 * Sin(sine / 40))) * angles(Rad(20 - 2.5 * Sin(sine / 20)), Rad(0 - 0 * Cos(sine / 40)), Rad(0 + 0 * Sin(sine / 40))), 0.15)
RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)
elseif Mode == 6 or Mode == 3 then					
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 - 3 * math.cos(sine / 34))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(20 - 3 * math.cos(sine / 56)),math.rad(0 + 3 * math.cos(sine / 34))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.03 * math.cos(sine / 34),0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0 - 3 * math.cos(sine / 34)),math.rad(0),math.rad(-20 + 3 * math.cos(sine / 56))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 3.5 * math.cos(sine / 33)),math.rad(0 + 4 * math.cos(sine / 63)),math.rad(20 - 3 * math.cos(sine / 56))),.1)
RW.C0=clerp(RW.C0,CFrame.new(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(2 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(8 + 3 * math.cos(sine / 45))),.1)
LW.C0=clerp(LW.C0,CFrame.new(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(5 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(-8 - 3 * math.cos(sine / 45))),.1)			
					elseif Mode == 7 then		
RootJoint.C0 = clerp(RootJoint.C0, RootCF * CF(0 + 0 * Cos(sine / 40)* Player_Size, 0* Player_Size, -0.1 + 0.04* Player_Size * Cos(sine / 20)) * angles(Rad(0 - 2.5 * Sin(sine / 40)), Rad(0 + 0 * Cos(sine / 40)), Rad(-40)), 0.15)
RH.C0 = clerp(RH.C0, CF(1 + 0 * Cos(sine / 40) * Player_Size, -1.1 * Player_Size - 0.04 * Player_Size * Cos(sine / 20), 0 * Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-4.5 + 0 * Sin(sine / 40)), Rad(-30), Rad(-5 - 1.5 * Sin(sine / 40))), 0.15)
LH.C0 = clerp(LH.C0, CF(-1 + 0 * Cos(sine / 40) * Player_Size, -0.9 * Player_Size - 0.04 * Player_Size * Cos(sine / 20), 0 * Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-5 - 0 * Sin(sine / 40)), Rad(30), Rad(5 + 2.5 * Sin(sine / 40))), 0.15)
Torso.Neck.C0 = clerp(Torso.Neck.C0, necko* CF(0 * Cos(sine / 25), 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 2.5 * Sin(sine / 20)), Rad(0 - 0 * Cos(sine / 40)), Rad(40 + 0 * Sin(sine / 40))) * angles(Rad(20 - 2.5 * Sin(sine / 20)), Rad(0 - 0 * Cos(sine / 40)), Rad(0 + 0 * Sin(sine / 40))), 0.15)
RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)
				elseif Mode == 8 then
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 35),0)* angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 - 3 * math.cos(sine / 30))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 35),0)*angles(math.rad(0),math.rad(-56),math.rad(0))*angles(math.rad(-7.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 30))),.25)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.025 * math.cos(sine / 35))*angles(math.rad(0 - .5 * math.cos(sine / 15)),math.rad(0),math.rad(-24)),.1)
RW.C0=clerp(RW.C0,cf(1.5,.5 + 0.025 * math.cos(sine / 35), 0)*angles(math.rad(0 - 0 * math.cos(sine / 35)),math.rad(10),math.rad(6 - 2 * math.cos(sine / 35))),.2)
LW.C0=clerp(LW.C0,cf(-1.5,.5 + 0.025 * math.cos(sine / 35),0)*angles(math.rad(4 - 0 * math.cos(sine / 35)),math.rad(10),math.rad(6 + 2 * math.cos(sine / 35))),.2)
Torso.Neck.C0 = clerp(Torso.Neck.C0, necko* CF(0 * Cos(sine / 25), 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 2.5 * Sin(sine / 20)), Rad(0 - 0 * Cos(sine / 40)), Rad(40 + 0 * Sin(sine / 40))) * angles(Rad(20 - 2.5 * Sin(sine / 20)), Rad(0 - 0 * Cos(sine / 40)), Rad(0 + 0 * Sin(sine / 40))), 0.15)
				
				end
			end
elseif torvel>2 and torvel<22 and hitfloor~=nil and Humanoid.Sit == false then
Anim="Walk"
if attack==false then
				--smokt.Enabled = true 
				if Mode ~= 2 and Mode ~= 2.5 and Mode ~= 3 and Mode ~= 3.5 and Mode ~= 4 then
RootJoint.C0 = clerp(RootJoint.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.01 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(forwardvelocity*15 - 0 * Cos(sine / 3.5)), Rad(-sidevelocity*11) , Rad(5 * Cos(sine / 7))), 0.15)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-forwardvelocity*10),math.rad(-sidevelocity*7),math.rad(-sidevelocity*40)),.1)
RH.C0=clerp(RH.C0,cf(1, -1 + 0.5 * Cos(sine / 7) / 2* Player_Size,0+ forwardvelocity/2 * Cos(sine / 7) / 2* Player_Size)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(sidevelocity*35 * math.cos(sine / 7)),math.rad(0),math.rad(0 - forwardvelocity*70 * math.cos(sine / 7))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 + 0.5 * Cos(sine / 7) / 2* Player_Size,0- forwardvelocity/2 * Cos(sine / 7) / 2* Player_Size)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(sidevelocity*35 * math.cos(sine / 7)),math.rad(0),math.rad(0 - forwardvelocity*70 * math.cos(sine / 7))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(0-forwardvelocity*7+ forwardvelocity*70 * math.cos(sine / 7)),math.rad(0),math.rad(10)),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0-forwardvelocity*7- forwardvelocity*70 * math.cos(sine / 7)),math.rad(0),math.rad(-10)),.1)
				
				
			elseif Mode == 2 then	
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.3 + 0.2 * math.cos(sine / 20))*angles(math.rad(forwardvelocity*40 - 1 * math.cos(sine / 34)),math.rad(-sidevelocity*10),math.rad(0)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-forwardvelocity*25),math.rad(-sidevelocity*14),math.rad(0)),.2)
					
  	LH.C0 = LH.C0:lerp(cf(-0.8,-0.7,0)*angles(math.rad(-29.4 - 5 *math.cos(sine / 28)),math.rad(17.8+ 5 * math.cos(sine / 30)),math.rad(-14.1 - 5 * math.cos(sine / 28)))*angles(math.rad(0),math.rad(-90),math.rad(0)),.1)
  	RH.C0 = RH.C0:lerp(cf(1,-0.4 + 0.05 * math.cos(sine / 28),-0.8)*angles(math.rad(-29.9 + 5 * math.cos(sine / 28)),math.rad(-12.8 - 5 * math.cos(sine / 30)),math.rad(5.5+ 5 * math.cos(sine / 28)))*angles(math.rad(0),math.rad(90),math.rad(0)),.1)
--RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(5 + 4 * math.cos(sine / 48)),math.rad(0),math.rad(15 + 5 * math.cos(sine / 33))),.1)
--LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(6 + 3 * math.cos(sine / 52)),math.rad(0),math.rad(-15 - 4 * math.cos(sine / 34))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(12 + 6 * math.cos(sine / 55*-1.25)),math.rad(3 - 2 * math.cos(sine / 55*-1.25)),math.rad(10 + 10 * math.sin(sine / 55))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(9 - 7 * math.cos(sine / 55*-1.25)),math.rad(4 - 3 * math.cos(sine / 55*-1.25)),math.rad(-10 - 10 * math.sin(sine / 55))),.1)
					
				elseif Mode == 3 then		
						RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20 - 5 * math.cos(sine / 34))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20 + 2 * math.cos(sine / 38))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.25 * math.cos(sine / 256),0 + 0.5 * math.cos(sine / 128),1 + 0.5 * math.cos(sine / 14))*angles(math.rad(-forwardvelocity*-40),math.rad(-sidevelocity*14),math.rad(0 - root.RotVelocity.Y *4.5 + 3 * math.cos(sine / 47))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-forwardvelocity*35),math.rad(-sidevelocity*14),math.rad(0)),.2)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(-8 - 4 * math.cos(sine / 59)),math.rad(-20 + 7 * math.cos(sine / 62)),math.rad(20 + 5 * math.cos(sine / 50))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(-8 - 3 * math.cos(sine / 55)),math.rad(20 + 8 * math.cos(sine / 67)),math.rad(-20 - 4 * math.cos(sine / 29))),.1)
					
									elseif Mode == 3.5 then		
						RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20 - 5 * math.cos(sine / 34))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20 + 2 * math.cos(sine / 38))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.5 * math.cos(sine / 128),1 + 0.45 * math.cos(sine / 32))*angles(math.rad(-forwardvelocity*-40),math.rad(-sidevelocity*14),math.rad(0 - root.RotVelocity.Y *4.5 + 3 * math.cos(sine / 47))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-forwardvelocity*35),math.rad(-sidevelocity*14),math.rad(0)),.2)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(-8 - 4 * math.cos(sine / 59)),math.rad(-20 + 7 * math.cos(sine / 62)),math.rad(20 + 5 * math.cos(sine / 50))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(-8 - 3 * math.cos(sine / 55)),math.rad(20 + 8 * math.cos(sine / 67)),math.rad(-20 - 4 * math.cos(sine / 29))),.1)

				elseif Mode == 4 then	
					RootJoint.C0 = clerp(RootJoint.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.01 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(forwardvelocity*15 - 0 * Cos(sine / 3.5)), Rad(-sidevelocity*11) , Rad(5 * Cos(sine / 7))), 0.15)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-forwardvelocity*10),math.rad(-sidevelocity*7),math.rad(-sidevelocity*40)),.1)
RH.C0=clerp(RH.C0,cf(1, -0.8 + 0.5 * Cos(sine / 7) / 2* Player_Size,0+ forwardvelocity/2 * Cos(sine / 7) / 2* Player_Size)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(sidevelocity*35 * math.cos(sine / 7)),math.rad(0),math.rad(0 - forwardvelocity*70 * math.cos(sine / 7))),.1)
LH.C0=clerp(LH.C0,cf(-1,-0.8 + 0.5 * Cos(sine / 7) / 2* Player_Size,0- forwardvelocity/2 * Cos(sine / 7) / 2* Player_Size)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(sidevelocity*35 * math.cos(sine / 7)),math.rad(0),math.rad(0 - forwardvelocity*70 * math.cos(sine / 7))),.1)
RW.C0=clerp(RW.C0,cf(1,0.5 + 0.025 * math.cos(sine / 45),-0.25)*angles(math.rad(33 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(-33 + 3 * math.cos(sine / 45))),.1)
LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.25)*angles(math.rad(23 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(33 - 3 * math.cos(sine / 45))),.1)
			elseif Mode == 2.5 then		
					RootJoint.C0 = clerp(RootJoint.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.01 * Cos(sine / 14.5) + -Sin(sine / 14.5) / 7* Player_Size) * angles(Rad(forwardvelocity*15 - 0 * Cos(sine / 3.5)), Rad(-sidevelocity*11) , Rad(5 * Cos(sine / 16))), .1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-forwardvelocity*10),math.rad(-sidevelocity*7),math.rad(-sidevelocity*40)),.1)
RH.C0=clerp(RH.C0,cf(1, -1 + 0.5 * Cos(sine / 16) / 2* Player_Size,0+ forwardvelocity/2 * Cos(sine / 16) / 2* Player_Size)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(sidevelocity*35 * math.cos(sine / 16)),math.rad(0),math.rad(0 - forwardvelocity*50 * math.cos(sine / 16))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 + 0.5 * Cos(sine / 16) / 2* Player_Size,0- forwardvelocity/2 * Cos(sine / 16) / 2* Player_Size)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(sidevelocity*35 * math.cos(sine / 16)),math.rad(0),math.rad(0 - forwardvelocity*50 * math.cos(sine / 16))),.1)
RW.C0=clerp(RW.C0,cf(1.1,0.2,-0.4)*angles(math.rad(44.7 + 4 * math.cos(sine / 48)),math.rad(7),math.rad(-75.5 + 5 * math.cos(sine / 33))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0-forwardvelocity*7- forwardvelocity*70 * math.cos(sine / 16)),math.rad(0),math.rad(-10)),.1)
	
end				
end
elseif torvel>=22 and hitfloor~=nil and Humanoid.Sit == false then
Anim="Run"
			if attack==false then
				if Mode ~= 2 and Mode ~= 3 and Mode ~= 3.5 then
 smokt.Enabled = true
			        				RootJoint.C0 = clerp(RootJoint.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.13 * Cos(sine / 3) + -Sin(sine / 3) / 7* Player_Size) * angles(Rad(forwardvelocity*23 - 2.5 * Cos(sine / 3)), Rad(-sidevelocity*11) - root.RotVelocity.Y / 75, Rad(0)), 0.15)

			--	rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.13 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(23 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(15 * Cos(sine / 7))), 0.15)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-10), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1* Player_Size - 0.5 * Cos(sine / 7) / 1* Player_Size, 0.6 * Cos(sine / 7) / 1)  * angles(Rad(-10 - 25 * Cos(sine / 7)) - rl.RotVelocity.Y / 95 + -Sin(sine / 7) / 2.5, Rad(90 - 0 * Cos(sine / 7)), Rad(0)) * angles(Rad(sidevelocity*30 * Cos(sine / 7)), Rad(0), Rad(0 - forwardvelocity*1)), 0.35)
        		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -1* Player_Size + 0.5 * Cos(sine / 7) / 1* Player_Size, -0.6 * Cos(sine / 7) / 1) * angles(Rad(-10 + 25 * Cos(sine / 7)) + ll.RotVelocity.Y / 95 + Sin(sine / 7) / 2.5, Rad(-90 - 0 * Cos(sine / 7)), Rad(0)) * angles(Rad(sidevelocity*30 * Cos(sine / 7)), Rad(0), Rad(-0 - forwardvelocity*1)), 0.35)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(77)  * Cos(sine / 7) , Rad(10 * Cos(sine / 7)), Rad(6) - ra.RotVelocity.Y / 75), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-77)  * Cos(sine / 7) , Rad(10 * Cos(sine / 7)) ,	Rad(-6) + la.RotVelocity.Y / 75), 0.1)

				elseif Mode == 2 then
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,.1 + 0.2 * math.cos(sine / 20),1.3 + 0.2 * math.cos(sine / 20))*angles(math.rad(forwardvelocity*60 - 1 * math.cos(sine / 34)),math.rad(-sidevelocity*10),math.rad(0)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-forwardvelocity*35),math.rad(-sidevelocity*14),math.rad(0)),.2)
					
  	LH.C0 = LH.C0:lerp(cf(-0.8,-0.7,0)*angles(math.rad(-29.4 - 5 *math.cos(sine / 28)),math.rad(17.8+ 5 * math.cos(sine / 30)),math.rad(-14.1 - 5 * math.cos(sine / 28)))*angles(math.rad(0),math.rad(-90),math.rad(0)),.1)
  	RH.C0 = RH.C0:lerp(cf(1,-0.4 + 0.05 * math.cos(sine / 28),-0.8)*angles(math.rad(-29.9 + 5 * math.cos(sine / 28)),math.rad(-12.8 - 5 * math.cos(sine / 30)),math.rad(5.5+ 5 * math.cos(sine / 28)))*angles(math.rad(0),math.rad(90),math.rad(0)),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(5 + 4 * math.cos(sine / 48)),math.rad(0),math.rad(25 + 5 * math.cos(sine / 33))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(6 + 3 * math.cos(sine / 52)),math.rad(0),math.rad(-25 - 4 * math.cos(sine / 34))),.1)
	elseif Mode == 3 then
											RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20 - 5 * math.cos(sine / 34))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20 + 2 * math.cos(sine / 38))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.25 * math.cos(sine / 256),0 + 0.5 * math.cos(sine / 128),1 + 0.5 * math.cos(sine / 14))*angles(math.rad(-forwardvelocity*-70),math.rad(-sidevelocity*14),math.rad(0 - root.RotVelocity.Y *4.5 + 3 * math.cos(sine / 47))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-forwardvelocity*35),math.rad(-sidevelocity*14),math.rad(0)),.2)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(-8 - 4 * math.cos(sine / 59)),math.rad(-20 + 7 * math.cos(sine / 62)),math.rad(20 + 5 * math.cos(sine / 50))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(-8 - 3 * math.cos(sine / 55)),math.rad(20 + 8 * math.cos(sine / 67)),math.rad(-20 - 4 * math.cos(sine / 29))),.1)
	elseif Mode == 3.5 then
											RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20 - 5 * math.cos(sine / 34))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20 + 2 * math.cos(sine / 38))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.5 * math.cos(sine / 128),1 + 0.45 * math.cos(sine / 32))*angles(math.rad(-forwardvelocity*-70),math.rad(-sidevelocity*14),math.rad(0 - root.RotVelocity.Y *4.5 + 3 * math.cos(sine / 47))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-forwardvelocity*35),math.rad(-sidevelocity*14),math.rad(0)),.2)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(-8 - 4 * math.cos(sine / 59)),math.rad(-20 + 7 * math.cos(sine / 62)),math.rad(20 + 5 * math.cos(sine / 50))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(-8 - 3 * math.cos(sine / 55)),math.rad(20 + 8 * math.cos(sine / 67)),math.rad(-20 - 4 * math.cos(sine / 29))),.1)

					
				end
				end
elseif Humanoid.Sit == true then
Anim = "Sit"
if attack == false then
local Alpha,Easing,Direction,Repeat,Reverse,Delay = .1,'Sine','InOut',0,false,0
TweenAnimate(RootJoint,{C0=cf(0,0+.1*math.cos(sine/25),0)*angles(math.rad(6.1),math.rad(0),math.rad(0))*RootCF},Alpha,Easing,Direction,Repeat,Reverse,Delay)
TweenAnimate(LH,{C0=cf(-0.9,0-1.1-.1*math.cos(sine/25),0)*angles(math.rad(85.4),math.rad(12.4),math.rad(-14.2))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
TweenAnimate(RH,{C0=cf(0.9,0-1.1-.1*math.cos(sine/25),0)*angles(math.rad(89.7),math.rad(-7.3),math.rad(12.9))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
TweenAnimate(LW,{C0=cf(-1.3,0.3,0)*angles(math.rad(49.7-1.7*math.cos(sine/12)),math.rad(20),math.rad(18.5-1.3*math.cos(sine/10)))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
TweenAnimate(RW,{C0=cf(1.3,0.5,0.1)*angles(math.rad(-8.3-1.3*math.cos(sine/13)),math.rad(-8.7+1.2*math.cos(sine/16)),math.rad(3.2))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
TweenAnimate(Torso.Neck,{C0 =necko*angles(math.rad(11.1),math.rad(0),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
end
end
end
end

--The end of the story bruh.
--end)

	
end)

Section2:CreateButton("ACL", function()
	function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end
function Swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end

function Align(Part0, Part1, Position, Angle)
	if Part0:FindFirstChild("Attachment") then
		Part0:FindFirstChild("Attachment"):Remove()
	end
    local AlignPosition = Instance.new("AlignPosition",Part0)
    local AlignOrientation = Instance.new("AlignOrientation",Part0)
    
    local Attachment1 = Instance.new("Attachment", Part0)
    local Attachment2 = Instance.new("Attachment", Part1)

    AlignPosition.Attachment0 = Attachment1
    AlignPosition.Attachment1 = Attachment2
    
    AlignOrientation.Attachment0 = Attachment1
    AlignOrientation.Attachment1 = Attachment2
    
    Attachment2.Position = Position or Vector3.new(0,0,0)
    Attachment2.Orientation = Angle or Vector3.new(0,0,0)
    
    AlignOrientation.MaxTorque = math.huge
    AlignOrientation.MaxAngularVelocity = math.huge
    AlignOrientation.PrimaryAxisOnly = false 
    AlignOrientation.Responsiveness = 200
    AlignOrientation.RigidityEnabled = false
    AlignOrientation.ReactionTorqueEnabled = false
    AlignPosition.MaxForce = math.huge
    AlignPosition.MaxVelocity = math.huge
    AlignPosition.ReactionForceEnabled = false
    AlignPosition.Responsiveness = 200
    AlignPosition.ApplyAtCenterOfMass = true
    AlignPosition.RigidityEnabled = true
    game:GetService("RunService").Heartbeat:Connect(function()
        Part0.Velocity = Vector3.new(-29.99,0,0)
    end)
    if Part0.Parent:IsA("Accessory") then
    	Part0:BreakJoints()
    end
end

Mouse = game.Players.LocalPlayer:GetMouse()
local Player = game:GetService("Players").LocalPlayer
USERNAME = Player
local lplr = game:GetService("Players").LocalPlayer
local funnychar = game:GetObjects("rbxassetid://7815525148")[1]
local Character = workspace.Camera.CameraSubject.Parent
local Humanoid = Character.Humanoid
Humanoid:ClearAllChildren()
--Humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
local LeftArm = Character["Left Arm"]
local RightArm = Character["Right Arm"]
local LeftLeg = Character["Left Leg"]
local RightLeg = Character["Right Leg"]
local Head = Character.Head
local Torso = Character.Torso
local GlitchEffect = funnychar.Torso.GlitchEffect
local RootPart = Character.HumanoidRootPart
local RootJoint = RootPart.RootJoint
local Neck = Torso["Neck"]
local RightShoulder = Torso["Right Shoulder"]
local LeftShoulder = Torso["Left Shoulder"]
local RightHip = Torso["Right Hip"]
local LeftHip = Torso["Left Hip"]
local Effects = Instance.new("Folder", Character)
local Eyes = funnychar.Head.Eyes
--Eyes.Parent = Character
local GUN = funnychar.MegaGunnModel
for i,v in pairs(GUN:GetChildren()) do
	--v.CanCollide = false
end
GUN.Parent = Character
-- 4623059912
Align(game.Players.LocalPlayer.Character["Starslayer Railgun"].Handle, GUN.Base, Vector3.new(1.2, 0.5, 0), Vector3.new(-0, -180, 3))
local GunJoint = GUN.PrimaryPart.Weld
GUN.Joint.Weld.Part0 = RightArm
GUN.Base.Transparency = 1
GUN.NeonParts.Transparency = 1
GUN.GunAdditions.Transparency = 1
local Hole = GUN.Hole
local Holetwo = GUN.Hole2
local outerm = funnychar.Visualizer.Mesh
local outerm2 = funnychar.Visualizer2.Mesh
local shade = outerm2.Parent.Color
local songid = Instance.new("StringValue")
songid.Name = "SongID"
songid.Value = "rbxassetid://923445685"
local eee = Instance.new("Sound",Character.Torso)
eee.Volume = 2
eee.PlaybackSpeed = 1
eee.Pitch = 1
eee.SoundId = songid.Value
eee:Play()
eee.Name = "funny"
eee.Looped = true
eee.TimePosition = 0

function chatfunc(text)
	local chat = coroutine.wrap(function()
		local oldthing = RealRoot:FindFirstChild("TalkingBillBoard")
		if oldthing then
			oldthing:Destroy()
		end
		local naeeym2 = Instance.new("BillboardGui",RealRoot)
		naeeym2.Size = UDim2.new(0,9999,2,0)
		naeeym2.StudsOffset = Vector3.new(0,4.5,0)
		naeeym2.Adornee = RealRoot
		naeeym2.Name = "TalkingBillBoard"
		local tecks2 = Instance.new("TextLabel",naeeym2)
		tecks2.BackgroundTransparency = 1
		tecks2.BorderSizePixel = 0
		tecks2.Text = ""
		tecks2.Font = "Code"
		tecks2.TextScaled = true
		tecks2.TextStrokeTransparency = 0
		coroutine.resume(coroutine.create(function()
			while tecks2:IsDescendantOf(game) do
				local hBRUH,sBRUH,vBRUH = Color3.toHSV(GUN.NeonParts.Color)
				tecks2.TextColor3 = Color3.fromHSV(hBRUH,sBRUH,vBRUH/2)
				swait()
			end
		end))
		tecks2.TextStrokeColor3 = shade
		tecks2.Size = UDim2.new(1,0,1,0)
		local tecks3 = Instance.new("TextLabel",naeeym2)
		tecks3.BackgroundTransparency = 1
		tecks3.BorderSizePixel = 0
		tecks3.Text = ""
		tecks3.Font = "Code"
		tecks3.TextScaled = true
		tecks3.TextStrokeTransparency = 0
		coroutine.resume(coroutine.create(function()
			while tecks3:IsDescendantOf(game) do
				tecks3.TextColor3 = GUN.NeonParts.Color
				swait()
			end
		end))
		tecks3.TextStrokeColor3 = shade
		tecks3.Size = UDim2.new(1,0,1,0)
		coroutine.resume(coroutine.create(function()
			while naeeym2 ~= nil do
				swait()
				tecks2.Position = UDim2.new(0,math.random(-3,3),0,math.random(-3,3)) 
				tecks3.Position = UDim2.new(0,math.random(-3,3),0,math.random(-3,3)) 
			end
		end))
		for i = 1,string.len(text) do
			swait(2)
			tecks2.Text = string.sub(text,1,i)
			tecks3.Text = string.sub(text,1,i)
		end
		swait(120)
		for i = 1,50 do
			swait()
			tecks2.Position = tecks2.Position - UDim2.new(0,math.random(-3,3),0,math.random(-3,3))
			tecks3.Position = tecks2.Position - UDim2.new(0,math.random(-3,3),0,math.random(-3,3)) 
			tecks2.Rotation = tecks2.Rotation + math.random(-2,2)
			tecks3.Rotation = tecks3.Rotation + math.random(-2,2)
			tecks2.TextStrokeTransparency = i/50
			tecks2.TextTransparency = tecks2.TextStrokeTransparency
			tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency
			tecks3.TextTransparency = tecks2.TextStrokeTransparency
		end
		naeeym2:Destroy()
	end)
	chat()
end

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
CS = ColorSequence.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
BRICKCRNDM = BrickColor.Random
MRANDOM = math.random
FLOOR = math.floor
it = Instance.new
NUMK = NumberSequenceKeypoint.new
NUMS = NumberSequence.new
NUMR = NumberRange.new


local alreadyfixing = false
local endingscript = false
local function characterfixer()
	
end

workspace.DescendantRemoving:Connect(function(v)

end)



local Mouse = {}
local mouse = Mouse

spawn(function()


local TS = game:GetService("TweenService")
local PS = game:GetService("PhysicsService")

local ArtificialHB = Instance.new("BindableEvent",script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

local frame = 1/60
local tf = 0
local allowframeloss = false
local tossremainder = false
local lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:Connect(function(s,p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1,math.floor(tf / frame) do
				ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

end)
local attack = false
local Anim = "Idle"
local attacktype = 1
local delays = false
local play = true
local Torsovelocity = (RootPart.Velocity * Vector3.new(1,0,1)).magnitude 
local sine = 0

local change = 1
local doe = 0
local walkspeed = 10
Humanoid.WalkSpeed = walkspeed
local rc0 = CFrame.new() * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local nc0 = CFrame.new(0,1,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local rscp = CFrame.new(-.5,0,0) * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))
local lscp = CFrame.new(.5,0,0) * CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))

function QFCF(cf)
	local mx,my,mz,m00,m01,m02,m10,m11,m12,m20,m21,m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip,(m02 - m20) * recip,(m10 - m01) * recip,s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s,(m10 + m01) * recip,(m20 + m02) * recip,(m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip,0.5 * s,(m21 + m12) * recip,(m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip,(m12 + m21) * recip,0.5 * s,(m10 - m01) * recip
		end
	end
end
 
function QTCF(px,py,pz,x,y,z,w)
	local xs,ys,zs = x + x,y + y,z + z
	local wx,wy,wz = w * xs,w * ys,w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px,py,pz,1 - (yy + zz),xy - wz,xz + wy,xy + wz,1 - (xx + zz),yz - wx,xz - wy,yz + wx,1 - (xx + yy))
end
 
function QS(a,b,t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp,finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1 / math.sin(theta)
			startInterp = math.sin((1 - t) * theta) * invSinTheta
			finishInterp = math.sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = math.acos(-cosTheta)
			local invSinTheta = 1 / math.sin(theta)
			startInterp = math.sin((t - 1) * theta) * invSinTheta
			finishInterp = math.sin(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp,a[2] * startInterp + b[2] * finishInterp,a[3] * startInterp + b[3] * finishInterp,a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a,b,t)
	local qa = {QFCF(a)}
	local qb = {QFCF(b)}
	local ax,ay,az = a.x,a.y,a.z
	local bx,by,bz = b.x,b.y,b.z
	local _t = 1 - t
	return QTCF(_t * ax + t * bx,_t * ay + t * by,_t * az + t * bz,QS(qa,qb,t))
end

local ArtificialHB = Instance.new("BindableEvent",script)
ArtificialHB.Name = "Heartbeat"

script:WaitForChild("Heartbeat")

local frame = 1 / 60
local tf = 0
local allowframeloss = false
local tossremainder = false
local lastframe = tick()
script.Heartbeat:Fire()

game:GetService("RunService").Heartbeat:Connect(function(s,p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1,math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

--local taunt = "None"

function CreateConnection(TYPE,PARENT,PART0,PART1,C0,C1)
	local NEWWELD = Instance.new(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end	

function CreateMesh(MESH,PARENT,MESHTYPE,MESHID,TEXTUREID,SCALE,OFFSET)
	local NEWMESH = Instance.new(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" and tonumber(MESHID) ~= nil then
			NEWMESH.MeshId = "rbxassetid://"..MESHID
		elseif MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "rbxassetid://"..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or Vector3.new()
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR,PARENT,MATERIAL,REFLECTANCE,TRANSPARENCY,BRICKCOLOR,NAME,SIZE,ANCHOR)
	local NEWPART = Instance.new("Part")
	NEWPART.Massless = true
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.Color = BRICKCOLOR
	NEWPART.Name = "funny"
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

local S = Instance.new("Sound")
function CreateSound(ID,PARENT,VOLUME,PITCH,DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "rbxassetid://"..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			coroutine.resume(coroutine.create(function()
				pcall(function()
					repeat Swait() until NEWSOUND.Playing == false
					NEWSOUND:Destroy()
				end)
			end))
		end
	end))
	return NEWSOUND
end

local function weldBetween(a,b)
	local weldd = Instance.new("Weld")
	weldd.Part0 = a
	weldd.Part1 = b
	weldd.C0 = CFrame.new()
	weldd.C1 = b.CFrame:inverse() * a.CFrame
	weldd.Parent = b
	return weldd
end
function rayCast(Position,Direction,Range,Ignore)
	return workspace:FindPartOnRay(Ray.new(Position,Direction.unit * (Range or 999.999)),Ignore) 
end 		


function mdmg(centerofeffect,range)

end

function Effect(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or Vector3.new(1,1,1))
	local ENDSIZE = (Table.Size2 or Vector3.new())
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or shade)
	local hOK,sOK,vOK = Color3.toHSV(COLOR)
	local RAINBOWPART = false
	if sOK > .1 then
		RAINBOWPART = true
	end
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
	local BOOMERANG = (Table.Boomerang or 0)
	local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3,Effects,MATERIAL,0,TRANSPARENCY,shade,"Effect",Vector3.new(1,1,1),true)
		if RAINBOWPART then
			coroutine.resume(coroutine.create(function()
				while EFFECT:IsDescendantOf(game) do
					EFFECT.Color = GUN.NeonParts.Color
					swait()
				end
			end))
		end
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID,EFFECT,SOUNDVOLUME,SOUNDPITCH,false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"Sphere","","",SIZE,Vector3.new())
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = Instance.new("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","20329976","",SIZE,Vector3.new(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","559831844","",Vector3.new(SIZE.X,SIZE.X,0.1),Vector3.new())
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662586858","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662585058","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","168892432","",SIZE,Vector3.new())
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","4770583","",SIZE,Vector3.new())
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","9756362","",SIZE,Vector3.new())
		end
		if MSH ~= nil then
			local BOOMR1 = 1+BOOMERANG/50
			local BOOMR2 = 1+SIZEBOOMERANG/50
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				if USEBOOMERANGMATH == true then
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
				else
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
				end
			end
			local GROWTH = nil
			if USEBOOMERANGMATH == true then
				GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
			else
				GROWTH = (SIZE - ENDSIZE)
			end
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			if USEBOOMERANGMATH == true then
				for LOOP = 1,TIME+1 do
					swait()
					MSH.Scale = MSH.Scale - (Vector3.new((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
					if TYPE == "Wave" then
						MSH.Offset = Vector3.new(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
						EFFECT.Orientation = ORI
					end
				end
			else
				for LOOP = 1,TIME+1 do
					swait()
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = Vector3.new(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-MOVESPEED)
						EFFECT.Orientation = ORI
					end
				end
			end
			EFFECT.Transparency = 1
			if PLAYSSOUND == false then
				EFFECT:Destroy()
			else
				repeat swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:Destroy()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:Destroy()
			else
				repeat swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:Destroy()
			end
		end
	end))
end

function Lightning(Part0,Part1,Timess,Offset,Color,Timer,sSize,eSize,Trans,Boomer,sBoomer,Trans2)
  local magz = (Part0 - Part1).magnitude
	local Times = math.floor(math.clamp(magz/10,5,20))
  local curpos = Part0
  local trz = {
    -Offset,
    Offset
  }
  for i = 1,Times do
    local li = Instance.new("Part",Effects)
    li.Name = "funny"
    li.TopSurface = 0
    li.Material = "Neon"
    li.BottomSurface = 0
    li.Anchored = true
    li.Locked = true
    li.Transparency = 0
    li.Color = Color
    li.formFactor = "Custom"
    li.CanCollide = false
    li.Size = Vector3.new(0.1,0.1,magz / Times)
    local Offzet = Vector3.new(trz[math.random(1,2)],trz[math.random(1,2)],trz[math.random(1,2)])
    local trolpos = CFrame.new(curpos,Part1) * CFrame.new(0,0,magz / Times).p + Offzet
    if Times == i then
      local magz2 = (curpos - Part1).magnitude
      li.Size = Vector3.new(0.1,0.1,magz2)
      li.CFrame = CFrame.new(curpos,Part1) * CFrame.new(0,0,-magz2 / 2)
    else
      li.CFrame = CFrame.new(curpos,trolpos) * CFrame.new(0,0,magz / Times / 2)
    end
    curpos = li.CFrame * CFrame.new(0,0,magz / Times / 2).p
    li:Destroy()
	Effect({Time = Timer,EffectType = "Box",Size = Vector3.new(sSize,sSize,li.Size.Z),Size2 = Vector3.new(eSize,eSize,li.Size.Z),Transparency = Trans,Transparency2 = Trans2 or 1,CFrame = li.CFrame,MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = li.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = Boomer,Boomerang = 0,SizeBoomerang = sBoomer})
  end
end

function FireArc(Part,ToLocation,AmountOfTime,Height,DoesCourontine)
    if DoesCourontine == false then
        local Direction = CFrame.new(Part.Position,ToLocation)
        local Distance = (Part.Position - ToLocation).magnitude
        for i = 1,AmountOfTime do
            swait()
            Part.CFrame = Direction*CFrame.new(0,(AmountOfTime/200)+((AmountOfTime/Height)-((i*2)/Height)),-Distance/AmountOfTime)
            Direction = Part.CFrame
        end
    elseif DoesCourontine == true then
        coroutine.resume(coroutine.create(function()
            local Direction = CFrame.new(Part.Position,ToLocation)
            local Distance = (Part.Position - ToLocation).magnitude
            for i = 1,AmountOfTime do
                swait()
                Part.CFrame = Direction*CFrame.new(0,(AmountOfTime/200)+((AmountOfTime/Height)-((i*2)/Height)),-Distance/AmountOfTime)
                Direction = Part.CFrame
            end
        end))
    end
end

function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = Instance.new("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = Instance.new("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = Instance.new("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

function AttackGyro()
	local GYRO = Instance.new("BodyGyro",RootPart)
	GYRO.D = 25
	GYRO.P = 20000
	GYRO.MaxTorque = Vector3.new(0,4000000,0)
	GYRO.CFrame = CFrame.new(RootPart.Position,Mouse.Hit.p)
	coroutine.resume(coroutine.create(function()
		repeat
			swait()
			GYRO.CFrame = CFrame.new(RootPart.Position,Mouse.Hit.p)
		until attack == false
		GYRO:Destroy()
	end))
end
coroutine.resume(coroutine.create(function()
	while true do
		for i = 0,1,(1/60) do
			swait()
			if not alreadyfixing then
				GUN.NeonParts.Color = Color3.fromHSV(i,1,1)
				for _,v in pairs(Character:GetChildren()) do
					if v:IsA("Pants") or v:IsA("Shirt") then
						v.Color3 = Color3.fromHSV(i,1,1)
					end
				end
				for i,v in pairs(Eyes:GetChildren()) do
					--v.Color = GUN.NeonParts.Color
				end
			end
		end
	end
end))
--[[
coroutine.resume(coroutine.create(function()
	while true do
		Swait()
		if not alreadyfixing then
			if SongSync.Value > eee.TimeLength and eee.TimeLength >= .1 then
				ResetSongSync:FireServer()
			end
			if eee.TimePosition < (SongSync.Value - 1) or eee.TimePosition > (SongSync.Value + 1) then
				eee.TimePosition = SongSync.Value
			end
		end
	end
end))
--]]

function attackone()
	attack = true
	walkspeed = 5
	AttackGyro()
	for i = 0,0.5,0.05 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(30)),1 / 3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-30)),1 / 3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(30)) * rscp,1 / 3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(30),math.rad(0),math.rad(0)) * lscp,1 / 3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-5),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-70),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
	end
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = 642890855,SoundPitch = 0.45,SoundVolume = 6,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	local DISTANCE = (Holetwo.Position - Mouse.Hit.p).Magnitude
	local killbeam = CreatePart(3,Effects,"Neon",0,0,shade,"Kill Beam",Vector3.new(1,DISTANCE,1))
	killbeam.CFrame = CFrame.new(Holetwo.Position,Mouse.Hit.p) * CFrame.new(0,0,-DISTANCE/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
	MakeForm(killbeam,"Cyl")
	killbeam.Touched:Connect(function(victim)
		mdmg(victim.Position,5)
	end)
	coroutine.resume(coroutine.create(function()
		for i = 1,25 do
			swait()
			killbeam.Transparency = i/25
		end
		killbeam:Destroy()
	end))
	Lightning(Holetwo.Position,Mouse.Hit.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
	Lightning(Holetwo.Position,Mouse.Hit.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
	Lightning(Holetwo.Position,Mouse.Hit.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
	Lightning(Holetwo.Position,Mouse.Hit.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
	Lightning(Holetwo.Position,Mouse.Hit.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
	for i = 0,2 do
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
	end
		Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = 192410089,SoundPitch = .55,SoundVolume = 8,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
		Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	for i = 0,2 do
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
  end
	mdmg(Mouse.Hit.p,10)
	for i = 0,0.5,0.075 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new() * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(60)),1 / 3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(10),math.rad(0),math.rad(-60)),1 / 3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(160),math.rad(-20),math.rad(60)) * rscp,1 / 3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(40),math.rad(5),math.rad(5)) * lscp,1 / 3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-5),math.rad(75),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-65),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
	end
	walkspeed = 10
	attack = false
end

function attacktwo()
	attack = true
	walkspeed = 0
	AttackGyro()
   local gBullet = CreatePart(3,Effects,"Neon",0,0,Color3.new(0,0,1),"BullyFuck",Vector3.new())
   MakeForm(gBullet,"Ball")
   gBullet.CFrame = LeftArm.CFrame*CFrame.new(0,-1.5,0)
	CreateSound(2785493,gBullet,2,0.8)
	for i = 0,1.25,0.025 do
		swait()
		Effect({Time = math.random(35,55),EffectType = "Sphere",Size = Vector3.new(0.5,0.5,0.5),Size2 = Vector3.new(1,1,1),Transparency = 0,Transparency2 = 1,CFrame = LeftArm.CFrame*CFrame.new(0,-1.5,0),MoveToPos = LeftArm.CFrame*CFrame.new(0,-1.5,0)*CFrame.new(math.random(-10,10),math.random(-10,10),math.random(-10,10)).p,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 50,SizeBoomerang = 50})
		gBullet.Size = gBullet.Size * 1.085
        gBullet.CFrame = LeftArm.CFrame*CFrame.new(0,-1.5,0)
		RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0,0,0 + 0.05 * math.cos(sine / 12)) * CFrame.Angles(math.rad(5),math.rad(0),math.rad(-30)),1 / 3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(-5 - 3 * math.cos(sine / 12)),math.rad(0),math.rad(30)),1 / 3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-62.5),math.rad(0 - 5 * math.cos(sine / 12)),math.rad(30)) * rscp,1 / 3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5 + 0.1 * math.cos(sine / 12),-0) * CFrame.Angles(math.rad(85 - 1.5 * math.cos(sine / 12)),math.rad(0 - 6 * math.cos(sine / 12)),math.rad(-30 - 6 * math.cos(sine / 12))) * lscp,1 / 3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1 - 0.075 * math.cos(sine / 12),0) * CFrame.Angles(math.rad(5),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1 - 0.075 * math.cos(sine / 12),0) * CFrame.Angles(math.rad(0),math.rad(-70),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
	end
	local bullets = {}
	for i = 1,math.random(27,41) do
		swait()
		local Bullet = CreatePart(3,Effects,"Neon",0,0,Color3.new(0,0,1),"BulletFuck",Vector3.new(0.6,0.6,0.6))
    	MakeForm(Bullet,"Ball")
		Bullet.CFrame = gBullet.CFrame
		Effect({Time = math.random(5,20),EffectType = "Sphere",Size = Vector3.new(3,3,3)*math.random(-3,2),Size2 = Vector3.new(6,6,6)*math.random(-3,2),Transparency = 0.4,Transparency2 = 1,CFrame = Bullet.CFrame,MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 25})
		table.insert(bullets,Bullet)
	end
	for b = 1,#bullets do
		swait()
		local part,pos = rayCast(LeftArm.CFrame*CFrame.new(0,-1.5,0).p,((Mouse.Hit.p+Vector3.new(math.random(-15,15),math.random(-7,7),math.random(-15,15))) - LeftArm.CFrame*CFrame.new(0,-1.5,0).p),500,Character)
		coroutine.resume(coroutine.create(function()
		FireArc(bullets[b],pos,math.random(17,31),math.random(9,15),false)
		Effect({Time = math.random(25,35),EffectType = "Sphere",Size = Vector3.new(0.6,0.6,0.6),Size2 = Vector3.new(1.6,1.6,1.6),Transparency = 0,Transparency2 = 1,CFrame = bullets[b].CFrame,MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 25})
		swait(math.random(55,65))
		for i = 1,3 do
			Effect({Time = math.random(45,65),EffectType = "Sphere",Size = Vector3.new(0.6,6,0.6)*math.random(-1.05,1.25),Size2 = Vector3.new(1.6,10,1.6)*math.random(-1.05,1.25),Transparency = 0,Transparency2 = 1,CFrame = bullets[b].CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 20,SizeBoomerang = 35})
		end
		for i = 0,10 do
		swait()
		bullets[b].Transparency = bullets[b].Transparency + 0.1
		end
		mdmg(bullets[b].Position,10)
		local EEEBRUHEEE = CreateSound(168513088,bullets[b],3.5,1.1,false)
		bullets[b].Transparency = 1
		EEEBRUHEEE.Ended:Connect(function()
			bullets[b]:Destroy()
		end)
		end))
	end
	for i = 0,10 do
		swait()
		gBullet.Transparency = gBullet.Transparency + 0.1
	end
	gBullet:Destroy()
	walkspeed = 10
	attack = false
end

function hedshoot()
	attack = true
	walkspeed = 5
	CreateSound(235097614,RootPart,6,1.5,false)
	for i = 0,0.5,0.05 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-60)),1 / 3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(60)),1 / 3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.25,0.5,-.25) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-60)) * rscp,1 / 3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.25,0.5,-.25) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(10)) * lscp,1 / 3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-5),math.rad(75),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-65),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
	end
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = 642890855,SoundPitch = 0.45,SoundVolume = 6,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = math.random(25,45),EffectType = "Sphere",Size = Vector3.new(2,100,2),Size2 = Vector3.new(6,100,6),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame*CFrame.new(math.random(-1,1),math.random(-1,1),-50)*CFrame.Angles(math.rad(math.random(89,91)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 45})
	Effect({Time = math.random(25,45),EffectType = "Sphere",Size = Vector3.new(3,100,3),Size2 = Vector3.new(9,100,9),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame*CFrame.new(math.random(-1,1),math.random(-1,1),-50)*CFrame.Angles(math.rad(math.random(89,91)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 45})
	mdmg(RootPart.Position,14)
	for i = 1,4 do
		RootPart.CFrame = RootPart.CFrame * CFrame.new(0,0,-25)
		mdmg(RootPart.Position,14)
		Lightning(RootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).p,RootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).p,6,25,shade,math.random(30,45),0.5,1.5,0,true,60) Lightning(RootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).p,RootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).p,6,25,Color3.new(0,0,1),math.random(30,45),0.5,1.5,0,true,60)
	end
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	for i = 0,0.5,0.1 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90)),1 / 3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-90)),1 / 3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(90)) * rscp,1 / 3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(40),math.rad(5),math.rad(5)) * lscp,1 / 3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-5),math.rad(75),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-65),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
	end
	attack = false
	walkspeed = 10
end

function painlessrain()
attack = true
    walkspeed = 5
	coroutine.wrap(function()
	for i = 0,2 do
	swait(12)
	CreateSound(199145095,GUN,6,1)
	end
	end)()
	for i = 0,2,0.1 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-10)),1 / 3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(25),math.rad(0),math.rad(-20)),1 / 3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(35),math.rad(-35),math.rad(20)) * rscp,1 / 3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-20),math.rad(-5),math.rad(-10)) * lscp,1 / 3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-5),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-70),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(doe * 22),math.rad(0),math.rad(0)),1 / 2)
	end
	for i = 0,1.5,0.1 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),1 / 3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1 / 3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(175),math.rad(-10),math.rad(10)) * rscp,1 / 3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-10),math.rad(-10),math.rad(-5)) * lscp,1 / 3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-5),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-70),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
	end
	local Hole2 = Hole.CFrame*CFrame.new(-600,0,0)
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = Hole.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = 642890855,SoundPitch = 0.45,SoundVolume = 6,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = Hole.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Lightning(Hole.Position,Hole2.p,15.137,3.5,shade,25,1,3,0,true,55) Lightning(Hole.Position,Hole2.p,15.137,3.5,Color3.new(0,0,1),25,1,3,0,true,55)
	for i = 0,2 do
	Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(0.1,0.1,0.1),Size2 = Vector3.new(0.4,0,0.4),Transparency = 0,Transparency2 = 1,CFrame = Hole.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
	Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(0.1,0.1,0.1),Size2 = Vector3.new(0.4,0,0.4),Transparency = 0,Transparency2 = 1,CFrame = Hole.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
	end
	for i = 0,.5,0.1 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),1 / 3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1 / 3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(225),math.rad(-20),math.rad(20)) * rscp,1 / 3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-5),math.rad(-5),math.rad(0)) * lscp,1 / 3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-5),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-70),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
	end
	for i = 0,.5,0.1 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),1 / 3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1 / 3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(175),math.rad(-10),math.rad(10)) * rscp,1 / 3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-5),math.rad(-5),math.rad(0)) * lscp,1 / 3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-5),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-70),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
	end
	attack = false
	walkspeed = 10
	swait(36)
	for i = 1,75 do
		local Sky = RootPart.CFrame*CFrame.new(0,600,0)
		local MoPos = Mouse.Hit*CFrame.new(math.random(-18,18),0,math.random(-18,18)).p
		local DISTANCE = (Sky.p - MoPos).Magnitude
		Lightning(Sky.p,MoPos,35.137,7,Color3.new(0,0,1),25,2,4,0,true,55)
		Effect({Time = 25,EffectType = "Box",Size = Vector3.new(1,1,DISTANCE),Size2 = Vector3.new(2,2,DISTANCE),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(Sky.p,MoPos) * CFrame.new(0,0,-DISTANCE / 2),MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
		Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(MoPos),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(0,0,1),SoundID = 192410089,SoundPitch = .55,SoundVolume = 8,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
		Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(MoPos),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
		local a = math.random(1,2)
		if a == 1 then
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(0.1,0.1,0.1),Size2 = Vector3.new(0.3,0,0.3),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(MoPos)*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(0,0,1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		else
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(0.1,0.1,0.1),Size2 = Vector3.new(0.3,0,0.3),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(MoPos)*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		end
		mdmg(MoPos,12)
		swait(5)
	end
end
function SingularityBeam()
	attack = true
	walkspeed = 0
	AttackGyro()
	for i = 0,0.5,0.05 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-60)),1 / 3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(60)),1 / 3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.25,0.5,-.25) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-60)) * rscp,1 / 3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.25,0.5,-.25) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(10)) * lscp,1 / 3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-5),math.rad(75),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-65),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
	end
	local HoleDist = (Hole.Position - Holetwo.Position).Magnitude
	local chargebeam = CreatePart(3,Effects,"Neon",0,0,shade,"Charge Beam",Vector3.new(.25,HoleDist,.25),false)
	MakeForm(chargebeam,"Cyl")
	chargebeam.CFrame = CFrame.new(Hole.Position,Holetwo.Position) * CFrame.new(0,0,-HoleDist/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
	local chargeweld = weldBetween(GUN.PrimaryPart,chargebeam)
	local chargeball = CreatePart(3,Effects,"Neon",0,0,shade,"Charge Ball",Vector3.new(.5,.5,.5),false)
	chargeball.Shape = "Ball"
	chargeball.CFrame = Holetwo.CFrame
	weldBetween(Holetwo,chargeball)
	CreateSound(342793847,Hole,10,1,false)
	local bigball = game:GetService("TweenService"):Create(chargeball,TweenInfo.new(3.86,Enum.EasingStyle.Linear),{Size = Vector3.new(2.5,2.5,2.5)})
	bigball:Play()
	bigball.Completed:Wait()
	chargebeam:Destroy()
	local KillDist = (Holetwo.Position - Mouse.Hit.p).Magnitude
	coroutine.resume(coroutine.create(function()
		repeat KillDist = (Holetwo.Position - Mouse.Hit.p).Magnitude Swait() until attack == false
	end))
	local killbeam = CreatePart(3,Effects,"Neon",0,0,shade,"Kill Beam",Vector3.new(2.5,KillDist,2.5))
	MakeForm(killbeam,"Cyl")
	killbeam.Touched:Connect(function(victim)
		mdmg(victim.Position,5)
	end)
	coroutine.resume(coroutine.create(function()
		while killbeam:IsDescendantOf(game) do
			mdmg(Mouse.Hit.p,5)
			Swait(6)
		end
	end))
	coroutine.resume(coroutine.create(function()
		local isdoingathing = false
		while killbeam:IsDescendantOf(game) do
			isdoingathing = not isdoingathing
			if lplr.Name == USERNAME then
				RootPart.CFrame = RootPart.CFrame * CFrame.new(0,0,.1)
			end
			killbeam.Size = Vector3.new(2.5,KillDist,2.5)
			killbeam.CFrame = CFrame.new(Holetwo.Position,Mouse.Hit.p) * CFrame.new(0,0,-KillDist/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
			if isdoingathing then
				Lightning(Holetwo.Position,Mouse.Hit.p,15,3,Color3.new(0,0,1),10,0,1,0,true,55)
				Effect({Time = 10,EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
				Effect({Time = 10,EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
				Effect({Time = 10,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
				Effect({Time = 10,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
				Effect({Time = 10,EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
				Effect({Time = 10,EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
			end
			Swait()
		end
	end))
	CreateSound(138677306,Holetwo,10,1,false)
	CreateSound(415700134,Holetwo,10,1,false)
	Swait(150)
	CreateSound(3264923,Holetwo,10,1,false)
	Swait(30)
	chargeball:Destroy()
	killbeam:Destroy()
	walkspeed = 10
	attack = false
end
Mouse = game.Players.LocalPlayer:GetMouse()

local taunt2 = Instance.new("Folder")
local taunt = Instance.new("StringValue", taunt)
taunt.Value = "None"
	Mouse.Button1Down:Connect(function()
	if attack == false and taunt.Value == "None" then
		attackone()
	end
end)
Mouse.KeyDown:Connect(function(k)
	k = k:lower()
	if k == "z" and attack == false and taunt.Value == "None" then	
		hedshoot()
	elseif k == "x" and attack == false and taunt.Value == "None" then
		SingularityBeam()
	elseif k == "c" and attack == false and taunt.Value == "None" then
		painlessrain()
	elseif k == "v" and attack == false and taunt.Value == "None" then
		attacktwo()
	elseif k == "1" then
		CreateSound(907332525,Head,10,1,false)
		chatfunc("Your Attack Is An Insult.")
		--[[
	elseif k == "t" then
		if taunt.Value ~= "Fave" then
			MainFolder.TauntRemote:FireServer("Fave",290182215)
			eee.Volume = 2
		else
			MainFolder.TauntRemote:FireServer("None",923445685)
			eee.Volume = 2
		end
	elseif k == "u" then
		if taunt.Value ~= "Memer" then
			MainFolder.TauntRemote:FireServer("Memer",5599930438)
			eee.Volume = 10
		else
			MainFolder.TauntRemote:FireServer("None",923445685)
			eee.Volume = 2
		end
	elseif k == "y" then
		if taunt.Value ~= "Krump" then
			MainFolder.TauntRemote:FireServer("Krump",1511734302)
			eee.Volume = 2
		else
			MainFolder.TauntRemote:FireServer("None",923445685)
			eee.Volume = 2
			end
       elseif k == "m" then
		if songid.Value ~= "rbxassetid://923445685" and songid.Value ~= "rbxassetid://3247404955" and songid.Value ~= "rbxassetid://3040719791" and songid.Value ~= "rbxassetid://2297862957" and songid.Value ~= "rbxassetid://2920078671" then
			MainFolder.TauntRemote:FireServer("None",923445685)
			eee.Volume = 2
		elseif songid.Value == "rbxassetid://923445685" then
			MainFolder.TauntRemote:FireServer("None",3040719791)
			eee.Volume = 10
		elseif songid.Value == "rbxassetid://3040719791" then
			MainFolder.TauntRemote:FireServer("None",923445685)
			eee.Volume = 2
		--]]
		end
		
	--end
end)

coroutine.resume(coroutine.create(function()
	while not stopeverything do
		for i = 0,1,(1/60) do
			swait()
			if not alreadyfixing then
				GUN.NeonParts.Color = Color3.fromHSV(i,1,1)
				if taunt.Value == "iNSaNiTY" then
					GUN.NeonParts.Color = Color3.fromHSV(math.random(0,19)/20,1,1)
				elseif taunt.Value == "Err0r" then
					GUN.NeonParts.Color = Color3.fromRGB(0,math.clamp(eee.PlaybackLoudness-255,0,255),0)
				elseif taunt.Value == "Dep" then
					GUN.NeonParts.Color = Color3.fromHSV(math.random(0,19)/20,1,1)
				elseif taunt.Value == "FAST BOIII" then
					GUN.NeonParts.Color = Color3.fromRGB(0,0,math.clamp(eee.PlaybackLoudness-191,0,255))
				elseif taunt.Value == "Glitch" then
					GUN.NeonParts.Color = Color3.fromHSV(i,1,math.clamp((eee.PlaybackLoudness/255)-.5,0,1))
				end
				--Eyes.Color3 = GUN.NeonParts.Color3
			end
		end
	end
end))
--[[
coroutine.wrap(function()
	while 1 do
		swait()
		if doe <= 360 then
			doe = doe + 2
		else
			doe = 0
		end
	end
end)()
--]]
local Glitching = false
function GlitchVisually(duration,intensity)
	if Glitching then return end
	Glitching = true
	coroutine.wrap(function()
		local GlitchMeshes = {}
		for _,v in next, Character:GetDescendants() do
			if not v:IsDescendantOf(GUN) and not v:IsDescendantOf(Effects) and not v:IsDescendantOf(Head) then
				local mesh = v:FindFirstChildWhichIsA("DataModelMesh")
				local removeAfter = not mesh
				if not mesh then
					if v == LeftLeg or v == RightLeg or v == LeftArm or v == RightArm or v == Torso then
						mesh = CreateMesh("SpecialMesh",v,"FileMesh","rbxasset://fonts/rightarm.mesh","nil",Vector3.new(v.Size.X,v.Size.Y/2,v.Size.Z),Vector3.new())
					elseif v == Head then
						mesh = CreateMesh("SpecialMesh",v,"Head","nil","nil",Vector3.new(1.25,1.25,1.25),Vector3.new())
					elseif v:IsA("Part") and v.Shape == Enum.PartType.Block then
						mesh = Instance.new("BlockMesh",v)
					end
				end
				if mesh then
					table.insert(GlitchMeshes,{mesh,removeAfter})
				end
			end
		end
		local start=tick()
		for i,v in pairs(Eyes:GetChildren()) do
			v.Transparency = 1
		end
		GlitchEffect.Volume = 1
		local lowww = Instance.new("PitchShiftSoundEffect")
		lowww.Parent = eee
		while tick()-start<duration and not alreadyfixing do
			for i = 1,#GlitchMeshes do
				GlitchMeshes[i][1].Offset=Vector3.new(math.random(-intensity,intensity)/10,math.random(-intensity,intensity)/10,math.random(-intensity,intensity)/10)
			end
			lowww.Octave = math.random(5,20)/10
			swait()
		end
		for i,v in pairs(Eyes:GetChildren()) do
			v.Transparency = 0
		end
		GlitchEffect.Volume = 0
		lowww.Enabled = false
		game:GetService("Debris"):AddItem(lowww,.01)
		for i = 1,#GlitchMeshes do
			if(GlitchMeshes[i][2])then
				GlitchMeshes[i][1]:destroy()
			else
				GlitchMeshes[i][1].Offset = Vector3.new()
			end
		end
		Glitching = false
	end)()
end
local isbruhhcircle = false

function CreateStar(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos,ori)
	isbruhhcircle = not isbruhhcircle
	local isbruhcircle = isbruhhcircle
	local type = type
	local rng = Instance.new("Part")
	rng.Anchored = true
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	if isbruhcircle then
		rng.Color = GUN.NeonParts.Color
	else
		rng.Color = shade
	end
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local rngm = Instance.new("SpecialMesh")
	rngm.MeshType = "Sphere"
	--rngm.MeshId = "rbxassetid://3054497727"
	rngm.Scale = Vector3.new(x1*20,y1*20,z1*20)
	rngm.Parent = rng
	rng.Parent = Effects
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		if ori == true then
			rng.Orientation = Vector3.new(0,0,0)
		end
		for i = 0,10/bonuspeed,0.1 do
			Swait()
			if isbruhcircle then
				rng.Color = GUN.NeonParts.Color
			else
				rng.Color = shade
			end
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			speeder = speeder - 0.01*FastSpeed*bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
		end
		rng:Destroy()
	end))
end

while true do
	swait()
	if not alreadyfixing then
		Humanoid.MaxHealth = 999
		if Humanoid.Health < 999 then
			Humanoid.Health = Humanoid.Health + 3
		elseif Humanoid.Health > 999 then
			Humanoid.Health = 999
		end
		for i,v in pairs(Character:GetChildren()) do
			if v:IsA("BasePart") and v.Anchored == false and v.Position.Y < (workspace.FallenPartsDestroyHeight + 50) then
				local flot = Instance.new("BodyPosition")
				local spen = Instance.new("BodyGyro")
				local hu = math.huge
				flot.MaxForce = Vector3.new(hu,hu,hu)
				spen.MaxTorque = Vector3.new(hu,hu,hu)
				local spown = nil
				for o,b in pairs(workspace:GetDescendants()) do
					if not b:IsDescendantOf(Character) and b:IsA("SpawnLocation") then
						spown = b
					end
				end
				if spown then
					--RootPart.CFrame = CFrame.new(spown.Position.X,spown.Position.Y+(spown.Size.Y/2)+3,spown.Position.Z)
				else
					local base = workspace:FindFirstChild("Base")
					if not base then
						base = workspace:FindFirstChild("Baseplate")
					end
					if base then
						--RootPart.CFrame = CFrame.new(math.clamp(RootPart.Position.X,(-base.Size.X/2)+5,(base.Size.X/2)-5),base.Position.Y+(base.Size.Y/2)+3,math.clamp(RootPart.Position.Z,(-base.Size.X/2)+5,(base.Size.X/2)-5))
					else
						--RootPart.CFrame = CFrame.new(math.clamp(RootPart.Position.X,-100,100),20,math.clamp(RootPart.Position.Z,-100,100))
					end
				end
				--flot.Position = RootPart.Position
				--flot.Parent = RootPart
				--spen.CFrame = RootPart.CFrame
				--spen.Parent = RootPart
				game:GetService("Debris"):AddItem(flot,1)
				game:GetService("Debris"):AddItem(spen,1)
			end
		end
		Torsovelocity = (RootPart.Velocity * Vector3.new(1,0,1)).magnitude
		--Torsovelocity = 0
		if lplr.Name == USERNAME then
			--Torsovelocity = (RootPart.Velocity * Vector3.new(1,0,1)).magnitude
		end 
		sine = sine + change
		local hit,pos = rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
		-- 
			--CreateStar(5,1/45,"Add",RootPart.CFrame*CFrame.new(math.sin(sine/16)*5,math.sin(sine/32)*5,math.cos(sine/16)*5)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(0)),0.08,0.08,0.08,0,BrickColor.new("Institutional white"),0)
			--CreateStar(5,1/45,"Add",RootPart.CFrame*CFrame.new(math.cos(sine/16)*5,math.cos(sine/32)*5,math.sin(sine/16)*5)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(0)),0.08,0.08,0.08,0,BrickColor.new("Institutional white"),0)
			--CreateStar(5,1/45,"Add",RootPart.CFrame*CFrame.new(math.sin(sine/16)*-5,math.sin(sine/32)*-5,math.cos(sine/16)*-5)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(0)),0.08,0.08,0.08,0,BrickColor.new("Institutional white"),0)
			--CreateStar(5,1/45,"Add",RootPart.CFrame*CFrame.new(math.cos(sine/16)*-5,math.cos(sine/32)*-5,math.sin(sine/16)*-5)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(0)),0.08,0.08,0.08,0,BrickColor.new("Institutional white"),0)
			--CreateStar(6,math.random(5,15)/45,"Add",RootPart.CFrame*CFrame.new(math.random(-10,10),-5,math.random(-10,10))*CFrame.Angles(math.rad(90 + math.random(-3,3)),math.rad(math.random(-3,3)),math.rad(math.random(-3,3))),0.045,0.045,0.045,0,BrickColor.new("Institutional white"),0)
			--CreateStar(6,math.random(5,15)/45,"Add",RootPart.CFrame*CFrame.new(math.random(-10,10),-5,math.random(-10,10))*CFrame.Angles(math.rad(90 + math.random(-3,3)),math.rad(math.random(-3,3)),math.rad(math.random(-3,3))),0.045,0.045,0.045,0,BrickColor.new("Institutional white"),0)
		--
		if taunt.Value == "None" then
			if math.random(1,60) == 1 then
				--GlitchVisually(.25,5)
			end
			if Anim == "Walk" and Torsovelocity > 1 then
				RootJoint.C1 = Clerp(RootJoint.C1,rc0 * CFrame.new(0,0,0.1 + 0.05 * math.cos(sine / 6)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),2 / 3)
				Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-0.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0) - Head.RotVelocity.Y / 30),0.2 / 3)
				RightHip.C1 = Clerp(RightHip.C1,CFrame.new(0.5,.95-.2*math.sin(sine/12),-.15*math.sin(sine/12)) * CFrame.Angles(math.rad(-5),math.rad(90),math.rad(0)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-10+35 * math.cos(sine / 12))),0.6 / 3)
				LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-0.5,.95+.2*math.sin(sine/12),.15*math.sin(sine/12)) * CFrame.Angles(math.rad(-5),math.rad(-90),math.rad(0)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(10+35 * math.cos(sine / 12))),0.6 / 3)
			elseif (Anim ~= "Walk") or (Torsovelocity < 1) then
				RootJoint.C1 = Clerp(RootJoint.C1,rc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.2 / 3)
				Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-0.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
				if math.random(1,20) == 1 then
					--Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-0.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)) * CFrame.Angles(math.rad(math.random(-45,45)),math.rad(math.random(-45,45)),math.rad(math.random(-45,45))),1)
				end
				RightHip.C1 = Clerp(RightHip.C1,CFrame.new(0.5,1,0) * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.7 / 3)
				LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-0.5,1,0) * CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.7 / 3)
			end
			if RootPart.Velocity.y > 1 and hit == nil then 
				Anim = "Jump"
				if attack == false then
					RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0,0,0 ) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
					Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0 ,0 + ((1) - 1)) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(10)),1 / 3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-50),math.rad(0),math.rad(0 + 10 * math.cos(sine / 12))) * rscp,1 / 3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(50),math.rad(0),math.rad(-25 - 10 * math.cos(sine / 12))) * lscp,1 / 3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.4,-0.6) * CFrame.Angles(math.rad(1),math.rad(90),math.rad(0)) * CFrame.Angles(math.rad(-1 * math.sin(sine / 6)),math.rad(0),math.rad(0)),1 / 3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-85),math.rad(0)) * CFrame.Angles(math.rad(-1 * math.sin(sine / 6)),math.rad(0),math.rad(0)),1 / 3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
				end
			elseif RootPart.Velocity.y < -1 and hit == nil then 
				Anim = "Fall"
				if attack == false then
					RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0,0,0 ) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(0)),1 / 3)
					Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0 ,0 + ((1) - 1)) * CFrame.Angles(math.rad(-15),math.rad(2.5),math.rad(5+5 * math.cos(sine / 12))),1 / 3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-90 - 4 * math.cos(sine / 6)),math.rad(0),math.rad(0 + 10 * math.cos(sine / 12))) * rscp,1 / 3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(35 - 4 * math.cos(sine / 6)),math.rad(0),math.rad(-45 - 10 * math.cos(sine / 12))) * lscp,1 / 3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.3,-0.7) * CFrame.Angles(math.rad(-25 + 5 * math.sin(sine / 12)),math.rad(90),math.rad(0)) * CFrame.Angles(math.rad(-1 * math.sin(sine / 6)),math.rad(0),math.rad(0)),1 / 3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-0.8,-0.3) * CFrame.Angles(math.rad(-10),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(-1 * math.sin(sine / 6)),math.rad(0),math.rad(0)),1 / 3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
				end
			elseif Torsovelocity < 1 and hit ~= nil then
				Anim = "Idle"
				if taunt.Value == "None" and attack == false then
					change = 1
					RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0,0,0 + 0.05 * math.cos(sine / 12)) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(0)),1 / 3)
					Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),1/3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5 + 0.1 * math.cos(sine / 12),0) * CFrame.Angles(math.rad(-53.75+1.75 * math.cos(sine / 12)),math.rad(0),math.rad(5)) * rscp,1 / 3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5 + 0.1 * math.cos(sine / 12),-0) * CFrame.Angles(math.rad(15 - 1.5 * math.cos(sine / 12)),math.rad(0 - 6 * math.cos(sine / 12)),math.rad(0 - 6 * math.cos(sine / 12))) * lscp,1 / 3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1.1 - 0.05 * math.cos(sine / 12),0) * CFrame.Angles(math.rad(15),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1.1 - 0.05 * math.cos(sine / 12),0) * CFrame.Angles(math.rad(10),math.rad(-70),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-106.3-.9*math.cos(sine/12)),math.rad(0),math.rad(0)),1 / 2)
				end
				if taunt.Value == "Glitch" and attack == false then
					change = 1
					RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0,0,0 + 0.05 * math.cos(sine / 12)) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(0)),1 / 3)
					Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),1/3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5 + 0.1 * math.cos(sine / 12),0) * CFrame.Angles(math.rad(-53.75+1.75 * math.cos(sine / 12)),math.rad(0),math.rad(5)) * rscp,1 / 3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5 + 0.1 * math.cos(sine / 12),-0) * CFrame.Angles(math.rad(15 - 1.5 * math.cos(sine / 12)),math.rad(0 - 6 * math.cos(sine / 12)),math.rad(0 - 6 * math.cos(sine / 12))) * lscp,1 / 3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1.1 - 0.05 * math.cos(sine / 12),0) * CFrame.Angles(math.rad(15),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1.1 - 0.05 * math.cos(sine / 12),0) * CFrame.Angles(math.rad(10),math.rad(-70),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-106.3-.9*math.cos(sine/12)),math.rad(0),math.rad(0)),1 / 2)
				end
			elseif Torsovelocity > 2 and hit ~= nil then
				Anim = "Walk"
				if taunt.Value == "None" and attack == false then
					RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0,0,0 + 0.05 * math.cos(sine / 12)) * CFrame.Angles(math.rad(20),math.rad(0 + 2.5 * math.cos(sine / 12)),math.rad(0 - 2.5 * math.cos(sine / 12))),1 / 3)
					Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(-20 - 3 * math.cos(sine / 12)),math.rad(0 - 2.5 * math.cos(sine / 12)),math.rad(0 - 2.5 * math.cos(sine / 12))),1 / 3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-60 - 5 * math.cos(sine / 12)),math.rad(0 - 2.5 * math.cos(sine / 12)),math.rad(5 + 2.5 * math.cos(sine / 12))) * rscp,1 / 3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0 - 0.2 * math.cos(sine / 12)) * CFrame.Angles(math.rad(20 - 45 * math.cos(sine / 12)),math.rad(0 - 10 * math.cos(sine / 12)),math.rad(0 + 2.5 * math.cos(sine / 12))) * lscp,1 / 3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1 ,-1,0) * CFrame.Angles(math.rad(0),math.rad(85),math.rad(0)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1 / 3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-85),math.rad(0)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1 / 3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-93.75+7.25*math.cos(sine/12)),math.rad(0),math.rad(0)),1 / 2)
				end
				if taunt.Value == "Glitch" and attack == false then
					RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0,0,0 + 0.05 * math.cos(sine / 12)) * CFrame.Angles(math.rad(20),math.rad(0 + 2.5 * math.cos(sine / 12)),math.rad(0 - 2.5 * math.cos(sine / 12))),1 / 3)
					Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(-20 - 3 * math.cos(sine / 12)),math.rad(0 - 2.5 * math.cos(sine / 12)),math.rad(0 - 2.5 * math.cos(sine / 12))),1 / 3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-60 - 5 * math.cos(sine / 12)),math.rad(0 - 2.5 * math.cos(sine / 12)),math.rad(5 + 2.5 * math.cos(sine / 12))) * rscp,1 / 3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0 - 0.2 * math.cos(sine / 12)) * CFrame.Angles(math.rad(20 - 45 * math.cos(sine / 12)),math.rad(0 - 10 * math.cos(sine / 12)),math.rad(0 + 2.5 * math.cos(sine / 12))) * lscp,1 / 3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1 ,-1,0) * CFrame.Angles(math.rad(0),math.rad(85),math.rad(0)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1 / 3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-85),math.rad(0)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1 / 3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-93.75+7.25*math.cos(sine/12)),math.rad(0),math.rad(0)),1 / 2)
				end
			end
			--GUN.Base.Transparency = 0
			--GUN.GunAdditions.Transparency = 0
			--GUN.NeonParts.Transparency = 0
		elseif taunt.Value == "Glitch" then
			RootJoint.C1 = Clerp(RootJoint.C1,rc0 * CFrame.new(0,0,0),0.2/3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-0.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),0.2/3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(0.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-0.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
			if attack == false then
				if Torsovelocity < 1 then
					Anim = "Idle"
					RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0,0,0 + 0.05 * math.cos(sine / 12)) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(0)),1 / 3)
					Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),1/3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5 + 0.1 * math.cos(sine / 12),0) * CFrame.Angles(math.rad(-53.75+1.75 * math.cos(sine / 12)),math.rad(0),math.rad(5)) * rscp,1 / 3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5 + 0.1 * math.cos(sine / 12),-0) * CFrame.Angles(math.rad(15 - 1.5 * math.cos(sine / 12)),math.rad(0 - 6 * math.cos(sine / 12)),math.rad(0 - 6 * math.cos(sine / 12))) * lscp,1 / 3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1.1 - 0.05 * math.cos(sine / 12),0) * CFrame.Angles(math.rad(15),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1.1 - 0.05 * math.cos(sine / 12),0) * CFrame.Angles(math.rad(10),math.rad(-70),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-106.3-.9*math.cos(sine/12)),math.rad(0),math.rad(0)),1 / 2)
				elseif Torsovelocity >= 2 then
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5+.25*math.sin(sine/9),0) * CFrame.Angles(math.rad(-50+5*math.sin(sine/9)),math.rad(0),math.rad(0)) * rscp,0.7/3)
					--LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5+.25*math.sin(sine/9),0) * CFrame.Angles(math.rad(110),math.rad(0),math.rad(0)) * LEFTSHOULDERC0,0.7/3)
					RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0,0,0 + 0.05 * math.cos(sine / 12)) * CFrame.Angles(math.rad(20),math.rad(0 + 2.5 * math.cos(sine / 12)),math.rad(0 - 2.5 * math.cos(sine / 12))),1 / 3)
					Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(-20 - 3 * math.cos(sine / 12)),math.rad(0 - 2.5 * math.cos(sine / 12)),math.rad(0 - 2.5 * math.cos(sine / 12))),1 / 3)
					--RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-60 - 5 * math.cos(sine / 12)),math.rad(0 - 2.5 * math.cos(sine / 12)),math.rad(5 + 2.5 * math.cos(sine / 12))) * rscp,1 / 3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0 - 0.2 * math.cos(sine / 12)) * CFrame.Angles(math.rad(20 - 45 * math.cos(sine / 12)),math.rad(0 - 10 * math.cos(sine / 12)),math.rad(0 + 2.5 * math.cos(sine / 12))) * lscp,1 / 3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1 ,-1,0) * CFrame.Angles(math.rad(0),math.rad(85),math.rad(0)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1 / 3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-85),math.rad(0)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1 / 3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-93.75+7.25*math.cos(sine/12)),math.rad(0),math.rad(0)),1 / 2)
				end
				local partnum = math.random(1,48)
				coroutine.resume(coroutine.create(function()
					local wingpart = Character.Wings:GetChildren()[partnum]
					wingpart.Color = GUN.NeonParts.Color
					wingpart.WingTrail.Color = ColorSequence.new(wingpart.Color)
					swait()
					if not alreadyfixing then
						wingpart.Color = shade
						wingpart.WingTrail.Color = ColorSequence.new(shade)
					end
				end))
				--GUN.Base.Transparency = 0
				--GUN.GunAdditions.Transparency = 0
				--GUN.NeonParts.Transparency = 0
			end
		else
			GUN.Base.Transparency = 1
			GUN.GunAdditions.Transparency = 1
			GUN.NeonParts.Transparency = 1
			if taunt.Value == "Fave" then
				RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
				Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)) * rscp,1)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.3,0.7,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-135)) * lscp,1)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(.5,-2,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-.9,-1.9,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-25)),1)
				RightHip.C1 = Clerp(RightHip.C1,CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
				LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0,-1,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			end
			if taunt.Value == "Memer" then
				RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0 , 0 , 0) * CFrame.Angles(math.rad(MRANDOM(-9000,9000)), math.rad(MRANDOM(-9000,9000)), math.rad(MRANDOM(-9000,9000))),1)
				Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * rscp,1)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(-90)) * lscp,1)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)),1)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)),1)
				RightHip.C1 = Clerp(RightHip.C1,CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
				LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0,-1,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			end
			if taunt.Value == "Krump" then
				RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0+1*math.sin(sine/3),0+1*math.cos(sine/3),-.75) * CFrame.Angles(math.rad(0),math.rad(-10),math.rad(0)),1)
				Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,1,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90)) * rscp,1)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,1,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-90)) * lscp,1)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1.5,-1,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(70)),1)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-.5,-1.25,-.25) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(10)),1)
				RightHip.C1 = Clerp(RightHip.C1,CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
				LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0,-1,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			end
		end
	end
end
end)

Section2:CreateButton("Full X Banisher", function()
	
warn[[.
--//==============================================================\\--
--||			  "MURDER" BY SHACKLUSTER
--||                EDITED BY megamoeus
--||
--||                The player has risen.
--||           And he wants to avenge everyone.
--||      REALITY WILL BE CORRUPTED IF YOU LET THAT HAPPEN MORE.
--\\==============================================================//--]]
lplr = game.Players.LocalPlayer
Player = lplr
Cam = workspace.CurrentCamera
Mouse,mouse=Player:GetMouse(),Player:GetMouse()

local ActualVelocity = Vector3.new(0,0,0)
--[[
if lplr == Player then
	spawn(function()
		while true do
			local Positions = {}
			local Speeds = {}
			for i = 1,10 do
				table.insert(Positions, RootPart.CFrame)
				table.insert(Speeds, RootPart.Velocity)
				script.ArtificialHB2.Event:wait()
			end
			--Movement:FireServer(Positions, Speeds)
		end
	end)
	spawn(function()
		while true do
			game:GetService("RunService").RenderStepped:wait()
			--RealRoot = workspace.Terrain:WaitForChild(Player.Name.." tracker")
			--RealRoot.CFrame = RootPart.CFrame
		end
	end)

end
--]]
local S = setmetatable({},{__index = function(s,i) return game:service(i) end})
local CF = {N=CFrame.new,A=CFrame.Angles,fEA=CFrame.fromEulerAnglesXYZ}
local C3 = {N=Color3.new,RGB=Color3.fromRGB,HSV=Color3.fromHSV,tHSV=Color3.toHSV}
local V3 = {N=Vector3.new,FNI=Vector3.FromNormalId,A=Vector3.FromAxis}
local M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}
local R3 = {N=Region3.new}
local De = S.Debris
local WS = workspace
local Lght = S.Lighting
local RepS = S.ReplicatedStorage
local IN = Instance.new
local Plrs = S.Players

Character = workspace.Camera.CameraSubject.Parent
PlayerGui = Player.PlayerGui
Backpack = Player.Backpack
Humanoid = Character.Humanoid
RootPart = Character["HumanoidRootPart"]
Torso = Character["Torso"]
Head = Character["Head"]
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart["RootJoint"]
Neck = Torso["Neck"]
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]

IT = Instance.new
it = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
vt = Vector3.new
cf = CFrame.new


--//=================================\\
--|| 	      USEFUL VALUES
--\\=================================//
local SONG1 = 2371543268
local SONG2 = 2371543268
local BanishMode = 1
local KeepPlayersOutfit = false
local SIZE = 1
local Player_Size = 1
local Jump = 50
local Animation_Speed = 3
local lastbeat = 0
local lastloud = 0
local AntiBullet = true
local PlaybackSound = 0
local Speed = 16
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local faceShadingFolder = IT("Model", Character)
faceShadingFolder.Name = "Face Shading Folder"
local Weapon = IT("Model")
Weapon.Name = "Finding Lost"
local Karma = IT("Model")
Weapon.Name = "Finding Lost"
local KarmaWeapon = IT("Model")
Weapon.Name = "Finding Lost"
local KarmaWeapon2 = IT("Model")
Weapon.Name = "Finding Lost"
--[[local HornFolder = IT("Model", Character)
HornFolder.Name = "Horns"]]--
local BannedSkids = {}
local TOBANISH = {}
local qui = Enum.EasingStyle.Quint
local io = Enum.EasingDirection.InOut
local char = workspace.Camera.CameraSubject.Parent
local t = char:FindFirstChild("Torso")
local ls = t:FindFirstChild("Left Shoulder")
local rh = t:FindFirstChild("Right Hip")
local lh = t:FindFirstChild("Left Hip")
local hum = char:FindFirstChildOfClass("Humanoid")
local tweens = game:GetService("TweenService")
local rs = t:FindFirstChild("Right Shoulder")
local rut = char.HumanoidRootPart
local rutj = rut.RootJoint
local t = char:FindFirstChild("Torso")
local nec = t.Neck
local MAINRUINCOLOR = BrickColor.Black()
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local targetted = nil
local EQUIPPED = false
local HOLD = false
local furmode = false
local sitting = false
local COMBO = 1
local Rooted = false
local SINE = 0
local rad = math.rad
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local RunService = game:GetService("RunService")
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
--ROBLOXIDLEANIMATION.Parent = Humanoid
local Effects = IT("Folder", Character)
Effects.Name = "Effects"
pcall(function()
	Character.Animate.Parent = nil
end)
local UNANCHOR = true

function Rainbowify(name)
	while RunService.Stepped:Wait() do
		for hue = 0, 1, 0.06 do
			name.Color = Color3.fromHSV(hue,1,1)
			wait(0.001)
		end
	end
end

function RainbowifyText(name)
	while RunService.Stepped:Wait() do
		for hue = 0, 1, 0.06 do
			name.TextColor3 = Color3.fromHSV(hue, 1, 1)
			name.TextStrokeColor3 = Color3.fromHSV(hue, 1, 1)
			wait(0.0005)
		end
	end
end

local FONTS = {
	Enum.Font.Antique,
	Enum.Font.Arcade,
	Enum.Font.Arial,
	Enum.Font.ArialBold,
	Enum.Font.Bodoni,
	Enum.Font.Cartoon,
	Enum.Font.Code,
	Enum.Font.Fantasy,
	Enum.Font.Garamond,
	Enum.Font.Highway,
	Enum.Font.Legacy,
	Enum.Font.SciFi,
	Enum.Font.SourceSans,
	Enum.Font.SourceSansBold,
	Enum.Font.SourceSansItalic,
	Enum.Font.SourceSansLight,
	Enum.Font.SourceSansSemibold
	}

local naeeym2 = Instance.new("BillboardGui",Character)
naeeym2.AlwaysOnTop = true
naeeym2.Size = UDim2.new(7,35,3,15)
naeeym2.StudsOffset = Vector3.new(0,2,0)
naeeym2.MaxDistance = 10000
naeeym2.Adornee = Head
naeeym2.Name = "Name2"
local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.TextScaled = true
tecks2.BorderSizePixel = 0
tecks2.Text = "   "
tecks2.Font = "Arcade"
tecks2.TextSize = 35
tecks2.TextStrokeTransparency = 0
tecks2.Size = UDim2.new(1,0,0.5,0)
tecks2.Parent = naeeym2
tecks2.TextColor3 = Color3.fromRGB()
coroutine.resume(coroutine.create(function()
				while true do
					Swait()
					tecks2.Font = FONTS[MRANDOM(1, #FONTS)]
					tecks2.Position = UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))
				end
			end))
spawn(function() RainbowifyText(tecks2) end)

--//=================================\\
--\\=================================//

--//=================================\\
--|| SAZERENOS' ARTIFICIAL HEARTBEAT
--\\=================================//
Frame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
		lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

--//=================================\\
--\\=================================//


--//=================================\\
--|| 	      SOME FUNCTIONS
--\\=================================//
NewInstance = function(instance,parent,properties)
	local inst = Instance.new(instance,parent)
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end

local tlerp = function(part,tablee,leinght,easingstyle,easingdirec)
pcall(function()
    local info = TweenInfo.new(
    leinght,
    easingstyle,
    easingdirec,
    0,
    false,
    0
    )
    local lerp = tweens:Create(part,info,tablee)
    lerp:Play()
end)
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end

function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function hasarrived(whom)
	for i,v in pairs(game:GetService("Players"):GetPlayers()) do
		coroutine.resume(coroutine.create(function()
			if v.PlayerGui:FindFirstChild("ARRIVAL")~= nil then
				v.PlayerGui:FindFirstChild("ARRIVAL"):destroy()
			end
			local droppingFrame = false
			local scrg = Instance.new("ScreenGui",v.PlayerGui)
			scrg.Name = "ARRIVAL"
			local mainFrame = Instance.new("Frame", scrg)
			mainFrame.Name = "MainFrame"
			mainFrame.BackgroundTransparency = 0
			mainFrame.BorderSizePixel = 5
			mainFrame.Size = UDim2.new(1, 0, -0.013, 100)
			mainFrame.Position = UDim2.new(0, 0, 0.365, 0)
			local TextFrame = Instance.new("TextLabel",mainFrame)
			TextFrame.Name = "TextFrame"
			TextFrame.Font = "Arcade"
			TextFrame.Text = "   "
			TextFrame.TextScaled = true
			TextFrame.TextSize = 14
			TextFrame.TextStrokeTransparency = 0
			TextFrame.BackgroundTransparency = 1
			TextFrame.Size = UDim2.new(1, 0, 0, 92)
			TextFrame.Position = UDim2.new(0, 0, 0, 0)
			local fvalen = 0.55
			local fval = -0.49
			coroutine.resume(coroutine.create(function()
				while true do
					Swait()
					mainFrame.BackgroundColor3 = C3(0,0,0)
					mainFrame.BorderColor3 = C3(1, 1, 1)
					if(not droppingFrame)then
						mainFrame.Rotation = 0 - 2 * COS(SINE / 24)
					end
					TextFrame.TextColor3 = C3(0,0,0)
					TextFrame.Font = FONTS[MRANDOM(1, #FONTS)]
					TextFrame.TextStrokeColor3 = C3(1, 1, 1)
					TextFrame.TextStrokeTransparency = 0
				end
			end))
			for i = 1,string.len(whom),1 do
				TextFrame.Text = string.sub(whom,1,i)
				wait(0.2)
			end
			wait(2)
			droppingFrame = true
			mainFrame.Rotation = 0
			local vinc2 = 1
			for i = 0, 99 do
				Swait()
				vinc2 = vinc2 + 0.25
				mainFrame.Position = mainFrame.Position + UDim2.new(0,0,0.0005*vinc2,0)
			end
			scrg:Destroy()
		end))
	end
end

function hasarrivedB(whom)
	for i,v in pairs(game:GetService("Players"):GetPlayers()) do
		coroutine.resume(coroutine.create(function()
			if v.PlayerGui:FindFirstChild("ARRIVAL")~= nil then
				v.PlayerGui:FindFirstChild("ARRIVAL"):destroy()
			end
			local droppingFrame = false
			local scrg = Instance.new("ScreenGui",v.PlayerGui)
			scrg.Name = "ARRIVAL"
			local mainFrame = Instance.new("Frame", scrg)
			mainFrame.Name = "MainFrame"
			mainFrame.BackgroundTransparency = 1
			mainFrame.BorderSizePixel = 0
			mainFrame.Size = UDim2.new(1, 0, -0.013, 100)
			mainFrame.Position = UDim2.new(0, 0, 0.365, 0)
			local TextFrame = Instance.new("TextLabel",mainFrame)
			TextFrame.Name = "TextFrame"
			TextFrame.Font = "Arcade"
			TextFrame.Text = "   "
			TextFrame.TextScaled = true
			TextFrame.TextSize = 9
			TextFrame.TextStrokeTransparency = 1
			TextFrame.BackgroundTransparency = 1
			TextFrame.TextColor3 = C3(1,1,1)
			TextFrame.TextStrokeColor3 = C3(0, 0, 0)
			TextFrame.Size = UDim2.new(1, 0, 0, 92)
			TextFrame.Position = UDim2.new(0, 0, 0, 0)
			spawn(function() RainbowifyText(TextFrame) end)
			local fvalen = 0.55
			local fval = -0.49
			coroutine.resume(coroutine.create(function()
				while true do
					Swait()
					mainFrame.BackgroundColor3 = C3(0,0,0)
					mainFrame.BorderColor3 = C3(0, 0, 0)
					if(not droppingFrame)then
						mainFrame.Rotation = 0 - 2 * COS(SINE / 24)
					end
					TextFrame.TextStrokeTransparency = 0
				end
			end))
			for i = 1,string.len(whom),1 do
				TextFrame.Text = string.sub(whom,1,i)
				wait(0.2)
			end
			wait(2)
			droppingFrame = true
			mainFrame.Rotation = 0
			local vinc2 = 1
			for i = 0, 99 do
				Swait()
				vinc2 = vinc2 + 0.25
				mainFrame.Position = mainFrame.Position + UDim2.new(0,0,0.0005*vinc2,0)
			end
			scrg:Destroy()
		end))
	end
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

	local function weldBetween(a, b)
	    local weldd = Instance.new("ManualWeld")
	    weldd.Part0 = a
	    weldd.Part1 = b
	    weldd.C0 = CFrame.new()
	    weldd.C1 = b.CFrame:inverse() * a.CFrame
	    weldd.Parent = a
	    return weldd
	end


function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end

function turnto(position)
    RootPart.CFrame=CFrame.new(RootPart.CFrame.p,VT(position.X,RootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
end

function CreateWave(SIZE,WAIT,CFRAME,DOESROT,ROT,COLOR,GROW)
    local wave = CreatePart(3, Effects, "Neon", 0, 0.5, COLOR, "Effect", VT(0,0,0))
    local mesh = IT("SpecialMesh",wave)
    mesh.MeshType = "FileMesh"
    mesh.MeshId = "http://www.roblox.com/asset/?id=20329976"
    mesh.Scale = SIZE
    mesh.Offset = VT(0,0,-SIZE.X/8)
    wave.CFrame = CFRAME
    coroutine.resume(coroutine.create(function(PART)
        for i = 1, WAIT do
            Swait()
            mesh.Scale = mesh.Scale + GROW
            mesh.Offset = VT(0,0,-(mesh.Scale.X/8))
			wave.Color = C3(0,0,0)
            if DOESROT == true then
                wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0,ROT,0)
            end
            wave.Transparency = wave.Transparency + (0.5/WAIT)
            if wave.Transparency > 0.99 then
                wave:remove()
            end
        end
    end))
end

function CreateSwirl(SIZE,WAIT,CFRAME,DOESROT,ROT,COLOR,GROW)
    local wave = CreatePart(3, Effects, "Neon", 0, 0.5, COLOR, "Effect", VT(0,0,0))
    local mesh = IT("SpecialMesh",wave)
    mesh.MeshType = "FileMesh"
    mesh.MeshId = "http://www.roblox.com/asset/?id=1051557"
    mesh.Scale = SIZE
    wave.CFrame = CFRAME
    coroutine.resume(coroutine.create(function(PART)
        for i = 1, WAIT do
            Swait()
            mesh.Scale = mesh.Scale + GROW
            mesh.Offset = VT(0,0,-(mesh.Scale.X/8))
			wave.Color = C3(0,0,0)
            if DOESROT == true then
                wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0,ROT,0)
            end
            wave.Transparency = wave.Transparency + (0.5/WAIT)
            if wave.Transparency > 0.99 then
                wave:remove()
            end
        end
    end))
end

function killnearest(position,range,maxstrength,direction)
    for i,v in ipairs(workspace:GetChildren()) do
    local body = v:GetChildren()
        for part = 1, #body do
            if((body[part].ClassName == "Part" or body[part].ClassName == "MeshPart") and v ~= Character) then
                if(body[part].Position - position).Magnitude < range then
                    if v.ClassName == "Model" then
                        --v:BreakJoints()
                    end
                    local POS = position
                    coroutine.resume(coroutine.create(function()
                        body[part].Anchored = true
                        body[part].Parent = Effects
                        body[part].CanCollide = true
                        local SIZE = body[part].Size
                        body[part].Material = "Neon"
                        CFuncs["Sound"].Create("rbxassetid://62339698", workspace, 10, 0.3)
                        for i = 1, 75 do
                            Swait()
                            body[part].Color = C3(255/255, 255/255, 255/255)
                            body[part].Size = VT(SIZE.X+MRANDOM(-2,2),SIZE.Y+MRANDOM(-2,2),SIZE.Z+MRANDOM(-2,2))
                        end
                        coroutine.resume(coroutine.create(function()
                            while true do
                                Swait()
                                body[part].Color = C3(255/255, 255/255, 255/255)
                                body[part].Size = VT(SIZE.X+MRANDOM(-2,2),SIZE.Y+MRANDOM(-2,2),SIZE.Z+MRANDOM(-2,2))
                            end
                        end))
                        body[part].Anchored = false
                        body[part].Velocity = direction.lookVector*maxstrength
                    end))
                end
            end
        end
        if v.ClassName == "Part" then
            if v.Anchored == false and (v.Position - position).Magnitude < range then
                local POS = position
                coroutine.resume(coroutine.create(function()
                    v.Anchored = true
                    v.Parent = Effects
                    local SIZE = v.Size
                    v.Material = "Neon"
                    CreateSound("952306739", v, 2, MRANDOM(7, 12) / 10)
                    for i = 1, 75 do
                        Swait()
                        v.Color = C3(MRANDOM(0,100)/100,MRANDOM(0,100)/100,MRANDOM(0,100)/100)
                        v.Size = VT(SIZE.X+MRANDOM(-2,2),SIZE.Y+MRANDOM(-2,2),SIZE.Z+MRANDOM(-2,2))
                    end
                    coroutine.resume(coroutine.create(function()
                        while true do
                            Swait()
                            v.Color = C3(MRANDOM(0,100)/100,MRANDOM(0,100)/100,MRANDOM(0,100)/100)
                            v.Size = VT(SIZE.X+MRANDOM(-2,2),SIZE.Y+MRANDOM(-2,2),SIZE.Z+MRANDOM(-2,2))
                        end
                    end))
                    v.Anchored = false
                    v.Velocity = direction.lookVector*maxstrength
                end))
            end
        end
    end
end
 

function MagicSphere(SIZE,WAIT,CFRAME,COLOR,GROW)
    local wave = CreatePart(3, Effects, "Neon", 0, 0, COLOR, "Effect", VT(1,1,1), true)
    local mesh = IT("SpecialMesh",wave)
    mesh.MeshType = "Sphere"
    mesh.Scale = SIZE
    mesh.Offset = VT(0,0,0)
    wave.CFrame = CFRAME
    coroutine.resume(coroutine.create(function(PART)
        for i = 1, WAIT do
            Swait()
            mesh.Scale = mesh.Scale + GROW
			wave.Color = C3(0,0,0)
            wave.Transparency = wave.Transparency + (1/WAIT)
            if wave.Transparency > 0.99 then
                wave:remove()
            end
        end
    end))
end

function SpliceSlice(KIND, SIZE, WAIT, CFRAME, COLOR, GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(1, 1, 1), true)
	local mesh
	if KIND == "Base" then
		mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "448386996", "", VT(0, SIZE / 10, SIZE / 10), VT(0, 0, 0))
	elseif KIND == "Thin" then
		mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "662586858", "", VT(SIZE / 10, 0, SIZE / 10), VT(0, 0, 0))
	elseif KIND == "Round" then
		mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "662585058", "", VT(SIZE / 10, 0, SIZE / 10), VT(0, 0, 0))
	end
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW / 10
			wave.Color = C3(0,0,0)
			wave.Transparency = wave.Transparency + 0.5 / WAIT
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function AddChildrenToTable(FROM, PARENT, DIST, TABLE)
	for _, c in pairs(PARENT:GetChildren()) do
		if c.ClassName == "Model" then
			if c ~= Character and c:FindFirstChildOfClass("Humanoid") and (c:FindFirstChild("Torso") or c:FindFirstChild("UpperTorso")) then
				local HUMANOID = c:FindFirstChildOfClass("Humanoid")
				local TORSO = c:FindFirstChild("Torso") or c:FindFirstChild("UpperTorso")
				if DIST > (TORSO.Position - FROM).Magnitude then
					table.insert(TABLE, c)
				end
				AddChildrenToTable(FROM, c, DIST, TABLE)
			elseif c.ClassName == "Folder" then
				AddChildrenToTable(FROM, c, DIST, TABLE)
			end
		end
	end
end

function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function Slice(SIZE,WAIT,CFRAME,COLOR,GROW)
    local wave = CreatePart(3, Effects, "Neon", 0, 0.5, COLOR, "Effect", VT(1,1,1), true)
    local mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "448386996", "", VT(0,SIZE/10,SIZE/10), VT(0,0,0))
    wave.CFrame = CFRAME
    coroutine.resume(coroutine.create(function(PART)
        for i = 1, WAIT do
            Swait()
            mesh.Scale = mesh.Scale * GROW
			wave.Color = C3(0,0,0)
            wave.Transparency = wave.Transparency + (0.5/WAIT)
            if wave.Transparency > 0.99 then
                wave:remove()
            end
        end
    end))
end

function CreateWave2(SIZE,WAIT,CFRAME,DOESROT,ROT,COLOR,GROW)
    local wave = CreatePart(3, Effects, "Neon", 0, 0.5, COLOR, "Effect", VT(0,0,0))
    local mesh = IT("SpecialMesh",wave)
    mesh.MeshType = "FileMesh"
    mesh.MeshId = "http://www.roblox.com/asset/?id=20329976"
    mesh.Scale = SIZE
    wave.CFrame = CFRAME
    coroutine.resume(coroutine.create(function(PART)
        for i = 1, WAIT do
            Swait()
            mesh.Scale = mesh.Scale + GROW
			wave.Color = C3(0,0,0)
            if DOESROT == true then
                wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0,ROT,0)
            end
            wave.Transparency = wave.Transparency + (0.5/WAIT)
            if wave.Transparency > 0.99 then
                wave:remove()
            end
        end
    end))
end

function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end

function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
	local frame = IT("Frame")
	frame.BackgroundTransparency = TRANSPARENCY
	frame.BorderSizePixel = BORDERSIZEPIXEL
	frame.Position = POSITION
	frame.Size = SIZE
	frame.BackgroundColor3 = COLOR
	frame.BorderColor3 = BORDERCOLOR
	frame.Name = NAME
	frame.Parent = PARENT
	return frame
end

function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
	local label = IT("TextLabel")
	label.BackgroundTransparency = 1
	label.Size = UD2(1, 0, 1, 0)
	label.Position = UD2(0, 0, 0, 0)
	label.TextColor3 = TEXTCOLOR
	label.TextStrokeTransparency = STROKETRANSPARENCY
	label.TextTransparency = TRANSPARENCY
	label.FontSize = TEXTFONTSIZE
	label.Font = TEXTFONT
	label.BorderSizePixel = BORDERSIZEPIXEL
	label.TextScaled = false
	label.Text = TEXT
	label.Name = NAME
	label.Parent = PARENT
	return label
end

function NoOutlines(PART)
	PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
end

function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end

local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function CFrameFromTopBack(at, top, back)
	local right = top:Cross(back)
	return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end

--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME+1 do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = VT(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		end
	end))
end

Debris = game:GetService("Debris")

function CharacterFade(COLOR,TIMER)
	coroutine.resume(coroutine.create(function()
		local FADE = IT("Model",Effects)
		FADE.Name = "FadingEffect"
		for _, c in pairs(Character:GetChildren()) do
			if c.ClassName == "Part" and c ~= RootPart then
				local FADER = c:Clone()
				FADER.Color = COLOR
				FADER.CFrame = c.CFrame
				FADER.Parent = FADE
				FADER.Anchored = true
				FADER.Transparency = 0.25+c.Transparency
				FADER:BreakJoints()
				FADER.Material = "Neon"
				if FADER.Name == "Head" then
					FADER:ClearAllChildren()
					FADER.Size = VT(1,1,1)
				end
				FADER.CanCollide = false
			end
		end
		local TRANS = 0.75/TIMER
		for i = 1, TIMER do
			Swait()
			for _, c in pairs(FADE:GetChildren()) do
				if c.ClassName == "Part" then
					c.Transparency = c.Transparency + TRANS
				end
			end
		end
		FADE:remove()
	end))
end

function Chunks(PART)
	for i = 1, MRANDOM(3,5) do
		coroutine.resume(coroutine.create(function()
			local CHUNK = CreatePart(3, workspace, PART.Material, 0, PART.Transparency, PART.BrickColor, "Chunk", VT(0.3,0.3,0.3)*MRANDOM(7,13)/10, false)
			CHUNK.CFrame = PART.CFrame*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			local CFRAME = PART.CFrame*CF(MRANDOM(-4,4)/2,MRANDOM(-4,4)/2,-6)
			CHUNK.Velocity = CF(PART.Position,CFRAME.p).lookVector*MRANDOM(15,65)
			wait(0.1)
			CHUNK.CanCollide = true
			wait(MRANDOM(15,25)/5)
			for i = 1, 25 do
				Swait()
				CHUNK.Transparency = CHUNK.Transparency + 1/25
			end
			CHUNK:remove()
		end))
	end
end

New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end

NewInstance = function(instance,parent,properties)
	local inst = Instance.new(instance,parent)
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end

local function ToMesh(Part)
	local Mesh=Instance.new("SpecialMesh",Part)
	if Part.Shape==Enum.PartType.Block then Mesh.MeshType="Brick"elseif Part.Shape==Enum.PartType.Ball then Mesh.MeshType="Sphere"elseif Part.Shape==Enum.PartType.Cylinder then Mesh.MeshType="Cylinder"end
	Mesh.Scale=Part.Size*20 Part.Size=Vector3.new()
	return Mesh
end
local function GHK(char)
local Players=game:service("Players")
local soidk=Players:FindFirstChild(tostring(char))
if soidk~=nil then if soidk.Character and soidk~=Player and tostring(soidk)~="CKBackup"then-- print("hit : "..tostring(soidk))
	soidk.Character.Parent=workspace soidk.Character:BreakJoints()--soidk.Character:Destroy()
	if soidk.Character:FindFirstChild("HumanoidRootPart")then
	local p=Instance.new("Part")p.Size=Vector3.new(8,8,8)p.Material="Neon"p.Color=Color3.new(1)local m=ToMesh(p)p.Anchored=true p.CanCollide=false p.CFrame=soidk.Character.HumanoidRootPart.CFrame p.Parent=workspace m.MeshType="Sphere"
	p.CFrame=p.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),0)spawn(function()for i=0,1,.05 do if p.Parent then m.Scale=m.Scale+Vector3.new(25,25,25)p.Transparency=i swait()end end p:Destroy()end)
	for i=1,3 do local p=Instance.new("Part")p.Size=Vector3.new(8,8,8)p.Material="Neon"p.Color=Color3.new(1)local m=ToMesh(p)p.Anchored=true p.CanCollide=false p.CFrame=soidk.Character.HumanoidRootPart.CFrame p.Parent=workspace m.MeshType="Sphere"
	p.CFrame=p.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),0)spawn(function()for i=0,1,.01 do if p.Parent then m.Scale=m.Scale+Vector3.new(25,-1,-1)p.Transparency=i swait()end end p:Destroy()end)	
	end
	end spawn(function()swait(20)soidk.Character:Destroy()end)
end
end return soidk end

function dmg(dude,bloods,isfal)--(Position, Direction, Range, Ignore)

end

function mdmg(Part, Magnitude,Spread)--, MinimumDamage, MaximumDamage, KnockBack, Type, HitSound, HitPitch)
    --local buddy
	for _, c in pairs(workspace:children()) do
		local hum = c:FindFirstChildOfClass("Humanoid")
		if hum ~= nil then
			local head = c:findFirstChild("HumanoidRootPart")
			if head ~= nil then
				local targ = head.Position - Part.Position
				local mag = targ.magnitude
				if mag <= Magnitude and c.Name ~= Player.Name then 
				if c.Name ~= Character then
				if c.Name ~= "tomonaoboys" then
			local asd = Instance.new("ParticleEmitter",c.HumanoidRootPart)
			asd.Color = ColorSequence.new(Color3.new(1, 0, 0), Color3.new(.5, 0, 0))
			asd.LightEmission = .1
			asd.Size = NumberSequence.new(0.2)
			asd.Texture = "http://www.roblox.com/asset/?ID=771221224"
			asd.ZOffset = .9
			asd.Acceleration = Vector3.new(0, -5, 0)
			asd.LockedToPart = false
			asd.EmissionDirection = "Back"
			asd.Lifetime = NumberRange.new(1, 2)
			asd.Rate = 1000
			asd.Rotation = NumberRange.new(-10000, 10000)
			asd.RotSpeed = NumberRange.new(-100, 100)
			asd.Speed = NumberRange.new(6)
			asd.VelocitySpread = 1000000
			asd.Enabled=true
					--Damage(head, head, MinimumDamage, MaximumDamage, KnockBack, Type, RootPart, .1, "rbxassetid://" .. HitSound, HitPitch)
					if Spread==nil then Spread=1 end
					dmg(c,Spread)
					coroutine.wrap(function()
					wait(.2)
					asd.Enabled = false
					wait(2)
					asd:Remove()
					end)()
				       else		
   		Effects.Sphere.Create(BrickColor.new("Bright red"), c.HumanoidRootPart.CFrame, 30, 30, 30, .5, .5, .5, 0.04)

					end
				end
			end
			end
		end
		if c:FindFirstChild("Torso")then
			if (Part.Position-c.Torso.Position).magnitude<=Magnitude then
			GHK(c)
			end
		end
	end
end

function sphereMK(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos)
	local chaosmode = true
	hum = char.Humanoid
	local storehumanoidWS = 16
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = vt(x1, y1, z1)
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			if chaosmode == true then
				rng.BrickColor = BrickColor.Black()
			end
			speeder = speeder - 0.01 * FastSpeed * bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
		end
		rng:Destroy()
	end))
end

function sphere(bonuspeed, type, pos, scale, value, color)
    local chaosmode = true
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			if chaosmode == true then
				rng.BrickColor = BrickColor.Black()
			end
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
		end
		rng:Destroy()
	end))
end



function RemoveOutlines(part)
  part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end

CFuncs = {	
	["Part"] = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part"){
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material,
			}
			RemoveOutlines(Part)
			return Part
		end;
	};
	
	["Mesh"] = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end;
	};
	
	["Mesh"] = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end;
	};
	
	["Weld"] = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld"){
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1,
			}
			return Weld
		end;
	};

	["Sound"] = {
		Create = function(id, par, vol, pit) 
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound"){
					Volume = vol,
                                        Name = "EffectSoundo",
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 10)
			end))
		end;
	};

	["TimeSound"] = {
		Create = function(id, par, vol, pit, timepos) 
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound"){
					Volume = vol,
                                        Name = "EffectSoundo",
					Pitch = pit or 1,
					SoundId = id,
                                        TimePosition = timepos,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 10)
			end))
		end;
	};
	["EchoSound"] = {
		Create = function(id, par, vol, pit, timepos,delays,echodelay,fedb,dryl) 
			coroutine.resume(coroutine.create(function()
				local Sas = Create("Sound"){
					Volume = vol,
                    Name = "EffectSoundo",
					Pitch = pit or 1,
					SoundId = id,
                    TimePosition = timepos,
					Parent = par or workspace,
				}
				local E = Create("EchoSoundEffect"){
					Delay = echodelay,
                    Name = "Echo",
					Feedback = fedb,
                    DryLevel = dryl,
					Parent = Sas,
				}
				wait() 
				Sas:play() 
				game:GetService("Debris"):AddItem(Sas, delays)
			end))
		end;
	};

	["LongSound"] = {
		Create = function(id, par, vol, pit) 
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound"){
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 60)
			end))
		end;
	};
	
	["ParticleEmitter"] = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter"){
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread,
			}
			return fp
		end;
	};

	CreateTemplate = {
	
	};
}

function slash(bonuspeed,rotspeed,rotatingop,typeofshape,type,typeoftrans,pos,scale,value,color)
local type = type
local rotenable = rotatingop
local rng = Instance.new("Part", Effects)
        rng.Anchored = true
        rng.BrickColor = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
if typeoftrans == "In" then
rng.Transparency = 1
end
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "FileMesh"
if typeofshape == "Normal" then
rngm.MeshId = "rbxassetid://662586858"
elseif typeofshape == "Round" then
rngm.MeshId = "rbxassetid://662585058"
end
rngm.Scale = scale
local scaler2 = 1/10
if type == "Add" then
scaler2 = 1*value/10
elseif type == "Divide" then
scaler2 = 1/value/10
end
local randomrot = MRANDOM(1,2)
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
Swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed/10
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed/10
end
if rotenable == true then
if randomrot == 1 then
rng.CFrame = rng.CFrame*CFrame.Angles(0,RAD(rotspeed*bonuspeed/2),0)
elseif randomrot == 2 then
rng.CFrame = rng.CFrame*CFrame.Angles(0,RAD(-rotspeed*bonuspeed/2),0)
end
end
if typeoftrans == "Out" then
rng.Transparency = rng.Transparency + 0.01*bonuspeed
elseif typeoftrans == "In" then
rng.Transparency = rng.Transparency - 0.01*bonuspeed
end
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed/10, 0, scaler2*bonuspeed/10)
end
rng:Destroy()
end))
end

function block(bonuspeed,type,pos,scale,value,value2,value3,color,color3)
local type = type
local rng = Instance.new("Part", Effects)
        rng.Anchored = true
        rng.BrickColor = color
        rng.Color = color3
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Brick"
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
Swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.CFrame = rng.CFrame*CFrame.Angles(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)))
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end))
end

function sphere2(bonuspeed,type,pos,scale,value,value2,value3,color)
	local type = type
	local rng = Instance.new("Part", Effects)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = scale
	local scaler2 = 1
	local scaler2b = 1
	local scaler2c = 1
	if type == "Add" then
		scaler2 = 1*value
		scaler2b = 1*value2
		scaler2c = 1*value3
	elseif type == "Divide" then
		scaler2 = 1/value
		scaler2b = 1/value2
		scaler2c = 1/value3
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			Swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
				scaler2b = scaler2b - 0.01*value/bonuspeed
				scaler2c = scaler2c - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
				scaler2b = scaler2b - 0.01/value*bonuspeed
				scaler2c = scaler2c - 0.01/value*bonuspeed
			end
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
		end
		rng:Destroy()
	end))
end

function ManualDamage(Humanoid,Damage,TorsoPart)

end

function ManualAoE(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD.Parent ~= Effects then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if INSTAKILL == true then
							CHILD:BreakJoints()
						else
							local DMG = MRANDOM(MINDMG,MAXDMG)
							ManualDamage(HUM,DMG,TORSO)
						end
						if FLING > 0 then
							for _, c in pairs(CHILD:GetChildren()) do
								if c:IsA("BasePart") then
									local bv = Instance.new("BodyVelocity") 
									bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
									bv.Parent = c
									Debris:AddItem(bv,0.05)
								end
							end
						end
					end
				end
			end
		end
	end
end

function dmj(dude)

end


local function FindHumanoid(Part)local humanoid=nil if Part.Parent then if Part.Parent~=Player.Character and Part.Parent:FindFirstChildOfClass("Humanoid")~=nil then humanoid=Part.Parent:FindFirstChildOfClass("Humanoid")else if Part.Parent.Parent then if Part.Parent.Parent:FindFirstChildOfClass("Humanoid")and Part.Parent.Parent~=Player.Character then humanoid=Part.Parent.Parent:FindFirstChildOfClass("Humanoid")end end end end if humanoid==Humanoid then humanoid=nil end return humanoid end  
function CreateBeam(Parent,isReversed)local p=Instance.new("Beam",Parent)local a0=Instance.new("Attachment",Parent)local a1=Instance.new("Attachment",Parent)if isReversed then p.Attachment0=a1 p.Attachment1=a0 else p.Attachment0=a0 p.Attachment1=a1 end return a0,a1,p end
function CTE(Part)Part.Size=Vector3.new()Part.Transparency=1 Part.CanCollide=false Part.Anchored=true local j=Instance.new("BodyVelocity",Part)j.MaxForce=Vector3.new(1/0,1/0,1/0)j.Velocity=Vector3.new(0,0,0)end
function RingE(pos,siz,tim,dsiz,seg,wid,z,col,w)local IDK=.7
	local p=Instance.new("Part",workspace)if col==nil then col=ColorSequence.new(Color3.new())end if z==nil then z=0 end
	CTE(p)p.CFrame=pos
	local a0,a1,b=CreateBeam(p)a0.Position=Vector3.new(0,0,-dsiz)a1.Position=-a0.Position b.Texture="rbxassetid://1251856844"b.Color=col
	local b2=Instance.new("Beam",b.Parent)b2.Attachment0=a1 b2.Attachment1=a0 b2.Texture="rbxassetid://1251856844"b2.Color=col
	b.CurveSize0=math.abs(a0.Position.Z)*2 *IDK b.CurveSize1=math.abs(a0.Position.Z)*2 *IDK b2.CurveSize0=-math.abs(a0.Position.Z)*2 *IDK b2.CurveSize1=math.abs(a0.Position.Z)*2 *IDK
	b.Segments=seg b2.Segments=seg b.ZOffset=z b2.ZOffset=z b.Width0=wid b.Width1=wid b2.Width0=wid b2.Width1=wid spawn(function()
	for i=1,tim do if p.Parent then
		a0.Position=a0.Position-Vector3.new(0,0,siz)a1.Position=a1.Position+Vector3.new(0,0,siz)b.CurveSize0=(a1.Position.Z*2)*IDK b.CurveSize1=-(a1.Position.Z*2)*IDK
		b2.CurveSize0=-(a1.Position.Z*2)*IDK b2.CurveSize1=(a1.Position.Z*2)*IDK
		if w~=nil then b.Width0=b.Width0+w b.Width1=b.Width0 b2.Width0=b.Width0 b2.Width1=b.Width0 end b.Transparency=NumberSequence.new(i/tim)b2.Transparency=NumberSequence.new(i/tim)swait()
		end end p:Destroy()
	end)
end

function CreateFlyingDebree(FLOOR,POSITION,AMOUNT,BLOCKSIZE,SWAIT,STRENGTH)
	if FLOOR ~= nil then
		for i = 1, AMOUNT do
			local DEBREE = CreatePart(3, Effects, "Neon", FLOOR.Reflectance, FLOOR.Transparency, "Peal", "Debree", BLOCKSIZE, false)
			DEBREE.Material = FLOOR.Material
			DEBREE.Color = FLOOR.Color
			DEBREE.CFrame = POSITION * ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)))
			DEBREE.Velocity = VT(MRANDOM(-STRENGTH,STRENGTH),MRANDOM(-STRENGTH,STRENGTH),MRANDOM(-STRENGTH,STRENGTH))
			coroutine.resume(coroutine.create(function()
				Swait(15)
				DEBREE.Parent = workspace
				DEBREE.CanCollide = true
				Debris:AddItem(DEBREE,SWAIT)
			end))
		end
	end
end

--//=================================\\
--||	    GUIS AND MISC
--\\=================================//

local SKILLTEXTCOLOR = C3(1,0,0)
local SKILLFONT = "Antique"
local SKILLTEXTSIZE = 7

local ATTACKS = {"Z - Neckless","C - Brave Speed","G - Slashed","V - Dirtface"}

local GUIS = {}
local WEAPONGUI = IT("ScreenGui")
WEAPONGUI.Name = "[M U R D E R]"
for i = 1, #ATTACKS do
	local SKILLFRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.74, 0, 0.97-(0.02*i), 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill Frame")
	local SKILLTEXT = CreateLabel(SKILLFRAME, "["..ATTACKS[i].."]", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Skill text")
	SKILLTEXT.TextXAlignment = "Right"
	table.insert(GUIS,SKILLTEXT)
end

local sick = IT("Sound", Torso)
sick.SoundId = "rbxassetid://"..SONG1
sick.TimePosition = 0
sick.Looped = true
sick.Pitch = 1
sick.Volume = 10
sick:Play()

local BODY = {}
for _, c in pairs(Character:GetDescendants()) do
	if c:IsA("BasePart") and c.Name ~= "Handle" then
		if c ~= RootPart and c ~= Torso and c ~= Head and c ~= RightArm and c ~= LeftArm and c ~= RightLeg and c ~= LeftLeg then
			c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		end
		table.insert(BODY,{c,c.Parent,c.Material,c.Color,c.Transparency})
	elseif c:IsA("JointInstance") then
		table.insert(BODY,{c,c.Parent,nil,nil,nil})
	end
end
for e = 1, #BODY do
	if BODY[e] ~= nil then
		local STUFF = BODY[e]
		local PART = STUFF[1]
		local PARENT = STUFF[2]
		local MATERIAL = STUFF[3]
		local COLOR = STUFF[4]
		local TRANSPARENCY = STUFF[5]
		if PART.ClassName == "Part" and PART ~= RootPart then
			PART.Material = MATERIAL
			PART.Color = COLOR
			PART.Transparency = TRANSPARENCY
		end
		PART.AncestryChanged:Connect(function()
			PART.Parent = PARENT
		end)
	end
end

warn("All your friends are dead.")
warn("You're the only one left...")
warn("YOU NEED TO AVENGE THEM =)")

--//=================================\\
--||			DAMAGING
--\\=================================//

function ApplyDamage(Humanoid,Damage,OneShot)
	Damage = Damage * DAMAGEMULTIPLIER
	local DEAD = false
	if Humanoid.Health < 2000 and OneShot == false then
		if Humanoid.Health - Damage > 0 then
			Humanoid.Health = Humanoid.Health - Damage
		else
			if lplr == Player then
				DamageRemote:FireServer("BreakJoints", Humanoid.Parent)
			end
			DEAD = true
		end
	else
		DEAD = true
		if lplr == Player then
			DamageRemote:FireServer("BreakJoints", Humanoid.Parent)
		end
	end
	if DEAD == true then
		local PARTS = {}
		for index, CHILD in pairs(Humanoid.Parent:GetChildren()) do
			if CHILD:IsA("BasePart") then
				table.insert(PARTS,CHILD)
			end
		end
		coroutine.resume(coroutine.create(function()
			wait(2)
			repeat
				Swait()
				local PIECE = nil
				if MRANDOM(1,5) == 1 then
					for E = 1, #PARTS do
						if MRANDOM(1,5) == 1 then
							PIECE = PARTS[E]
							table.remove(PARTS,E)
							break
						end
					end
				end
				if PIECE ~= nil then
					if PIECE.Name == "Head" then
						WACKYEFFECT({Time = MRANDOM(10,30)*5, EffectType = "Box", Size = VT(PIECE.Size.Z,PIECE.Size.Y,PIECE.Size.Z), Size2 = (VT(PIECE.Size.Z,PIECE.Size.Y,PIECE.Size.Z))*MRANDOM(7,14)/10, Transparency = PIECE.Transparency, Transparency2 = 1, CFrame = PIECE.CFrame, MoveToPos = PIECE.Position+VT(0,MRANDOM(5,8)/1.5,0), RotationX = MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Neon", Color = C3(0.4,0,0), SoundID = 3264923, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2})
					else
						WACKYEFFECT({Time = MRANDOM(10,30)*5, EffectType = "Box", Size = PIECE.Size, Size2 = PIECE.Size*MRANDOM(7,14)/10, Transparency = PIECE.Transparency, Transparency2 = 1, CFrame = PIECE.CFrame, MoveToPos = PIECE.Position+VT(0,MRANDOM(5,8)/1.5,0), MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Neon", Color = C3(0.4,0,0), SoundID = 3264923, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2})
					end
					if lplr == Player then
						DamageRemote:FireServer("Remove", PIECE)
					end
					PIECE:Remove()
				end
			until #PARTS == 0
		end))
	end
end

--//=================================\\
--||         WEAPON CREATION
--\\=================================//

local Shield = IT("MeshPart")
Shield.Name = Player.Name.."'s Shield Anti Bullets"
Shield.CanCollide = false
Shield.Transparency = 1
Shield.Material = "Neon"
Shield.BrickColor = BrickColor.new("fat")
Shield.Size = Vector3.new(5.3,6.3,5.3)
--Shield.CFrame = Torso.CFrame
--local Wed = Instance.new("Weld", Shield)
--Wed.Part0 = Shield
--Wed.Part1 = Torso
		
local outer = Instance.new("Part")
outer.Locked = true
outer.CanCollide = false
outer.Shape = Enum.PartType.Cylinder
outer.Size = Vector3.new(0.05, 1, 1)
outer.Material = Enum.Material.Neon
outer.Color = Color3.new(0, 0, 0)
outer.Parent = Character
spawn(function() Rainbowify(outer) end)

local outerm = Instance.new("SpecialMesh")
outerm.MeshType = Enum.MeshType.Cylinder
outerm.Parent = outer

local weld1 = Instance.new("Weld")
weld1.Part0 = outer
weld1.Part1 = Character["HumanoidRootPart"]
weld1.Parent = outer
weld1.C0 = CFrame.new(-2.95, 0, 0) * CFrame.Angles(0, 0, 1.571)
coroutine.resume(coroutine.create(function()
				while true do
					Swait()
					outerm.Scale = Vector3.new(0, sick.PlaybackLoudness / 25, sick.PlaybackLoudness / 25)
				end
			end))

--RightArm.Material = Enum.Material.ForceField
--spawn(function() Rainbowify(RightArm) end)

function Weld(part0,part1,c0,c1)
	local weld = IT("Weld")
	weld.Parent = part0
	weld.Part0 = part0
	weld.Part1 = part1
	weld.C0 = c0 or CF()
	weld.C1 = c1 or CF()
	return weld
end

function MakeForm(PART,TYPE)
    if TYPE == "Cyl" then
        local MSH = IT("CylinderMesh",PART)
    elseif TYPE == "Ball" then
        local MSH = IT("SpecialMesh",PART)
        MSH.MeshType = "Sphere"
    elseif TYPE == "Wedge" then
        local MSH = IT("SpecialMesh",PART)
        MSH.MeshType = "Wedge"
    end
end

if Head:FindFirstChildOfClass("Decal") then
	Head:FindFirstChildOfClass("Decal").Texture = "rbxassetid://176217464"
else
	local newFace = Instance.new("Decal", Head)
	newFace.Parent = Head
	newFace.Face = "Front"
	newFace.Texture = "rbxassetid://176217464"
end 

New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end

local all, last = {}, nil
ArmourParts = {}
NeonParts = {}
function scan(p)
  for _, v in pairs(p:GetChildren()) do
    if v:IsA("BasePart") then
      if v.BrickColor == BrickColor.new("Black") then
        table.insert(ArmourParts, v)
      end
      if v.BrickColor == BrickColor.new("Institutional white") then
        table.insert(NeonParts, v)
      end
      if last then
        local w = Instance.new("Weld")
        w.Part0, w.Part1 = last, v
        w.C0 = v.CFrame:toObjectSpace(last.CFrame):inverse()
        w.Parent = last
      end
      table.insert(all, v)
      last = v
    end
    scan(v)
  end
end

for i, v in pairs(ArmourParts) do
     v.BrickColor = BrickColor.new("Black")
	 v.Material = Enum.Material.Neon
		end
for i, v in pairs(NeonParts) do
     v.BrickColor = BrickColor.Black()
      	end

local FaceGradient = IT("Folder", Character)
FaceGradient.Name = "FaceGradient"
local Eyes = IT("Folder", Character)
Eyes.Name = "Eyes"
--[[
for i = 1, 10 do
	local FACE = CreatePart(3, faceShadingFolder, "Neon", 0, 0+(i-1)/10.2, "Dark stone grey", "FaceGradient", VT(1.01,0.65,1.01),false)
	FACE.Color = C3(0,0,0)
	Head:FindFirstChildOfClass("SpecialMesh"):Clone().Parent = FACE
	CreateWeldOrSnapOrMotor("Weld", FACE, Head, FACE, CF(0,0.28-(i-1)/30,0), CF(0, 0, 0))
end

local Eye = CreatePart(3, Eyes, "Neon", 0, 0, "Lily white", "Eye", VT(0.1,1,1)/2,false)
MakeForm(Eye,"Ball")
CreateWeldOrSnapOrMotor("Weld", Eye, Head, Eye, CF(0,0.15,0) * ANGLES(RAD(0), RAD(-18), RAD(0)), CF(0, 0, 0.4))
spawn(function() Rainbowify(Eye) end)
local Eye = CreatePart(3, Eyes, "Neon", 0, 0, "Lily white", "Eye", VT(0.1,1,1)/2,false)
MakeForm(Eye,"Ball")
CreateWeldOrSnapOrMotor("Weld", Eye, Head, Eye, CF(0,0.15,0) * ANGLES(RAD(0), RAD(18), RAD(0)), CF(0, 0, 0.4))
spawn(function() Rainbowify(Eye) end)
--]]
local Particle = IT("ParticleEmitter",nil)
Particle.Enabled = false
Particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.3),NumberSequenceKeypoint.new(0.3,0),NumberSequenceKeypoint.new(1,1)})
Particle.LightEmission = 0.5
Particle.Rate = 150
Particle.ZOffset = 0.2
Particle.Rotation = NumberRange.new(-180, 180)
Particle.RotSpeed = NumberRange.new(-180, 180)
Particle.Texture = "http://www.roblox.com/asset/?id=304437537"
Particle.Color = ColorSequence.new(C3(1,0,0),C3(0.4,0,0))

--ParticleEmitter({Speed = 5, Drag = 0, Size1 = 1, Size2 = 5, Lifetime1 = 1, Lifetime2 = 1.5, Parent = Torso, Emit = 100, Offset = 360, Enabled = false})
function ParticleEmitter(Table)
	local PRTCL = Particle:Clone()
	local Speed = Table.Speed or 5
	local Drag = Table.Drag or 0
	local Size1 = Table.Size1 or 1
	local Size2 = Table.Size2 or 5
	local Lifetime1 = Table.Lifetime1 or 1
	local Lifetime2 = Table.Lifetime2 or 1.5
	local Parent = Table.Parent or Torso
	local Emit = Table.Emit or 100
	local Offset = Table.Offset or 360
	local Acel = Table.Acel or VT(0,0,0)
	local Enabled = Table.Enabled or false
	PRTCL.Parent = Parent
	PRTCL.Size = NumberSequence.new(Size1,Size2)
	PRTCL.Lifetime = NumberRange.new(Lifetime1,Lifetime2)
	PRTCL.Speed = NumberRange.new(Speed)
	PRTCL.VelocitySpread = Offset
	PRTCL.Drag = Drag
	PRTCL.Acceleration = Acel
	if Enabled == false then
		PRTCL:Emit(Emit)
		Debris:AddItem(PRTCL,Lifetime2)
	else
		PRTCL.Enabled = true
	end
	return PRTCL
end

-- IdleWeapon(Karma) --

local Handle = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Handle", VT(0.2,0.6,0.2),false)
spawn(function() Rainbowify(Handle) end)
local RightArmGrasp = CreateWeldOrSnapOrMotor("Weld", Handle, RightArm, Handle, CF(0,0.05, 0) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0.21, 0))
spawn(function() Rainbowify(RightArmGrasp) end)
local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.2,0.5,0.2),false)
MakeForm(Part,"Wedge")
CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.3, 0.2) * ANGLES(RAD(0), RAD(180), RAD(0)), CF(0, 0, 0))
spawn(function() Rainbowify(Part) end)
local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.2,0.3,0.2),false)
MakeForm(Part,"Wedge")
CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.4, 0) * ANGLES(RAD(0), RAD(0), RAD(180)), CF(0, 0, 0))
spawn(function() Rainbowify(Part) end)
local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.3,0.3,0.3),false)
CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.5, 0.2) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
spawn(function() Rainbowify(Part) end)
local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.3,0.5,0.5),false)
CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.5) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
spawn(function() Rainbowify(Part) end)
local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.4,0.4,0.4),false)
MakeForm(Part,"Cyl")
CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.5) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
spawn(function() Rainbowify(Part) end)
for i = 1, 8 do
	local Piece = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Eye", VT(0,0.35,0.41),false)
	CreateWeldOrSnapOrMotor("Weld", Handle, Part, Piece, CF(0, 0, 0) * ANGLES(RAD(0), RAD((360/8)*i), RAD(0)), CF(0, 0, 0))
	spawn(function() Rainbowify(Piece) end)
end
local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Eye", VT(0.38,0.41,0.38),false)
MakeForm(Part,"Cyl")
CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.5) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
spawn(function() Rainbowify(Part) end)
local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.37,0.5,0.37),false)
MakeForm(Part,"Ball")
CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.3) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
spawn(function() Rainbowify(Part) end)
local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.2,0.7,0.4),false)
MakeForm(Part,"Wedge")
CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.7, 0.5) * ANGLES(RAD(90), RAD(180), RAD(180)), CF(0, 0, 0))
spawn(function() Rainbowify(Part) end)
local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.3,0.4,0.2),false)
CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.7) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
spawn(function() Rainbowify(Part) end)
local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.35,0.35,0.35),false)
MakeForm(Part,"Cyl")
CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.7) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
spawn(function() Rainbowify(Part) end)
local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.5,0.1,0.5),false)
MakeForm(Part,"Cyl")
CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 1) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
spawn(function() Rainbowify(Part) end)
local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.5,0.1,0.45),false)
MakeForm(Part,"Cyl")
CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 1.1) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
spawn(function() Rainbowify(Part) end)
local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.2,0.5,0.2),false)
MakeForm(Part,"Wedge")
CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.55, 0.2) * ANGLES(RAD(-135), RAD(0), RAD(0)), CF(0, -0.3, 0))
spawn(function() Rainbowify(Part) end)
local LASTPART = Handle
for i = 1, 10 do
	if LASTPART == Handle then
		local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.1,0.2,0),false)
		LASTPART = Part
		CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.1, 0.2) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
		spawn(function() Rainbowify(Part) end)
	else
		local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.1,0.05,0),false)
		CreateWeldOrSnapOrMotor("Weld", Handle, LASTPART, Part, CF(0, 0.025, 0) * ANGLES(RAD(8), RAD(0), RAD(0)), CF(0, -0.025, 0))
		LASTPART = Part
		spawn(function() Rainbowify(Part) end)
	end
end

local Barrel = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.15,4,0.15),false)
MakeForm(Barrel,"Cyl")
CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Barrel, CF(0, -0.6, 1.85) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
spawn(function() Rainbowify(Barrel) end)
local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0.25,2,0.25),false)
MakeForm(Part,"Cyl")
CreateWeldOrSnapOrMotor("Weld", Handle, Barrel, Part, CF(0, -0.2, 0), CF(0, 0, 0))
spawn(function() Rainbowify(Part) end)
local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0,0.1,0.2),false)
MakeForm(Part,"Wedge")
CreateWeldOrSnapOrMotor("Weld", Handle, Barrel, Part, CF(0, 0.945, 0.1) * ANGLES(RAD(180), RAD(0), RAD(0)), CF(0, 0, 0))
spawn(function() Rainbowify(Part) end)
local Hole = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Eye", VT(0.125,0,0.125),false)
MakeForm(Hole,"Cyl")
CreateWeldOrSnapOrMotor("Weld", Handle, Barrel, Hole, CF(0, 2, 0), CF(0, 0, 0))
spawn(function() Rainbowify(Hole) end)
local Part = CreatePart(3, Weapon, "ForceField", 0, 0, "Mid gray", "Part", VT(0,0,0),false)
spawn(function() Rainbowify(Part) end)
local GEARWELD = CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.7), CF(0, 0, 0))
CreateMesh("SpecialMesh", Part, "FileMesh", 156292343, "", VT(0.8,0.8,1.5), VT(0,0,0.2))
spawn(function() Rainbowify(GEARWELD) end)
local Part = CreatePart(3, Weapon, "ForceField", 0, 0.5, "Mid gray", "Eye", VT(0,0,0),false)
spawn(function() Rainbowify(Part) end)
local GEARWELD2 = CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.7), CF(0, 0, 0))
CreateMesh("SpecialMesh", Part, "FileMesh", 156292343, "", VT(0.9,0.9,0.3), VT(0,0,0.2))
spawn(function() Rainbowify(GEARWELD2) end)
coroutine.resume(coroutine.create(function()
	while wait() do
		GEARWELD.C0 = GEARWELD.C0 * ANGLES(RAD(0), RAD(0), RAD(sick.PlaybackLoudness/60 + 0.05))
		GEARWELD2.C0 = GEARWELD2.C0 * ANGLES(RAD(0), RAD(0), RAD(-sick.PlaybackLoudness/60 - 0.05))
	end
end))

for i,v in pairs(Weapon:GetChildren()) do
	if v:IsA("BasePart") then
		v.Transparency = 1
	end
end

-- 4962455546

function Align(Part0, Part1, Position, Angle)
	if Part0:FindFirstChild("Attachment") then
		Part0:FindFirstChild("Attachment"):Remove()
	end
    local AlignPosition = Instance.new("AlignPosition",Part0)
    local AlignOrientation = Instance.new("AlignOrientation",Part0)
    
    local Attachment1 = Instance.new("Attachment", Part0)
    local Attachment2 = Instance.new("Attachment", Part1)

    AlignPosition.Attachment0 = Attachment1
    AlignPosition.Attachment1 = Attachment2
    
    AlignOrientation.Attachment0 = Attachment1
    AlignOrientation.Attachment1 = Attachment2
    
    Attachment2.Position = Position or Vector3.new(0,0,0)
    Attachment2.Orientation = Angle or Vector3.new(0,0,0)
    
    AlignOrientation.MaxTorque = math.huge
    AlignOrientation.MaxAngularVelocity = math.huge
    AlignOrientation.PrimaryAxisOnly = false 
    AlignOrientation.Responsiveness = 200
    AlignOrientation.RigidityEnabled = false
    AlignOrientation.ReactionTorqueEnabled = false
    AlignPosition.MaxForce = 2626668
    AlignPosition.MaxVelocity = math.huge
    AlignPosition.ReactionForceEnabled = false
    AlignPosition.Responsiveness = 200
    AlignPosition.ApplyAtCenterOfMass = true
    AlignPosition.RigidityEnabled = false
    game:GetService("RunService").Heartbeat:Connect(function()
        Part0.Velocity = Vector3.new(-35,0,0)
    end)
    if Part0.Parent:IsA("Accessory") then
    	Part0:BreakJoints()
    end
end

--FunnyPart = Instance.new("Part",game.Players.LocalPlayer.Character)
--FunnyPart.Size = Vector3.new(0.1, 0.1, 0.1)
--FunnyPart.Anchored = false
--FunnyPart.CFrame = game.Players.LocalPlayer.Character["Type-49 Abomindation Back Accessory"].Handle.CFrame
Align(game.Players.LocalPlayer.Character["Type-49 Abomindation Back Accessory"].Handle, Handle, Vector3.new(-0.3, -0.58, 1.45), Vector3.new(-0, -90, 135))
--Align(FunnyPart,game.Players.LocalPlayer.Character["Type-49 Abomindation Back Accessory"].Handle, Vector3.new(-1.6, -1.7, -0.3)) 

ParticleEmitter({Speed = 0.1, Drag = 0, Size1 = 0.1, Size2 = 0, Lifetime1 = 0.3, Lifetime2 = 0.5, Parent = Hole, Emit = 100, Offset = 360, Enabled = true, Acel = VT(0,5,0)})
--[[local LASTPART = Head
for i = 1, 20 do
	local MATH = (1-(i/25))
	if LASTPART == Head then
		local Horn = CreatePart(3, Character, "ForceField", 0, 0, "Really black", "Horn", VT(0.25*MATH,0.25,0.25*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0.3, 0.7, -0.35) * ANGLES(RAD(-55), RAD(15), RAD(-15)), CF(0, 0, 0))
		LASTPART = Horn
		Horn.Color = C3((i*3-3)/.5,0,.5)
		spawn(function() Rainbowify(Horn) end)
	else
		local Horn = CreatePart(3, Character, "ForceField", 0, 0, "Really black", "Horn", VT(0.25*MATH,0.25,0.25*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0, Horn.Size.Y/1.8, 0) * ANGLES(RAD(6), RAD(-0.3), RAD(0)), CF(0, 0, 0))
		LASTPART = Horn
		Horn.Color = C3((i*3-3)/.5,0,.5)
		spawn(function() Rainbowify(Horn) end)
	end
end
local LASTPART = Head
for i = 1, 20 do
	local MATH = (1-(i/25))
	if LASTPART == Head then
		local Horn = CreatePart(3, Character, "ForceField", 0, 0, "Really black", "Horn", VT(0.25*MATH,0.25,0.25*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(-0.3, 0.7, -0.35) * ANGLES(RAD(-55), RAD(-15), RAD(15)), CF(0, 0, 0))
		LASTPART = Horn
		Horn.Color = C3((i*3-3)/.5,0,.5)
		spawn(function() Rainbowify(Horn) end)
	else
		local Horn = CreatePart(3, Character, "ForceField", 0, 0, "Really black", "Horn", VT(0.25*MATH,0.25,0.25*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0, Horn.Size.Y/1.8, 0) * ANGLES(RAD(6), RAD(0.3), RAD(0)), CF(0, 0, 0))
		LASTPART = Horn
		Horn.Color = C3((i*3-3)/.5,0,.5)
		spawn(function() Rainbowify(Horn) end)
	end
end]]--

for _, b in pairs(Karma:GetChildren()) do
	if b.ClassName == "Part" then
		b.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
	end
end

for _, b in pairs(Weapon:GetChildren()) do
	if b.ClassName == "Part" then
		b.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
	end
end

coroutine.resume(coroutine.create(function()
	while true do
		Swait()
		for _, c in pairs(KarmaWeapon2:GetDescendants()) do
			if c.ClassName == "Part" and c.Name ~= "Eye" and c.Parent ~= Effects and c.Parent.Parent ~= Effects then
				c.Material = "Glass"
				c.Color = BrickColor.Black().Color
			elseif c.ClassName == "Part" and c.Name == "Eye" then
				c.Material = "Neon"
				c.Color = C3(0,0,0)
				spawn(function() Rainbowify(c) end)
			end
		end
		for _, c in pairs(KarmaWeapon:GetDescendants()) do
			if c.ClassName == "Part" and c.Name ~= "Eye" and c.Parent ~= Effects and c.Parent.Parent ~= Effects then
				c.Material = "Glass"
				c.Color = BrickColor.Black().Color
			elseif c.ClassName == "Part" and c.Name == "Eye" then
				c.Material = "Neon"
				c.Color = C3(0,0,0)
				spawn(function() Rainbowify(c) end)
			end
		end
	end
end))

Weapon.Parent = Character


--//=================================\\
--||	ATTACK FUNCTIONS AND STUFF
--\\=================================//

abss = Instance.new("BillboardGui",Character)
abss.Size = UDim2.new(10,0,10,0)
abss.Enabled = false
imgl = Instance.new("ImageLabel",abss)
imgl.Position = UDim2.new(0,0,0,0)
imgl.Size = UDim2.new(1,0,1,0)
imgl.Image = "rbxassetid://342199418"
imgl.BackgroundTransparency = 1
imgl.ImageColor3 = Color3.new(.9,0,0)
img2 = Instance.new("ImageLabel",abss)
img2.Position = UDim2.new(0,0,0,0)
img2.Size = UDim2.new(1,0,1,0)
img2.Image = "rbxassetid://342199418"
img2.BackgroundTransparency = 1
img2.ImageColor3 = Color3.new(.9,0,0)

function CreatePartC(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, COLOR3, NAME, SIZE, ANCHOR)
    local NEWPART = IT("Part")
    NEWPART.formFactor = FORMFACTOR
    NEWPART.Reflectance = REFLECTANCE
    NEWPART.Transparency = TRANSPARENCY
    NEWPART.CanCollide = false
    NEWPART.Locked = true
    NEWPART.Anchored = true
    if ANCHOR == false then
        NEWPART.Anchored = false
    end
    NEWPART.Color = COLOR3
    NEWPART.Name = NAME
    NEWPART.Size = SIZE
    NEWPART.Position = Torso.Position
    NEWPART.Material = MATERIAL
    NEWPART:BreakJoints()
    NEWPART.Parent = PARENT
    return NEWPART
end


function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end

function SpawnTrail(FROM,TO,BIG)
	local TRAIL = CreatePart(3, Effects, "Neon", 0, 0.5, "Really red", "Trail", VT(0,0,0))
	spawn(function() Rainbowify(TRAIL) end)
	MakeForm(TRAIL,"Cyl")
	local DIST = (FROM - TO).Magnitude
	if BIG == true then
		TRAIL.Size = VT(0.5,DIST,0.5)
	else
		TRAIL.Size = VT(0.25,DIST,0.25)
	end
	TRAIL.CFrame = CF(FROM, TO) * CF(0, 0, -DIST/2) * ANGLES(RAD(90),RAD(0),RAD(0))
	coroutine.resume(coroutine.create(function()
		for i = 1, 5 do
			Swait()
			TRAIL.Transparency = TRAIL.Transparency + 0.01
		end
		wait(4.2)
		TRAIL:remove()
	end))
end

function chatfunc(text)
	local chat = coroutine.wrap(function()
		if Character:FindFirstChild("TalkingBillBoard")~= nil then
			Character:FindFirstChild("TalkingBillBoard"):destroy()
		end
		local Bill = Instance.new("BillboardGui",Character)
		Bill.Size = UDim2.new(0,100,0,40)
		Bill.StudsOffset = VT(0,3,0)
		Bill.Adornee = Character.Head
		Bill.Name = "TalkingBillBoard"
		local Hehe = Instance.new("TextLabel",Bill)
		Hehe.BackgroundTransparency = 1
		Hehe.BorderSizePixel = 0
		Hehe.Text = "   "
		Hehe.Font = "Bodoni"
		Hehe.TextSize = 40
		Hehe.TextStrokeTransparency = 0
		Hehe.Size = UDim2.new(1,0,0.5,0)
		coroutine.resume(coroutine.create(function()
			while Hehe ~= nil do
				Swait()	
				Hehe.Font = FONTS[MRANDOM(1, #FONTS)]
				Hehe.Position = UDim2.new(0, 0, .05, 0)
				Hehe.TextColor3 = BrickColor.Black().Color
				Hehe.TextStrokeColor3 = BrickColor.Black().Color
			end
		end))
		for i = 1,string.len(text),1 do
			Swait()
			Hehe.Text = string.sub(text,1,i)
		end
		Swait(90)
		for i = 0, 1, .025 do
			Swait()
			Hehe.TextStrokeTransparency = i
			Hehe.TextTransparency = i
		end
		Bill:Destroy()
	end)
	chat()
end

function printbye(Name)
	local MESSAGES = {"You re a bad boi, ", "Go away, ", "YO GO AWAY PLS, ", "Chill, ", "BEGONE THOOOOT, ", "STAAAAAAAAAAFFFFFFFFFFF, ", "Try it again, ", "Welcome to my special hell, ", "Dont come back please, ", "You are a bad doggy, ","Don't try that ever again, "}
	chatfunc(MESSAGES[MRANDOM(1,#MESSAGES)]..Name..".")	
end

Player.Chatted:connect(function(msg)
	if BanishMode == 324 then
        if msg:sub(1, 5):lower()=='play/' then
                sick:Stop()
                SONG1 = msg:sub(6)
                sick:Play()
                sick.Looped = true
                chatfunc("Now playing "..msg:sub(6))
        elseif msg:sub(1, 6):lower()=='pitch/' then
                local Pitch = msg:sub(7)
                sick.Pitch = Pitch
                chatfunc("Now pitch is "..msg:sub(7))
        elseif msg:sub(1, 4):lower()=='vol/' then
                local Volume = msg:sub(5)
                sick.Volume = Volume
                chatfunc("Now volume is "..msg:sub(5))
        elseif msg:sub(1, 5):lower()=='stop/' then
                sick:Stop()
                chatfunc("Music Stopped")
        elseif msg:sub(1, 7):lower()=='parent/' then
	            local Parent = msg:sub(7)
                sick.Parent = Parent
                chatfunc("Music Parent Changed to "..msg:sub(7))
        end
end
end)

function Kick(Foe)
	
end

function Respawn(Foe)

end

function Banish(Foe)
	
end

function ApplyAoE(POSITION,RANGE,ISBANISH)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if ISBANISH == true then
							Banish(CHILD)
						else
							if ISBANISH == "Gravity" then
								HUM.PlatformStand = true
								if TORSO:FindFirstChild("BanishForceV5"..Player.Name) then
									local grav = Instance.new("BodyPosition",TORSO)
									grav.D = 15
									grav.P = 20000
									grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
									grav.position = TORSO.Position
									grav.Name = "BanishForceV5"..Player.Name
								else
									TORSO:FindFirstChild("BanishForceV5"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
									TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
								end
							else
								HUM.PlatformStand = false
							end
						end
					elseif ISBANISH == "Gravity" then
						if TORSO:FindFirstChild("BanishForceV5"..Player.Name) then
							TORSO:FindFirstChild("BanishForceV5"..Player.Name):remove()
							HUM.PlatformStand = false
						end
					end
				end
			end
		end
	end
end

workspace.ChildAdded:connect(function(instance)
    for BANISH = 1, #TOBANISH do
		if TOBANISH[BANISH] ~= nil then
			if instance.Name == TOBANISH[BANISH] then
				coroutine.resume(coroutine.create(function()
					printbye(instance.Name)
					instance:ClearAllChildren()
					Debris:AddItem(instance,0.0005)
				end))
			end
		end
	end
end)

function BanishBullet()
	if Weapon.Parent == Character then
	ATTACK = true
	Rooted = false
	for i=0, 0.01, 0.1 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	repeat
		for i=0, 0.01, 0.1 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
		local HIT,POS = CastProperRay(Hole.Position, Mouse.Hit.p, 1000, Character)
		SpawnTrail(Hole.Position,POS)
		CreateSound(904440937, Character, 10, 1, false)
		if HIT ~= nil then
			if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
				Banish(HIT.Parent)
			end
		end
		for i=0, 0.01, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.25 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(15), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
	until KEYHOLD == false
	ATTACK = false
	Rooted = false
	end
end

function BanBullet()
	if Weapon.Parent == Character then
	ATTACK = true
	Rooted = false
	for i=0, 0.01, 0.1 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	repeat
		for i=0, 0.01, 0.1 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
		local HIT,POS = CastProperRay(Hole.Position, Mouse.Hit.p, 1000, Character)
		SpawnTrail(Hole.Position,POS)
		CreateSound(904440937, Character, 10, 1, false)

		for i=0, 0.01, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.25 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(15), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
	until KEYHOLD == false
	ATTACK = false
	Rooted = false
	end
end

function RespawnBullet()
    if Weapon.Parent == Character then
	ATTACK = true
	Rooted = false
	for i=0, 0.01, 0.1 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	repeat
		for i=0, 0.01, 0.1 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
		local HIT,POS = CastProperRay(Hole.Position, Mouse.Hit.p, 1000, Character)
		SpawnTrail(Hole.Position,POS)
		CreateSound(664046210, Character, 10, 1, false)

		for i=0, 0.01, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.25 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(15), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
	until KEYHOLD == false
	ATTACK = false
	Rooted = false
	end
end


function Rush()
    local ORIGIN = RootPart.Position
    CreateWave2(VT(1,1,1),65,CF(RootPart.Position)*CF(0,-3,0),false,2,"Pearl",VT(0.2,1,0.2))
    CreateWave2(VT(1,1,1),65,CF(RootPart.Position)*CF(0,-3,0),false,2,"Pearl",VT(0.2,1,0.2))
    spawn(function() Rainbowify(ORIGIN) end)
    local SOUNDPART = CreatePart(3, Effects, "Neon", 0, 1, "Pearl", "Sound", VT(0,0,0))
    SOUNDPART.CFrame = RootPart.CFrame
    Debris:AddItem(SOUNDPART,5)
    CreateSound("1295446488", SOUNDPART, 2, 1)
    RootPart.CFrame = CF(Mouse.Hit.p+VT(0,3,0),VT(ORIGIN.X,Mouse.Hit.p.Y,ORIGIN.Z))
    Swait()
    CreateWave2(VT(1,1,1),65,CF(RootPart.Position)*CF(0,-3,0),false,2,"Pearl",VT(0.2,1,0.2))
    CreateWave2(VT(1,1,1),65,CF(RootPart.Position)*CF(0,-3,0),false,2,"Pearl",VT(0.2,1,0.2))
    spawn(function() Rainbowify(SOUNDPART) end)
    local SOUNDPART = CreatePart(3, Effects, "Neon", 0, 1, "Pearl", "Sound", VT(0,0,0))
    SOUNDPART.CFrame = RootPart.CFrame
    Debris:AddItem(SOUNDPART,5)
    CreateSound("1295446488", SOUNDPART, 2, 1)
    if MRANDOM(1,8) == 1 then
        ATTACK = true
        Rooted = true
        local FRUITSTABLE = {
            {MeshId = "16190555", TextureId = "16190577", Color = BrickColor.Black()},
            {MeshId = "119574562", TextureId = "64374853", Color = BrickColor.Black()},
            {MeshId = "24394186", TextureId = "24394178", Color = BrickColor.Black()}
        }
        local FRUIT = FRUITSTABLE[MRANDOM(1, #FRUITSTABLE)]
        local FRUITMODEL = CreatePart(3, Effects, "Neon", 0, 0, FRUIT.Color, "Fruit", VT(0,0,0),false)
        CreateMesh("SpecialMesh", FRUITMODEL, "FileMesh", FRUIT.MeshId, FRUIT.TextureId, VT(2,2,2), VT(0,0,0))
        FRUITMODEL.CFrame = RightArm.CFrame * CF(0,-1.5,0)
        weldBetween(RightArm,FRUITMODEL)
        for i=0, 4, 0.1 / Animation_Speed do
            Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(190), RAD(-145)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
        end
        CreateSound("414517163", RightArm, 10, MRANDOM(7, 12) / 10)
        FRUITMODEL:remove()
        for i = 1, 15 do
            Slice(0.1,15,RightArm.CFrame*CF(0,-1,0) * ANGLES(RAD(MRANDOM(-180,180)), RAD(MRANDOM(-180,180)), RAD(MRANDOM(-180,180))),FRUIT.Color, 1 + MRANDOM(1,10)/15)
        end
        for i=0, 0.5, 0.1 / Animation_Speed do
            Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(190), RAD(-175)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
        end
        ATTACK = false
        Rooted = false
    end
end

function CreateParta(parent,transparency,reflectance,material,brickcolor)
	local p = Instance.new("Part")
	p.TopSurface = 0
	p.BottomSurface = 0
	p.Parent = parent
	p.Size = Vector3.new(0.1,0.1,0.1)
	p.Transparency = transparency
	p.Reflectance = reflectance
	p.CanCollide = false
	p.Locked = true
	p.BrickColor = brickcolor
	p.Material = material
	return p
end

function FireArc(Part, ToLocation, AmountOfTime, Height, DoesCourontine)
	if DoesCourontine == false then
		local Direction = CF(Part.Position, ToLocation)
		local Distance = (Part.Position - ToLocation).magnitude
		for i = 1, AmountOfTime do
			Swait()
			Part.CFrame = Direction * CF(0, AmountOfTime / 200 + (AmountOfTime / Height - i * 2 / Height), -Distance / AmountOfTime)
			Direction = Part.CFrame
		end
		Part:remove()
	elseif DoesCourontine == true then
		coroutine.resume(coroutine.create(function()
			local Direction = CF(Part.Position, ToLocation)
			local Distance = (Part.Position - ToLocation).magnitude
			for i = 1, AmountOfTime do
				Swait()
				Part.CFrame = Direction * CF(0, AmountOfTime / 200 + (AmountOfTime / Height - i * 2 / Height), -Distance / AmountOfTime)
				Direction = Part.CFrame
			end
			Part:remove()
		end))
	end
end

 function chatfunc(text)
	local chat = coroutine.wrap(function()
	if Character:FindFirstChild("TalkingBillBoard")~= nil then
		Character:FindFirstChild("TalkingBillBoard"):destroy()
	end
	local Bill = Instance.new("BillboardGui",Character)
	Bill.Size = UDim2.new(0,35,0,18)
	Bill.StudsOffset = Vector3.new(0,4.5,0)
	Bill.Adornee = Character.Head
	Bill.Name = "TalkingBillBoard"
	local Hehe = Instance.new("TextLabel",Bill)
	Hehe.BackgroundTransparency = 1
	Hehe.BorderSizePixel = 0
		Hehe.Text = "   "
	Hehe.Font = "Arcade"
	Hehe.TextSize = 45
	Hehe.TextStrokeTransparency = 0
	Hehe.Size = UDim2.new(1,0,0.5,0)
	coroutine.resume(coroutine.create(function()
		while Hehe ~= nil do
			wait()	
			Hehe.Position = UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))	
		end
	end))
	spawn(function() RainbowifyText(Hehe) end)
	for i = 1,string.len(text),1 do
		wait()
		Hehe.Text = string.sub(text,1,i)
	end
	wait(3)
	for i = 0, 5, .025 do
		wait()
		Bill.ExtentsOffset = Vector3.new(math.random(-i, i), math.random(-i, i), math.random(-i, i))
		Hehe.TextStrokeTransparency = i
		Hehe.TextTransparency = i
	end
	Bill:Destroy()
	end)
chat()
end

Player.Chatted:Connect(function(aa)
	chatfunc(aa)
end)

function warnedpeople(text)
	for i,v in pairs(game:GetService("Players"):GetPlayers()) do
		coroutine.resume(coroutine.create(function()
			if v.PlayerGui:FindFirstChild("Spinny")~= nil then
				v.PlayerGui:FindFirstChild("Spinny"):destroy()
			end
			local scrg = Instance.new("ScreenGui",v.PlayerGui)
			scrg.Name = "Spinny"
			local wobble = Instance.new("Frame",scrg)
			wobble.Name = "Wobble"
			wobble.BackgroundTransparency = 0.5
			wobble.Size = UDim2.new(1.1,0,1.1,0)
			wobble.Position = UDim2.new(-0.08,0,0.943,0)
			local wobble2 = Instance.new("Frame",scrg)
			wobble2.Name = "wobble2"
			wobble2.BackgroundTransparency = 0.5
			wobble2.Size = UDim2.new(1.1,0,0.09,0)
			wobble2.Position = UDim2.new(-0.08,0,0.878,0)
			local Visuals = Instance.new("Frame",scrg)
			Visuals.Name = "Visuals"
			Visuals.BackgroundTransparency = 0.3
			Visuals.Size = UDim2.new(0,100,0,100)
			Visuals.Position = UDim2.new(0.462,0,0.826,0)
			local glow = Instance.new("ImageLabel",scrg)
			glow.Name = "glow"
			glow.BackgroundTransparency = 1
			glow.ImageTransparency = 0
			glow.Image = "rbxassetid://2344870656"
			glow.Size = UDim2.new(0,0,0,0)
			glow.Position = UDim2.new(0.026,0,-0.235,0)
			local Visuals2 = Instance.new("Frame",scrg)
			Visuals2.Name = "Visuals2"
			Visuals2.BackgroundTransparency = 0.3
			Visuals2.Size = UDim2.new(0,50,0,50)
			Visuals2.Position = UDim2.new(0.48,0,0.867,0)
			local TextFrame = Instance.new("TextLabel",scrg)
			TextFrame.Name = "Farmer"
			TextFrame.Font = "Arcade"
			TextFrame.Text = text
			TextFrame.TextScaled = true
			TextFrame.TextSize = 60
			TextFrame.TextColor3 = C3(1,1,1)
			TextFrame.TextStrokeColor3 = C3(0, 0, 0)
			TextFrame.BackgroundTransparency = 1
			TextFrame.Size = UDim2.new(0.8,0,0,42)
			TextFrame.Position = UDim2.new(0.11,0,0.867,0)
			spawn(function() RainbowifyText(TextFrame) end)
			local fvalen = 0.55
			local fval = -0.49
			coroutine.resume(coroutine.create(function()
				while true do
					Swait()
					TextFrame.TextStrokeTransparency = 0
					TextFrame.Rotation = 0 + MRANDOM(-3, 3)
					TextFrame.Position = UDim2.new(0.11, 0 + MRANDOM(-3, 3), 0.867, 0 + MRANDOM(-3, 3))
					TextFrame.Font = Enum.Font.Arcade
					glow.ImageColor3 = C3(0, 0, 0)
					wobble.Rotation = 0 - 2 * COS(SINE / 24)
					wobble2.Rotation = 0 - 2 * COS(SINE / 30)
					wobble2.BackgroundColor3 = C3(0,0,0)
					wobble2.BorderColor3 = C3(0,0,0)
					wobble2.BorderSizePixel = 4
					Visuals.Rotation = Visuals.Rotation + MRANDOM(-5, 5)
					Visuals2.Rotation = Visuals2.Rotation + MRANDOM(-10, 10)
					Visuals.BackgroundColor3 = C3(0,0,0)
					Visuals.BorderColor3 = C3(0,0,0)
					Visuals2.BackgroundColor3 = C3(0,0,0)
					Visuals2.BorderColor3 = C3(0,0,0)
					wobble.BackgroundColor3 = C3(0,0,0)
					wobble.BorderColor3 = C3(0,0,0)
					wobble.BorderSizePixel = 5
				end
			end))
			coroutine.resume(coroutine.create(function()
				for i = 0, 205 do
					Swait()
				end
				scrg:Destroy()
			end))
		end))
	end
end

function warnedpeople2(text)
	for i,v in pairs(game:GetService("Players"):GetPlayers()) do
		coroutine.resume(coroutine.create(function()
			if v.PlayerGui:FindFirstChild("Spinny")~= nil then
				v.PlayerGui:FindFirstChild("Spinny"):destroy()
			end
			local scrg = Instance.new("ScreenGui",v.PlayerGui)
			scrg.Name = "Spinny"
			local wobble = Instance.new("Frame",scrg)
			wobble.Name = "Wobble"
			wobble.BackgroundTransparency = 0.5
			wobble.Size = UDim2.new(1.1,0,1.1,0)
			wobble.Position = UDim2.new(-0.08,0,0.943,0)
			local wobble2 = Instance.new("Frame",scrg)
			wobble2.Name = "wobble2"
			wobble2.BackgroundTransparency = 0.5
			wobble2.Size = UDim2.new(1.1,0,0.09,0)
			wobble2.Position = UDim2.new(-0.08,0,0.878,0)
			local Visuals = Instance.new("Frame",scrg)
			Visuals.Name = "Visuals"
			Visuals.BackgroundTransparency = 0.3
			Visuals.Size = UDim2.new(0,100,0,100)
			Visuals.Position = UDim2.new(0.462,0,0.826,0)
			local glow = Instance.new("ImageLabel",scrg)
			glow.Name = "glow"
			glow.BackgroundTransparency = 1
			glow.ImageTransparency = 0
			glow.Image = "rbxassetid://2344870656"
			glow.Size = UDim2.new(0,0,0,0)
			glow.Position = UDim2.new(0.026,0,-0.235,0)
			local Visuals2 = Instance.new("Frame",scrg)
			Visuals2.Name = "Visuals2"
			Visuals2.BackgroundTransparency = 0.3
			Visuals2.Size = UDim2.new(0,50,0,50)
			Visuals2.Position = UDim2.new(0.48,0,0.867,0)
			local TextFrame = Instance.new("TextLabel",scrg)
			TextFrame.Name = "Farmer"
			TextFrame.Font = "Arcade"
			TextFrame.Text = text
			TextFrame.TextScaled = true
			TextFrame.TextSize = 60
			TextFrame.BackgroundTransparency = 1
			TextFrame.Size = UDim2.new(0.8,0,0,42)
			TextFrame.Position = UDim2.new(0.11,0,0.867,0)
			local fvalen = 0.55
			local fval = -0.49
			coroutine.resume(coroutine.create(function()
				while true do
					Swait()
					TextFrame.TextColor3 = C3(1,0,0)
					TextFrame.TextStrokeColor3 = C3(0, 0, 0)
					TextFrame.TextStrokeTransparency = 0
					TextFrame.Rotation = 0 + MRANDOM(-3, 3)
					TextFrame.Position = UDim2.new(0.11, 0 + MRANDOM(-3, 3), 0.867, 0 + MRANDOM(-3, 3))
					TextFrame.Font = Enum.Font.Fantasy
					glow.ImageColor3 = C3(0, 0, 0)
					wobble.Rotation = 0 - 2 * COS(SINE / 24)
					wobble2.Rotation = 0 - 2 * COS(SINE / 30)
					wobble2.BackgroundColor3 = C3(0,0,0)
					wobble2.BorderColor3 = C3(1,0,0)
					wobble2.BorderSizePixel = 5
					Visuals.Rotation = Visuals.Rotation + MRANDOM(-5, 5)
					Visuals2.Rotation = Visuals2.Rotation + MRANDOM(-10, 10)
					Visuals.BackgroundColor3 = C3(0,0,0)
					Visuals.BorderColor3 = C3(1,0,0)
					Visuals2.BackgroundColor3 = C3(0,0,0)
					Visuals2.BorderColor3 = C3(1,0,0)
					wobble.BackgroundColor3 = C3(0,0,0)
					wobble.BorderColor3 = C3(1,0,0)
					wobble.BorderSizePixel = 5
				end
			end))
			coroutine.resume(coroutine.create(function()
				for i = 0, 205 do
					Swait()
				end
				scrg:Destroy()
			end))
		end))
	end
end

function warnedpeopleB(text)
	for i,v in pairs(game:GetService("Players"):GetPlayers()) do
		coroutine.resume(coroutine.create(function()
			if v.PlayerGui:FindFirstChild("Spinny")~= nil then
				v.PlayerGui:FindFirstChild("Spinny"):destroy()
			end
			local scrg = Instance.new("ScreenGui",v.PlayerGui)
			scrg.Name = "Spinny"
			local wobble = Instance.new("Frame",scrg)
			wobble.Name = "Wobble"
			wobble.BackgroundTransparency = 1
			wobble.Size = UDim2.new(1.1,0,1.1,0)
			wobble.Position = UDim2.new(-0.08,0,0.943,0)
			local wobble2 = Instance.new("Frame",scrg)
			wobble2.Name = "wobble2"
			wobble2.BackgroundTransparency = 1
			wobble2.Size = UDim2.new(1.1,0,0.09,0)
			wobble2.Position = UDim2.new(-0.08,0,0.878,0)
			local Visuals = Instance.new("Frame",scrg)
			Visuals.Name = "Visuals"
			Visuals.BackgroundTransparency = 1
			Visuals.Size = UDim2.new(0,100,0,100)
			Visuals.Position = UDim2.new(0.462,0,0.826,0)
			local glow = Instance.new("ImageLabel",scrg)
			glow.Name = "glow"
			glow.BackgroundTransparency = 1
			glow.ImageTransparency = 0
			glow.Image = "rbxassetid://2344870656"
			glow.Size = UDim2.new(0,0,0,0)
			glow.Position = UDim2.new(0.026,0,-0.235,0)
			local Visuals2 = Instance.new("Frame",scrg)
			Visuals2.Name = "Visuals2"
			Visuals2.BackgroundTransparency = 1
			Visuals2.Size = UDim2.new(0,50,0,50)
			Visuals2.Position = UDim2.new(0.48,0,0.867,0)
			local TextFrame = Instance.new("TextLabel",scrg)
			TextFrame.Name = "Farmer"
			TextFrame.Font = "Arcade"
			TextFrame.Text = text
			TextFrame.TextScaled = true
			TextFrame.TextSize = 60
			TextFrame.BackgroundTransparency = 1
			TextFrame.Size = UDim2.new(0.8,0,0,42)
			TextFrame.Position = UDim2.new(0.11,0,0.867,0)
			local fvalen = 0.55
			local fval = -0.49
			coroutine.resume(coroutine.create(function()
				while true do
					Swait()
					TextFrame.TextColor3 = C3(1,1,1)
					TextFrame.TextStrokeColor3 = C3(0, 0, 0)
					TextFrame.TextStrokeTransparency = 0
					TextFrame.Rotation = 0 + MRANDOM(-3, 3)
					TextFrame.Position = UDim2.new(0.11, 0 + MRANDOM(-3, 3), 0.867, 0 + MRANDOM(-3, 3))
					TextFrame.Font = Enum.Font.Arcade
					glow.ImageColor3 = C3(0, 0, 0)
					wobble.Rotation = 0 - 2 * COS(SINE / 24)
					wobble2.Rotation = 0 - 2 * COS(SINE / 30)
					wobble2.BackgroundColor3 = C3(0,0,0)
					wobble2.BorderColor3 = C3(0,0,0)
					wobble2.BorderSizePixel = 0
					Visuals.Rotation = Visuals.Rotation + MRANDOM(-5, 5)
					Visuals2.Rotation = Visuals2.Rotation + MRANDOM(-10, 10)
					Visuals.BackgroundColor3 = C3(0,0,0)
					Visuals.BorderColor3 = C3(0,0,0)
					Visuals2.BackgroundColor3 = C3(0,0,0)
					Visuals2.BorderColor3 = C3(0,0,0)
					wobble.BackgroundColor3 = C3(0,0,0)
					wobble.BorderColor3 = C3(0,0,0)
					wobble.BorderSizePixel = 0
				end
			end))
			coroutine.resume(coroutine.create(function()
				for i = 0, 205 do
					Swait()
				end
				scrg:Destroy()
			end))
		end))
	end
end


--//=================================\\
--||	  ASSIGN THINGS TO KEYS
--\\=================================//

function KeyDown(Key)
	KEYHOLD = true
	if Key == "f" and ATTACK == false then
		TOBANISH = {}
		BannedSkids = {}
		warnedpeople("I spare you.")
	end
	
    if Key == "e" and ATTACK == false then
		BanishBullet()
    end

    if Key == "r" and ATTACK == false then
		BanBullet()
    end

    if Key == "t" and ATTACK == false then
		RespawnBullet()
    end
	
	if Key == "y" and ATTACK == false then
		SONG1 = 846573741
		sick.TimePosition = 0
		Speed = 16
		Handle.Attachment.Position = Vector3.new(-0.3, -0.58, 1.45)
		BanishMode = 666
		Jump = 50
		tecks2.Text = "   "
	end
	
	if Key == "j" and ATTACK == false then
		SONG1 = 2371543268
		sick.TimePosition = 0
		Speed = 16
		Handle.Attachment.Position = Vector3.new(-0.3, -0.58, 1.45)
		BanishMode = 1
		Jump = 50
		tecks2.Text = "   "
	end
	
	if Key == "p" and ATTACK == false then
		chatfunc("Lets Hear Some Music :3!")
        SONG1 = 2664096416
        sick.TimePosition = 0
		Speed = 12
		Jump = 40
		--Weapon.Parent = nil
		Handle.Attachment.Position = Vector3.new(50,50,50)
		BanishMode = 324
		tecks2.Text = "   "
	end
	
	if Key == "u" and ATTACK == false then
		SONG1 = 2969432275
		sick.TimePosition = 0
		Speed = 45
		Weapon.Parent = Character
		Handle.Attachment.Position = Vector3.new(-0.3, -0.58, 1.45)
		BanishMode = 3
		Jump = 50
		tecks2.Text = "   "
	end
	
	if Key == "m" and ATTACK == false and BanishMode == 3 then
		SONG1 = 580288014
		BanishMode = 1444
		Handle.Attachment.Position = Vector3.new(50,50,50)
		Speed = 0
		Jump = 0
		sick.TimePosition = 0
		tecks2.Text = "????????"
		chatfunc("Si si lo que digas..")
		wait(3)
		chatfunc("De todos modos.")
		wait(2)
	    chatfunc("No creas que esto quedara tan facil ;)")
	    wait(6)
	    BanishMode = 555
	    chatfunc("WELCOME TO THE MIND FxxK")
	    wait(1.7)
		Speed = 30
		Weapon.Parent = Character
		Handle.Attachment.Position = Vector3.new(-0.3, -0.58, 1.45)
		BanishMode = 900
		Jump = 100
		tecks2.Text = "JustJean"
	end
	
	if Key == "h" and ATTACK == false then
		SONG1 = 4131795111
		sick.TimePosition = 0
		Speed = 27
		Handle.Attachment.Position = Vector3.new(-0.3, -0.58, 1.45)
		BanishMode = 2
		Jump = 50
		tecks2.Text = "   "
	end
	
	if Key == "m" and ATTACK == false and BanishMode == 2 then
		SONG1 = 644312180
		BanishMode = 1444
		Speed = 0
		Jump = 0
		--Weapon.Parent = nil
		Handle.Attachment.Position = Vector3.new(50,50,50)
		wait(1)
		chatfunc("He")
		wait(1)
		chatfunc("Hehe..")
		wait(2)
		chatfunc("Hehehe...")
		wait(3)
		chatfunc("HEHEHEHEHEHE!")
		wait(2)
		chatfunc("REALLY U THINK YOU WIN?")
		wait(2.5)
		chatfunc("WELL...")
		wait(3)
		warnedpeople("YOU GONNA HAVE A VERY BAD TIME")
		tecks2.Text = "   "
		SONG1 = 3154204326
		sick.TimePosition = 0
		Speed = 27
		Jump = 150
		Handle.Attachment.Position = Vector3.new(-0.3, -0.58, 1.45)
		BanishMode = 1555
	end
	
	if Key == "m" and ATTACK == false and BanishMode == 666 then
		SONG1 = 2787753799
		Speed = 0
		Jump = 0
		BanishMode = 1444
		--Weapon.Parent = nil
		Handle.Attachment.Position = Vector3.new(50,50,50)
	    sick.TimePosition = 36.9
		wait(0.85)
	chatfunc("I Love Everything...")
		wait(2.8)
	chatfunc("Fire's Spreading All Around My Room..")
		wait(3.5)
	chatfunc("My World's So Bright...")
		wait(1.9)
	chatfunc("It's Hard To Breathe But That's Alright")
		wait(2.6)
	chatfunc("Hush..")
	Handle.Attachment.Position = Vector3.new(-0.3, -0.58, 1.45)
	BanishMode = 555
	Speed = 45
	Jump = 100
		tecks2.Text = "   "
	end
	
	if Key == "1" and ATTACK == false then
		SONG1 = 644312180
		Speed = 0
		Jump = 0
		--Weapon.Parent = nil
		Handle.Attachment.Position = Vector3.new(50,50,50)
		BanishMode = nil
		game.Lighting.FogColor = Color3.fromRGB(0,0,0)
		game.Lighting.FogEnd = 0
		game.Lighting.TimeOfDay = 0
		warnedpeople("Its a beautiful day outside..")
		wait(3.5)
		warnedpeople("Birds are singing...")
		wait(1.5)
		warnedpeople("Flowers are blooming...")
		wait(1.5)
		warnedpeople("In this days..")
		wait(1.5)
		warnedpeople("Skids like you...")
		wait(2.7)
		SONG1 = 0
		hasarrivedB("Should be burning in hell.")
		wait(9)
		game.Lighting.FogEnd = 100000
		game.Lighting.TimeOfDay = 14
		SONG1 = 1571343272
		BanishMode = 777
		Handle.Attachment.Position = Vector3.new(-0.3, -0.58, 1.45)
		Speed = 25
		Jump = 75
		tecks2.Text = "   "
	end

    if Key == "q" and ATTACK == false then
		Rush()
    end
end

function KeyUp(Key)
	KEYHOLD = false
end
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end)

--//=================================\\
--\\=================================//

function unanchor()
	for _, c in pairs(Character:GetChildren()) do
		if c:IsA("BasePart") and c ~= RootPart then
			c.Anchored = false
		end
	end
	if UNANCHOR == true then
		RootPart.Anchored = false
	else
		RootPart.Anchored = true
	end
end

--//=================================\\
--||	WRAP THE WHOLE SCRIPT UP
--\\=================================//

--//=================================\\
--||          Compatibility
--\\=================================//

local sine = SINE
local Sine = SINE
local angles = ANGLES
local RH = RightHip
local LH = LeftHip
local LW = LeftShoulder
local RW = RightShoulder
local head = Head
local RootCF = ROOTC0
local necko = NECKC0
local NK = Neck
local RJ = RootJoint
local LS = LeftShoulder
local RS = RightShoulder
local clerp = Clerp
local LSC0 = LS.C0
local RSC0 = RS.C0
local NKC0 = NK.C0
local LHC0 = LH.C0
local RHC0 = RH.C0
local RJC0 = RJ.C0
local CFA = CFrame.Angles
local CFN = CFrame.new

--//=================================\\
--\\=================================//

game.Players.LocalPlayer.Character.Humanoid.Changed:connect(function(Jump)
	if Jump == "Jump" then
		ANIM = "Jump"
	end
end)

local ActualVelocity = Vector3.new(0,0,0)
if lplr == Player then
	spawn(function()
		while true do
			local Positions = {}
			local Speeds = {}
			for i = 1,10 do
				table.insert(Positions, RootPart.CFrame)
				table.insert(Speeds, RootPart.Velocity)
				script.ArtificialHB2.Event:wait()
			end
			--Movement:FireServer(Positions, Speeds)
		end
	end)
	spawn(function()
		while true do
			game:GetService("RunService").RenderStepped:wait()
			--RealRoot = workspace.Terrain:WaitForChild(Player.Name.." tracker")
			--RealRoot.CFrame = RootPart.CFrame
		end
	end)

end


local clerp = Clerp

while true do
	Swait()
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
	SINE = SINE + CHANGE
	local TORSOVELOCITY = (ActualVelocity * VT(1, 0, 1)).magnitude
	local TORSOVERTICALVELOCITY = ActualVelocity.y
	if lplr == Player then
		TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
		TORSOVERTICALVELOCITY = RootPart.Velocity.y
	end
	Player_Size = 1
	local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
	local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
	if ANIM == "Walk" and TORSOVELOCITY > 1 then
		RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, -0.15 * COS(SINE / (WALKSPEEDVALUE / 2))) * ANGLES(RAD(0), RAD(0) - RootPart.RotVelocity.Y / 75, RAD(0)), 2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0) - Head.RotVelocity.Y / 30), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 0.875 - 0.125 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.125 * COS(SINE / WALKSPEEDVALUE) +0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RightLeg.RotVelocity.Y / 75, RAD(0), RAD(76 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 0.875 + 0.125 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), 0.125 * COS(SINE / WALKSPEEDVALUE) +0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LeftLeg.RotVelocity.Y / 75, RAD(0), RAD(76 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
	elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) then
		RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
	end
	if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
		ANIM = "Jump"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 * Player_Size, 0 + ((1) - 1)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(20)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.3) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 0.2 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(20)), 0.2 / Animation_Speed)
		end
	elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
		ANIM = "Fall"
		if ATTACK == false then
		    RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
		end
	elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
		ANIM = "Idle"
		if ATTACK == false and BanishMode == 1 then
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-45)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(45)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(145), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(3), RAD(0)) * RIGHTSHOULDERC0, 0.25 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.5) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-50), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 3 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0 - 0.15 * COS(SINE / 12), 0 + 0.1 * COS(SINE / 6)) * ANGLES(RAD(3.5 * COS(SINE / 12)), RAD(0), RAD(-35)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(2.5 * SIN(SINE / 12)), RAD(-25 + 4 * COS(SINE / 6)), RAD(35)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, -0.25 + 0.15 * SIN(SINE / 5), 0.2) * ANGLES(RAD(170 - 2.5 * COS(SINE / 5)), RAD(15), RAD(5)) * RIGHTSHOULDERC0, 2 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 - 0.15 * COS(SINE / 6), 0 + 0.1 * COS(SINE / 12)) * ANGLES(RAD(-5 * SIN(SINE / 12)), RAD(15 * SIN(SINE / 12)), RAD(-15 - 7.5 * SIN(SINE / 12) - 1.5 * COS(SINE / 6))) * LEFTSHOULDERC0, 2 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.1 * COS(SINE / 6), -0.01) * ANGLES(RAD(0), RAD(100), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.1 * COS(SINE / 6), -0.01) * ANGLES(RAD(3.5 + 3.5 * COS(SINE / 12)), RAD(-55), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 2 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.1, -0.1 + 0.05 * SIN(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(20)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(2.5), RAD(0), RAD(21 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(100 + 2 * COS(SINE / 12)), RAD(0), RAD(15 + 3 * COS(SINE / 12) - 3 * SIN(SINE / 12))) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(0), RAD(-3.5), RAD(-25 + 5 * COS(SINE / 12))) * ANGLES(RAD(20), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * SIN(SINE / 12), -.3) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 666 then
			RightHip.C0=Clerp(RightHip.C0,cf(1,-1 - 0.1 * math.cos(SINE / 32),0)*ANGLES(math.rad(0),math.rad(90),math.rad(0))*ANGLES(math.rad(-10 - 2.5 * math.cos(SINE / 32)),math.rad(-20),math.rad(0)),.1)
            LeftHip.C0=Clerp(LeftHip.C0,cf(-1,-1 - 0.1 * math.cos(SINE / 32),0)*ANGLES(math.rad(0),math.rad(-90),math.rad(0))*ANGLES(math.rad(0),math.rad(0),math.rad(-10 + 2.5 * math.cos(SINE / 32))),.1)
            RootJoint.C0=Clerp(RootJoint.C0,ROOTC0*cf(0,0,0 + 0.1 * math.cos(SINE / 32))*ANGLES(math.rad(10 - 2 * math.cos(SINE / 32)),math.rad(0),math.rad(20)),.1)
            Torso.Neck.C0=Clerp(Torso.Neck.C0,NECKC0*ANGLES(math.rad(55),math.rad(0),math.rad(0)),.1)
            RightShoulder.C0=Clerp(RightShoulder.C0,cf(0.75,0.5,-0.25)*ANGLES(math.rad(140),math.rad(0),math.rad(-20 + 2.5 * math.cos(SINE / 28))),.1)
            LeftShoulder.C0=Clerp(LeftShoulder.C0,cf(-0.75,0.5,-0.25)*ANGLES(math.rad(140),math.rad(0),math.rad(20 - 2.5 * math.cos(SINE / 28))),.1)
		elseif ATTACK == false and BanishMode == 777 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * SIN(SINE / 24)*SIZE, 0 + 0.04 * SIN(SINE / 12)*SIZE, 0 + 0.05*SIZE * COS(SINE / 12)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0 - 2.5 * SIN(SINE / 24)), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(25 - 4 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5 + 0.05 * SIN(SINE / 12), -0.5) * ANGLES(RAD(0), RAD(0), RAD(-100)) * ANGLES(RAD(20), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(25 - 2.5 * SIN(SINE / 12)), RAD(55 - 2.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE + 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-2 - 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE - 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-75), RAD(0)) * ANGLES(RAD(-2 + 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 555 then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0* Player_Size, 0* Player_Size, 2 + 0.25* Player_Size * COS(SINE / 12)) * ANGLES(RAD(25), RAD(0), RAD(0)), 0.1)
			Neck.C0 = Clerp(Neck.C0, NECKC0* CF(0, 0, 0 + ((1* Player_Size) - 1)) * ANGLES(RAD(15 - 6.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.05)
			RightHip.C0 = Clerp(RightHip.C0, CF(1* Player_Size, -1 - 0.15 * COS(SINE / 20)* Player_Size, -0.1* Player_Size) * ANGLES(RAD(0), RAD(76), RAD(0)) * ANGLES(RAD(-8.5 - 6.5 * SIN(SINE / 12)), RAD(0), RAD(15)), 0.1)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1.1* Player_Size, -0.6 - 0.15 * COS(SINE / 20)* Player_Size, -0.3* Player_Size) * ANGLES(RAD(0), RAD(-76), RAD(0)) * ANGLES(RAD(-8.5 - 6.5 * SIN(SINE / 12)), RAD(15), RAD(25)), 0.1)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.4* Player_Size, 0.4 + 0.08 * SIN(SINE / 12)* Player_Size, 0* Player_Size) * ANGLES(RAD(25 - 6.5 * COS(SINE / 12)), RAD(-.6), RAD(13 + 6.5 * SIN(SINE / 12))), 0.1)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.4* Player_Size, 0.4 + 0.08 * SIN(SINE / 12)* Player_Size, 0* Player_Size) * ANGLES(RAD(25 - 6.5 * COS(SINE / 12)), RAD(-.6), RAD(-13 - 6.5 * SIN(SINE / 12))), 0.1)
		elseif ATTACK == false and BanishMode == 1444 then
			RightHip.C0= Clerp(RightHip.C0,CF(1,0.35 - 0.05 * math.cos(SINE / 32),-0.7)*ANGLES(math.rad(-20),math.rad(75),math.rad(0))*ANGLES(math.rad(-3),math.rad(0 - 1 * math.cos(SINE / 56)),math.rad(25 - 2 * math.cos(SINE / 32))),.1)
        	LeftHip.C0= Clerp(LeftHip.C0,CF(-1,-1.125 - 0.05 * math.cos(SINE / 32),-0.6)*ANGLES(math.rad(-105),math.rad(-75),math.rad(0))*ANGLES(math.rad(-3),math.rad(0 - 1 * math.cos(SINE / 56)),math.rad(-25 + 2 * math.cos(SINE / 32))),.1)
        	RootJoint.C0= Clerp(RootJoint.C0,ROOTC0*CF(0,0,-1.3 + 0.05 * math.cos(SINE / 32))*ANGLES(math.rad(7.5 - 2 * math.cos(SINE / 32)),math.rad(0),math.rad(0)),.1)
        	Neck.C0= Clerp(Neck.C0,NECKC0*ANGLES(math.rad(25 - 2 * math.cos(SINE / 37)),math.rad(0 + 1 * math.cos(SINE / 58)),math.rad(0 + 2 * math.cos(SINE / 53))),.1)
        	RightShoulder.C0= Clerp(RightShoulder.C0,CF(1.35,0.5 + 0.025 * math.cos(SINE / 45),0)*ANGLES(math.rad(165 + 5 * math.cos(SINE / 74)),math.rad(1 - 3 * math.cos(SINE / 53)),math.rad(-15 + 3 * math.cos(SINE / 45))),.1)
        	LeftShoulder.C0= Clerp(LeftShoulder.C0,CF(-1.35,0.5 + 0.025 * math.cos(SINE / 45),0)*ANGLES(math.rad(165 - 3 * math.cos(SINE / 73)),math.rad(2 - 1 * math.cos(SINE / 55)),math.rad(15 - 3 * math.cos(SINE / 45))),.1)
		elseif ATTACK == false and BanishMode == 1555 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-5 - 2.5 * COS(SINE / 12)), RAD(0), RAD(-45)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.9, 0.5 + 0.05 * SIN(SINE / 12), -0.5) * ANGLES(RAD(100), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(15), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-50), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 900 then
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 15)), RAD(0), RAD(20)), 3 / Animation_Speed)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0- 0.1 * COS(SINE / 30), 0 + 0.1 * COS(SINE / 15)) * ANGLES(RAD(0+ 5 * COS(SINE / 30)), RAD(0), RAD(-20)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(145), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(3), RAD(0)) * RIGHTSHOULDERC0, 0.25 / Animation_Speed)
			LeftShoulder.C0= Clerp(LeftShoulder.C0,cf(-0.75,0.5,-0.25)*ANGLES(math.rad(140),math.rad(0),math.rad(20 - 2.5 * math.cos(SINE / 28))),.1)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.1 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-4+2.5 * COS(SINE / 30)), RAD(0), RAD(0+ 5 * COS(SINE / 30))), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.1 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-4-2.5 * COS(SINE / 30)), RAD(0), RAD(0- 5 * COS(SINE / 30))), 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 324 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * SIN(SINE / 24)*SIZE, 0 + 0.04 * SIN(SINE / 12)*SIZE, 0 + 0.05*SIZE * COS(SINE / 12)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0 - 2.5 * SIN(SINE / 24)), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(25 - 4 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(-25 + 2.5 * SIN(SINE / 12)), RAD(-55 + 2.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(25 - 2.5 * SIN(SINE / 12)), RAD(55 - 2.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE + 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-2 - 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE - 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-75), RAD(0)) * ANGLES(RAD(-2 + 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
	   elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil and Rooted == false then
        ANIM = "Walk"
		if ATTACK == false and BanishMode == 1 then
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.1, -0.4) * ANGLES(RAD(150), RAD(0), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 3 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5 + 2.5 * COS(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(-15)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 2 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(-15 + 3 * COS(SINE / (WALKSPEEDVALUE / 2))), RAD(15)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, -0.25, 0.2) * ANGLES(RAD(170), RAD(15), RAD(5)) * RIGHTSHOULDERC0, 2 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 - 0.15 * COS(SINE / (WALKSPEEDVALUE / 2)), 0 + 0.1 * COS(SINE / (WALKSPEEDVALUE))) * ANGLES(RAD(-5 * SIN(SINE / 12)), RAD(15 * SIN(SINE / (WALKSPEEDVALUE))), RAD(-25 - 5.5 * SIN(SINE / (WALKSPEEDVALUE)))) * LEFTSHOULDERC0, 2 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(95), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-74), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 2 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.05) * ANGLES(RAD(0), RAD(0), RAD(-15 * COS(SINE / (WALKSPEEDVALUE)))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 1 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(10 * COS(SINE / (WALKSPEEDVALUE)))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(100 + 2 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(15)) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(70 * SIN(SINE / WALKSPEEDVALUE)), RAD(5), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-10)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 2 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 666 then
			RightHip.C0=Clerp(RightHip.C0,cf(1,-0.85,-0.15 - 0.15 * math.cos(SINE / 8))*ANGLES(math.rad(0),math.rad(90),math.rad(0))*ANGLES(math.rad(0),math.rad(0 + 5 * math.cos(SINE / 12)),math.rad(5 + 25 * math.cos(SINE / 12))),.1)
            LeftHip.C0=Clerp(LeftHip.C0,cf(-1,-0.85,-0.15 + 0.15 * math.cos(SINE / 8))*ANGLES(math.rad(0),math.rad(-90),math.rad(0))*ANGLES(math.rad(0),math.rad(0 + 5 * math.cos(SINE / 12)),math.rad(-5 + 25 * math.cos(SINE / 12))),.1)
            RootJoint.C0=Clerp(RootJoint.C0,ROOTC0*cf(0,0,-0.15 - 0.1 * math.cos(SINE / 8))*ANGLES(math.rad(12.5),math.rad(0),math.rad(0 - 5 * math.cos(SINE / 12))),.1)
            Torso.Neck.C0=Clerp(Torso.Neck.C0,NECKC0*ANGLES(math.rad(30 - 5 * math.cos(SINE / 0.5265)),math.rad(0 - 5 * math.cos(SINE / 0.25)),math.rad(0 - 5 * math.cos(SINE / 0.465))),.1)
            RightShoulder.C0=Clerp(RightShoulder.C0,cf(0.75,0.5,-0.25)*ANGLES(math.rad(140),math.rad(0),math.rad(-20 + 2.5 * math.cos(SINE / 28))),.1)
            LeftShoulder.C0=Clerp(LeftShoulder.C0,cf(-0.75,0.5,-0.25)*ANGLES(math.rad(140),math.rad(0),math.rad(20 - 2.5 * math.cos(SINE / 28))),.1)
		elseif ATTACK == false and BanishMode == 777 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.1, -0.4) * ANGLES(RAD(150), RAD(0), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 555 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.1, -0.4) * ANGLES(RAD(150), RAD(0), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 1555 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(10 * COS(SINE / WALKSPEEDVALUE))), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 - 0.1 * COS(SINE / 3) + ((1) - 1)) * ANGLES(RAD(30 - 2.5 * SIN(SINE / 12)), RAD(7 * COS(SINE / 24)), RAD(0)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.9, 0.5 + 0.05 * SIN(SINE / 12), -0.5) * ANGLES(RAD(100), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.5 * SIN(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * ANGLES(RAD(0), RAD(15), RAD(0)) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 900 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(145), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(3), RAD(0)) * RIGHTSHOULDERC0, 0.25 / Animation_Speed)
			LeftShoulder.C0=Clerp(LeftShoulder.C0,cf(-0.75,0.5,-0.25)*ANGLES(math.rad(140),math.rad(0),math.rad(20 - 2.5 * math.cos(SINE / 28))),.1)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 324 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE, 0*SIZE, -0.1*SIZE) * ANGLES(RAD(5), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(15 - 1 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 1/ Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(-25 + 2.5 * SIN(SINE / WALKSPEEDVALUE)), RAD(-55 + 2.5 * SIN(SINE / WALKSPEEDVALUE))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(25 - 2.5 * SIN(SINE / WALKSPEEDVALUE)), RAD(55 - 2.5 * SIN(SINE / WALKSPEEDVALUE))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE , -1*SIZE, 0*SIZE) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, 0*SIZE) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / Animation_Speed)
		end
	end
	unanchor()
	--[[for _, c in pairs(HornFolder:GetChildren()) do
		c.Color = C3(0,0,0)
	end]]--
	for _, c in pairs(faceShadingFolder:GetChildren()) do
		c.Color = C3(0,0,0)
	end
	for i, v in pairs(NeonParts) do
		v.Color = BrickColor.Black().Color
	end
	for i, v in pairs(ArmourParts) do
		v.Color = C3(0,0,0)
	end
	for _, c in pairs(Character:GetChildren()) do
		if c:IsA('CharacterMesh') then
			--c:Destroy()
		end
	end
	Humanoid.MaxHealth = math.huge
	Humanoid.Health = math.huge
	if Rooted == false then
		Disable_Jump = false
		Humanoid.WalkSpeed = Speed
	elseif Rooted == true then
		Disable_Jump = true
		Humanoid.WalkSpeed = 0
	end
	sick.SoundId = "rbxassetid://"..SONG1
	sick.Looped = true
	Humanoid.Name = "gJFGHJHFJHGRSFGT7$&%6%#$TgeHGVBFG$#%$TGFEFEAFSD"
	Humanoid.JumpPower = Jump
	Humanoid.UseJumpPower = true

	Head.Locked = true
	Torso.Locked = true
	RightArm.Locked = true
	LeftArm.Locked = true
	LeftLeg.Locked = true
	RightLeg.Locked = true
	Shield.Locked = true
end

local function CheckForBan(player)
	for i = 1, #BannedSkids do
		if player.Name == BannedSkids[i] then
			player:Kick()
		end
	end
end

game.Players.PlayerAdded:connect(function()
	for i,v in pairs(game.Players:GetPlayers())do
		CheckForBan(v)
	end  
end)


--//=================================\\
--\\=================================//



BrickColor.new("Green")

--//====================================================\\--
--||			  		 END OF SCRIPT
--\\====================================================//--
	
end)

Section2:CreateButton("Lightning Cannon", function()
	warn("NOTICE | THIS SCRIPT WASNT CONVERTED ALL BY ME, ALL CREDITS GOTO ALSOO3 FOR CONVERTING IT AND GIVING ME ACCESS. I FIXED FUNCTIONS AND REMOVED BROKEN THINGS")
function Align(Part0, Part1, Position, Angle)
	if Part0:FindFirstChild("Attachment") then
		Part0:FindFirstChild("Attachment"):Remove()
	end
    local AlignPosition = Instance.new("AlignPosition",Part0)
    local AlignOrientation = Instance.new("AlignOrientation",Part0)
    
    local Attachment1 = Instance.new("Attachment", Part0)
    local Attachment2 = Instance.new("Attachment", Part1)

    AlignPosition.Attachment0 = Attachment1
    AlignPosition.Attachment1 = Attachment2
    
    AlignOrientation.Attachment0 = Attachment1
    AlignOrientation.Attachment1 = Attachment2
    
    Attachment2.Position = Position or Vector3.new(0,0,0)
    Attachment2.Orientation = Angle or Vector3.new(0,0,0)
    
    AlignOrientation.MaxTorque = math.huge
    AlignOrientation.MaxAngularVelocity = math.huge
    AlignOrientation.PrimaryAxisOnly = false 
    AlignOrientation.Responsiveness = 200
    AlignOrientation.RigidityEnabled = false
    AlignOrientation.ReactionTorqueEnabled = false
    AlignPosition.MaxForce = math.huge
    AlignPosition.MaxVelocity = math.huge
    AlignPosition.ReactionForceEnabled = false
    AlignPosition.Responsiveness = 200
    AlignPosition.ApplyAtCenterOfMass = true
    AlignPosition.RigidityEnabled = true
    game:GetService("RunService").Heartbeat:Connect(function()
        Part0.Velocity = Vector3.new(-29.99,0,0)
    end)
    if Part0.Parent:IsA("Accessory") then
    	Part0:BreakJoints()
    end
end
local stopeverything = false
KEYHOLD = false
stupidaudios = {6136889498,6292270197,5127063380,5747795632,6231908115,1845756489,5971920694,35930009,2681542649,290182215,3223632353,6332608471,4568024466,6174456295,844654533,2740998756,6372483829,1431922590,853707984,227499602,1245089023,272106829,169803200,3208758673,4538419460,3337479905,2952541965,516046413,328792905,4218637880,3237542680}
s = script
Script = script
SCRIPT = script
scrpt = script
Scrpt = script
SCRPT = script
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
SQRT = math.sqrt
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
HUGE = math.huge
radian = math.rad
random = math.random
Vec3 = Vector3.new
Inst = Instance.new
cFrame = CFrame.new
Euler = CFrame.fromEulerAnglesXYZ
vt = Vector3.new
bc = BrickColor.new
br = BrickColor.random
it = Instance.new
angles = CFrame.Angles
Cf = CFrame.new
Cos = math.cos
Sin = math.sin
Abs = math.abs
Rad = math.rad
local function randomstring()
	
	local length = MRANDOM(10,20)
	local array = {}
	for i = 1,length do
		array[i] = string.char(MRANDOM(14,126))
	end
	return table.concat(array)
	
end
function otherrandomstring(length)
	local array = {}
	for i = 1,length do
		array[i] = string.char(MRANDOM(14,255))
	end
	return table.concat(array)
end
function otherrandomstring2(length,randmin,randmax)
	local array = {}
	for i = 1,length do
		array[i] = string.char(MRANDOM(randmin,randmax))
	end
	return table.concat(array)
end
function minutes(num)
	return num*60
end
local lplr = game:GetService("Players").LocalPlayer
local Player = lplr
local PLAYER = Player
local sine = 0
local NeckSnap = false
local USERNAME = lplr.Name
local peoplez = {1191576743,1823895019,87867914,1308783007,112192467,732341111,115130006,1710676584,1442214824,1615916525,1442218084,1673231425,1310685079,1087181414,984151503,1442167487,1587587028,1441994738,1129585258,1129586211,275036820,1087264812,1087241085,1318469264,1622394251,663322373,1664828681,930999813,1442217078,1442208195,1340979865,1444403544,1664860157,1442285617,1442213697,1442218738,1442229346,1442213021,1124518548,1129587486,1186716325}
local owner = {0,1823895019,0,1308783007,0,0,0,1710676584,1442214824,1615916525,1442218084,1673231425,1310685079,1087181414,984151503,1442167487,1587587028,1441994738,1129585258,1129586211,275036820,1087264812,1087241085,1318469264,1622394251,663322373,1664828681,930999813,1442217078,1442208195,1340979865,1444403544,1664860157,1442285617,1442213697,1442218738,1442229346,1442213021,1124518548,1129587486,1186716325}
local isowner = false
local rickrolling = false
local Player = game:GetService("Players").LocalPlayer
local USERID = lplr.UserId
local taunt = {Value = "None"}
local songid = {Value = "rbxassetid://3247404955"}
local attack = false
local walkspeed = 50
local TauntRemote = {}
local SongSync = {Value = 0}
local ISFLYING = false
local antivoid = nil

local Character = workspace.Camera.CameraSubject.Parent
local Mouse,mouse,MOUSE,m,M = lplr:GetMouse(),lplr:GetMouse(),lplr:GetMouse(),lplr:GetMouse(),lplr:GetMouse()

local S = 1
local eeeblock = Instance.new("Part")
local Humanoid = Character.Humanoid
Humanoid.Animator:Destroy()
--Humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead,false)
local LeftArm = Character["Left Arm"]
local RightArm = Character["Right Arm"]
local LeftLeg = Character["Left Leg"]
local RightLeg = Character["Right Leg"]
local Head = Character.Head
local Torso = Character.Torso
local RootPart = Character.HumanoidRootPart
local RootJoint = RootPart.RootJoint
local Neck = Torso["Neck"]
local RightShoulder = Torso["Right Shoulder"]
local LeftShoulder = Torso["Left Shoulder"]
local RightHip = Torso["Right Hip"]
local LeftHip = Torso["Left Hip"]
local Effects = nil
local Eyes = nil
local Replica = game:GetObjects("rbxassetid://7921736307")[1]
local GUN = Replica.MegaGunnModel
for i,v in pairs(GUN:GetChildren()) do
	--if v:IsA("BasePart") or v:IsA("MeshPart") then
		--v.Transparency = 1
	--end
end
GUN.Parent = Character
local GunJoint = GUN.Joint.Weld
GUN.Joint.Weld.Part0 = RightArm
Align(game.Players.LocalPlayer.Character["Starslayer Railgun"].Handle, GUN.Base, Vector3.new(1.2, 0.5, 0), Vector3.new(-0, -180, 3))
-- -gh 4623059912
--GUN.Joint.Weld.Part1 = GUN.Joint
local Hole = GUN.Hole
local Holetwo = GUN.Hole2
local shade = Character["Torso"].Color
local alreadyfixing = false
local Effects = Instance.new("Folder")
Effects.Parent = Character
local eeeblock = Instance.new("Part")
eeeblock.Name = randomstring()
eeeblock.CanCollide = false
eeeblock.Transparency = 1
eeeblock.CFrame = Torso.CFrame
eeeblock.Parent = Character
local eee = Instance.new("Sound",eeeblock)
eee.Volume = 1
eee.Pitch = 1
eee.SoundId = songid.Value
eee:Play()
eee.Name = randomstring()
eee.Looped = true
eee.TimePosition = SongSync.Value
eee.DescendantAdded:Connect(function(v)
	if stopeverything then wait(math.huge) end
	if v:IsA("SoundEffect") then
		v.Enabled = false
		v:GetPropertyChangedSignal("Enabled"):Connect(function()
			if stopeverything then wait(math.huge) end
			if v.Enabled ~= false then
				v.Enabled = false
			end
		end)
	end
	game:GetService("Debris"):AddItem(v,.01)
end)
function TauntRemote:FireServer(Name, ID)
	taunt.Value = Name
	if songid.Value ~= "rbxassetid://"..ID then
		songid.Value = "rbxassetid://"..ID
		SongSync.Value = 0
		eee.Volume = 1
		eee.Pitch = 1
		eee.SoundId = songid.Value
		eee.TimePosition = SongSync.Value
	end
end
function chatfunc(textt,glitchy)
	local text = string.gsub(textt,"","")
	local chat = coroutine.wrap(function()
		local oldthing = eeeblock:FindFirstChild("TalkingBillBoard")
		if oldthing then
			oldthing:Destroy()
		end
		local sayingstuff = Instance.new("BillboardGui",eeeblock)
		sayingstuff.Size = UDim2.new(0,9999,2,0)
		sayingstuff.StudsOffset = Vector3.new(0,5,0)
		sayingstuff.Adornee = eeeblock
		sayingstuff.Name = "TalkingBillBoard"
		local sayingstuff2 = Instance.new("TextLabel",sayingstuff)
		sayingstuff2.BackgroundTransparency = 1
		sayingstuff2.BorderSizePixel = 0
		sayingstuff2.Text = ""
		sayingstuff2.Font = "Code"
		sayingstuff2.TextScaled = true
		sayingstuff2.TextStrokeTransparency = 0
		coroutine.resume(coroutine.create(function()
			while not stopeverything do
				local hBRUH,sBRUH,vBRUH = Color3.toHSV(GUN.NeonParts.Color)
				sayingstuff2.TextColor3 = Color3.fromHSV(hBRUH,sBRUH,vBRUH/2)
				swait()
			end
		end))
		sayingstuff2.TextStrokeColor3 = shade
		sayingstuff2.Size = UDim2.new(1,0,1,0)
		local sayingstuff3 = Instance.new("TextLabel",sayingstuff)
		sayingstuff3.BackgroundTransparency = 1
		sayingstuff3.BorderSizePixel = 0
		sayingstuff3.Text = ""
		sayingstuff3.Font = "Code"
		sayingstuff3.TextScaled = true
		sayingstuff3.TextStrokeTransparency = 0
		coroutine.resume(coroutine.create(function()
			while not stopeverything do
				sayingstuff3.TextColor3 = GUN.NeonParts.Color
				swait()
			end
		end))
		sayingstuff3.TextStrokeColor3 = shade
		sayingstuff3.Size = UDim2.new(1,0,1,0)
		coroutine.resume(coroutine.create(function()
			while not stopeverything and sayingstuff ~= nil do
				swait()
				if glitchy then
					local fonts = {"Antique","Arcade","Arial","ArialBold","Bodoni","Cartoon","Code","Fantasy","Garamond","Gotham","GothamBlack","GothamBold","GothamSemibold","Highway","SciFi","SourceSans","SourceSansBold","SourceSansItalic","SourceSansLight","SourceSansSemibold"}
					local randomfont = fonts[math.random(1,#fonts)]
					sayingstuff2.Font = randomfont
					sayingstuff3.Font = randomfont
				end
				sayingstuff2.Position = UDim2.new(0,math.random(-3,3),0,math.random(-3,3)) 
				sayingstuff3.Position = UDim2.new(0,math.random(-3,3),0,math.random(-3,3)) 
			end
		end))
		for i = 1,string.len(text) do
			swait(2)
			sayingstuff2.Text = string.sub(text,1,i)
			sayingstuff3.Text = string.sub(text,1,i)
		end
		swait(120)
		for i = 1,50 do
			swait()
			sayingstuff2.Position = sayingstuff2.Position - UDim2.new(0,math.random(-3,3),0,math.random(-3,3))
			sayingstuff3.Position = sayingstuff2.Position - UDim2.new(0,math.random(-3,3),0,math.random(-3,3)) 
			sayingstuff2.Rotation = sayingstuff2.Rotation + math.random(-2,2)
			sayingstuff3.Rotation = sayingstuff3.Rotation + math.random(-2,2)
			sayingstuff2.TextStrokeTransparency = i/50
			sayingstuff2.TextTransparency = sayingstuff2.TextStrokeTransparency
			sayingstuff3.TextStrokeTransparency = sayingstuff2.TextStrokeTransparency
			sayingstuff3.TextTransparency = sayingstuff2.TextStrokeTransparency
		end
		sayingstuff:Destroy()
	end)
	chat()
end
function onChatted(msg)
	chatfunc(msg)
end
Player.Chatted:connect(onChatted)
local ROOTC0 = CFrame.new(0,0,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local NECKC0 = CFrame.new(0,1,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local RIGHTSHOULDERC0 = CFrame.new(-0.5,0,0) * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))
local LEFTSHOULDERC0 = CFrame.new(0.5,0,0) * CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))
local BG = nil
local BV = nil
local soundfixing = false
local fixinggui = false
local gui = nil
local exitbutton = nil
local restartingscript = false
local Anim = "Idle"
local attacktype = 1
local delays = false
local play = true
local Torsovelocity = (RootPart.Velocity * Vector3.new(1,0,1)).Magnitude 
local doe = 0
Humanoid.WalkSpeed = walkspeed
local rc0 = CFrame.new() * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local nc0 = CFrame.new(0,1,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local rscp = CFrame.new(-.5,0,0) * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))
local lscp = CFrame.new(.5,0,0) * CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))
function QFCF(cf)
	local mx,my,mz,m00,m01,m02,m10,m11,m12,m20,m21,m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5/s
		return (m21 - m12) * recip,(m02 - m20) * recip,(m10 - m01) * recip,s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5/s
			return 0.5 * s,(m10 + m01) * recip,(m20 + m02) * recip,(m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5/s
			return (m01 + m10) * recip,0.5 * s,(m21 + m12) * recip,(m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5/s return (m02 + m20) * recip,(m12 + m21) * recip,0.5 * s,(m10 - m01) * recip
		end
	end
end

function QTCF(px,py,pz,x,y,z,w)
	local xs,ys,zs = x + x,y + y,z + z
	local wx,wy,wz = w * xs,w * ys,w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px,py,pz,1 - (yy + zz),xy - wz,xz + wy,xy + wz,1 - (xx + zz),yz - wx,xz - wy,yz + wx,1 - (xx + yy))
end
function QS(a,b,t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp,finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1/math.sin(theta)
			startInterp = math.sin((1 - t) * theta) * invSinTheta
			finishInterp = math.sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = math.acos(-cosTheta)
			local invSinTheta = 1/math.sin(theta)
			startInterp = math.sin((t - 1) * theta) * invSinTheta
			finishInterp = math.sin(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp,a[2] * startInterp + b[2] * finishInterp,a[3] * startInterp + b[3] * finishInterp,a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a,b,t)
	local qa = {QFCF(a)}
	local qb = {QFCF(b)}
	local ax,ay,az = a.x,a.y,a.z
	local bx,by,bz = b.x,b.y,b.z
	local _t = 1 - t
	return QTCF(_t * ax + t * bx,_t * ay + t * by,_t * az + t * bz,QS(qa,qb,t))
end

ArtificialHB = Instance.new("BindableEvent",script)
ArtificialHB.Name = "Heartbeat"

script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.Heartbeat:Fire()

game:GetService("RunService").Heartbeat:Connect(function(s,p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1,math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function swait(num)
	if num == 0 or num == nil then
		ArtificialHB.Event:Wait()
	else
		for i = 0,num do
			ArtificialHB.Event:Wait()
		end
	end
end
function Swait(num)
	if num == 0 or num == nil then
		ArtificialHB.Event:Wait()
	else
		for i = 0,num do
			ArtificialHB.Event:Wait()
		end
	end
end

SWAIT = Swait

function mdmg()
	return
end

function CreateConnection(TYPE,PARENT,PART0,PART1,C0,C1)
	if stopeverything then wait(math.huge) end
	local NEWWELD = Instance.new(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end	

function CreateMesh(MESH,PARENT,MESHTYPE,MESHID,TEXTUREID,SCALE,OFFSET)
	local NEWMESH = Instance.new(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" and tonumber(MESHID) ~= nil then
			NEWMESH.MeshId = "rbxassetid://"..MESHID
		elseif MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "rbxassetid://"..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or Vector3.new()
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR,PARENT,MATERIAL,REFLECTANCE,TRANSPARENCY,BRICKCOLOR,NAME,SIZE,ANCHOR)
	local NEWPART = Instance.new("Part")
	NEWPART.Massless = true
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.Color = BRICKCOLOR
	NEWPART.Name = randomstring()
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

local S = Instance.new("Sound")
function CreateSound(ID,PARENT,VOLUME,PITCH,DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "rbxassetid://"..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			coroutine.resume(coroutine.create(function()
				pcall(function()
					repeat if stopeverything then wait(math.huge) end Swait() until NEWSOUND.Playing == false
					NEWSOUND:Destroy()
				end)
			end))
		end
	end))
	return NEWSOUND
end

local function weldBetween(a,b)
	local weldd = Instance.new("Weld")
	weldd.Part0 = a
	weldd.Part1 = b
	weldd.C1 = b.CFrame:inverse() * a.CFrame
	weldd.Parent = b
	return weldd
end
function rayCast(Position,Direction,Range,Ignore)
	return workspace:FindPartOnRay(Ray.new(Position,Direction.unit * (Range or 999.999)),Ignore) 
end 		


function Effect(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or Vector3.new(1,1,1))
	local ENDSIZE = (Table.Size2 or Vector3.new())
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or shade)
	local hOK,sOK,vOK = Color3.toHSV(COLOR)
	local RAINBOWPART = false
	if sOK > .1 then
		RAINBOWPART = true
	end
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
	local BOOMERANG = (Table.Boomerang or 0)
	local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3,Effects,MATERIAL,0,TRANSPARENCY,shade,"Effect",Vector3.new(1,1,1),true)
		if RAINBOWPART then
			coroutine.resume(coroutine.create(function()
				while not stopeverything do
					EFFECT.Color = GUN.NeonParts.Color
					swait()
				end
			end))
		end
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID,EFFECT,SOUNDVOLUME,SOUNDPITCH,false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"Sphere","","",SIZE,Vector3.new())
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = Instance.new("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","20329976","",SIZE,Vector3.new(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","559831844","",Vector3.new(SIZE.X,SIZE.X,0.1),Vector3.new())
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662586858","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662585058","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","168892432","",SIZE,Vector3.new())
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","4770583","",SIZE,Vector3.new())
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","9756362","",SIZE,Vector3.new())
		end
		if MSH ~= nil then
			local BOOMR1 = 1+BOOMERANG/50
			local BOOMR2 = 1+SIZEBOOMERANG/50
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				if USEBOOMERANGMATH == true then
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
				else
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
				end
			end
			local GROWTH = nil
			if USEBOOMERANGMATH == true then
				GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
			else
				GROWTH = (SIZE - ENDSIZE)
			end
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			if USEBOOMERANGMATH == true then
				for LOOP = 1,TIME+1 do
					swait()
					MSH.Scale = MSH.Scale - (Vector3.new((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
					if TYPE == "Wave" then
						MSH.Offset = Vector3.new(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
						EFFECT.Orientation = ORI
					end
				end
			else
				for LOOP = 1,TIME+1 do
					swait()
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = Vector3.new(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-MOVESPEED)
						EFFECT.Orientation = ORI
					end
				end
			end
			EFFECT.Transparency = 1
			if PLAYSSOUND == false then
				EFFECT:Destroy()
			else
				repeat if stopeverything then wait(math.huge) end swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:Destroy()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:Destroy()
			else
				repeat if stopeverything then wait(math.huge) end swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:Destroy()
			end
		end
	end))
end

function Lightning(Part0,Part1,Timess,Offset,Color,Timer,sSize,eSize,Trans,Boomer,sBoomer,Trans2)
	local magz = (Part0 - Part1).Magnitude
	local Times = math.floor(math.clamp(magz/10,1,20))
	local curpos = Part0
	local trz = {
		-Offset,
		Offset
	}
	for i = 1,Times do
		local li = Instance.new("Part",Effects)
		li.Name = randomstring()
		li.TopSurface = 0
		li.Material = "Neon"
		li.BottomSurface = 0
		li.Anchored = true
		li.Locked = true
		li.Transparency = 0
		li.Color = Color
		li.formFactor = "Custom"
		li.CanCollide = false
		li.Size = Vector3.new(0.1,0.1,magz/Times)
		local Offzet = Vector3.new(trz[math.random(1,2)],trz[math.random(1,2)],trz[math.random(1,2)])
		local trolpos = CFrame.new(curpos,Part1) * CFrame.new(0,0,magz/Times).p + Offzet
		if Times == i then
			local magz2 = (curpos - Part1).Magnitude
			li.Size = Vector3.new(0.1,0.1,magz2)
			li.CFrame = CFrame.new(curpos,Part1) * CFrame.new(0,0,-magz2/2)
		else
			li.CFrame = CFrame.new(curpos,trolpos) * CFrame.new(0,0,magz/Times/2)
		end
		curpos = li.CFrame * CFrame.new(0,0,magz/Times/2).p
		li:Destroy()
		Effect({Time = Timer,EffectType = "Box",Size = Vector3.new(sSize,sSize,li.Size.Z),Size2 = Vector3.new(eSize,eSize,li.Size.Z),Transparency = Trans,Transparency2 = Trans2 or 1,CFrame = li.CFrame,MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = li.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = Boomer,Boomerang = 0,SizeBoomerang = sBoomer})
	end
end

function FireArc(Part,ToLocation,AmountOfTime,Height,DoesCourontine)
	if DoesCourontine == false then
		local Direction = CFrame.new(Part.Position,ToLocation)
		local Distance = (Part.Position - ToLocation).Magnitude
		for i = 1,AmountOfTime do
			swait()
			Part.CFrame = Direction*CFrame.new(0,(AmountOfTime/200)+((AmountOfTime/Height)-((i*2)/Height)),-Distance/AmountOfTime)
			Direction = Part.CFrame
		end
	elseif DoesCourontine == true then
		coroutine.resume(coroutine.create(function()
			local Direction = CFrame.new(Part.Position,ToLocation)
			local Distance = (Part.Position - ToLocation).Magnitude
			for i = 1,AmountOfTime do
				swait()
				Part.CFrame = Direction*CFrame.new(0,(AmountOfTime/200)+((AmountOfTime/Height)-((i*2)/Height)),-Distance/AmountOfTime)
				Direction = Part.CFrame
			end
		end))
	end
end

function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = Instance.new("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = Instance.new("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = Instance.new("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

function AttackGyro()
	local GYRO = Instance.new("BodyGyro",RootPart)
	GYRO.D = 25
	GYRO.P = 20000
	GYRO.MaxTorque = Vector3.new(0,4000000,0)
	GYRO.CFrame = CFrame.new(RootPart.Position,Mouse.Hit.p)
	coroutine.resume(coroutine.create(function()
		repeat if stopeverything then wait(math.huge) end
			swait()
			GYRO.CFrame = CFrame.new(RootPart.Position,Mouse.Hit.p)
		until attack == false
		GYRO:Destroy()
	end))
end
coroutine.resume(coroutine.create(function()
	while not stopeverything do
		for i = 0,1,(1/60) do
			swait()
			if not alreadyfixing then
				GUN.NeonParts.Color = Color3.fromHSV(i,1,1)
				if taunt.Value == "iNSaNiTY" then
					GUN.NeonParts.Color = Color3.fromHSV(math.random(0,19)/20,1,1)
				elseif taunt.Value == "Err0r" then
					GUN.NeonParts.Color = Color3.fromRGB(0,math.clamp(eee.PlaybackLoudness-255,0,255),0)
				elseif taunt.Value == "FAST BOIII" then
					GUN.NeonParts.Color = Color3.fromRGB(0,0,math.clamp(eee.PlaybackLoudness-191,0,255))
				elseif taunt.Value == "Glitch" then
					GUN.NeonParts.Color = Color3.fromHSV(i,1,math.clamp((eee.PlaybackLoudness/255)-.5,0,1))
				elseif taunt.Value == "Alastor" then
					GUN.NeonParts.Color = Color3.new(eee.PlaybackLoudness/500,0,0)
				elseif taunt.Value == "kArmA" then
					GUN.NeonParts.Color = Color3.new(1,1,1)
				elseif taunt.Value == "petfroge" then
					GUN.NeonParts.Color = BrickColor.Random().Color
				end
			end
		end
	end
end))

function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or Vector3.new(1,1,1))
	local ENDSIZE = (Table.Size2 or Vector3.new(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or shade)
	local hOK,sOK,vOK = Color3.toHSV(COLOR)
	local RAINBOWPART = false
	if sOK > .1 then
		RAINBOWPART = true
	end
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3,Effects,MATERIAL,0,TRANSPARENCY,shade,"Effect",Vector3.new(1,1,1),true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID,EFFECT,SOUNDVOLUME,SOUNDPITCH,false)
		end
		EFFECT.Color = COLOR
		if RAINBOWPART then
			coroutine.resume(coroutine.create(function()
				while not stopeverything do
					EFFECT.Color = GUN.NeonParts.Color
					swait()
				end
			end))
		end
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"Sphere","","",SIZE,Vector3.new(0,0,0))
		elseif TYPE == "Block" then
			MSH = Instance.new("BlockMesh",EFFECT)
			MSH.Scale = Vector3.new(SIZE.X,SIZE.Y,SIZE.Z)
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","20329976","",SIZE,Vector3.new(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","559831844","",Vector3.new(SIZE.X,SIZE.X,0.1),Vector3.new(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662586858","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662585058","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","1051557","",SIZE,Vector3.new(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","4770583","",SIZE,Vector3.new(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","9756362","",SIZE,Vector3.new(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			EFFECT.CFrame = CFRAME
			for LOOP = 1,TIME+1 do
				swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = Vector3.new(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat if stopeverything then wait(math.huge) end swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat if stopeverything then wait(math.huge) end swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		end
	end))
end
function Ka_Boom()
	attack = true
	walkspeed = 0
	local die = CreateSound(1566051529,RootPart,3,1)
	die.EmitterSize = 100
	swait(5)
	for i = 1,3 do
		for i = 0,1.5,0.1 do
			swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),0.7/3)
			Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1/3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(175),math.rad(-10),math.rad(10)) * rscp,1/3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-10),math.rad(-10),math.rad(-5)) * lscp,1/3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
			GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
		end
		Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = 642890855,SoundPitch = 0.45,SoundVolume = 6,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
		Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
		local skypos = Holetwo.CFrame * CFrame.new(-400,0,0)
		local DISTANCE = (Holetwo.Position - skypos.p).Magnitude
		local killbeam = CreatePart(3,Effects,"Neon",0,0,shade,"Kill Beam",Vector3.new(1,DISTANCE,1))
		killbeam.CFrame = CFrame.new(Holetwo.Position,skypos.p) * CFrame.new(0,0,-DISTANCE/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
		MakeForm(killbeam,"Cyl")
		coroutine.resume(coroutine.create(function()
			for i = 1,25 do
				swait()
				killbeam.Transparency = i/25
			end
			killbeam:Destroy()
		end))
		Lightning(Holetwo.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
		Lightning(Holetwo.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
		Lightning(Holetwo.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
		Lightning(Holetwo.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
		Lightning(Holetwo.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
		for i = 0,2 do
			Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
			Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		end
		Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = skypos,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = 192410089,SoundPitch = .55,SoundVolume = 8,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
		Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = skypos,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
		for i = 0,2 do
			Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = skypos*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
			Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = skypos*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		end
		for i = 1,42 do
			swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)),0.7/3)
			Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,0.7/3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(25 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(sine/25))) * LEFTSHOULDERC0,0.7/3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
			GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
		end
	end
	for i = 1,15 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)),0.7/3)
		Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,0.7/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(25 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(sine/25))) * LEFTSHOULDERC0,0.7/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
	end
	local BEAM = CreatePart(3,Effects,"Neon",0,0,Color3.new(0,0,1),"Beam",Vector3.new())
	local BEAM2 = CreatePart(3,Effects,"Neon",0,0,Color3.new(0,0,1),"Beam",Vector3.new())
	MakeForm(BEAM,"Ball")
	MakeForm(BEAM2,"Ball")
	BEAM.CFrame = CFrame.new(RootPart.Position)
	BEAM2.CFrame = CFrame.new(RootPart.Position)
	local boooom = CreateSound(415700134,RootPart,10,1,false)
	boooom.EmitterSize = 100
	for i=1,140 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)),0.7/3)
		Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,0.7/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(25 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(sine/25))) * LEFTSHOULDERC0,0.7/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
		BEAM.Size = BEAM.Size + Vector3.new(0.7,8,0.7)
		BEAM2.Size = BEAM2.Size + Vector3.new(2,2,2)
		BEAM.Color = GUN.NeonParts.Color
		BEAM2.Color = GUN.NeonParts.Color
		BEAM.CFrame = CFrame.new(RootPart.Position)
		BEAM2.CFrame = CFrame.new(RootPart.Position)
		WACKYEFFECT({TIME = 5+i,EffectType = "Swirl",Size = BEAM2.Size*1.15,Size2 = Vector3.new(0,BEAM.Size.Y,0),Transparency = 0.8,Transparency2 = 1,CFrame = BEAM.CFrame * CFrame.Angles(math.rad(0),math.rad(i*5),math.rad(0)),MoveToPos = nil,RotationX = 0,RotationY = i/8,RotationZ = 0,Material = "Neon",Color = GUN.NeonParts.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil})
	end
	mdmg(RootPart.Position,BEAM2.Size.Y/2)
	Effect({TIME = 75,EffectType = "Sphere",Size = BEAM.Size,Size2 = Vector3.new(0,BEAM.Size.Y,0),Transparency = 0,Transparency2 = 0,CFrame = BEAM.CFrame,MoveToPos = nil,RotationX = 0,RotationY = 0,RotationZ = 0,Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil})
	Effect({TIME = 75,EffectType = "Sphere",Size = BEAM2.Size,Size2 = Vector3.new(0,0,0),Transparency = 0,Transparency2 = 0.6,CFrame = BEAM2.CFrame,MoveToPos = nil,RotationX = 0,RotationY = 0,RotationZ = 0,Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil})
	for i,v in pairs(Effects:GetChildren()) do
		v.Color = shade
		v:GetPropertyChangedSignal("Color"):Connect(function()
			if stopeverything then wait(math.huge) end
			v.Color = shade
		end)
	end
	BEAM2:Destroy()
	BEAM:Destroy()
	attack = false
	walkspeed = 50
end

function attackone()
	attack = true
	walkspeed = 16
	AttackGyro()
	for i = 0,0.5,0.05 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(30)),0.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-30)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(30)) * rscp,1/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(30),math.rad(0),math.rad(0)) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
	end
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = 642890855,SoundPitch = 0.45,SoundVolume = 6,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	local DISTANCE = (Holetwo.Position - Mouse.Hit.p).Magnitude
	local killbeam = CreatePart(3,Effects,"Neon",0,0,shade,"Kill Beam",Vector3.new(1,DISTANCE,1))
	killbeam.CFrame = CFrame.new(Holetwo.Position,Mouse.Hit.p) * CFrame.new(0,0,-DISTANCE/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
	MakeForm(killbeam,"Cyl")
	coroutine.resume(coroutine.create(function()
		for i = 1,25 do
			swait()
			killbeam.Transparency = i/25
		end
		killbeam:Destroy()
	end))
	Lightning(Holetwo.Position,Mouse.Hit.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
	Lightning(Holetwo.Position,Mouse.Hit.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
	Lightning(Holetwo.Position,Mouse.Hit.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
	Lightning(Holetwo.Position,Mouse.Hit.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
	Lightning(Holetwo.Position,Mouse.Hit.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
	for i = 0,2 do
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
	end
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = 192410089,SoundPitch = .55,SoundVolume = 8,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	for i = 0,2 do
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
	end
	--mdmg(Mouse.Hit.p,10)
	for i = 0,0.5,0.075 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(30)),0.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(10),math.rad(0),math.rad(-60)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(160),math.rad(-20),math.rad(60)) * rscp,1/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(40),math.rad(5),math.rad(5)) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
	end
	walkspeed = 50
	attack = false
end

function attacktwo()
	attack = true
	walkspeed = 0
	AttackGyro()
	local gBullet = CreatePart(3,Effects,"Neon",0,0,Color3.new(0,0,1),"BullyFuck",Vector3.new())
	MakeForm(gBullet,"Ball")
	gBullet.CFrame = LeftArm.CFrame*CFrame.new(0,-1.5,0)
	CreateSound(2785493,gBullet,2,0.8)
	for i = 0,1.25,0.025 do
		swait()
		Effect({Time = math.random(35,55),EffectType = "Sphere",Size = Vector3.new(0.5,0.5,0.5),Size2 = Vector3.new(1,1,1),Transparency = 0,Transparency2 = 1,CFrame = LeftArm.CFrame*CFrame.new(0,-1.5,0),MoveToPos = LeftArm.CFrame*CFrame.new(0,-1.5,0)*CFrame.new(math.random(-10,10),math.random(-10,10),math.random(-10,10)).p,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 50,SizeBoomerang = 50})
		gBullet.Size = gBullet.Size * 1.085
		gBullet.CFrame = LeftArm.CFrame*CFrame.new(0,-1.5,0)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-30)),0.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(-5 - 3 * math.cos(sine/12)),math.rad(0),math.rad(30)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(sine/49)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,0.7/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5 + 0.1 * math.cos(sine/12),-0) * CFrame.Angles(math.rad(85 - 1.5 * math.cos(sine/12)),math.rad(0 - 6 * math.cos(sine/12)),math.rad(-30 - 6 * math.cos(sine/12))) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
	end
	local bullets = {}
	for i = 1,math.random(27,41) do
		swait()
		local Bullet = CreatePart(3,Effects,"Neon",0,0,Color3.new(0,0,1),"BulletFuck",Vector3.new(0.6,0.6,0.6))
		MakeForm(Bullet,"Ball")
		Bullet.CFrame = gBullet.CFrame
		Effect({Time = math.random(5,20),EffectType = "Sphere",Size = Vector3.new(3,3,3)*math.random(-3,2),Size2 = Vector3.new(6,6,6)*math.random(-3,2),Transparency = 0.4,Transparency2 = 1,CFrame = Bullet.CFrame,MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 25})
		table.insert(bullets,Bullet)
	end
	local oofing = false
	for b = 1,#bullets do
		swait()
		local part,pos = rayCast(LeftArm.CFrame*CFrame.new(0,-1.5,0).p,((Mouse.Hit.p+Vector3.new(math.random(-15,15),math.random(-7,7),math.random(-15,15))) - LeftArm.CFrame*CFrame.new(0,-1.5,0).p),500,Character)
		coroutine.resume(coroutine.create(function()
			FireArc(bullets[b],pos,math.random(17,31),math.random(9,15),false)
			Effect({Time = math.random(25,35),EffectType = "Sphere",Size = Vector3.new(0.6,0.6,0.6),Size2 = Vector3.new(1.6,1.6,1.6),Transparency = 0,Transparency2 = 1,CFrame = bullets[b].CFrame,MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 25})
			swait(math.random(55,65))
			for i = 1,3 do
				Effect({Time = math.random(45,65),EffectType = "Sphere",Size = Vector3.new(0.6,6,0.6)*math.random(-1.05,1.25),Size2 = Vector3.new(1.6,10,1.6)*math.random(-1.05,1.25),Transparency = 0,Transparency2 = 1,CFrame = bullets[b].CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 20,SizeBoomerang = 35})
			end
			for i = 0,10 do
				swait()
				bullets[b].Transparency = bullets[b].Transparency + 0.1
			end
			oofing = not oofing
			if oofing then
				mdmg(bullets[b].Position,10)
			end
			local EEEBRUHEEE = CreateSound(168513088,bullets[b],3.5,1.1,false)
			bullets[b].Transparency = 1
			EEEBRUHEEE.Ended:Connect(function()
				if stopeverything then wait(math.huge) end
				bullets[b]:Destroy()
			end)
		end))
	end
	for i = 0,10 do
		swait()
		gBullet.Transparency = gBullet.Transparency + 0.1
	end
	gBullet:Destroy()
	walkspeed = 50
	attack = false
end

function hedshoot()
	attack = true
	walkspeed = 16
	CreateSound(235097614,RootPart,6,1.5,false)
	for i = 0,0.5,0.05 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-60)),0.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(60)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.25,0.5,-.25) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-60)) * rscp,1/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.25,0.5,-.25) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(10)) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
	end
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = 642890855,SoundPitch = 0.45,SoundVolume = 6,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = math.random(25,45),EffectType = "Sphere",Size = Vector3.new(2,100,2),Size2 = Vector3.new(6,100,6),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame*CFrame.new(math.random(-1,1),math.random(-1,1),-50)*CFrame.Angles(math.rad(math.random(89,91)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 45})
	Effect({Time = math.random(25,45),EffectType = "Sphere",Size = Vector3.new(3,100,3),Size2 = Vector3.new(9,100,9),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame*CFrame.new(math.random(-1,1),math.random(-1,1),-50)*CFrame.Angles(math.rad(math.random(89,91)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 45})
	mdmg(RootPart.Position,14)
	for i = 1,4 do
		RootPart.CFrame = RootPart.CFrame * CFrame.new(0,0,-25)
		mdmg(RootPart.Position,14)
		Lightning(RootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).p,RootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).p,6,25,shade,math.random(30,45),0.5,1.5,0,true,60) Lightning(RootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).p,RootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).p,6,25,Color3.new(0,0,1),math.random(30,45),0.5,1.5,0,true,60)
	end
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	for i = 0,0.5,0.1 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90)),0.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-90)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(90)) * rscp,1/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(40),math.rad(5),math.rad(5)) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
	end
	attack = false
	walkspeed = 50
end

function painlessrain()
	attack = true
	walkspeed = 16
	coroutine.wrap(function()
		for i = 0,2 do
			swait(12)
			CreateSound(199145095,GUN.Joint,10,1)
		end
	end)()
	for i = 0,2,0.1 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-10)),0.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(25),math.rad(0),math.rad(-20)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(35),math.rad(-35),math.rad(20)) * rscp,1/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-20),math.rad(-5),math.rad(-10)) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(doe * 22),math.rad(0),math.rad(0)),1/2)
	end
	for i = 0,1.5,0.1 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),0.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(175),math.rad(-10),math.rad(10)) * rscp,1/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-10),math.rad(-10),math.rad(-5)) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
	end
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = 642890855,SoundPitch = 0.45,SoundVolume = 6,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	local skypos = Holetwo.CFrame * CFrame.new(-400,0,0)
	local DISTANCE = (Holetwo.Position - skypos.p).Magnitude
	local killbeam = CreatePart(3,Effects,"Neon",0,0,shade,"Kill Beam",Vector3.new(1,DISTANCE,1))
	killbeam.CFrame = CFrame.new(Holetwo.Position,skypos.p) * CFrame.new(0,0,-DISTANCE/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
	MakeForm(killbeam,"Cyl")
	coroutine.resume(coroutine.create(function()
		for i = 1,25 do
			swait()
			killbeam.Transparency = i/25
		end
		killbeam:Destroy()
	end))
	Lightning(Holetwo.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
	Lightning(Holetwo.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
	Lightning(Holetwo.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
	Lightning(Holetwo.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
	Lightning(Holetwo.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
	for i = 0,2 do
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
	end
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = skypos,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = 192410089,SoundPitch = .55,SoundVolume = 8,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = skypos,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	for i = 0,2 do
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = skypos*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = skypos*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
	end
	for i = 0,.5,0.1 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),0.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(225),math.rad(-20),math.rad(20)) * rscp,1/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-5),math.rad(-5),math.rad(0)) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
	end
	for i = 0,.5,0.1 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),0.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(175),math.rad(-10),math.rad(10)) * rscp,1/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-5),math.rad(-5),math.rad(0)) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
	end
	attack = false
	walkspeed = 50
	swait(36)
	local onethirdattack = 0
	for i = 1,5 do
		onethirdattack = onethirdattack + 1
		if onethirdattack >= 4 then
			onethirdattack = 1
		end
		local Sky = RootPart.CFrame*CFrame.new(0,500,0)
		local MoPos = Mouse.Hit*CFrame.new(math.random(-18,18),0,math.random(-18,18)).p
		local DISTANCE = (Sky.p - MoPos).Magnitude
		Lightning(Sky.p,MoPos,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
		Lightning(Sky.p,MoPos,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
		Lightning(Sky.p,MoPos,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
		Lightning(Sky.p,MoPos,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
		Lightning(Sky.p,MoPos,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
		local killbeam = CreatePart(3,Effects,"Neon",0,0,shade,"Kill Beam",Vector3.new(1,DISTANCE,1))
		killbeam.CFrame = CFrame.new(Sky.p,MoPos) * CFrame.new(0,0,-DISTANCE/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
		MakeForm(killbeam,"Cyl")
		coroutine.resume(coroutine.create(function()
			for i = 1,25 do
				swait()
				killbeam.Transparency = i/25
			end
			killbeam:Destroy()
		end))
		Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(MoPos),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = 192410089,SoundPitch = .55,SoundVolume = 8,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
		Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(MoPos),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
		for i = 0,2 do
			Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(MoPos)*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
			Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(MoPos)*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		end
		if onethirdattack == 3 then
			mdmg(MoPos,12)
		end
		swait(15)
	end
end
function SingularityBeam()
	attack = true
	walkspeed = 0
	AttackGyro()
	for i = 0,0.5,0.05 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-60)),0.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(60)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.25,0.5,-.25) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-60)) * rscp,1/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.25,0.5,-.25) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(10)) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
	end
	local HoleDist = (Hole.Position - Holetwo.Position).Magnitude
	local chargebeam = CreatePart(3,Effects,"Neon",0,0,shade,"Charge Beam",Vector3.new(.25,HoleDist,.25),false)
	MakeForm(chargebeam,"Cyl")
	chargebeam.CFrame = CFrame.new(Hole.Position,Holetwo.Position) * CFrame.new(0,0,-HoleDist/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
	local chargeweld = weldBetween(GUN.Joint,chargebeam)
	local chargeball = CreatePart(3,Effects,"Neon",0,0,shade,"Charge Ball",Vector3.new(.5,.5,.5),false)
	chargeball.Shape = "Ball"
	chargeball.CFrame = Holetwo.CFrame
	weldBetween(Holetwo,chargeball)
	CreateSound(342793847,Hole,10,1,false)
	local bigball = game:GetService("TweenService"):Create(chargeball,TweenInfo.new(3.86,Enum.EasingStyle.Linear),{Size = Vector3.new(2.5,2.5,2.5)})
	bigball:Play()
	bigball.Completed:Wait()
	chargebeam:Destroy()
	local KillDist = (Holetwo.Position - Mouse.Hit.p).Magnitude
	coroutine.resume(coroutine.create(function()
		repeat if stopeverything then wait(math.huge) end KillDist = (Holetwo.Position - Mouse.Hit.p).Magnitude Swait() until attack == false
	end))
	local killbeam = CreatePart(3,Effects,"Neon",0,0,shade,"Kill Beam",Vector3.new(2.5,KillDist,2.5))
	MakeForm(killbeam,"Cyl")
	killbeam.Touched:Connect(function(victim)
		if stopeverything then wait(math.huge) end
		mdmg(victim.Position,5)
	end)
	coroutine.resume(coroutine.create(function()
		while not stopeverything and attack do
			mdmg(Mouse.Hit.p,5)
			Swait(6)
		end
	end))
	coroutine.resume(coroutine.create(function()
		local isdoingathing = false
		while not stopeverything and attack do
			isdoingathing = not isdoingathing
			if lplr.Name == USERNAME then
				RootPart.CFrame = RootPart.CFrame * CFrame.new(0,0,.1)
			end
			killbeam.Size = Vector3.new(2.5,KillDist,2.5)
			killbeam.CFrame = CFrame.new(Holetwo.Position,Mouse.Hit.p) * CFrame.new(0,0,-KillDist/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
			if isdoingathing then
				Lightning(Holetwo.Position,Mouse.Hit.p,15,3,Color3.new(0,0,1),10,0,1,0,true,55)
				Effect({Time = 10,EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
				Effect({Time = 10,EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
				Effect({Time = 10,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
				Effect({Time = 10,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
				Effect({Time = 10,EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
				Effect({Time = 10,EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
			end
			Swait()
		end
	end))
	CreateSound(138677306,Holetwo,10,1,false)
	CreateSound(415700134,Holetwo,10,1,false)
	Swait(150)
	CreateSound(3264923,Holetwo,10,1,false)
	Swait(30)
	chargeball:Destroy()
	killbeam:Destroy()
	walkspeed = 50
	attack = false
end

local FLYING = false
iyflyspeed = 1
function sFLY()
	if not ISFLYING then
		FLYING = false
	else
		local CONTROL = {F = 0,B = 0,L = 0,R = 0,Q = 0,E = 0}
		local lCONTROL = {F = 0,B = 0,L = 0,R = 0,Q = 0,E = 0}
		local SPEED = 0			
		local function FLY()
			FLYING = true
			BG = Instance.new('BodyGyro',RootPart)
			BV = Instance.new('BodyVelocity',RootPart)
			BG.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
			BG.P = 1e4
			BG.CFrame = RootPart.CFrame
			BV.Velocity = Vector3.new(0,0,0)
			BV.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
			coroutine.resume(coroutine.create(function()
				repeat if stopeverything then wait(math.huge) end
					game:GetService("RunService").RenderStepped:Wait()
					if not alreadyfixing then
						if CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0 then
							SPEED = 50
						elseif not (CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0) and SPEED ~= 0 then
							SPEED = 0
						end
						if (CONTROL.L + CONTROL.R) ~= 0 or (CONTROL.F + CONTROL.B) ~= 0 or (CONTROL.Q + CONTROL.E) ~= 0 then
							BV.Velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (CONTROL.F + CONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(CONTROL.L + CONTROL.R,(CONTROL.F + CONTROL.B + CONTROL.Q + CONTROL.E) * 0.2,0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
							lCONTROL = {F = CONTROL.F,B = CONTROL.B,L = CONTROL.L,R = CONTROL.R}
						elseif (CONTROL.L + CONTROL.R) == 0 and (CONTROL.F + CONTROL.B) == 0 and (CONTROL.Q + CONTROL.E) == 0 and SPEED ~= 0 then
							BV.Velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (lCONTROL.F + lCONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(lCONTROL.L + lCONTROL.R,(lCONTROL.F + lCONTROL.B + CONTROL.Q + CONTROL.E) * 0.2,0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
						else
							BV.Velocity = Vector3.new(0,0,0)
						end
						BG.CFrame = workspace.CurrentCamera.CoordinateFrame
					end
				until not FLYING
				CONTROL = {F = 0,B = 0,L = 0,R = 0,Q = 0,E = 0}
				lCONTROL = {F = 0,B = 0,L = 0,R = 0,Q = 0,E = 0}
				SPEED = 0
				if not alreadyfixing then
					for i,v in pairs(RootPart:GetChildren()) do
						if v:IsA("BodyMover") then
							v:Destroy()
						end
					end
					RootPart.CFrame = CFrame.new(RootPart.Position)
				end
			end))
		end
		local IYMouse = Player:GetMouse()
		IYMouse.KeyDown:connect(function(KEY)
			if stopeverything then wait(math.huge) end
			if KEY:lower() == 'w' then
				CONTROL.F = iyflyspeed
			elseif KEY:lower() == 's' then
				CONTROL.B = - iyflyspeed
			elseif KEY:lower() == 'a' then
				CONTROL.L = - iyflyspeed
			elseif KEY:lower() == 'd' then 
				CONTROL.R = iyflyspeed
			elseif KEY:lower() == 'e' then
				CONTROL.Q = iyflyspeed*2
			elseif KEY:lower() == 'q' then
				CONTROL.E = -iyflyspeed*2
			end
		end)
		IYMouse.KeyUp:connect(function(KEY)
			if stopeverything then wait(math.huge) end
			if KEY:lower() == 'w' then
				CONTROL.F = 0
			elseif KEY:lower() == 's' then
				CONTROL.B = 0
			elseif KEY:lower() == 'a' then
				CONTROL.L = 0
			elseif KEY:lower() == 'd' then
				CONTROL.R = 0
			elseif KEY:lower() == 'e' then
				CONTROL.Q = 0
			elseif KEY:lower() == 'q' then
				CONTROL.E = 0
			end
		end)
		FLY()
	end
end
function sphere(bonuspeed,type,pos,scale,value,color)
	local type = type
	local rng = Instance.new("Part",Effects)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1,1,1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh",rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			rng.BrickColor = BrickColor.random()
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed,scaler2*bonuspeed,scaler2*bonuspeed)
		end
		rng:Destroy()
	end))
end

function sphere2(bonuspeed,type,pos,scale,value,value2,value3,color)
	local type = type
	local rng = Instance.new("Part",Effects)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1,1,1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh",rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = scale
	local scaler2 = 1
	local scaler2b = 1
	local scaler2c = 1
	if type == "Add" then
		scaler2 = 1*value
		scaler2b = 1*value2
		scaler2c = 1*value3
	elseif type == "Divide" then
		scaler2 = 1/value
		scaler2b = 1/value2
		scaler2c = 1/value3
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
				scaler2b = scaler2b - 0.01*value/bonuspeed
				scaler2c = scaler2c - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
				scaler2b = scaler2b - 0.01/value*bonuspeed
				scaler2c = scaler2c - 0.01/value*bonuspeed
			end
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed,scaler2b*bonuspeed,scaler2c*bonuspeed)
		end
		rng:Destroy()
	end))
end

function PixelBlockX(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
	local type = type
	local rng = Instance.new("Part",Effects)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1,1,1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local rngm = Instance.new("SpecialMesh",rng)
	rngm.MeshType = "Brick"
	rngm.Scale = Vector3.new(x1,y1,z1)
	local scaler2 = 1
	local speeder = FastSpeed/10
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			rng.BrickColor = BrickColor.random()
			speeder = speeder - 0.01*FastSpeed*bonuspeed/10
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed,scaler2*bonuspeed,scaler2*bonuspeed)
		end
		rng:Destroy()
	end))
end

function sphereMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
	local type = type
	local rng = Instance.new("Part",Effects)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1,1,1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local rngm = Instance.new("SpecialMesh",rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = Vector3.new(x1,y1,z1)
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			rng.BrickColor = BrickColor.random()
			speeder = speeder - 0.01*FastSpeed*bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed,scaler2*bonuspeed,0)
		end
		rng:Destroy()
	end))
end

function slash(bonuspeed,rotspeed,rotatingop,typeofshape,type,typeoftrans,pos,scale,value,color)
	local type = type
	local rotenable = rotatingop
	local rng = Instance.new("Part",Effects)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1,1,1)
	rng.Transparency = 0
	if typeoftrans == "In" then
		rng.Transparency = 1
	end
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh",rng)
	rngm.MeshType = "FileMesh"
	if typeofshape == "Normal" then
		rngm.MeshId = "rbxassetid://662586858"
	elseif typeofshape == "Round" then
		rngm.MeshId = "rbxassetid://662585058"
	end
	rngm.Scale = scale
	local scaler2 = 1/10
	if type == "Add" then
		scaler2 = 1*value/10
	elseif type == "Divide" then
		scaler2 = 1/value/10
	end
	local randomrot = math.random(1,2)
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed/10
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed/10
			end
			if rotenable == true then
				if randomrot == 1 then
					rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(rotspeed*bonuspeed/2),0)
				elseif randomrot == 2 then
					rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(-rotspeed*bonuspeed/2),0)
				end
			end
			if typeoftrans == "Out" then
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
			elseif typeoftrans == "In" then
				rng.Transparency = rng.Transparency - 0.01*bonuspeed
			end
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed/10,0,scaler2*bonuspeed/10)
		end
		rng:Destroy()
	end))
end

Mouse.KeyDown:Connect(function(k)
	if stopeverything then wait(math.huge) end
	k = k:lower()
	if k == "m" then
		if songid.Value ~= "rbxassetid://3247404955" and songid.Value ~= "rbxassetid://6190635423" and songid.Value ~= "rbxassetid://2371543268" and songid.Value ~= "rbxassetid://5315171837" and songid ~= "rbxassetid://5089636816" and songid.Value ~= "rbxassetid://6768783121" and songid.Value ~= "rbxassetid://4835535512" and songid.Value ~= "rbxassetid://5089636816" and songid.Value ~= "rbxassetid://1280010741" and songid.Value ~= "rbxassetid://5355210927" and songid.Value ~="rbxassetid://2581112923" and songid.Value ~= "rbxassetid://262950484" and songid.Value ~= "rbxassetid://481104377" and songid.Value ~= "rbxassetid://2920078671" and songid.Value ~= "rbxassetid://2297862957" and songid.Value ~= "rbxassetid://1338971957" and songid.Value ~= "rbxassetid://5460732000" and songid.Value ~= "rbxassetid://4557673096" and songid.Value ~= "rbxassetid://348832364" and songid.Value ~= "rbxassetid://1143392568" then
			TauntRemote:FireServer("None",3247404955)
		elseif songid.Value == "rbxassetid://3247404955" then
			TauntRemote:FireServer("None",5315171837)
			elseif songid.Value == "rbxassetid://5315171837" then
			TauntRemote:FireServer("sAnIty",262950484)
			songid.Value = "rbxassetid://262950484"
			repeat if stopeverything then wait(math.huge) end 
				game:GetService("RunService").RenderStepped:Wait()
			until SongSync.Value >= 24 or songid.Value ~= "rbxassetid://262950484"
			if songid.Value == "rbxassetid://262950484" then
				--chatfunc(" ")
				sphere(1,"Add",Torso.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),Vector3.new(1,100000,1),0.6,BrickColor.new("Really black"))
				sphere2(math.random(1,4),"Add",Torso.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),Vector3.new(5,1,5),-0.005,math.random(25,100)/25,-0.005,BrickColor.new("Institutional white"))
				sphere(1,"Add",Torso.CFrame,Vector3.new(1,1,1),0.8,BrickColor.new("Really black"))
				sphere2(2,"Add",Torso.CFrame,Vector3.new(5,5,5),0.5,0.5,0.5,BrickColor.new("Institutional white"))
				sphere2(2,"Add",Torso.CFrame,Vector3.new(5,5,5),0.75,0.75,0.75,BrickColor.new("Institutional white"))
				sphere2(3,"Add",Torso.CFrame,Vector3.new(5,5,5),1,1,1,BrickColor.new("Institutional white"))
				sphere2(3,"Add",Torso.CFrame,Vector3.new(5,5,5),1.25,1.25,1.25,BrickColor.new("Institutional white"))
				sphere2(1,"Add",Torso.CFrame,Vector3.new(5,10000,5),0.5,0.5,0.5,BrickColor.new("Institutional white"))
				sphere2(2,"Add",Torso.CFrame,Vector3.new(5,10000,5),0.6,0.6,0.6,BrickColor.new("Institutional white"))
				for i = 0,49 do
					PixelBlockX(1,math.random(1,20),"Add",Torso.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),8,8,8,0.16,BrickColor.new("Really black"),0)
					sphereMK(2.5,-1,"Add",Torso.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,25,-0.025,BrickColor.new("Really black"),0)
					slash(math.random(10,20)/10,5,true,"Round","Add","Out",Torso.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-30,30)),math.rad(math.random(-30,30)),math.rad(math.random(-40,40))),Vector3.new(0.05,0.01,0.05),math.random(50,60)/250,BrickColor.new("Really black"))
				end
				CreateSound(239000203,Torso,10,false)
				CreateSound(1042716828,Torso,10,false)
				TauntRemote:FireServer("iNSaNiTY",262950484)
			end
		elseif songid.Value == "rbxassetid://262950484" then
			TauntRemote:FireServer("Err0r",481104377)
		elseif songid.Value == "rbxassetid://262950484" then
			TauntRemote:FireServer("iNSaNiTY",262950484)
		elseif songid.Value == "rbxassetid://481104377" then
			TauntRemote:FireServer("FAST BOIII",2920078671)
		elseif songid.Value == "rbxassetid://2920078671" then
			TauntRemote:FireServer("Glitch",2297862957)
		elseif songid.Value == "rbxassetid://2297862957" then
			TauntRemote:FireServer("None",3247404955)
			--[[
		elseif songid.Value == "rbxassetid://2297862957" then
			TauntRemote:FireServer("Chill",1338971957)
		elseif songid.Value == "rbxassetid://1338971957" then
			TauntRemote:FireServer("Alastor",5460732000)
		elseif songid.Value == "rbxassetid://5460732000" then
			TauntRemote:FireServer("kArmA",4557673096)
		elseif songid.Value == "rbxassetid://4557673096" then
			TauntRemote:FireServer("V1",2581112923)
		elseif songid.Value == "rbxassetid://2581112923" then
			TauntRemote:FireServer("caverns",5355210927)
		elseif songid.Value == "rbxassetid://5355210927" then
			TauntRemote:FireServer("funk",1280010741)
		elseif songid.Value == "rbxassetid://1280010741" then
			TauntRemote:FireServer("sussyhoney",5089636816)
		elseif songid.Value == "rbxassetid://5089636816" then
			TauntRemote:FireServer("hi",4835535512)
		elseif songid.Value == "rbxassetid://4835535512" then
			TauntRemote:FireServer("Lord",2371543268)
		elseif songid.Value == "rbxassetid://2371543268" then
			TauntRemote:FireServer("MaddoxLC",6768783121)
		elseif songid.Value == "rbxassetid://6768783121" then
			TauntRemote:FireServer("friday",6190635423)
		elseif songid.Value == "rbxassetid://6190635423" then
			TauntRemote:FireServer("SolidLC",348832364)
		elseif songid.Value == "rbxassetid://348832364" then
			TauntRemote:FireServer("HoneyLC",1143392568)
		elseif songid.Value == "rbxassetid://1143392568" then
			TauntRemote:FireServer("None",3247404955)
			--]]
		elseif songid.Value == "rbxassetid://3247404955" then
			TauntRemote:FireServer("None",5315171837)
		end
	elseif k == "y" then
		if taunt.Value ~= "Fave" then
			TauntRemote:FireServer("Fave",290182215)
		else
			TauntRemote:FireServer("None",3247404955)
		end
	elseif k == "t" then
		if taunt.Value ~= "Krump" then
			TauntRemote:FireServer("Krump",1511734302)
		else
			TauntRemote:FireServer("None",3247404955)
		end
	elseif k == "u" then
		if taunt.Value ~= "OOOOO" then
			TauntRemote:FireServer("OOOOO",2681542649)
		else
			TauntRemote:FireServer("None",3247404955)
		end
	elseif k == "f" then
		ISFLYING = not ISFLYING
		if lplr.Name == USERNAME then
			sFLY()
		end
	elseif k == "z" and attack == false and (taunt.Value == "None" or taunt.Value == "iNSaNiTY" or taunt.Value == "Err0r" or taunt.Value == "FAST BOIII" or taunt.Value == "Glitch") then	
		hedshoot()
	elseif k == "x" and attack == false and (taunt.Value == "None" or taunt.Value == "iNSaNiTY" or taunt.Value == "Err0r" or taunt.Value == "FAST BOIII" or taunt.Value == "Glitch") then
		SingularityBeam()
	elseif k == "c" and attack == false and (taunt.Value == "None" or taunt.Value == "iNSaNiTY" or taunt.Value == "Err0r" or taunt.Value == "FAST BOIII" or taunt.Value == "Glitch") then
		painlessrain()
	elseif k == "v" and attack == false and (taunt.Value == "None" or taunt.Value == "iNSaNiTY" or taunt.Value == "Err0r" or taunt.Value == "FAST BOIII" or taunt.Value == "Glitch") then
		attacktwo()
	elseif k == "b" and attack == false and (taunt.Value == "None" or taunt.Value == "iNSaNiTY" or taunt.Value == "Err0r" or taunt.Value == "FAST BOIII" or taunt.Value == "Glitch") then
		Ka_Boom()
	end
end)

Mouse.Button1Down:Connect(function()
if stopeverything then wait(math.huge) end
	if attack == false and (taunt.Value == "None" or taunt.Value == "iNSaNiTY" or taunt.Value == "Err0r" or taunt.Value == "FAST BOIII" or taunt.Value == "Glitch") then
		attackone()
	end
end)

coroutine.wrap(function()
	while not stopeverything do
		swait()
		if doe < 360 then
			doe = doe + 2
		else
			doe = 0
		end
	end
end)()
antivoid = Instance.new("Part")
antivoid.Name = randomstring()
antivoid.Size = Vector3.new(400,10,400)
antivoid.Anchored = true
antivoid.Transparency = 1
antivoid.Position = Vector3.new(RootPart.Position.X,workspace.FallenPartsDestroyHeight+5,RootPart.Position.Z)
antivoid.Parent = nil
coroutine.resume(coroutine.create(function()
	while not stopeverything do
		swait()
		if not alreadyfixing then
			if antivoid:IsDescendantOf(workspace) then
				antivoid.Position = Vector3.new(RootPart.Position.X,workspace.FallenPartsDestroyHeight+5,RootPart.Position.Z)
			else
				pcall(function()
					antivoid:Destroy()
				end)
				antivoid = Instance.new("Part")
				antivoid.Name = randomstring()
				antivoid.Size = Vector3.new(400,10,400)
				antivoid.Anchored = true
				antivoid.Transparency = 1
				antivoid.Position = Vector3.new(RootPart.Position.X,workspace.FallenPartsDestroyHeight+5,RootPart.Position.Z)
				antivoid.Parent = nil
			end
		end
	end
end))

function fly()

	function weld(p0,p1,c0,c1,par)
		local w = Instance.new("Weld",p0 or par)
		w.Part0 = p0
		w.Part1 = p1
		w.C0 = c0 or CFrame.new()
		w.C1 = c1 or CFrame.new()
		return w
	end
	local motors = {}
	function motor(p0,p1,c0,c1,des,vel,par)
		local w = Instance.new("Motor6D",p0 or par)
		w.Part0 = p0
		w.Part1 = p1
		w.C0 = c0 or CFrame.new()
		w.C1 = c1 or CFrame.new()
		w.MaxVelocity = tonumber(vel) or .05
		w.DesiredAngle = tonumber(des) or 0
		return w
	end
	function lerp(a,b,c)
		return a+(b-a)*c
	end
	function clerp(c1,c2,alBRUH)
		local al = .05
		local com1 = {c1.X,c1.Y,c1.Z,c1:toEulerAnglesXYZ()}
		local com2 = {c2.X,c2.Y,c2.Z,c2:toEulerAnglesXYZ()}
		for i,v in pairs(com1) do
			com1[i] = lerp(v,com2[i],al)
		end
		return CFrame.new(com1[1],com1[2],com1[3]) * CFrame.Angles(select(4,unpack(com1)))
	end
	function ccomplerp(c1,c2,alBRUH)
		local al = .05
		local com1 = {c1:components()}
		local com2 = {c2:components()}
		for i,v in pairs(com1) do
			com1[i] = lerp(v,com2[i],al)
		end
		return CFrame.new(unpack(com1))
	end
	function tickwave(time,length,offset)
		return .2*math.sin(sine/20)
	end
	function invcol(c)
		c = c.Color
		return BrickColor.new(shade)
	end
	local oc = oc or function(...) return ... end
	local mod = Instance.new("Folder",Character)
	mod.Name = "Wings"
	mod.ChildAdded:Connect(function(v)
		if stopeverything then wait(math.huge) end
		if v.Name == "Part" and not v:FindFirstChild("WingTrail") then
			swait()
			local meesh = v:FindFirstChildOfClass("SpecialMesh")
			if meesh then
				meesh.Scale = v.Size
			end
			local top = Instance.new("Attachment")
			top.Name = "Top"
			top.Position = Vector3.new(0,v.Size.Y/2,0)
			top.Parent = v
			local bottom = Instance.new("Attachment")
			bottom.Name = "Bottom"
			bottom.Position = Vector3.new(0,-v.Size.Y/2,0)
			bottom.Parent = v
			local vtrail = Instance.new("Trail")
			vtrail.Name = "WingTrail"
			vtrail.Attachment0 = top
			vtrail.Attachment1 = bottom
			vtrail.Lifetime = 0.3
			vtrail.MinLength = 0
			vtrail.LightEmission = 0
			vtrail.LightInfluence = 0
			vtrail.Color = ColorSequence.new(shade)
			vtrail.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,1)}
			vtrail.Parent = v
		end
	end)
	local char = Character
	local tor = Torso
	local hum = Humanoid
	local special = {
	}
	local topcolor = invcol(Character.Torso.BrickColor)
	local feacolor = topcolor
	local ptrans = 0
	local pref = 0
	local fire = false
	local fmcol = Color3.new()
	local fscol = Color3.new()
	local part = Instance.new("Part")
	part.FormFactor = "Custom"
	part.Size = Vector3.new(.2,.2,.2)
	part.TopSurface,part.BottomSurface = 0,0
	part.CanCollide = false
	part.BrickColor = topcolor
	part.Transparency = 1
	part.Reflectance = pref
	local ef = Instance.new("Fire",fire and part or nil)
	ef.Heat = 0
	ef.Size = .15
	ef.Color = fmcol or Color3.new()
	ef.SecondaryColor = fscol or Color3.new()
	part:BreakJoints()
	function newpart()
		local clone = part:Clone()
		clone.Parent = mod
		clone:BreakJoints()
		return clone
	end
	local feath = newpart()
feath.BrickColor = feacolor
feath.Transparency = 0
Instance.new("SpecialMesh",feath).MeshType = "Sphere"
function newfeather()
	local clone = feath:Clone()
	clone.Parent = mod
	clone:BreakJoints()
	return clone
end
local r1 = newpart()
r1.Size = Vector3.new(.3,1.5,.3)*1.2
local rm1 = motor(tor,r1,CFrame.new(.35,.6,.4) * CFrame.Angles(0,0,math.rad(-60)) * CFrame.Angles(math.rad(30),math.rad(-25),0),CFrame.new(0,-.8,0),.1)
local r2 = newpart()
r2.Size = Vector3.new(.4,1.5,.4)*1.2
local rm2 = motor(r1,r2,CFrame.new(0,.75,0) * CFrame.Angles(0,0,math.rad(50)) * CFrame.Angles(math.rad(-30),math.rad(15),0),CFrame.new(0,-.9,0),.1)
local r3 = newpart()
r3.Size = Vector3.new(.3,2,.3)*1.2
local rm3 = motor(r2,r3,CFrame.new(.1,.9,0) * CFrame.Angles(0,0,math.rad(-140)) * CFrame.Angles(math.rad(-3),0,0),CFrame.new(0,-1.1,0),.1)
local r4 = newpart()
r4.Size = Vector3.new(.25,1.2,.25)*1.2
local rm4 = motor(r3,r4,CFrame.new(0,1.1,0) * CFrame.Angles(0,0,math.rad(-10)) * CFrame.Angles(math.rad(-3),0,0),CFrame.new(0,-.6,0),.1)
local feather = newfeather()
feather.Mesh.Scale = Vector3.new(1,1,1)
feather.Size = Vector3.new(.4,3,.3)
weld(r4,feather,CFrame.new(-.1,-.3,0),CFrame.new(0,-1.5,0))
feather = newfeather()
feather.Mesh.Scale = Vector3.new(1,1,1)
feather.Size = Vector3.new(.4,2.3,.3)
weld(r4,feather,CFrame.new(.1,-.1,0) * CFrame.Angles(0,math.random()*.1,0),CFrame.new(0,-1.1,0))
feather = newfeather()
feather.Mesh.Scale = Vector3.new(1,1,1)
feather.Size = Vector3.new(.35,2.2,.25)
weld(r4,feather,CFrame.new(.1,-.3,0) * CFrame.Angles(0,math.random()*.1,math.rad(-10)),CFrame.new(0,-1.1,0))
local rf3 = {}
for i = 0,7 do
	feather = newfeather()
	feather.Mesh.Scale = Vector3.new(1,1,1)
	feather.Size = Vector3.new(.45,2.2,.35)
	table.insert(rf3,motor(r3,feather,CFrame.new(.05,1-i*.285,0) * CFrame.Angles(0,math.random()*.1,math.rad(-25-i*2)),CFrame.new(0,-feather.Size.Y/2,0)))
end
local rf2 = {}
for i = 0,6 do
	feather = newfeather()
	feather.Mesh.Scale = Vector3.new(1,1,1)
	feather.Size = Vector3.new(.45,2.2-i*.08,.3)
	table.insert(rf2,motor(r2,feather,CFrame.new(.05,.75-i*.26,0) * CFrame.Angles(0,math.random()*.1,math.rad(-75-i*4)),CFrame.new(0,-feather.Size.Y/2,0)))
end
local rf1 = {}
for i = 0,6 do
	feather = newfeather()
	feather.Mesh.Scale = Vector3.new(1,1,1)
	feather.Size = Vector3.new(.37,1.65-i*.06,.25)
	table.insert(rf1,motor(r1,feather,CFrame.new(.05,.63-i*.21,0) * CFrame.Angles(0,math.random()*.05,math.rad(-75)),CFrame.new(0,-feather.Size.Y/2,0)))
end
local l1 = newpart()
l1.Size = Vector3.new(.3,1.5,.3)*1.2
local lm1 = motor(tor,l1,CFrame.new(-.35,.6,.4) * CFrame.Angles(0,0,math.rad(60)) * CFrame.Angles(math.rad(30),math.rad(25),0) * CFrame.Angles(0,-math.pi,0),CFrame.new(0,-.8,0) ,.1)
local l2 = newpart()
l2.Size = Vector3.new(.4,1.5,.4)*1.2
local lm2 = motor(l1,l2,CFrame.new(0,.75,0) * CFrame.Angles(0,0,math.rad(50)) * CFrame.Angles(math.rad(30),math.rad(-15),0),CFrame.new(0,-.9,0),.1)
local l3 = newpart()
l3.Size = Vector3.new(.3,2,.3)*1.2
local lm3 = motor(l2,l3,CFrame.new(.1,.9,0) * CFrame.Angles(0,0,math.rad(-140)) * CFrame.Angles(math.rad(3),0,0),CFrame.new(0,-1.1,0),.1)
local l4 = newpart()
l4.Size = Vector3.new(.25,1.2,.25)*1.2
local lm4 = motor(l3,l4,CFrame.new(0,1.1,0) * CFrame.Angles(0,0,math.rad(-10)) * CFrame.Angles(math.rad(3),0,0),CFrame.new(0,-.6,0),.1)
local feather = newfeather()
feather.Mesh.Scale = Vector3.new(1,1,1)
feather.Size = Vector3.new(.4,3,.3)
weld(l4,feather,CFrame.new(-.1,-.3,0),CFrame.new(0,-1.5,0))
feather = newfeather()
feather.Mesh.Scale = Vector3.new(1,1,1)
feather.Size = Vector3.new(.4,2.3,.3)
weld(l4,feather,CFrame.new(.1,-.1,0) * CFrame.Angles(0,math.random()*.1,0),CFrame.new(0,-1.1,0))
feather = newfeather()
feather.Mesh.Scale = Vector3.new(1,1,1)
feather.Size = Vector3.new(.35,2.2,.25)
weld(l4,feather,CFrame.new(.1,-.3,0) * CFrame.Angles(0,math.random()*.1,math.rad(-10)),CFrame.new(0,-1.1,0))
local lf3 = {}
for i = 0,7 do
	feather = newfeather()
	feather.Mesh.Scale = Vector3.new(1,1,1)
	feather.Size = Vector3.new(.45,2.2,.35)
	table.insert(lf3,motor(l3,feather,CFrame.new(.05,1-i*.285,0) * CFrame.Angles(0,math.random()*.1,math.rad(-25-i*2)),CFrame.new(0,-feather.Size.Y/2,0)))
end
local lf2 = {}
for i = 0,6 do
	feather = newfeather()
	feather.Mesh.Scale = Vector3.new(1,1,1)
	feather.Size = Vector3.new(.45,2.2-i*.08,.3)
	table.insert(lf2,motor(l2,feather,CFrame.new(.05,.75-i*.26,0) * CFrame.Angles(0,math.random()*.1,math.rad(-75-i*4)),CFrame.new(0,-feather.Size.Y/2,0)))
end
local lf1 = {}
for i = 0,6 do
	feather = newfeather()
	feather.Mesh.Scale = Vector3.new(1,1,1)
	feather.Size = Vector3.new(.37,1.65-i*.06,.25)
	table.insert(lf1,motor(l1,feather,CFrame.new(.05,.63-i*.21,0) * CFrame.Angles(0,math.random()*.05,math.rad(-75)),CFrame.new(0,-feather.Size.Y/2,0)))
end
local rwing = {rm1,rm2,rm3,rm4}
local lwing = {lm1,lm2,lm3,lm4}
local oc0 = {}
for i,v in pairs(rwing) do
	oc0[v] = v.C0
end
for i,v in pairs(lwing) do
	oc0[v] = v.C0
end
	function gotResized()
		if lastsize then
			if tor.Size == lastsize then return end
			local scaleVec = tor.Size/lastsize
			for i,v in pairs(oc0) do
				oc0[i] = v-v.p+scaleVec*v.p
			end
			lastsize = tor.Size
		end
		lastsize = tor.Size
	end
	tor:GetPropertyChangedSignal("Size"):Connect(function()
		if stopeverything then wait(math.huge) end
		gotResized()
	end)
	gotResized()
	local idle = {-.3,.3,1.1,-.2; .3,.05,.1,.05; .2,-.6,0,0}
	local outlow = {-.3,.3,1.1,-.2; .3,.05,.1,.05; .2,-.6,0,0}
	local outhigh = {-.3,.3,1.1,-.2; .3,.05,.1,.05; .2,-.6,0,0}
	local veryhigh = {-.3,.3,1.1,-.2; .3,.05,.1,.05; .2,-.6,0,0}
	local flap1 = {-.3,.3,1.1,-.2; .3,.05,.1,.05; .2,-.6,0,0}
	local divebomb = {-.3,.3,1.1,-.2; .3,.05,.1,.05; .2,-.6,0,0}
	function setwings(tab,time)
		time = time or 10
		for i = 1,4 do
			rwing[i].DesiredAngle = tab[i]
			lwing[i].DesiredAngle = tab[i]
			rwing[i].MaxVelocity = math.abs(tab[i]-rwing[i].CurrentAngle)/time
			lwing[i].MaxVelocity = math.abs(tab[i]-lwing[i].CurrentAngle)/time
			local rcf = oc0[rwing[i]] * (tab[12+i] or CFrame.new())
			local lcf = oc0[lwing[i]] * (tab[12+i] or CFrame.new())
		end
		for i,v in pairs(rf1) do
			v.DesiredAngle = tab[9]
			v.MaxVelocity = math.abs(v.DesiredAngle-v.CurrentAngle)/time
		end
		for i,v in pairs(lf1) do
			v.DesiredAngle = tab[9]
			v.MaxVelocity = math.abs(v.DesiredAngle-v.CurrentAngle)/time
		end
		for i,v in pairs(rf2) do
			v.DesiredAngle = tab[10]
			v.MaxVelocity = math.abs(v.DesiredAngle-v.CurrentAngle)/time
		end
		for i,v in pairs(lf2) do
			v.DesiredAngle = tab[10]
			v.MaxVelocity = math.abs(v.DesiredAngle-v.CurrentAngle)/time
		end
		for i,v in pairs(rf3) do
			v.DesiredAngle = tab[11]
			v.MaxVelocity = math.abs(v.DesiredAngle-v.CurrentAngle)/time
		end
		for i,v in pairs(lf3) do
			v.DesiredAngle = tab[11]
			v.MaxVelocity = math.abs(v.DesiredAngle-v.CurrentAngle)/time
		end
	end
	setwings(outhigh,1)
	flying = false
	moving = false
	for i,v in pairs(tor:GetChildren()) do
		if v.ClassName:lower():match("body") then
			v:Destroy()
		end
	end
	local ctor = tor:Clone()
	ctor:ClearAllChildren()
	ctor.Name = "cTorso"
	ctor.Transparency = 1
	ctor.CanCollide = false
	ctor.FormFactor = "Custom"
	ctor.Size = Vector3.new(.2,.2,.2)
	ctor.Parent = mod
	weld(tor,ctor)
	local bg = Instance.new("BodyGyro",ctor)
	bg.maxTorque = Vector3.new()
	bg.P = 15000
	bg.D = 1000
	local bv = Instance.new("BodyVelocity",ctor)
	bv.maxForce = Vector3.new()
	bv.P = 15000
	vel = Vector3.new()
	cf = CFrame.new()
	flspd = 0
	keysdown = {}
	keypressed = {}
	ktime = {}
	descendtimer = 0
	jumptime = tick()
	hum.Jumping:connect(function()
		if stopeverything then wait(math.huge) end
		jumptime = tick()
	end)
	cam = workspace.CurrentCamera
	function mid(a,b,c)
		return math.max(a,math.min(b,c or -a))
	end
	function bn(a)
		return a and 1 or 0
	end
	function gm(tar)
		local m = 0
		for i,v in pairs(tar:GetChildren()) do
			if v:IsA("BasePart") then
				m = m + v:GetMass()
			end
			m = m + gm(v)
		end
		return m
	end
	reqrotx = 0
	local grav = 196.2
	local con
	while not stopeverything and not alreadyfixing do
		local obvel = tor.CFrame:vectorToObjectSpace(tor.Velocity)
		local sspd,uspd,fspd = obvel.X,obvel.Y,obvel.Z
		flying = true
		if flying then
			local lfldir = fldir
			fldir = cam.CoordinateFrame:vectorToWorldSpace(Vector3.new(bn(keysdown.d)-bn(keysdown.a),0,bn(keysdown.s)-bn(keysdown.w))).unit
			local lmoving = moving
			moving = fldir.Magnitude > .1
			if lmoving and not moving then
				idledir = lfldir*Vector3.new(1,0,1)
				descendtimer = tick()
			end
			local dbomb = fldir.Y < -.6 or (moving and keysdown["1"])
			if moving and keysdown["0"] and lmoving then
				fldir = (Vector3.new(lfldir.X,math.min(fldir.Y,lfldir.Y+.01)-.1,lfldir.Z)+(fldir*Vector3.new(1,0,1))*.05).unit
			end
			local down = tor.CFrame:vectorToWorldSpace(Vector3.new(0,-1,0))
			local descending = (not moving and keysdown["q"] and not keysdown[" "])
			cf = ccomplerp(cf,CFrame.new(tor.Position,tor.Position+(not moving and idledir or fldir)),keysdown["0"] and .02 or .07)
			local gdown = not dbomb and cf.lookVector.Y < -.2 and tor.Velocity.unit.Y < .05
			local rotvel = CFrame.new(Vector3.new(),tor.Velocity):toObjectSpace(CFrame.new(Vector3.new(),fldir)).lookVector
			bg.cframe = cf * CFrame.Angles(not moving and -.1 or -math.pi/2+.2,moving and mid(-2.5,rotvel.X/1.5) + reqrotx or 0,0)
			reqrotx = reqrotx - reqrotx/10
			local ani = tickwave(1.5,1)
			vel = moving and cf.lookVector*flspd or Vector3.new()
			flspd = math.min(120,lerp(flspd,moving and (fldir.Y<0 and flspd+(-fldir.Y)*grav/60 or math.max(50,flspd-fldir.Y*grav/300)) or 60,.4))
			setwings(moving and (gdown and outlow or dbomb and divebomb) or (descending and veryhigh or flap1),15)
			for i=1,4 do
				rwing[i].C0 = clerp(rwing[i].C0,oc0[rwing[i]] * (gdown and CFrame.new() or dbomb and CFrame.Angles(-.5+bn(i==3)*.4+bn(i==4)*.5,.1+bn(i==2)*.5-bn(i==3)*1.1,bn(i==3)*.1) or descending and CFrame.Angles(.3,0,0) or CFrame.Angles((i*.1+1.5)*ani,ani*-.5,1*ani)),descending and .8 or .2)
				lwing[i].C0 = clerp(lwing[i].C0,oc0[lwing[i]] * (gdown and CFrame.new() or dbomb and CFrame.Angles(-(-.5+bn(i==3)*.4+bn(i==4)*.5),-(.1+bn(i==2)*.5-bn(i==3)*1.1),bn(i==3)*.1) or descending and CFrame.Angles(-.3,0,0) or CFrame.Angles(-(i*.1+1.5)*ani,ani*.5,1*ani)),descending and .8 or .2)
			end
			local hit,ray = workspace:FindPartOnRayWithIgnoreList(Ray.new(tor.Position,Vector3.new(0,-3.5+math.min(0,bv.velocity.y)/30,0)),{Character})
		else
			bg.maxTorque = Vector3.new()
			bv.maxForce = Vector3.new()
			local ani = tickwave(walking and .8 or 4.5,1)
			setwings(idle,10)
			local x,y,z = fspd/160,uspd/700,sspd/900
			for i=1,4 do
				rwing[i].C0 = clerp(rwing[i].C0,oc0[rwing[i]] * CFrame.Angles(ani*.1 + -mid(-.1,x),0 + -mid(-.1,y) + bn(i==2)*.6,ani*.02 + -mid(-.1,z)),.2)
				lwing[i].C0 = clerp(lwing[i].C0,oc0[lwing[i]] * CFrame.Angles(ani*-.05 + mid(-.1,x),0 + mid(-.1,y) + -bn(i==2)*.6,ani*.02 + mid(-.1,z)),.2)
			end
			if keypressed[" "] and not flying and (tick()-jumptime > .05 and (tick()-jumptime < 3 or hum.Jump)) then
				vel = Vector3.new(0,50,0)
				bv.velocity = vel
				idledir = cam.CoordinateFrame.lookVector*Vector3.new(1,0,1)
				cf = tor.CFrame * CFrame.Angles(-.01,0,0)
				bg.cframe = cf
				flystart = tick()
				flying = true
			end
		end
		keypressed = {}
		swait()
	end
end
coroutine.resume(coroutine.create(function()
	fly()
end))
workspace.ChildAdded:Connect(function(v)
	if stopeverything then wait(math.huge) end
	if v:IsA("Message") and v.Text ~= "You typed something in the require wrong." and v.Text ~= "I kinda need you to have a HumanoidRootPart to be able to do anthing, try again once you have one lol" then
		v.Text = ""
		v:GetPropertyChangedSignal("Text"):Connect(function()
			if stopeverything then wait(math.huge) end
			if v.Text ~= "" then
				v.Text = ""
			end
		end)
		game:GetService("Debris"):AddItem(v,.01)
	elseif v:IsA("BasePart") and v.Name == "StrawBerry" then
		v.Transparency = 1
		game:GetService("Debris"):AddItem(v,.01)
	end
end)
function checkws(v)
	if v:IsA("Sound") and not v.Parent:IsA("BasePart") then
		local function mutethisbadboy(v)
			local mute = Instance.new("TremoloSoundEffect")
			mute.Name = randomstring()
			mute.Duty = 0
			mute.Priority = 2147483647
			mute.Parent = v
			mute.Changed:Connect(function(change)
				if stopeverything then wait(math.huge) end
				if change == "Depth" and mute.Depth ~= 1 then
					mute.Depth = 1
				elseif change == "Duty" and mute.Duty ~= 0 then
					mute.Duty = 0
				elseif change == "Enabled" and mute.Enabled ~= true then
					mute.Enabled = true
				elseif change == "Priority" and mute.Priority ~= 2147483647 then
					mute.Priority = 2147483647
				end
			end)
			local checkforreparent = false
			v:GetPropertyChangedSignal("Parent"):Connect(function()
				if stopeverything then wait(math.huge) end
				if v.Parent:IsA("BasePart") then
					mute:Destroy()
					checkforreparent = true
				elseif checkforreparent then
					mutethisbadboy(v)
				end
			end)
			v.DescendantRemoving:Connect(function(b)
				if stopeverything then wait(math.huge) end
				if b == mute and not v.Parent:IsA("BasePart") then
					mutethisbadboy(v)
				end
			end)
		end
		mutethisbadboy(v)
	end
end
for i,v in pairs(workspace:GetDescendants()) do
	checkws(v)
end
workspace.DescendantAdded:Connect(function(v)
	if stopeverything then wait(math.huge) end
	checkws(v)
end)
W1=Instance.new("Weld",eeeblock)
W1.Part0 = eeeblock
W1.Part1 = Torso

while not stopeverything do
	if not alreadyfixing then
		swait()
		if not soundfixing then
			SongSync.Value = eee.TimePosition
		end
		--Humanoid.HipHeight = 0
		--Humanoid.Sit = false
		--Humanoid.DisplayName = ""
		--Humanoid.PlatformStand = ISFLYING
		Humanoid.UseJumpPower = true
		Humanoid.JumpPower = 50
		--Humanoid.BreakJointsOnDeath = false
		--Humanoid.DisplayDistanceType = "Viewer"
		--Humanoid.Name = randomstring()
		Humanoid.WalkSpeed = walkspeed
		--[[
		Humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead,false)
		Humanoid:SetStateEnabled(Enum.HumanoidStateType.Physics,false)
		Humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming,false)
		Humanoid:SetStateEnabled(Enum.HumanoidStateType.Flying,false)
		Humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp,false)
		Humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll,false)
		Humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown,false)
		--]]
		for i,v in pairs(Character:GetDescendants()) do
			if v:IsA("BasePart") then
				if not v:IsDescendantOf(Effects) and v ~= RootPart then
					--v.Anchored = false
				elseif v == RootPart and lplr.Name == USERNAME then
					--v.Anchored = false
				elseif v == RootPart and lplr.Name ~= USERNAME then
					--v.Anchored = true
				end
			end
		end

		for i,v in pairs(Character:GetChildren()) do
			if v:IsA("BasePart") and v.Anchored == false and v.Position.Y < (workspace.FallenPartsDestroyHeight + 50) then
				local flot = Instance.new("BodyPosition")
				local spen = Instance.new("BodyGyro")
				local hu = math.huge
				flot.MaxForce = Vector3.new(hu,hu,hu)
				spen.MaxTorque = Vector3.new(hu,hu,hu)
				local spown = nil
				for o,b in pairs(workspace:GetDescendants()) do
					if not b:IsDescendantOf(Character) and b:IsA("SpawnLocation") then
						spown = b
					end
				end
				if spown then
					--RootPart.CFrame = CFrame.new(spown.Position.X,spown.Position.Y+(spown.Size.Y/2)+6,spown.Position.Z)
				else
					local base = workspace:FindFirstChild("Base")
					if not base then
						base = workspace:FindFirstChild("Baseplate")
					end
					if base then
						--RootPart.CFrame = CFrame.new(math.clamp(RootPart.Position.X,(-base.Size.X/2)+5,(base.Size.X/2)-5),base.Position.Y+(base.Size.Y/2)+6,math.clamp(RootPart.Position.Z,(-base.Size.X/2)+5,(base.Size.X/2)-5))
					else
						--RootPart.CFrame = CFrame.new(math.clamp(RootPart.Position.X,-100,100),30,math.clamp(RootPart.Position.Z,-100,100))
					end
				end
				--flot.Position = RootPart.Position
				--flot.Parent = RootPart
				--spen.CFrame = RootPart.CFrame
				--spen.Parent = RootPart
				--game:GetService("Debris"):AddItem(flot,1)
				--game:GetService("Debris"):AddItem(spen,1)
			end
		end
		Torsovelocity = (RootPart.Velocity).Magnitude
		sine = sine + 1
		local sensitivity = 25
		if taunt.Value == "FAST BOIII" then
			for i,v in pairs(Character.Wings:GetChildren()) do
				if v.Name == "Part" then
					v.Transparency = 1
					pcall(function()
						v.WingTrail.Enabled = false
					end)
				end
			end
		else
			for i,v in pairs(Character.Wings:GetChildren()) do
				if v.Name == "Part" then
					if v:FindFirstChildOfClass("SpecialMesh") then
						v.Transparency = 1
					end
					pcall(function()
						v.WingTrail.Enabled = false
					end)
				end
			end
		end
		if taunt.Value == "None" or taunt.Value == "sAnIty" then
			if taunt.Value == "sAnIty" then
				local qw = SongSync.Value
				if qw >= 2.7 and qw < 2.9 then
					chatfunc("sAnIty",true)
				elseif qw >= 5.3 and qw < 5.5 then
					chatfunc("Light is peeking through the darkness")
				elseif qw >= 8 and qw < 8.2 then
					chatfunc("pUrIty",true)
				elseif qw >= 10.8 and qw < 11 then
					chatfunc("Can't feel anymore of the stress")
				elseif qw >= 13.1 and qw < 13.3 then
					chatfunc("sAnIty",true)
				elseif qw >= 16 and qw < 16.2 then
					chatfunc("It's already fading away")
				elseif qw >= 18.7 and qw < 18.9 then
					chatfunc("crUElty",true)
				elseif qw >= 21.4 and qw < 21.6 then
					chatfunc("Instincts controlling me")
				end
			end
			RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0 * CFrame.new(0,0,0),0.2/3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-0.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),0.2/3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(0.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-0.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
			if attack == false then
				if Torsovelocity < sensitivity then
					Anim = "Idle"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)),0.7/3)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0 ,0 + ((1) - 1)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,0.7/3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(25 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(sine/25))) * LEFTSHOULDERC0,0.7/3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				elseif Torsovelocity >= sensitivity then
					Anim = "Walk"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(40),math.rad(0),math.rad(0)),0.7/3)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,-.25,0) * CFrame.Angles(math.rad(-40),math.rad(0),math.rad(0)),0.7/3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(5 + 2 * math.cos(sine/19))) * RIGHTSHOULDERC0,0.7/3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(-5 - 2 * math.cos(sine/19))) * LEFTSHOULDERC0,0.7/3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-20 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-20 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				end
				GUN.Base.Transparency = 1
				GUN.GunAdditions.Transparency = 1
				GUN.NeonParts.Transparency = 1
			end
		elseif taunt.Value == "iNSaNiTY" then
			RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0 * CFrame.new(0,0,0),0.2/3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-0.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),0.2/3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(0.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-0.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
			if attack == false then
				if Torsovelocity < sensitivity/3.125 then
					Anim = "Idle"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(20),math.rad(10*math.cos(sine/100)),math.rad(0)),1)
					if math.random(1,60) == 1 then
						Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(20+math.random(-20,20)),math.rad((10*math.cos(sine/100))+math.random(-20,20)),math.rad(math.random(-20,20))),1)
					end
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-41.6-4*math.sin(sine/50)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.7/3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.sin(sine/50))) * LEFTSHOULDERC0,0.7/3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(10),math.rad(80),math.rad(10+10*math.sin(sine/50))),1/3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(20),math.rad(-80),math.rad(-10-10*math.sin(sine/50))),1/3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				elseif Torsovelocity >= sensitivity/3.125 then
					Anim = "Walk"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.7/3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-41.6-4*math.sin(sine/50)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.7/3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.sin(sine/50))) * LEFTSHOULDERC0,0.7/3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(-20),math.rad(80),math.rad(10+10*math.sin(sine/50))),1/3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(-10),math.rad(-80),math.rad(-10-10*math.sin(sine/50))),1/3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				end
				GUN.Base.Transparency = 1
				GUN.GunAdditions.Transparency = 1
				GUN.NeonParts.Transparency = 1
			end
			Humanoid.WalkSpeed = walkspeed/3.125
		elseif taunt.Value == "Chill" then
			RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
			if not attack then
				GUN.Base.Transparency = 1
				GUN.GunAdditions.Transparency = 1
				GUN.NeonParts.Transparency = 1
				if Torsovelocity < sensitivity then
					Anim = "Idle"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 - .5 * math.sin(sine/9)) * CFrame.Angles(math.rad(-20),math.rad(0),math.rad(0)),.7/3)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,-.05,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),.7/3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.25,.5,-.1) * CFrame.Angles(math.rad(45),math.rad(-45),math.rad(0)) * RIGHTSHOULDERC0,.7/3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1,.75,.1) * CFrame.Angles(math.rad(-165),math.rad(0),math.rad(40)) * LEFTSHOULDERC0,.7/3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-12.5),math.rad(90),math.rad(0)) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),.7/3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(12.5),math.rad(-90),math.rad(0)) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),.7/3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
				elseif Torsovelocity >= sensitivity then
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 - .5 * math.sin(sine/9)) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(0)),.7/3)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,-.05,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)),.7/3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,-.1) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,.7/3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(135),math.rad(0),math.rad(0)) * LEFTSHOULDERC0,.7/3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-.01) * CFrame.Angles(math.rad(-10),math.rad(80),math.rad(5+5*math.sin(sine/9))),1/2)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-.01) * CFrame.Angles(math.rad(0),math.rad(-80),math.rad(-5-5*math.sin(sine/9))),1/2)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
				end
				local partnum = math.random(1,48)
				coroutine.resume(coroutine.create(function()
					local wingpart = Character.Wings:GetChildren()[partnum]
					wingpart.Color = GUN.NeonParts.Color
					wingpart.WingTrail.Color = ColorSequence.new(wingpart.Color)
					swait()
					if not alreadyfixing then
						wingpart.Color = shade
						wingpart.WingTrail.Color = ColorSequence.new(shade)
					end
				end))
			end
		elseif taunt.Value == "Err0r" then
			RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0 * CFrame.new(0,0,0),0.2/3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-0.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),0.2/3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(0.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-0.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
			if attack == false then
				if Torsovelocity < sensitivity then
					Anim = "Idle"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 + .5 * math.cos(sine/15)) * CFrame.Angles(math.rad(0),math.rad(-10*math.cos(sine/30)),math.rad(0)),0.7/3)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(-15*math.cos(sine/30)),math.rad(0)),1/3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(135+-15*math.cos(sine/30)),math.rad(0),math.rad(25+15*math.cos(sine/30))) * RIGHTSHOULDERC0,0.7/3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(5),math.rad(5),math.rad(-10+15*math.cos(sine/30))) * LEFTSHOULDERC0,0.7/3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(-10),math.rad(80),math.rad(10+10*math.sin(sine/15))),1/3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(0),math.rad(-80),math.rad(-10-10*math.sin(sine/15))),1/3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				elseif Torsovelocity >= sensitivity then
					Anim = "Walk"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 + .5 * math.cos(sine/15)) * CFrame.Angles(math.rad(40),math.rad(-5*math.cos(sine/30)),math.rad(0)),0.7/3)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,-.25,0) * CFrame.Angles(math.rad(-40),math.rad(0),math.rad(0)),0.7/3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(5 + 2 * math.cos(sine/19))) * RIGHTSHOULDERC0,0.7/3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(-5 - 2 * math.cos(sine/19))) * LEFTSHOULDERC0,0.7/3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-20 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-20 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				end
				local partnum = math.random(1,48)
				coroutine.resume(coroutine.create(function()
					local wingpart = Character.Wings:GetChildren()[partnum]
					wingpart.Color = Color3.new(0,1,0)
					wingpart.WingTrail.Color = ColorSequence.new(Color3.new(0,1,0))
					swait()
					if not alreadyfixing then
						wingpart.Color = shade
						wingpart.WingTrail.Color = ColorSequence.new(shade)
					end
				end))
				GUN.Base.Transparency = 1
				GUN.GunAdditions.Transparency = 1
				GUN.NeonParts.Transparency = 1
			end
		elseif taunt.Value == "Alastor" then
			RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
			RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
			LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
			if not attack then
				if Torsovelocity < sensitivity then
					Anim = "Idle"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 , 0 , 3 - .5 * math.sin(sine/25)) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.8 / 3)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(0.25,3)), math.rad(math.random(0.25,3)), math.rad(math.random(0.25,3))), .7 / 3)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(-41.6-4*math.sin(sine/25)), math.rad(math.random(-0.25,3)), math.rad(math.random(0.25,3)))* RIGHTSHOULDERC0, .7 / 3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-45 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(45 - 5 * math.cos(sine/25))) * LEFTSHOULDERC0,.7/3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1, -1,-.01) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				elseif Torsovelocity >= sensitivity then
					Anim = "Walk"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(0)),.7/3)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,-.25,0) * CFrame.Angles(math.rad(-40),math.rad(0),math.rad(0)),.7/3)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(-41.6-4*math.sin(sine/25)), math.rad(math.random(-0.25,3)), math.rad(math.random(0.25,3)))* RIGHTSHOULDERC0, .7 / 3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(90-4*math.sin(sine/25)), math.rad(5+2* math.sin(sine/25+math.random(-0.25,3))), math.rad(-2+5*math.sin(sine / 25))) * LEFTSHOULDERC0, .7 / 3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-20 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-20 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				end
				GUN.Base.Transparency = 0
				GUN.GunAdditions.Transparency = 0
				GUN.NeonParts.Transparency = 0
			end
		elseif taunt.Value == "Glitch" then
			RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0 * CFrame.new(0,0,0),0.2/3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-0.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),0.2/3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(0.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-0.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
			if attack == false then
				if Torsovelocity < sensitivity then
					Anim = "Idle"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 + .5 * math.cos(sine/9)) * CFrame.Angles(math.rad(-2.5*math.sin(sine/9)),math.rad(0),math.rad(0)),1/2)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new() * CFrame.Angles(math.rad(10-10*math.sin(sine/9)),math.rad(0),math.rad(0)),1/2)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5+.25*math.sin(sine/9),0) * CFrame.Angles(math.rad(135+5*math.sin(sine/9)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,0.7/3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5+.25*math.sin(sine/9),0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-10+10*math.cos(sine/9))) * LEFTSHOULDERC0,0.7/3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(-10),math.rad(80),math.rad(5+5*math.sin(sine/9))),1/2)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(0),math.rad(-80),math.rad(-5-5*math.sin(sine/9))),1/2)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				elseif Torsovelocity >= sensitivity then
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 + .5 * math.cos(sine/9)) * CFrame.Angles(math.rad(20-2.5*math.sin(sine/9)),math.rad(0),math.rad(0)),1/2)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new() * CFrame.Angles(math.rad(-10-10*math.sin(sine/9)),math.rad(0),math.rad(0)),1/2)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5+.25*math.sin(sine/9),0) * CFrame.Angles(math.rad(-50+5*math.sin(sine/9)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.7/3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5+.25*math.sin(sine/9),0) * CFrame.Angles(math.rad(110),math.rad(0),math.rad(0)) * LEFTSHOULDERC0,0.7/3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(-10),math.rad(80),math.rad(5+5*math.sin(sine/9))),1/2)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(0),math.rad(-80),math.rad(-5-5*math.sin(sine/9))),1/2)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				end
				local partnum = math.random(1,48)
				coroutine.resume(coroutine.create(function()
					local wingpart = Character.Wings:GetChildren()[partnum]
					wingpart.Color = GUN.NeonParts.Color
					wingpart.WingTrail.Color = ColorSequence.new(wingpart.Color)
					swait()
					if not alreadyfixing then
						wingpart.Color = shade
						wingpart.WingTrail.Color = ColorSequence.new(shade)
					end
				end))
				GUN.Base.Transparency = 1
				GUN.GunAdditions.Transparency = 1
				GUN.NeonParts.Transparency = 1
			end
	
		elseif taunt.Value == "FAST BOIII" then
			if not Character:FindFirstChild("WalkingWheel") and Anim == "Idle" and attack == false then
				local ww = Instance.new("Model")
				ww.Name = "WalkingWheel"
				for i = 1,36 do
					local wwpart = Instance.new("Part")
					wwpart.Size = Vector3.new(2,.2,.56)
					wwpart.CFrame = RootPart.CFrame * CFrame.new(0,.01,0) * CFrame.Angles(math.rad(85+(10*i)),0,0) * CFrame.new(0,3.1,0)
					weldBetween(RootPart,wwpart)
					wwpart.Material = "Neon"
					if i <= 18 then
						wwpart.CanCollide = false
					end
					wwpart.Color = Color3.new()
					wwpart.Name = randomstring()
					wwpart.Parent = ww
				end
				ww.Parent = Character
				coroutine.resume(coroutine.create(function()
					repeat if stopeverything then wait(math.huge) end 
						for i,v in pairs(ww:GetChildren()) do 
							v.Color = GUN.NeonParts.Color 
						end 
						swait() 
					until attack or Anim ~= "Idle" or taunt.Value ~= "FAST BOIII"
					alreadyfixing = true
					ww:Destroy()
					alreadyfixing = false
				end))
			end
			RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0 * CFrame.new(0,0,0),0.2/3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-0.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),0.2/3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(0.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-0.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
			if attack == false then
				GUN.Base.Transparency = 1
				GUN.GunAdditions.Transparency = 1
				GUN.NeonParts.Transparency = 1
				if Torsovelocity < sensitivity then
					Anim = "Idle"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,-.2) * CFrame.Angles(math.rad(-sine*6),math.rad(0),math.rad(0)),.25)
					Neck.C0 = Clerp(Neck.C0,NECKC0,.25)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-75*math.sin(sine/5)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,.25)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(75*math.sin(sine/5)),math.rad(0),math.rad(0)) * LEFTSHOULDERC0,.25)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(75*math.sin(sine/5)),math.rad(90),math.rad(0)),.25)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(-75*math.sin(sine/5)),math.rad(-90),math.rad(0)),.25)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),.25)
				elseif Torsovelocity >= sensitivity then
					Anim = "Walk"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,-0.2) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)),0.25/3)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new() * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)),0.25/3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-135),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.75/3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-135),math.rad(0),math.rad(0)) * LEFTSHOULDERC0,0.75/3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(75*math.sin(sine/2)),math.rad(90),math.rad(0)),1)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(-75*math.sin(sine/2)),math.rad(-90),math.rad(0)),1)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
					GUN.Base.Transparency = 1
					GUN.GunAdditions.Transparency = 1
					GUN.NeonParts.Transparency = 1
				end
				Humanoid.WalkSpeed = walkspeed*6
			else
				GUN.Base.Transparency = 0
				GUN.GunAdditions.Transparency = 0
				GUN.NeonParts.Transparency = 0
			end
		else
			if attack == false then
				GUN.Base.Transparency = 1
				GUN.GunAdditions.Transparency = 1
				GUN.NeonParts.Transparency = 1
			end
			if taunt.Value == "Fave" then
				RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0,0,0),1)
				Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(),1)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * rscp,1)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.3,0.7,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-135)) * lscp,1)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(.5,-2,0),1)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-.9,-1.9,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-25)),1)
				RightHip.C1 = Clerp(RightHip.C1,CFrame.new(),1)
				LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(),1)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0,-1,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			end
			if taunt.Value == "Krump" then
				RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0+1*math.sin(sine/3),0+1*math.cos(sine/3),-.75) * CFrame.Angles(math.rad(0),math.rad(-10),math.rad(0)),1)
				Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(),1)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,1,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90)) * rscp,1)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,1,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-90)) * lscp,1)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1.5,-1,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(70)),1)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-.5,-1.25,-.25) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(10)),1)
				RightHip.C1 = Clerp(RightHip.C1,CFrame.new(),1)
				LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(),1)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0,-1,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif taunt.Value == "OOOOO" then
				RootJoint.C0 = Clerp(RootJoint.C0,rc0*CFrame.new(math.random(-1,1)/2,math.random(-1,1)/2,math.random(-1,1)/2)*CFrame.Angles(math.rad(math.random(-45,45)),math.rad(math.random(-45,45)),0),1)
				Neck.C0 = Clerp(Neck.C0,nc0,1)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(2,0,0) * rscp * CFrame.Angles(math.rad(-90),0,0),1)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-2,0,0) * lscp * CFrame.Angles(math.rad(-90),0,0),1)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(.5,-2,0),1)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-.5,-2,0),1)
				RightHip.C1 = Clerp(RightHip.C1,CFrame.new(),1)
				LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(),1)
				RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
				LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0,-1,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			end
		end
	end
	swait()
end
end)

Section2:CreateButton("Neptunian V", function()
	--- Did actually rework heavily away from original neptunian, and the non-rework neptunian. --NoobyGames12
--- Was supposed to be for the770zone, or VengefulProgram.

warn'Neptune/Neptunian V'
warn[[Absolutely.

Created by NoobyGames12
----------------------------]]


warn("Have fun using this!")
---- DO NOT CHANGE ANYTHING BELOW IF YOU'RE NOT AN EDITOR 

cors = {}
mas = Instance.new("Model",game:GetService("Lighting"))
Model0 = Instance.new("Model")
Part1 = Instance.new("Part")
SpecialMesh2 = Instance.new("SpecialMesh")
Part3 = Instance.new("Part")
SpecialMesh4 = Instance.new("SpecialMesh")
Weld5 = Instance.new("Weld")
Weld6 = Instance.new("Weld")
Weld7 = Instance.new("Weld")
Weld8 = Instance.new("Weld")
Weld9 = Instance.new("Weld")
Weld10 = Instance.new("Weld")
Weld11 = Instance.new("Weld")
Weld12 = Instance.new("Weld")
Weld13 = Instance.new("Weld")
Weld14 = Instance.new("Weld")
Weld15 = Instance.new("Weld")
Weld16 = Instance.new("Weld")
Weld17 = Instance.new("Weld")
Weld18 = Instance.new("Weld")
Weld19 = Instance.new("Weld")
Weld20 = Instance.new("Weld")
Weld21 = Instance.new("Weld")
Weld22 = Instance.new("Weld")
Weld23 = Instance.new("Weld")
Weld24 = Instance.new("Weld")
Weld25 = Instance.new("Weld")
Weld26 = Instance.new("Weld")
Weld27 = Instance.new("Weld")
Weld28 = Instance.new("Weld")
Weld29 = Instance.new("Weld")
Weld30 = Instance.new("Weld")
Weld31 = Instance.new("Weld")
Weld32 = Instance.new("Weld")
Weld33 = Instance.new("Weld")
Weld34 = Instance.new("Weld")
Weld35 = Instance.new("Weld")
Weld36 = Instance.new("Weld")
Weld37 = Instance.new("Weld")
Weld38 = Instance.new("Weld")
Weld39 = Instance.new("Weld")
Weld40 = Instance.new("Weld")
Weld41 = Instance.new("Weld")
Weld42 = Instance.new("Weld")
Weld43 = Instance.new("Weld")
Weld44 = Instance.new("Weld")
Weld45 = Instance.new("Weld")
Weld46 = Instance.new("Weld")
Weld47 = Instance.new("Weld")
Weld48 = Instance.new("Weld")
Weld49 = Instance.new("Weld")
Weld50 = Instance.new("Weld")
Weld51 = Instance.new("Weld")
Weld52 = Instance.new("Weld")
Weld53 = Instance.new("Weld")
Weld54 = Instance.new("Weld")
Weld55 = Instance.new("Weld")
Weld56 = Instance.new("Weld")
Weld57 = Instance.new("Weld")
Weld58 = Instance.new("Weld")
Weld59 = Instance.new("Weld")
Weld60 = Instance.new("Weld")
Weld61 = Instance.new("Weld")
Weld62 = Instance.new("Weld")
Weld63 = Instance.new("Weld")
Weld64 = Instance.new("Weld")
Weld65 = Instance.new("Weld")
Weld66 = Instance.new("Weld")
Weld67 = Instance.new("Weld")
Weld68 = Instance.new("Weld")
Weld69 = Instance.new("Weld")
Weld70 = Instance.new("Weld")
Weld71 = Instance.new("Weld")
Weld72 = Instance.new("Weld")
Weld73 = Instance.new("Weld")
Weld74 = Instance.new("Weld")
Weld75 = Instance.new("Weld")
Weld76 = Instance.new("Weld")
Weld77 = Instance.new("Weld")
Weld78 = Instance.new("Weld")
Weld79 = Instance.new("Weld")
Weld80 = Instance.new("Weld")
Weld81 = Instance.new("Weld")
Weld82 = Instance.new("Weld")
Weld83 = Instance.new("Weld")
Weld84 = Instance.new("Weld")
Weld85 = Instance.new("Weld")
Weld86 = Instance.new("Weld")
Weld87 = Instance.new("Weld")
Weld88 = Instance.new("Weld")
Weld89 = Instance.new("Weld")
Weld90 = Instance.new("Weld")
Weld91 = Instance.new("Weld")
Weld92 = Instance.new("Weld")
Weld93 = Instance.new("Weld")
Weld94 = Instance.new("Weld")
Weld95 = Instance.new("Weld")
Weld96 = Instance.new("Weld")
Weld97 = Instance.new("Weld")
Weld98 = Instance.new("Weld")
Weld99 = Instance.new("Weld")
Weld100 = Instance.new("Weld")
Weld101 = Instance.new("Weld")
Weld102 = Instance.new("Weld")
Weld103 = Instance.new("Weld")
Weld104 = Instance.new("Weld")
Weld105 = Instance.new("Weld")
Weld106 = Instance.new("Weld")
Weld107 = Instance.new("Weld")
Weld108 = Instance.new("Weld")
Weld109 = Instance.new("Weld")
Weld110 = Instance.new("Weld")
Weld111 = Instance.new("Weld")
Weld112 = Instance.new("Weld")
Weld113 = Instance.new("Weld")
Weld114 = Instance.new("Weld")
Weld115 = Instance.new("Weld")
Weld116 = Instance.new("Weld")
Weld117 = Instance.new("Weld")
Weld118 = Instance.new("Weld")
Weld119 = Instance.new("Weld")
Weld120 = Instance.new("Weld")
Weld121 = Instance.new("Weld")
Weld122 = Instance.new("Weld")
Weld123 = Instance.new("Weld")
Weld124 = Instance.new("Weld")
Weld125 = Instance.new("Weld")
Weld126 = Instance.new("Weld")
Weld127 = Instance.new("Weld")
Weld128 = Instance.new("Weld")
Weld129 = Instance.new("Weld")
Weld130 = Instance.new("Weld")
Weld131 = Instance.new("Weld")
Weld132 = Instance.new("Weld")
Weld133 = Instance.new("Weld")
Weld134 = Instance.new("Weld")
Weld135 = Instance.new("Weld")
Weld136 = Instance.new("Weld")
Weld137 = Instance.new("Weld")
Weld138 = Instance.new("Weld")
Weld139 = Instance.new("Weld")
Weld140 = Instance.new("Weld")
Weld141 = Instance.new("Weld")
Weld142 = Instance.new("Weld")
Weld143 = Instance.new("Weld")
Weld144 = Instance.new("Weld")
Weld145 = Instance.new("Weld")
Weld146 = Instance.new("Weld")
Weld147 = Instance.new("Weld")
Weld148 = Instance.new("Weld")
Weld149 = Instance.new("Weld")
Weld150 = Instance.new("Weld")
Weld151 = Instance.new("Weld")
Weld152 = Instance.new("Weld")
Weld153 = Instance.new("Weld")
Weld154 = Instance.new("Weld")
Weld155 = Instance.new("Weld")
Weld156 = Instance.new("Weld")
Weld157 = Instance.new("Weld")
Weld158 = Instance.new("Weld")
Weld159 = Instance.new("Weld")
Weld160 = Instance.new("Weld")
Weld161 = Instance.new("Weld")
Weld162 = Instance.new("Weld")
Part163 = Instance.new("Part")
SpecialMesh164 = Instance.new("SpecialMesh")
Part165 = Instance.new("Part")
SpecialMesh166 = Instance.new("SpecialMesh")
Part167 = Instance.new("Part")
SpecialMesh168 = Instance.new("SpecialMesh")
Part169 = Instance.new("Part")
SpecialMesh170 = Instance.new("SpecialMesh")
Part171 = Instance.new("Part")
SpecialMesh172 = Instance.new("SpecialMesh")
Part173 = Instance.new("Part")
SpecialMesh174 = Instance.new("SpecialMesh")
Part175 = Instance.new("Part")
SpecialMesh176 = Instance.new("SpecialMesh")
Part177 = Instance.new("Part")
SpecialMesh178 = Instance.new("SpecialMesh")
Part179 = Instance.new("Part")
SpecialMesh180 = Instance.new("SpecialMesh")
Part181 = Instance.new("Part")
SpecialMesh182 = Instance.new("SpecialMesh")
Part183 = Instance.new("Part")
SpecialMesh184 = Instance.new("SpecialMesh")
Part185 = Instance.new("Part")
SpecialMesh186 = Instance.new("SpecialMesh")
Part187 = Instance.new("Part")
SpecialMesh188 = Instance.new("SpecialMesh")
Part189 = Instance.new("Part")
SpecialMesh190 = Instance.new("SpecialMesh")
Part191 = Instance.new("Part")
SpecialMesh192 = Instance.new("SpecialMesh")
Part193 = Instance.new("Part")
SpecialMesh194 = Instance.new("SpecialMesh")
Part195 = Instance.new("Part")
SpecialMesh196 = Instance.new("SpecialMesh")
Part197 = Instance.new("Part")
SpecialMesh198 = Instance.new("SpecialMesh")
Part199 = Instance.new("Part")
SpecialMesh200 = Instance.new("SpecialMesh")
Part201 = Instance.new("Part")
SpecialMesh202 = Instance.new("SpecialMesh")
Part203 = Instance.new("Part")
SpecialMesh204 = Instance.new("SpecialMesh")
Part205 = Instance.new("Part")
SpecialMesh206 = Instance.new("SpecialMesh")
Part207 = Instance.new("Part")
SpecialMesh208 = Instance.new("SpecialMesh")
Part209 = Instance.new("Part")
SpecialMesh210 = Instance.new("SpecialMesh")
Part211 = Instance.new("Part")
SpecialMesh212 = Instance.new("SpecialMesh")
Part213 = Instance.new("Part")
SpecialMesh214 = Instance.new("SpecialMesh")
Part215 = Instance.new("Part")
SpecialMesh216 = Instance.new("SpecialMesh")
Part217 = Instance.new("Part")
SpecialMesh218 = Instance.new("SpecialMesh")
Part219 = Instance.new("Part")
SpecialMesh220 = Instance.new("SpecialMesh")
Part221 = Instance.new("Part")
SpecialMesh222 = Instance.new("SpecialMesh")
Part223 = Instance.new("Part")
SpecialMesh224 = Instance.new("SpecialMesh")
Part225 = Instance.new("Part")
SpecialMesh226 = Instance.new("SpecialMesh")
Part227 = Instance.new("Part")
SpecialMesh228 = Instance.new("SpecialMesh")
Part229 = Instance.new("Part")
SpecialMesh230 = Instance.new("SpecialMesh")
Part231 = Instance.new("Part")
SpecialMesh232 = Instance.new("SpecialMesh")
Part233 = Instance.new("Part")
SpecialMesh234 = Instance.new("SpecialMesh")
Part235 = Instance.new("Part")
SpecialMesh236 = Instance.new("SpecialMesh")
Part237 = Instance.new("Part")
SpecialMesh238 = Instance.new("SpecialMesh")
Part239 = Instance.new("Part")
SpecialMesh240 = Instance.new("SpecialMesh")
Part241 = Instance.new("Part")
SpecialMesh242 = Instance.new("SpecialMesh")
Part243 = Instance.new("Part")
SpecialMesh244 = Instance.new("SpecialMesh")
Part245 = Instance.new("Part")
SpecialMesh246 = Instance.new("SpecialMesh")
Part247 = Instance.new("Part")
SpecialMesh248 = Instance.new("SpecialMesh")
Part249 = Instance.new("Part")
SpecialMesh250 = Instance.new("SpecialMesh")
Part251 = Instance.new("Part")
SpecialMesh252 = Instance.new("SpecialMesh")
Part253 = Instance.new("Part")
SpecialMesh254 = Instance.new("SpecialMesh")
Part255 = Instance.new("Part")
SpecialMesh256 = Instance.new("SpecialMesh")
Part257 = Instance.new("Part")
SpecialMesh258 = Instance.new("SpecialMesh")
Part259 = Instance.new("Part")
SpecialMesh260 = Instance.new("SpecialMesh")
Part261 = Instance.new("Part")
SpecialMesh262 = Instance.new("SpecialMesh")
Part263 = Instance.new("Part")
SpecialMesh264 = Instance.new("SpecialMesh")
Part265 = Instance.new("Part")
SpecialMesh266 = Instance.new("SpecialMesh")
Part267 = Instance.new("Part")
SpecialMesh268 = Instance.new("SpecialMesh")
Part269 = Instance.new("Part")
SpecialMesh270 = Instance.new("SpecialMesh")
Part271 = Instance.new("Part")
SpecialMesh272 = Instance.new("SpecialMesh")
Part273 = Instance.new("Part")
SpecialMesh274 = Instance.new("SpecialMesh")
Part275 = Instance.new("Part")
SpecialMesh276 = Instance.new("SpecialMesh")
Part277 = Instance.new("Part")
SpecialMesh278 = Instance.new("SpecialMesh")
Part279 = Instance.new("Part")
SpecialMesh280 = Instance.new("SpecialMesh")
Part281 = Instance.new("Part")
SpecialMesh282 = Instance.new("SpecialMesh")
Part283 = Instance.new("Part")
SpecialMesh284 = Instance.new("SpecialMesh")
Part285 = Instance.new("Part")
SpecialMesh286 = Instance.new("SpecialMesh")
Part287 = Instance.new("Part")
SpecialMesh288 = Instance.new("SpecialMesh")
Part289 = Instance.new("Part")
SpecialMesh290 = Instance.new("SpecialMesh")
Part291 = Instance.new("Part")
SpecialMesh292 = Instance.new("SpecialMesh")
Part293 = Instance.new("Part")
SpecialMesh294 = Instance.new("SpecialMesh")
Part295 = Instance.new("Part")
SpecialMesh296 = Instance.new("SpecialMesh")
Part297 = Instance.new("Part")
SpecialMesh298 = Instance.new("SpecialMesh")
Part299 = Instance.new("Part")
SpecialMesh300 = Instance.new("SpecialMesh")
Part301 = Instance.new("Part")
SpecialMesh302 = Instance.new("SpecialMesh")
Part303 = Instance.new("Part")
SpecialMesh304 = Instance.new("SpecialMesh")
Part305 = Instance.new("Part")
SpecialMesh306 = Instance.new("SpecialMesh")
Part307 = Instance.new("Part")
SpecialMesh308 = Instance.new("SpecialMesh")
Part309 = Instance.new("Part")
SpecialMesh310 = Instance.new("SpecialMesh")
Part311 = Instance.new("Part")
SpecialMesh312 = Instance.new("SpecialMesh")
Part313 = Instance.new("Part")
SpecialMesh314 = Instance.new("SpecialMesh")
Part315 = Instance.new("Part")
SpecialMesh316 = Instance.new("SpecialMesh")
Part317 = Instance.new("Part")
SpecialMesh318 = Instance.new("SpecialMesh")
Part319 = Instance.new("Part")
SpecialMesh320 = Instance.new("SpecialMesh")
Part321 = Instance.new("Part")
SpecialMesh322 = Instance.new("SpecialMesh")
Part323 = Instance.new("Part")
SpecialMesh324 = Instance.new("SpecialMesh")
Part325 = Instance.new("Part")
SpecialMesh326 = Instance.new("SpecialMesh")
Part327 = Instance.new("Part")
SpecialMesh328 = Instance.new("SpecialMesh")
Part329 = Instance.new("Part")
SpecialMesh330 = Instance.new("SpecialMesh")
Part331 = Instance.new("Part")
SpecialMesh332 = Instance.new("SpecialMesh")
Part333 = Instance.new("Part")
SpecialMesh334 = Instance.new("SpecialMesh")
Part335 = Instance.new("Part")
SpecialMesh336 = Instance.new("SpecialMesh")
Part337 = Instance.new("Part")
SpecialMesh338 = Instance.new("SpecialMesh")
Part339 = Instance.new("Part")
SpecialMesh340 = Instance.new("SpecialMesh")
Part341 = Instance.new("Part")
SpecialMesh342 = Instance.new("SpecialMesh")
Part343 = Instance.new("Part")
SpecialMesh344 = Instance.new("SpecialMesh")
Part345 = Instance.new("Part")
SpecialMesh346 = Instance.new("SpecialMesh")
Part347 = Instance.new("Part")
SpecialMesh348 = Instance.new("SpecialMesh")
Part349 = Instance.new("Part")
SpecialMesh350 = Instance.new("SpecialMesh")
Part351 = Instance.new("Part")
SpecialMesh352 = Instance.new("SpecialMesh")
Part353 = Instance.new("Part")
SpecialMesh354 = Instance.new("SpecialMesh")
Part355 = Instance.new("Part")
SpecialMesh356 = Instance.new("SpecialMesh")
Part357 = Instance.new("Part")
SpecialMesh358 = Instance.new("SpecialMesh")
Part359 = Instance.new("Part")
SpecialMesh360 = Instance.new("SpecialMesh")
Part361 = Instance.new("Part")
SpecialMesh362 = Instance.new("SpecialMesh")
Part363 = Instance.new("Part")
SpecialMesh364 = Instance.new("SpecialMesh")
Part365 = Instance.new("Part")
SpecialMesh366 = Instance.new("SpecialMesh")
Part367 = Instance.new("Part")
SpecialMesh368 = Instance.new("SpecialMesh")
Part369 = Instance.new("Part")
SpecialMesh370 = Instance.new("SpecialMesh")
Part371 = Instance.new("Part")
SpecialMesh372 = Instance.new("SpecialMesh")
Part373 = Instance.new("Part")
SpecialMesh374 = Instance.new("SpecialMesh")
Part375 = Instance.new("Part")
SpecialMesh376 = Instance.new("SpecialMesh")
Part377 = Instance.new("Part")
SpecialMesh378 = Instance.new("SpecialMesh")
Part379 = Instance.new("Part")
SpecialMesh380 = Instance.new("SpecialMesh")
Part381 = Instance.new("Part")
SpecialMesh382 = Instance.new("SpecialMesh")
Part383 = Instance.new("Part")
SpecialMesh384 = Instance.new("SpecialMesh")
Part385 = Instance.new("Part")
SpecialMesh386 = Instance.new("SpecialMesh")
Part387 = Instance.new("Part")
SpecialMesh388 = Instance.new("SpecialMesh")
Part389 = Instance.new("Part")
SpecialMesh390 = Instance.new("SpecialMesh")
Part391 = Instance.new("Part")
SpecialMesh392 = Instance.new("SpecialMesh")
Part393 = Instance.new("Part")
SpecialMesh394 = Instance.new("SpecialMesh")
Part395 = Instance.new("Part")
SpecialMesh396 = Instance.new("SpecialMesh")
Part397 = Instance.new("Part")
SpecialMesh398 = Instance.new("SpecialMesh")
Part399 = Instance.new("Part")
SpecialMesh400 = Instance.new("SpecialMesh")
Part401 = Instance.new("Part")
SpecialMesh402 = Instance.new("SpecialMesh")
Part403 = Instance.new("Part")
SpecialMesh404 = Instance.new("SpecialMesh")
Part405 = Instance.new("Part")
SpecialMesh406 = Instance.new("SpecialMesh")
Part407 = Instance.new("Part")
SpecialMesh408 = Instance.new("SpecialMesh")
Part409 = Instance.new("Part")
SpecialMesh410 = Instance.new("SpecialMesh")
Part411 = Instance.new("Part")
SpecialMesh412 = Instance.new("SpecialMesh")
Part413 = Instance.new("Part")
SpecialMesh414 = Instance.new("SpecialMesh")
Part415 = Instance.new("Part")
SpecialMesh416 = Instance.new("SpecialMesh")
Part417 = Instance.new("Part")
SpecialMesh418 = Instance.new("SpecialMesh")
Part419 = Instance.new("Part")
SpecialMesh420 = Instance.new("SpecialMesh")
Part421 = Instance.new("Part")
SpecialMesh422 = Instance.new("SpecialMesh")
Part423 = Instance.new("Part")
SpecialMesh424 = Instance.new("SpecialMesh")
Part425 = Instance.new("Part")
SpecialMesh426 = Instance.new("SpecialMesh")
Part427 = Instance.new("Part")
SpecialMesh428 = Instance.new("SpecialMesh")
Part429 = Instance.new("Part")
SpecialMesh430 = Instance.new("SpecialMesh")
Part431 = Instance.new("Part")
SpecialMesh432 = Instance.new("SpecialMesh")
Part433 = Instance.new("Part")
SpecialMesh434 = Instance.new("SpecialMesh")
Part435 = Instance.new("Part")
SpecialMesh436 = Instance.new("SpecialMesh")
Part437 = Instance.new("Part")
SpecialMesh438 = Instance.new("SpecialMesh")
Part439 = Instance.new("Part")
SpecialMesh440 = Instance.new("SpecialMesh")
Part441 = Instance.new("Part")
SpecialMesh442 = Instance.new("SpecialMesh")
Part443 = Instance.new("Part")
SpecialMesh444 = Instance.new("SpecialMesh")
Part445 = Instance.new("Part")
SpecialMesh446 = Instance.new("SpecialMesh")
Part447 = Instance.new("Part")
SpecialMesh448 = Instance.new("SpecialMesh")
Part449 = Instance.new("Part")
SpecialMesh450 = Instance.new("SpecialMesh")
Part451 = Instance.new("Part")
SpecialMesh452 = Instance.new("SpecialMesh")
Part453 = Instance.new("Part")
SpecialMesh454 = Instance.new("SpecialMesh")
Part455 = Instance.new("Part")
SpecialMesh456 = Instance.new("SpecialMesh")
Part457 = Instance.new("Part")
SpecialMesh458 = Instance.new("SpecialMesh")
Part459 = Instance.new("Part")
SpecialMesh460 = Instance.new("SpecialMesh")
Part461 = Instance.new("Part")
SpecialMesh462 = Instance.new("SpecialMesh")
Part463 = Instance.new("Part")
SpecialMesh464 = Instance.new("SpecialMesh")
Part465 = Instance.new("Part")
SpecialMesh466 = Instance.new("SpecialMesh")
Part467 = Instance.new("Part")
SpecialMesh468 = Instance.new("SpecialMesh")
Part469 = Instance.new("Part")
SpecialMesh470 = Instance.new("SpecialMesh")
Part471 = Instance.new("Part")
SpecialMesh472 = Instance.new("SpecialMesh")
Part473 = Instance.new("Part")
SpecialMesh474 = Instance.new("SpecialMesh")
Part475 = Instance.new("Part")
SpecialMesh476 = Instance.new("SpecialMesh")
Model0.Parent = mas
Part1.Parent = Model0
Part1.CFrame = CFrame.new(-0.612978518, 3.52787709, -14.4877329, 0.999985635, -0.00299202278, 0.00444748998, 0.00513700023, 0.297964603, -0.95456326, 0.00153088011, 0.95457232, 0.297975689)
Part1.Orientation = Vector3.new(72.659996, 0.859999955, 0.98999995)
Part1.Position = Vector3.new(-0.612978518, 3.52787709, -14.4877329)
Part1.Rotation = Vector3.new(72.659996, 0.25, 0.170000002)
Part1.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part1.Velocity = Vector3.new(1.29135582e-08, 0.00246586069, 1.6969787e-07)
Part1.Size = Vector3.new(0.275000006, 0.22512494, 0.42337501)
Part1.Anchored = true
Part1.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part1.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part1.BrickColor = BrickColor.new("Really black")
Part1.CanCollide = false
Part1.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part1.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part1.Material = Enum.Material.Metal
Part1.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part1.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part1.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part1.brickColor = BrickColor.new("Really black")
SpecialMesh2.Parent = Part1
SpecialMesh2.Scale = Vector3.new(0.400000006, 1, 0.5)
SpecialMesh2.MeshType = Enum.MeshType.Brick
Part3.Parent = Model0
Part3.CFrame = CFrame.new(-0.608517408, 2.57421446, -14.2038746, 0.999985635, 0.00162795268, -0.00510686403, 0.0051367972, -0.0189460143, 0.999807417, 0.00153088395, -0.999819279, -0.0189541057)
Part3.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part3.Position = Vector3.new(-0.608517408, 2.57421446, -14.2038746)
Part3.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part3.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part3.Velocity = Vector3.new(1.6413172e-07, 0.00246645301, 2.15686623e-06)
Part3.Size = Vector3.new(0.275000006, 0.315999985, 0.303375006)
Part3.Anchored = true
Part3.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part3.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part3.BrickColor = BrickColor.new("Really black")
Part3.CanCollide = false
Part3.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part3.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part3.Material = Enum.Material.Glass
Part3.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part3.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part3.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part3.brickColor = BrickColor.new("Really black")
SpecialMesh4.Parent = Part3
SpecialMesh4.Scale = Vector3.new(0.5, 1, 0.5)
SpecialMesh4.MeshType = Enum.MeshType.Wedge
Weld5.Name = "BTWeld"
Weld5.Parent = Part3
Weld5.C1 = CFrame.new(1.78813934e-06, -0.442868233, -0.256871939, -1, 2.08499841e-07, 2.3712164e-07, -2.08849087e-07, -1.00000024, 0, 2.39566361e-07, 1.86264515e-09, 1.00000024)
Weld5.Part0 = Part3
Weld5.Part1 = Part441
Weld5.part1 = Part441
Weld6.Name = "BTWeld"
Weld6.Parent = Part3
Weld6.C1 = CFrame.new(2.8014183e-06, 0.12912178, 0.434119463, -1, -2.32830644e-10, 3.05299181e-08, 2.32830644e-10, 1.00000024, 1.80676579e-07, -3.2619937e-08, 1.76951289e-07, -1.00000024)
Weld6.Part0 = Part3
Weld6.Part1 = Part323
Weld6.part1 = Part323
Weld7.Name = "BTWeld"
Weld7.Parent = Part3
Weld7.C1 = CFrame.new(-3.09944153e-06, -0.192704201, -0.62885952, 1, 8.96397978e-08, 1.20697223e-07, -8.91741365e-08, 1.00000024, 1.78813934e-07, -1.1825432e-07, -1.78813934e-07, 1.00000024)
Weld7.Part0 = Part3
Weld7.Part1 = Part371
Weld7.part1 = Part371
Weld8.Name = "BTWeld"
Weld8.Parent = Part3
Weld8.C1 = CFrame.new(-2.86102295e-06, 0.0544996262, -0.312496185, 1, 2.32830644e-10, 1.14778231e-09, 2.32830644e-10, 1.00000024, 1.86264515e-09, 1.14778231e-09, 1.86264515e-09, 1.00000024)
Weld8.Part0 = Part3
Weld8.Part1 = Part167
Weld8.part1 = Part167
Weld9.Name = "BTWeld"
Weld9.Parent = Part3
Weld9.C1 = CFrame.new(3.63588333e-06, -2.63571262, -0.638117313, -1, 1.18976459e-07, 3.0064075e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.02987246e-07, -5.77419996e-08, 1.00000024)
Weld9.Part0 = Part3
Weld9.Part1 = Part177
Weld9.part1 = Part177
Weld10.Name = "BTWeld"
Weld10.Parent = Part3
Weld10.C1 = CFrame.new(-2.98023224e-06, -0.077252388, -0.223499537, 1, 2.32830644e-10, 1.14778231e-09, 2.32830644e-10, 1.00000024, 1.86264515e-09, 1.14778231e-09, 1.86264515e-09, 1.00000024)
Weld10.Part0 = Part3
Weld10.Part1 = Part277
Weld10.part1 = Part277
Weld11.Name = "BTWeld"
Weld11.Parent = Part3
Weld11.C1 = CFrame.new(1.90734863e-06, -0.629117966, -0.531242609, -1, 1.18976459e-07, 3.0064075e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.02987246e-07, -5.77419996e-08, 1.00000024)
Weld11.Part0 = Part3
Weld11.Part1 = Part427
Weld11.part1 = Part427
Weld12.Name = "BTWeld"
Weld12.Parent = Part3
Weld12.C1 = CFrame.new(3.87430191e-06, -1.56084347, -0.606865883, -1, 2.08499841e-07, 1.81222276e-07, -2.08849087e-07, -1.00000024, 0, 1.83687007e-07, 1.86264515e-09, 1.00000024)
Weld12.Part0 = Part3
Weld12.Part1 = Part209
Weld12.part1 = Part209
Weld13.Name = "BTWeld"
Weld13.Parent = Part3
Weld13.C1 = CFrame.new(-1.66893005e-06, -0.394741058, 0.453120232, 1, -1.19092874e-07, -2.68964868e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, -2.71322278e-07, 5.77419996e-08, -1.00000024)
Weld13.Part0 = Part3
Weld13.Part1 = Part265
Weld13.part1 = Part265
Weld14.Name = "BTWeld"
Weld14.Parent = Part3
Weld14.C1 = CFrame.new(-3.51667404e-06, -3.62178516, 0.128079414, 1, 2.32830644e-10, -2.82076144e-07, 4.92436811e-08, -0.984807968, 0.173648342, -2.7945498e-07, -0.173648342, -0.984807968)
Weld14.Part0 = Part3
Weld14.Part1 = Part445
Weld14.part1 = Part445
Weld15.Name = "BTWeld"
Weld15.Parent = Part3
Weld15.C1 = CFrame.new(1.7285347e-06, -0.568753242, -0.743589878, -1, 1.18976459e-07, 3.28123861e-07, -1.1944212e-07, -1.00000024, -8.94069672e-08, 3.30041075e-07, -8.7544322e-08, 1.00000024)
Weld15.Part0 = Part3
Weld15.Part1 = Part175
Weld15.part1 = Part175
Weld16.Name = "BTWeld"
Weld16.Parent = Part3
Weld16.C1 = CFrame.new(-0.568752289, -0.0312482715, 1.24358273, -5.98374754e-08, -1.00000024, 0, -1, 5.93718141e-08, 3.27925591e-07, -3.30370312e-07, -1.86264515e-09, -1.00000024)
Weld16.Part0 = Part3
Weld16.Part1 = Part433
Weld16.part1 = Part433
Weld17.Name = "BTWeld"
Weld17.Parent = Part3
Weld17.C1 = CFrame.new(1.7285347e-06, -0.568753242, -0.743589878, -1, 1.18976459e-07, 3.28123861e-07, -1.1944212e-07, -1.00000024, -8.94069672e-08, 3.30041075e-07, -8.7544322e-08, 1.00000024)
Weld17.Part0 = Part3
Weld17.Part1 = Part417
Weld17.part1 = Part417
Weld18.Name = "BTWeld"
Weld18.Parent = Part3
Weld18.C1 = CFrame.new(-3.09944153e-06, -0.364574432, -0.628859282, 1, 8.96397978e-08, 1.20697223e-07, -8.91741365e-08, 1.00000024, 1.78813934e-07, -1.1825432e-07, -1.78813934e-07, 1.00000024)
Weld18.Part0 = Part3
Weld18.Part1 = Part295
Weld18.part1 = Part295
Weld19.Name = "BTWeld"
Weld19.Parent = Part3
Weld19.C1 = CFrame.new(3.93390656e-06, -3.33387375, 1.42912102, -1, 2.08499841e-07, 7.08205334e-08, -1.35507435e-07, -0.838670611, 0.544639409, 1.75263267e-07, 0.544639468, 0.838670611)
Weld19.Part0 = Part3
Weld19.Part1 = Part165
Weld19.part1 = Part165
Weld20.Name = "BTWeld"
Weld20.Parent = Part3
Weld20.C1 = CFrame.new(1.78813934e-07, -3.38045502, 0.755048752, 1, 2.32830644e-10, -2.6903399e-07, -2.32830644e-10, -1.00000024, 8.7544322e-08, -2.71093086e-07, -9.12696123e-08, -1.00000024)
Weld20.Part0 = Part3
Weld20.Part1 = Part315
Weld20.part1 = Part315
Weld21.Name = "BTWeld"
Weld21.Parent = Part3
Weld21.C1 = CFrame.new(0.522247314, -0.031253159, 0.449784279, 2.578774e-06, -0.500000775, -0.866025329, 1, 2.96742655e-06, 1.26622399e-06, 1.93726737e-06, -0.866025329, 0.500000715)
Weld21.Part0 = Part3
Weld21.Part1 = Part457
Weld21.part1 = Part457
Weld22.Name = "BTWeld"
Weld22.Parent = Part3
Weld22.C1 = CFrame.new(-3.03983688e-06, -0.26757431, -0.628857851, 1, 8.96397978e-08, 1.20697223e-07, -8.91741365e-08, 1.00000024, 1.78813934e-07, -1.1825432e-07, -1.78813934e-07, 1.00000024)
Weld22.Part0 = Part3
Weld22.Part1 = Part363
Weld22.part1 = Part363
Weld23.Name = "BTWeld"
Weld23.Parent = Part3
Weld23.C1 = CFrame.new(-3.03983688e-06, 0.579193592, -0.519788742, 1, 2.08732672e-07, 7.35781214e-08, -9.66247171e-08, 0.707106471, -0.707107365, -1.97673216e-07, 0.707107365, 0.707106471)
Weld23.Part0 = Part3
Weld23.Part1 = Part429
Weld23.part1 = Part429
Weld24.Name = "BTWeld"
Weld24.Parent = Part3
Weld24.C1 = CFrame.new(3.57627869e-06, -2.7432127, -0.596743584, -1, 1.18976459e-07, 3.0064075e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.02987246e-07, -5.77419996e-08, 1.00000024)
Weld24.Part0 = Part3
Weld24.Part1 = Part253
Weld24.part1 = Part253
Weld25.Name = "BTWeld"
Weld25.Parent = Part3
Weld25.C1 = CFrame.new(-5.96046448e-08, -0.0365514755, -0.0244483948, -1, 2.08383426e-07, 3.34477591e-07, -3.4889672e-07, -0.866025686, -0.49999994, 1.87254045e-07, -0.499999881, 0.866025686)
Weld25.Part0 = Part3
Weld25.Part1 = Part383
Weld25.part1 = Part383
Weld26.Name = "BTWeld"
Weld26.Parent = Part3
Weld26.C1 = CFrame.new(0.0437097549, -0.0312481523, 1.49426508, -1.02329068e-07, -0.707107306, -0.707106531, -1, -1.1047814e-07, 2.52499376e-07, -2.57976353e-07, 0.70710659, -0.707107306)
Weld26.Part0 = Part3
Weld26.Part1 = Part289
Weld26.part1 = Part289
Weld27.Name = "BTWeld"
Weld27.Parent = Part3
Weld27.C1 = CFrame.new(-0.390325546, -0.0312492251, 0.188101292, 1.53668225e-07, 0.866025686, 0.5, -1, 1.49011612e-07, 4.73319233e-08, -3.19560058e-08, -0.49999994, 0.866025686)
Weld27.Part0 = Part3
Weld27.Part1 = Part465
Weld27.part1 = Part465
Weld28.Name = "BTWeld"
Weld28.Parent = Part3
Weld28.C1 = CFrame.new(3.69548798e-06, 1.39622211, 0.606865406, -1, -8.95233825e-08, 3.02316039e-08, -8.91741365e-08, 1.00000024, -8.94069672e-08, -3.26745067e-08, -9.12696123e-08, -1.00000024)
Weld28.Part0 = Part3
Weld28.Part1 = Part325
Weld28.part1 = Part325
Weld29.Name = "BTWeld"
Weld29.Parent = Part3
Weld29.C1 = CFrame.new(-3.03983688e-06, -0.0283536911, -0.593729019, 1, 8.95233825e-08, 4.61641321e-08, -6.54254109e-08, 0.923879802, -0.382683307, -7.52625056e-08, 0.382683337, 0.923879921)
Weld29.Part0 = Part3
Weld29.Part1 = Part435
Weld29.part1 = Part435
Weld30.Name = "BTWeld"
Weld30.Parent = Part3
Weld30.C1 = CFrame.new(-2.98023224e-06, 0.0857448578, -0.331493855, 1, 2.32830644e-10, 1.14778231e-09, 2.32830644e-10, 1.00000024, 1.86264515e-09, 1.14778231e-09, 1.86264515e-09, 1.00000024)
Weld30.Part0 = Part3
Weld30.Part1 = Part297
Weld30.part1 = Part297
Weld31.Name = "BTWeld"
Weld31.Parent = Part3
Weld31.C1 = CFrame.new(2.98023224e-06, 0.0857439041, 0.434119463, -1, -2.32830644e-10, -8.87230271e-08, 2.32830644e-10, 1.00000024, 1.86264515e-09, 8.63965397e-08, -1.86264515e-09, -1.00000024)
Weld31.Part0 = Part3
Weld31.Part1 = Part403
Weld31.part1 = Part403
Weld32.Name = "BTWeld"
Weld32.Parent = Part3
Weld32.C1 = CFrame.new(3.69548798e-06, -1.12822342, -0.591116667, -1, 1.18976459e-07, 3.0064075e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.02987246e-07, -5.77419996e-08, 1.00000024)
Weld32.Part0 = Part3
Weld32.Part1 = Part317
Weld32.part1 = Part317
Weld33.Name = "BTWeld"
Weld33.Parent = Part3
Weld33.C1 = CFrame.new(-3.57627869e-06, 1.17320824, 0.736830235, 1, -1.19092874e-07, 2.04781827e-07, -1.19325705e-07, -1.00000024, 2.68220901e-07, 2.03222953e-07, -2.68220901e-07, -1.00000024)
Weld33.Part0 = Part3
Weld33.Part1 = Part171
Weld33.part1 = Part171
Weld34.Name = "BTWeld"
Weld34.Parent = Part3
Weld34.C1 = CFrame.new(3.51667404e-06, -2.70561504, -1.06026649, -1, 1.18976459e-07, 3.69582267e-07, -1.82189979e-07, -0.984807968, -0.173648283, 3.45506123e-07, -0.173648298, 0.984807968)
Weld34.Part0 = Part3
Weld34.Part1 = Part251
Weld34.part1 = Part251
Weld35.Name = "BTWeld"
Weld35.Parent = Part3
Weld35.C1 = CFrame.new(0.568753242, -0.0312516689, 1.24358273, 1.1944212e-07, 1.00000024, 0, 1, -1.18976459e-07, -3.28123861e-07, -3.30370312e-07, -1.86264515e-09, -1.00000024)
Weld35.Part0 = Part3
Weld35.Part1 = Part443
Weld35.part1 = Part443
Weld36.Name = "BTWeld"
Weld36.Parent = Part3
Weld36.C1 = CFrame.new(-0.00166904926, -3.09995842, -0.665301085, -1, -2.32830644e-10, 6.22057996e-08, -1.16415322e-10, -1.00000024, -6.14672899e-08, 6.45686669e-08, -5.77419996e-08, 1.00000024)
Weld36.Part0 = Part3
Weld36.Part1 = Part243
Weld36.part1 = Part243
Weld37.Name = "BTWeld"
Weld37.Parent = Part3
Weld37.C1 = CFrame.new(-1.3257277, -0.0312492847, 5.10531425, 9.66574589e-08, 0.0174533594, 0.999847949, -1, 2.08499841e-07, 9.1315087e-08, -2.07335688e-07, -0.999847949, 0.0174533576)
Weld37.Part0 = Part3
Weld37.Part1 = Part191
Weld37.part1 = Part191
Weld38.Name = "BTWeld"
Weld38.Parent = Part3
Weld38.C1 = CFrame.new(2.98023224e-06, -0.520121574, 0.565322638, -1, 2.08499841e-07, -1.4426405e-08, 1.87777914e-07, 0.923879921, 0.382683069, 9.12114047e-08, 0.382683039, -0.923879921)
Weld38.Part0 = Part3
Weld38.Part1 = Part459
Weld38.part1 = Part459
Weld39.Name = "BTWeld"
Weld39.Parent = Part3
Weld39.C1 = CFrame.new(-2.44379044e-06, 1.62276363, -0.980819702, 1, -3.87430191e-07, 3.99177225e-08, -1.89582352e-07, -0.569997728, -0.821646571, 3.3993274e-07, 0.821646512, -0.569997668)
Weld39.Part0 = Part3
Weld39.Part1 = Part327
Weld39.part1 = Part327
Weld40.Name = "BTWeld"
Weld40.Parent = Part3
Weld40.C1 = CFrame.new(3.69548798e-06, -1.7807188, -0.638116598, -1, 1.18976459e-07, 3.0064075e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.02987246e-07, -5.77419996e-08, 1.00000024)
Weld40.Part0 = Part3
Weld40.Part1 = Part229
Weld40.part1 = Part229
Weld41.Name = "BTWeld"
Weld41.Parent = Part3
Weld41.C1 = CFrame.new(-2.98023224e-06, -0.170754433, -0.381493092, 1, 2.32830644e-10, 1.14778231e-09, 2.32830644e-10, 1.00000024, 1.86264515e-09, 1.14778231e-09, 1.86264515e-09, 1.00000024)
Weld41.Part0 = Part3
Weld41.Part1 = Part469
Weld41.part1 = Part469
Weld42.Name = "BTWeld"
Weld42.Parent = Part3
Weld42.C1 = CFrame.new(1.7285347e-06, -0.568753242, -0.743589878, -1, 1.18976459e-07, 3.28123861e-07, -1.1944212e-07, -1.00000024, -8.94069672e-08, 3.30041075e-07, -8.7544322e-08, 1.00000024)
Weld42.Part0 = Part3
Weld42.Part1 = Part169
Weld42.part1 = Part169
Weld43.Name = "BTWeld"
Weld43.Parent = Part3
Weld43.C1 = CFrame.new(1.84774399e-06, -0.227245331, -0.390619993, -1, 1.18976459e-07, 3.56074452e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.58400939e-07, -5.77419996e-08, 1.00000024)
Weld43.Part0 = Part3
Weld43.Part1 = Part463
Weld43.part1 = Part463
Weld44.Name = "BTWeld"
Weld44.Parent = Part3
Weld44.C1 = CFrame.new(-1.84774399e-06, 0.916108131, -0.790865183, 1, -5.93718141e-08, 2.56368367e-08, 5.97210601e-08, 1.00000024, 5.96046448e-08, -2.29756552e-08, -5.77419996e-08, 1.00000024)
Weld44.Part0 = Part3
Weld44.Part1 = Part411
Weld44.part1 = Part411
Weld45.Name = "BTWeld"
Weld45.Parent = Part3
Weld45.C1 = CFrame.new(3.75509262e-06, -2.08321857, -0.731868029, -1, 1.18976459e-07, 3.0064075e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.02987246e-07, -5.77419996e-08, 1.00000024)
Weld45.Part0 = Part3
Weld45.Part1 = Part475
Weld45.part1 = Part475
Weld46.Name = "BTWeld"
Weld46.Parent = Part3
Weld46.C1 = CFrame.new(0.00166875124, 3.12339592, -0.606613398, 1, -1.18976459e-07, -6.2136678e-08, 1.1944212e-07, 1.00000024, -8.94069672e-08, 6.48051355e-08, 9.12696123e-08, 1.00000024)
Weld46.Part0 = Part3
Weld46.Part1 = Part473
Weld46.part1 = Part473
Weld47.Name = "BTWeld"
Weld47.Parent = Part3
Weld47.C1 = CFrame.new(-0.246384621, -0.03125, 0.315700531, 8.35862011e-08, -0.965926051, 0.258819014, 1, 6.17001206e-08, -9.08512447e-08, 7.39237294e-08, 0.258818984, 0.965926111)
Weld47.Part0 = Part3
Weld47.Part1 = Part355
Weld47.part1 = Part355
Weld48.Name = "BTWeld"
Weld48.Parent = Part3
Weld48.C1 = CFrame.new(2.74181366e-06, 0.908480644, 0.621105194, -1, 3.87430191e-07, -2.68737494e-08, -1.25437509e-07, -0.382683992, -0.923879504, -3.67756002e-07, -0.923879564, 0.382684022)
Weld48.Part0 = Part3
Weld48.Part1 = Part341
Weld48.part1 = Part341
Weld49.Name = "BTWeld"
Weld49.Parent = Part3
Weld49.C1 = CFrame.new(1.96695328e-06, -0.43809557, 0.254676819, -1, 2.08499841e-07, 8.61909939e-08, -8.48667696e-08, -0.707106531, 0.707107365, 2.10478902e-07, 0.707107365, 0.707106471)
Weld49.Part0 = Part3
Weld49.Part1 = Part269
Weld49.part1 = Part269
Weld50.Name = "BTWeld"
Weld50.Parent = Part3
Weld50.C1 = CFrame.new(1.32572746, -0.0312505364, 5.10531616, -1.84201781e-07, -0.0174533594, -0.999847949, 1, -2.08499841e-07, -1.78890332e-07, -2.05705874e-07, -0.999847949, 0.0174533576)
Weld50.Part0 = Part3
Weld50.Part1 = Part379
Weld50.part1 = Part379
Weld51.Name = "BTWeld"
Weld51.Parent = Part3
Weld51.C1 = CFrame.new(1.7285347e-06, -0.242359161, -0.146375895, -1, 2.08499841e-07, 2.3712164e-07, -2.08849087e-07, -1.00000024, 0, 2.39566361e-07, 1.86264515e-09, 1.00000024)
Weld51.Part0 = Part3
Weld51.Part1 = Part455
Weld51.part1 = Part455
Weld52.Name = "BTWeld"
Weld52.Parent = Part3
Weld52.C1 = CFrame.new(-3.03983688e-06, -0.143110275, -0.641388893, 1, 8.95233825e-08, 7.0387614e-08, -6.88014552e-08, 0.96592617, -0.258818775, -8.91450327e-08, 0.258818746, 0.96592623)
Weld52.Part0 = Part3
Weld52.Part1 = Part453
Weld52.part1 = Part453
Weld53.Name = "BTWeld"
Weld53.Parent = Part3
Weld53.C1 = CFrame.new(1.84774399e-06, -0.316618919, -0.362743855, -1, 1.18976459e-07, 3.56074452e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.58400939e-07, -5.77419996e-08, 1.00000024)
Weld53.Part0 = Part3
Weld53.Part1 = Part425
Weld53.part1 = Part425
Weld54.Name = "BTWeld"
Weld54.Parent = Part3
Weld54.C1 = CFrame.new(-2.44379044e-06, 3.96811485, 0.642149091, 1, -2.08499841e-07, 1.92838343e-07, -1.85798854e-07, -0.993572116, -0.113202929, 2.13360181e-07, 0.113202937, -0.993572235)
Weld54.Part0 = Part3
Weld54.Part1 = Part241
Weld54.part1 = Part241
Weld55.Name = "BTWeld"
Weld55.Parent = Part3
Weld55.C1 = CFrame.new(-2.08616257e-06, 0.207164764, -0.535107613, 1, 2.08732672e-07, 7.35781214e-08, -2.08383426e-07, 1.00000024, 1.78813934e-07, -7.12225301e-08, -1.76951289e-07, 1.00000024)
Weld55.Part0 = Part3
Weld55.Part1 = Part321
Weld55.part1 = Part321
Weld56.Name = "BTWeld"
Weld56.Parent = Part3
Weld56.C1 = CFrame.new(0.3903265, -0.0312507153, 0.188101292, -2.43075192e-07, -0.866025627, -0.5, 1, -2.29571015e-07, -8.65911716e-08, -3.80096026e-08, -0.49999994, 0.866025686)
Weld56.Part0 = Part3
Weld56.Part1 = Part449
Weld56.part1 = Part449
Weld57.Name = "BTWeld"
Weld57.Parent = Part3
Weld57.C1 = CFrame.new(4.0832634, -0.0312500596, 2.68361759, -3.40398401e-07, -0.719340265, -0.694658279, 1, -3.15834768e-07, -1.60429408e-07, -1.03143975e-07, -0.694658279, 0.719340265)
Weld57.Part0 = Part3
Weld57.Part1 = Part261
Weld57.part1 = Part261
Weld58.Name = "BTWeld"
Weld58.Parent = Part3
Weld58.C1 = CFrame.new(3.87430191e-06, -2.97136497, -1.32431102, -1, 1.19092874e-07, 2.00954673e-07, -1.67870894e-07, -0.965925992, -0.258819073, 1.64814992e-07, -0.258819073, 0.965926111)
Weld58.Part0 = Part3
Weld58.Part1 = Part367
Weld58.part1 = Part367
Weld59.Name = "BTWeld"
Weld59.Parent = Part3
Weld59.C1 = CFrame.new(-3.21865082e-06, -0.0555143356, 0.74919796, 1, 2.08732672e-07, 1.05254003e-07, 7.4505806e-08, -0.707106292, 0.707107484, 2.20257789e-07, -0.707107544, -0.707106352)
Weld59.Part0 = Part3
Weld59.Part1 = Part179
Weld59.part1 = Part179
Weld60.Name = "BTWeld"
Weld60.Parent = Part3
Weld60.C1 = CFrame.new(0.854812145, -0.0312569141, 0.683163643, -7.71833584e-08, 0.707106531, -0.707107306, 1, 1.8987339e-07, 8.20728019e-08, 1.90921128e-07, -0.707107365, -0.707106531)
Weld60.Part0 = Part3
Weld60.Part1 = Part437
Weld60.part1 = Part437
Weld61.Name = "BTWeld"
Weld61.Parent = Part3
Weld61.C1 = CFrame.new(1.84774399e-06, -0.363491058, -0.331495762, -1, 1.18976459e-07, 3.56074452e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.58400939e-07, -5.77419996e-08, 1.00000024)
Weld61.Part0 = Part3
Weld61.Part1 = Part365
Weld61.part1 = Part365
Weld62.Name = "BTWeld"
Weld62.Parent = Part3
Weld62.C1 = CFrame.new(-5.96046448e-08, -0.251069069, 0.0857863426, -1, 2.08499841e-07, 1.84947567e-07, -1.53202564e-07, -0.965926051, 0.258819163, 2.35246262e-07, 0.258819163, 0.96592617)
Weld62.Part0 = Part3
Weld62.Part1 = Part423
Weld62.part1 = Part423
Weld63.Name = "BTWeld"
Weld63.Parent = Part3
Weld63.C1 = CFrame.new(2.92062759e-06, 0.530877113, 0.384551048, -1, -2.32830644e-10, 1.16708179e-07, -1.19271135e-07, -1.01514161e-06, -1.00000024, -1.16415322e-10, -1.00000024, 1.01141632e-06)
Weld63.Part0 = Part3
Weld63.Part1 = Part421
Weld63.part1 = Part421
Weld64.Name = "BTWeld"
Weld64.Parent = Part3
Weld64.C1 = CFrame.new(3.81469727e-06, -1.63659573, -0.658368826, -1, 2.08499841e-07, 1.81222276e-07, -2.08849087e-07, -1.00000024, 0, 1.83687007e-07, 1.86264515e-09, 1.00000024)
Weld64.Part0 = Part3
Weld64.Part1 = Part391
Weld64.part1 = Part391
Weld65.Name = "BTWeld"
Weld65.Parent = Part3
Weld65.C1 = CFrame.new(3.93390656e-06, -2.9557457, -1.37312269, -1, 1.19092874e-07, 2.00954673e-07, -1.67870894e-07, -0.965925992, -0.258819073, 1.64814992e-07, -0.258819073, 0.965926111)
Weld65.Part0 = Part3
Weld65.Part1 = Part419
Weld65.part1 = Part419
Weld66.Name = "BTWeld"
Weld66.Parent = Part3
Weld66.C1 = CFrame.new(-2.98023224e-07, 3.86712265, 0.467648745, 1, -2.08499841e-07, 1.92838343e-07, -1.85798854e-07, -0.993572116, -0.113202929, 2.13360181e-07, 0.113202937, -0.993572235)
Weld66.Part0 = Part3
Weld66.Part1 = Part415
Weld66.part1 = Part415
Weld67.Name = "BTWeld"
Weld67.Parent = Part3
Weld67.C1 = CFrame.new(-2.02655792e-06, 0.114692688, -0.875624657, 1, 2.08732672e-07, 7.35781214e-08, -2.19908543e-07, 0.965926111, 0.258818954, -1.55705493e-08, -0.258818954, 0.96592617)
Weld67.Part0 = Part3
Weld67.Part1 = Part193
Weld67.part1 = Part193
Weld68.Name = "BTWeld"
Weld68.Parent = Part3
Weld68.C1 = CFrame.new(1.84774399e-06, -0.820864677, -0.453119278, -1, 1.18976459e-07, 3.0064075e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.02987246e-07, -5.77419996e-08, 1.00000024)
Weld68.Part0 = Part3
Weld68.Part1 = Part447
Weld68.part1 = Part447
Weld69.Name = "BTWeld"
Weld69.Parent = Part3
Weld69.C1 = CFrame.new(1.84774399e-06, -0.879114151, -0.453119278, -1, 1.18976459e-07, 3.0064075e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.02987246e-07, -5.77419996e-08, 1.00000024)
Weld69.Part0 = Part3
Weld69.Part1 = Part329
Weld69.part1 = Part329
Weld70.Name = "BTWeld"
Weld70.Parent = Part3
Weld70.C1 = CFrame.new(-3.09944153e-06, 2.06479263, 0.744927168, 1, -1.19092874e-07, 2.05247488e-07, -1.07684173e-07, -0.998391926, -0.0566923842, 2.10064172e-07, 0.0566923767, -0.998391867)
Weld70.Part0 = Part3
Weld70.Part1 = Part213
Weld70.part1 = Part213
Weld71.Name = "BTWeld"
Weld71.Parent = Part3
Weld71.C1 = CFrame.new(-4.0832634, -0.0312493443, 2.68361759, 2.50991434e-07, 0.719340265, 0.694658279, -1, 2.34693289e-07, 1.15569492e-07, -7.84639269e-08, -0.694658279, 0.719340265)
Weld71.Part0 = Part3
Weld71.Part1 = Part257
Weld71.part1 = Part257
Weld72.Name = "BTWeld"
Weld72.Parent = Part3
Weld72.C1 = CFrame.new(1.84774399e-06, -0.227245331, -0.390619993, -1, 1.18976459e-07, 3.56074452e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.58400939e-07, -5.77419996e-08, 1.00000024)
Weld72.Part0 = Part3
Weld72.Part1 = Part173
Weld72.part1 = Part173
Weld73.Name = "BTWeld"
Weld73.Parent = Part3
Weld73.C1 = CFrame.new(2.86102295e-06, 0.835924149, -0.142241955, -1, 3.27709131e-07, -1.37008101e-07, -1.36438757e-07, -0.707107067, -0.707106829, -3.27592716e-07, -0.707106769, 0.707107008)
Weld73.Part0 = Part3
Weld73.Part1 = Part361
Weld73.part1 = Part361
Weld74.Name = "BTWeld"
Weld74.Parent = Part3
Weld74.C1 = CFrame.new(-0.00166893005, 2.82995987, 0.726299524, -1, 1.18976459e-07, 1.49711923e-07, 1.1944212e-07, 1.00000024, 0, -1.52022039e-07, -1.86264515e-09, -1.00000024)
Weld74.Part0 = Part3
Weld74.Part1 = Part377
Weld74.part1 = Part377
Weld75.Name = "BTWeld"
Weld75.Parent = Part3
Weld75.C1 = CFrame.new(1.7285347e-06, 0.0122146606, -1.26963711, -1, -2.32830644e-10, 3.04902642e-07, -2.17230991e-07, -0.707107246, -0.70710665, 2.16532499e-07, -0.70710665, 0.707107186)
Weld75.Part0 = Part3
Weld75.Part1 = Part283
Weld75.part1 = Part283
Weld76.Name = "BTWeld"
Weld76.Parent = Part3
Weld76.C1 = CFrame.new(-2.86102295e-06, -0.724999189, 0.384550095, 1, -1.19092874e-07, -4.21059667e-08, 4.47653292e-08, 1.01514161e-06, 1.00000024, -1.19325705e-07, -1.00000024, 1.01327896e-06)
Weld76.Part0 = Part3
Weld76.Part1 = Part291
Weld76.part1 = Part291
Weld77.Name = "BTWeld"
Weld77.Parent = Part3
Weld77.C1 = CFrame.new(-8.94069672e-07, 4.09370422, 0.476376891, 1, -5.93718141e-08, 2.00789145e-07, -3.6903657e-08, -0.993572116, -0.113202639, 2.04046955e-07, 0.113202639, -0.993572235)
Weld77.Part0 = Part3
Weld77.Part1 = Part395
Weld77.part1 = Part395
Weld78.Name = "BTWeld"
Weld78.Parent = Part3
Weld78.C1 = CFrame.new(2.92062759e-06, -0.468894958, 0.574460983, -1, 2.08499841e-07, -3.86498868e-08, 1.92318112e-07, 0.965926051, 0.258818746, 8.94651748e-08, 0.258818746, -0.965926111)
Weld78.Part0 = Part3
Weld78.Part1 = Part451
Weld78.part1 = Part451
Weld79.Name = "BTWeld"
Weld79.Parent = Part3
Weld79.C1 = CFrame.new(1.90734863e-06, 0.962981224, 0.66424036, -1, 5.93718141e-08, 6.19384082e-08, 5.98374754e-08, 1.00000024, -8.94069672e-08, -6.48051355e-08, -9.12696123e-08, -1.00000024)
Weld79.Part0 = Part3
Weld79.Part1 = Part203
Weld79.part1 = Part203
Weld80.Name = "BTWeld"
Weld80.Parent = Part3
Weld80.C1 = CFrame.new(-1.93451118, -0.0312488079, -0.270594597, 1.53435394e-07, 0.998629808, 0.0523359701, -1, 1.53202564e-07, 4.08908818e-09, -2.91402102e-09, -0.0523359627, 0.998629689)
Weld80.Part0 = Part3
Weld80.Part1 = Part397
Weld80.part1 = Part397
Weld81.Name = "BTWeld"
Weld81.Parent = Part3
Weld81.C1 = CFrame.new(-1.90734863e-06, 0.382622719, -0.453119993, 1, 2.32830644e-10, 1.14778231e-09, 2.32830644e-10, 1.00000024, 1.86264515e-09, 1.14778231e-09, 1.86264515e-09, 1.00000024)
Weld81.Part0 = Part3
Weld81.Part1 = Part237
Weld81.part1 = Part237
Weld82.Name = "BTWeld"
Weld82.Parent = Part3
Weld82.C1 = CFrame.new(-1.90734863e-06, 1.7890873, 3.13711452, 1, 2.68220901e-07, 1.37593815e-07, 9.1502443e-08, -0.700908601, 0.713251352, 2.86381692e-07, -0.713251412, -0.700908601)
Weld82.Part0 = Part3
Weld82.Part1 = Part373
Weld82.part1 = Part373
Weld83.Name = "BTWeld"
Weld83.Parent = Part3
Weld83.C1 = CFrame.new(-3.57627869e-06, 1.17321014, 0.911328077, 1, -1.19092874e-07, 2.04781827e-07, -1.19325705e-07, -1.00000024, 2.68220901e-07, 2.03222953e-07, -2.68220901e-07, -1.00000024)
Weld83.Part0 = Part3
Weld83.Part1 = Part163
Weld83.part1 = Part163
Weld84.Name = "BTWeld"
Weld84.Parent = Part3
Weld84.C1 = CFrame.new(1.7285347e-06, -0.568753242, -0.743589878, -1, 1.18976459e-07, 3.28123861e-07, -1.1944212e-07, -1.00000024, -8.94069672e-08, 3.30041075e-07, -8.7544322e-08, 1.00000024)
Weld84.Part0 = Part3
Weld84.Part1 = Part281
Weld84.part1 = Part281
Weld85.Name = "BTWeld"
Weld85.Parent = Part3
Weld85.C1 = CFrame.new(-4.17232513e-07, 4.000597, -2.49560165, 1, -3.27709131e-07, 1.59834599e-07, -1.16531737e-07, -0.700910211, -0.713249803, 3.44938599e-07, 0.713249862, -0.700910151)
Weld85.Part0 = Part3
Weld85.Part1 = Part345
Weld85.part1 = Part345
Weld86.Name = "BTWeld"
Weld86.Parent = Part3
Weld86.C1 = CFrame.new(1.78813934e-06, -0.568753242, -1.01896238, -1, 1.18976459e-07, 3.28123861e-07, -1.1944212e-07, -1.00000024, -8.94069672e-08, 3.30041075e-07, -8.7544322e-08, 1.00000024)
Weld86.Part0 = Part3
Weld86.Part1 = Part399
Weld86.part1 = Part399
Weld87.Name = "BTWeld"
Weld87.Parent = Part3
Weld87.C1 = CFrame.new(3.69548798e-06, -2.28520775, -0.633616686, -1, 1.18976459e-07, 3.0064075e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.02987246e-07, -5.77419996e-08, 1.00000024)
Weld87.Part0 = Part3
Weld87.Part1 = Part199
Weld87.part1 = Part199
Weld88.Name = "BTWeld"
Weld88.Parent = Part3
Weld88.C1 = CFrame.new(1.78813934e-06, -0.829603195, -0.33899641, -1, 2.08499841e-07, 1.81222276e-07, -2.08849087e-07, -1.00000024, 0, 1.83687007e-07, 1.86264515e-09, 1.00000024)
Weld88.Part0 = Part3
Weld88.Part1 = Part219
Weld88.part1 = Part219
Weld89.Name = "BTWeld"
Weld89.Parent = Part3
Weld89.C1 = CFrame.new(-3.33786011e-06, -0.0132074356, 0.994934082, 1, 2.32830644e-10, 2.04248863e-07, -5.65778464e-08, -0.960049927, 0.279829443, 1.94384484e-07, -0.279829443, -0.960049987)
Weld89.Part0 = Part3
Weld89.Part1 = Part1
Weld89.part1 = Part1
Weld90.Name = "BTWeld"
Weld90.Parent = Part3
Weld90.C1 = CFrame.new(1.96695328e-06, 0.916108131, 0.907114267, -1, 5.93718141e-08, 6.19384082e-08, 5.98374754e-08, 1.00000024, -8.94069672e-08, -6.48051355e-08, -9.12696123e-08, -1.00000024)
Weld90.Part0 = Part3
Weld90.Part1 = Part275
Weld90.part1 = Part275
Weld91.Name = "BTWeld"
Weld91.Parent = Part3
Weld91.C1 = CFrame.new(-1.7285347e-06, -1.12285709, 0.789239883, 1, 2.32830644e-10, -1.49781044e-07, -1.16415322e-10, -1.00000024, -6.14672899e-08, -1.52112989e-07, 5.77419996e-08, -1.00000024)
Weld91.Part0 = Part3
Weld91.Part1 = Part233
Weld91.part1 = Part233
Weld92.Name = "BTWeld"
Weld92.Parent = Part3
Weld92.C1 = CFrame.new(3.03983688e-06, 0.303620577, 0.382497787, -1, -2.08732672e-07, 1.17877789e-07, -1.20393452e-07, -1.19395554e-06, -1.00000024, 2.08499841e-07, -1.00000024, 1.1920929e-06)
Weld92.Part0 = Part3
Weld92.Part1 = Part221
Weld92.part1 = Part221
Weld93.Name = "BTWeld"
Weld93.Parent = Part3
Weld93.C1 = CFrame.new(-0.522247314, -0.0312470198, 0.449783325, -2.65327981e-06, 0.500000775, 0.866025329, -1, -2.96032522e-06, -1.35692608e-06, 1.88592821e-06, -0.866025269, 0.500000715)
Weld93.Part0 = Part3
Weld93.Part1 = Part467
Weld93.part1 = Part467
Weld94.Name = "BTWeld"
Weld94.Parent = Part3
Weld94.C1 = CFrame.new(-3.4570694e-06, 1.39806747, 0.593937159, 1, -1.19092874e-07, 2.05247488e-07, -1.07684173e-07, -0.998391926, -0.0566924736, 2.09929567e-07, 0.0566924661, -0.998391867)
Weld94.Part0 = Part3
Weld94.Part1 = Part339
Weld94.part1 = Part339
Weld95.Name = "BTWeld"
Weld95.Parent = Part3
Weld95.C1 = CFrame.new(0.795685768, -0.0312509537, -0.711493969, -8.45175236e-08, -0.932008028, 0.362438083, 1, -8.89413059e-08, 5.51335688e-09, 2.98023224e-08, 0.362438083, 0.932008028)
Weld95.Part0 = Part3
Weld95.Part1 = Part401
Weld95.part1 = Part401
Weld96.Name = "BTWeld"
Weld96.Parent = Part3
Weld96.C1 = CFrame.new(3.93390656e-06, -1.17022419, -0.44987011, -1, 2.08499841e-07, 1.81222276e-07, -2.08849087e-07, -1.00000024, 0, 1.83687007e-07, 1.86264515e-09, 1.00000024)
Weld96.Part0 = Part3
Weld96.Part1 = Part409
Weld96.part1 = Part409
Weld97.Name = "BTWeld"
Weld97.Parent = Part3
Weld97.C1 = CFrame.new(-2.92062759e-06, 2.3621769, 0.817341089, 1, -1.19092874e-07, 1.99657734e-07, -1.07917003e-07, -0.998391926, -0.0566924736, 2.04341632e-07, 0.0566924661, -0.998391867)
Weld97.Part0 = Part3
Weld97.Part1 = Part381
Weld97.part1 = Part381
Weld98.Name = "BTWeld"
Weld98.Parent = Part3
Weld98.C1 = CFrame.new(-0.431774139, -0.0312498212, 0.503154755, 7.72997737e-08, -0.70710665, 0.707107186, 1, 2.03726813e-08, -8.74406396e-08, 4.88944352e-08, 0.707107186, 0.70710665)
Weld98.Part0 = Part3
Weld98.Part1 = Part431
Weld98.part1 = Part431
Weld99.Name = "BTWeld"
Weld99.Parent = Part3
Weld99.C1 = CFrame.new(-3.15904617e-06, 0.420814514, 0.987199306, 1, -1.18976459e-07, 2.12703526e-07, -1.42492354e-07, -0.993572056, 0.1132036, 1.96479959e-07, -0.113203593, -0.993572116)
Weld99.Part0 = Part3
Weld99.Part1 = Part215
Weld99.part1 = Part215
Weld100.Name = "BTWeld"
Weld100.Parent = Part3
Weld100.C1 = CFrame.new(1.66893005e-06, -0.394741058, -0.312496424, -1, 1.18976459e-07, 3.56074452e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.58400939e-07, -5.77419996e-08, 1.00000024)
Weld100.Part0 = Part3
Weld100.Part1 = Part231
Weld100.part1 = Part231
Weld101.Name = "BTWeld"
Weld101.Parent = Part3
Weld101.C1 = CFrame.new(0.431774139, -0.0312502384, 0.503154755, 1.21071935e-08, 0.70710665, -0.707107186, -1, 2.66591087e-08, 8.21273716e-09, 2.63098627e-08, 0.707107186, 0.70710665)
Weld101.Part0 = Part3
Weld101.Part1 = Part195
Weld101.part1 = Part195
Weld102.Name = "BTWeld"
Weld102.Parent = Part3
Weld102.C1 = CFrame.new(-2.98023224e-06, 0.52676487, 0.681500196, 1, -1.18976459e-07, 2.07579433e-07, -1.19325705e-07, -1.00000024, 3.57627869e-07, 2.05687684e-07, -3.57627869e-07, -1.00000024)
Weld102.Part0 = Part3
Weld102.Part1 = Part247
Weld102.part1 = Part247
Weld103.Name = "BTWeld"
Weld103.Parent = Part3
Weld103.C1 = CFrame.new(-3.33786011e-06, -0.982596397, -1.40651131, 1, 2.08732672e-07, -4.8930815e-10, -1.93249434e-07, 0.922201157, -0.386711091, -7.82310963e-08, 0.386711091, 0.922201216)
Weld103.Part0 = Part3
Weld103.Part1 = Part307
Weld103.part1 = Part307
Weld104.Name = "BTWeld"
Weld104.Parent = Part3
Weld104.C1 = CFrame.new(-0.0437107086, -0.0312517285, 1.4942646, 1.91503204e-07, 0.707107306, 0.70710659, 1, 2.29338184e-08, -2.9189323e-07, -2.23633833e-07, 0.707106531, -0.707107246)
Weld104.Part0 = Part3
Weld104.Part1 = Part259
Weld104.part1 = Part259
Weld105.Name = "BTWeld"
Weld105.Parent = Part3
Weld105.C1 = CFrame.new(3.87430191e-06, -3.31824732, 1.47011757, -1, 2.08499841e-07, 7.08205334e-08, -1.35507435e-07, -0.838670611, 0.544639409, 1.75263267e-07, 0.544639468, 0.838670611)
Weld105.Part0 = Part3
Weld105.Part1 = Part407
Weld105.part1 = Part407
Weld106.Name = "BTWeld"
Weld106.Parent = Part3
Weld106.C1 = CFrame.new(-0.795685768, -0.0312490463, -0.711493969, -4.88944352e-09, 0.932008028, -0.362438083, -1, 1.22236088e-08, 4.33428795e-08, 4.74974513e-08, 0.362438083, 0.932008028)
Weld106.Part0 = Part3
Weld106.Part1 = Part263
Weld106.part1 = Part263
Weld107.Name = "BTWeld"
Weld107.Parent = Part3
Weld107.C1 = CFrame.new(-3.69548798e-06, -3.00638485, 1.33266807, 1, -1.18976459e-07, -3.95668394e-07, -1.86846592e-07, -0.984807968, -0.173648164, -3.70942871e-07, 0.173648179, -0.984807909)
Weld107.Part0 = Part3
Weld107.Part1 = Part351
Weld107.part1 = Part351
Weld108.Name = "BTWeld"
Weld108.Parent = Part3
Weld108.C1 = CFrame.new(3.63588333e-06, -0.320664406, -1.40051842, -1, -2.32830644e-10, 3.04902642e-07, -2.17230991e-07, -0.707107246, -0.70710665, 2.16532499e-07, -0.70710665, 0.707107186)
Weld108.Part0 = Part3
Weld108.Part1 = Part331
Weld108.part1 = Part331
Weld109.Name = "BTWeld"
Weld109.Parent = Part3
Weld109.C1 = CFrame.new(4.17232513e-07, 0.449201822, 1.99047565, -1, 4.76720743e-07, 8.52196536e-08, -6.01830834e-08, 0.0566915721, -0.998391926, -4.81144525e-07, -0.998391926, -0.0566915721)
Weld109.Part0 = Part3
Weld109.Part1 = Part187
Weld109.part1 = Part187
Weld110.Name = "BTWeld"
Weld110.Parent = Part3
Weld110.C1 = CFrame.new(-2.86102295e-06, 2.36217117, 0.642843485, 1, -1.19092874e-07, 1.99657734e-07, -1.07800588e-07, -0.998391807, -0.0566924661, 2.0434527e-07, 0.0566924587, -0.998391867)
Weld110.Part0 = Part3
Weld110.Part1 = Part239
Weld110.part1 = Part239
Weld111.Name = "BTWeld"
Weld111.Parent = Part3
Weld111.C1 = CFrame.new(-3.64600945, -0.0312488079, -0.13107121, 1.57626346e-07, 0.994522154, 0.104528487, -1, 1.56695023e-07, 1.25419319e-08, -2.27009878e-09, -0.104528494, 0.994522214)
Weld111.Part0 = Part3
Weld111.Part1 = Part293
Weld111.part1 = Part293
Weld112.Name = "BTWeld"
Weld112.Parent = Part3
Weld112.C1 = CFrame.new(-1.84774399e-06, -0.363490105, 0.43412137, 1, -1.19092874e-07, -2.68964868e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, -2.71322278e-07, 5.77419996e-08, -1.00000024)
Weld112.Part0 = Part3
Weld112.Part1 = Part387
Weld112.part1 = Part387
Weld113.Name = "BTWeld"
Weld113.Parent = Part3
Weld113.C1 = CFrame.new(1.7285347e-06, -0.568753242, -0.743589878, -1, 1.18976459e-07, 3.28123861e-07, -1.1944212e-07, -1.00000024, -8.94069672e-08, 3.30041075e-07, -8.7544322e-08, 1.00000024)
Weld113.Part0 = Part3
Weld113.Part1 = Part471
Weld113.part1 = Part471
Weld114.Name = "BTWeld"
Weld114.Parent = Part3
Weld114.C1 = CFrame.new(5.96046448e-08, 0.289498925, 3.66633129, -1, 4.76720743e-07, 1.08511813e-07, -5.57629392e-08, 0.113202013, -0.993572295, -4.86383215e-07, -0.993572235, -0.113202013)
Weld114.Part0 = Part3
Weld114.Part1 = Part301
Weld114.part1 = Part301
Weld115.Name = "BTWeld"
Weld115.Parent = Part3
Weld115.C1 = CFrame.new(3.75509262e-06, -2.22058773, -0.638116837, -1, 2.08499841e-07, 1.81222276e-07, -2.08849087e-07, -1.00000024, 0, 1.83687007e-07, 1.86264515e-09, 1.00000024)
Weld115.Part0 = Part3
Weld115.Part1 = Part389
Weld115.part1 = Part389
Weld116.Name = "BTWeld"
Weld116.Parent = Part3
Weld116.C1 = CFrame.new(-3.03983688e-06, 0.552669525, 1.01939201, 1, 2.32830644e-10, 1.78628397e-07, -6.84522092e-08, -0.922201097, 0.386711597, 1.62399374e-07, -0.386711597, -0.922201097)
Weld116.Part0 = Part3
Weld116.Part1 = Part255
Weld116.part1 = Part255
Weld117.Name = "BTWeld"
Weld117.Parent = Part3
Weld117.C1 = CFrame.new(-3.75509262e-06, -3.10320187, 0.522767544, 1, -1.19092874e-07, -3.84490704e-07, -8.49831849e-08, -0.996194959, 0.0871557072, -3.95724783e-07, -0.0871557146, -0.996194959)
Weld117.Part0 = Part3
Weld117.Part1 = Part299
Weld117.part1 = Part299
Weld118.Name = "BTWeld"
Weld118.Parent = Part3
Weld118.C1 = CFrame.new(-4.76837158e-07, -2.59509277, 3.90086365, -1, 3.87430191e-07, 3.84452505e-07, 5.47152013e-09, 0.713250041, -0.700909913, -5.47152013e-07, -0.700909972, -0.713250101)
Weld118.Part0 = Part3
Weld118.Part1 = Part461
Weld118.part1 = Part461
Weld119.Name = "BTWeld"
Weld119.Parent = Part3
Weld119.C1 = CFrame.new(-3.4570694e-06, 3.23180103, 0.775444984, 1, -1.19092874e-07, 2.05247488e-07, -1.07567757e-07, -0.998391926, -0.056692116, 2.10009603e-07, 0.0566921085, -0.998391867)
Weld119.Part0 = Part3
Weld119.Part1 = Part349
Weld119.part1 = Part349
Weld120.Name = "BTWeld"
Weld120.Parent = Part3
Weld120.C1 = CFrame.new(-0.854813099, -0.0312469006, 0.683163643, 1.75787136e-08, -0.707106531, 0.707107306, -1, -9.8021701e-08, -7.47404556e-08, 1.20606273e-07, -0.707107365, -0.707106531)
Weld120.Part0 = Part3
Weld120.Part1 = Part217
Weld120.part1 = Part217
Weld121.Name = "BTWeld"
Weld121.Parent = Part3
Weld121.C1 = CFrame.new(8.94069672e-07, 0.388443947, 0.0130519867, -1, 2.08383426e-07, 3.34477591e-07, -3.4889672e-07, -0.866025686, -0.49999994, 1.87254045e-07, -0.499999881, 0.866025686)
Weld121.Part0 = Part3
Weld121.Part1 = Part393
Weld121.part1 = Part393
Weld122.Name = "BTWeld"
Weld122.Parent = Part3
Weld122.C1 = CFrame.new(1.84774399e-06, -1.088727, -0.591116905, -1, 1.18976459e-07, 3.0064075e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.02987246e-07, -5.77419996e-08, 1.00000024)
Weld122.Part0 = Part3
Weld122.Part1 = Part287
Weld122.part1 = Part287
Weld123.Name = "BTWeld"
Weld123.Parent = Part3
Weld123.C1 = CFrame.new(-2.98023224e-06, 0.291165352, -0.776105642, 1, 2.08732672e-07, 7.35781214e-08, -2.08383426e-07, 1.00000024, 1.78813934e-07, -7.12225301e-08, -1.76951289e-07, 1.00000024)
Weld123.Part0 = Part3
Weld123.Part1 = Part235
Weld123.part1 = Part235
Weld124.Name = "BTWeld"
Weld124.Parent = Part3
Weld124.C1 = CFrame.new(-1.78813934e-06, -0.316618919, 0.434119701, 1, -1.19092874e-07, -2.68964868e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, -2.71322278e-07, 5.77419996e-08, -1.00000024)
Weld124.Part0 = Part3
Weld124.Part1 = Part227
Weld124.part1 = Part227
Weld125.Name = "BTWeld"
Weld125.Parent = Part3
Weld125.C1 = CFrame.new(1.7285347e-06, -0.568753242, -0.743589878, -1, 1.18976459e-07, 3.28123861e-07, -1.1944212e-07, -1.00000024, -8.94069672e-08, 3.30041075e-07, -8.7544322e-08, 1.00000024)
Weld125.Part0 = Part3
Weld125.Part1 = Part375
Weld125.part1 = Part375
Weld126.Name = "BTWeld"
Weld126.Parent = Part3
Weld126.C1 = CFrame.new(1.1920929e-06, 0.194246531, 0.194999695, -1, -2.08732672e-07, 1.17877789e-07, -1.20393452e-07, -1.19395554e-06, -1.00000024, 2.08499841e-07, -1.00000024, 1.1920929e-06)
Weld126.Part0 = Part3
Weld126.Part1 = Part223
Weld126.part1 = Part223
Weld127.Name = "BTWeld"
Weld127.Parent = Part3
Weld127.C1 = CFrame.new(2.08616257e-06, 0.382621765, 0.593743563, -1, -2.32830644e-10, -8.87230271e-08, 2.32830644e-10, 1.00000024, 1.86264515e-09, 8.63965397e-08, -1.86264515e-09, -1.00000024)
Weld127.Part0 = Part3
Weld127.Part1 = Part347
Weld127.part1 = Part347
Weld128.Name = "BTWeld"
Weld128.Parent = Part3
Weld128.C1 = CFrame.new(3.87430191e-06, -3.59139156, -0.606614113, -1, 2.08383426e-07, 1.49542757e-07, -2.08732672e-07, -1.00000024, -5.96046448e-08, 1.52112989e-07, -5.77419996e-08, 1.00000024)
Weld128.Part0 = Part3
Weld128.Part1 = Part207
Weld128.part1 = Part207
Weld129.Name = "BTWeld"
Weld129.Parent = Part3
Weld129.C1 = CFrame.new(3.64600849, -0.0312508941, -0.13107121, -2.47033313e-07, -0.994522214, -0.104528487, 1, -2.45636329e-07, -2.16805347e-08, -2.28465069e-09, -0.104528487, 0.994522214)
Weld129.Part0 = Part3
Weld129.Part1 = Part273
Weld129.part1 = Part273
Weld130.Name = "BTWeld"
Weld130.Parent = Part3
Weld130.C1 = CFrame.new(-1.84774399e-06, -0.879115105, 0.593742847, 1, -1.19092874e-07, -2.13065505e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, -2.15442924e-07, 5.77419996e-08, -1.00000024)
Weld130.Part0 = Part3
Weld130.Part1 = Part369
Weld130.part1 = Part369
Weld131.Name = "BTWeld"
Weld131.Parent = Part3
Weld131.C1 = CFrame.new(3.51667404e-06, 2.25183678, 0.638117313, -1, -8.95233825e-08, 3.02316039e-08, -8.92905518e-08, 1.00000024, 5.96046448e-08, -3.29036993e-08, 5.77419996e-08, -1.00000024)
Weld131.Part0 = Part3
Weld131.Part1 = Part285
Weld131.part1 = Part285
Weld132.Name = "BTWeld"
Weld132.Parent = Part3
Weld132.C1 = CFrame.new(1.93451023, -0.0312511921, -0.27059412, -2.42958777e-07, -0.998629749, -0.0523359664, 1, -2.42260285e-07, -8.10723577e-09, -2.90310709e-09, -0.0523359701, 0.998629689)
Weld132.Part0 = Part3
Weld132.Part1 = Part405
Weld132.part1 = Part405
Weld133.Name = "BTWeld"
Weld133.Parent = Part3
Weld133.C1 = CFrame.new(3.63588333e-06, -1.6542244, -0.638116837, -1, 1.18976459e-07, 3.0064075e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.02987246e-07, -5.77419996e-08, 1.00000024)
Weld133.Part0 = Part3
Weld133.Part1 = Part359
Weld133.part1 = Part359
Weld134.Name = "BTWeld"
Weld134.Parent = Part3
Weld134.C1 = CFrame.new(-1.78813934e-06, 0.12912178, -0.362743616, 1, 2.32830644e-10, -1.18105163e-07, 2.32830644e-10, 1.00000024, 1.80676579e-07, 1.20164259e-07, -1.76951289e-07, 1.00000024)
Weld134.Part0 = Part3
Weld134.Part1 = Part183
Weld134.part1 = Part183
Weld135.Name = "BTWeld"
Weld135.Parent = Part3
Weld135.C1 = CFrame.new(-1.7285347e-06, 0.139364243, -0.256871939, 1, -1.18976459e-07, -1.49711923e-07, 1.1944212e-07, 1.00000024, 0, 1.52022039e-07, 1.86264515e-09, 1.00000024)
Weld135.Part0 = Part3
Weld135.Part1 = Part225
Weld135.part1 = Part225
Weld136.Name = "BTWeld"
Weld136.Parent = Part3
Weld136.C1 = CFrame.new(2.86102295e-06, 0.0545005798, 0.453119755, -1, -2.32830644e-10, -8.87230271e-08, 2.32830644e-10, 1.00000024, 1.86264515e-09, 8.63965397e-08, -1.86264515e-09, -1.00000024)
Weld136.Part0 = Part3
Weld136.Part1 = Part337
Weld136.part1 = Part337
Weld137.Name = "BTWeld"
Weld137.Parent = Part3
Weld137.C1 = CFrame.new(0.246384621, -0.0312500596, 0.315700054, 5.82076609e-09, 0.965926111, -0.258819044, -1, 2.29338184e-08, 6.17128535e-08, 6.73753675e-08, 0.258819014, 0.965926111)
Weld137.Part0 = Part3
Weld137.Part1 = Part245
Weld137.part1 = Part245
Weld138.Name = "BTWeld"
Weld138.Parent = Part3
Weld138.C1 = CFrame.new(-1.07288361e-06, 1.90734863e-06, 0.152749538, 1, -1.18976459e-07, -3.88215994e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, -3.90531568e-07, 5.77419996e-08, -1.00000024)
Weld138.Part0 = Part3
Weld138.Part1 = Part309
Weld138.part1 = Part309
Weld139.Name = "BTWeld"
Weld139.Parent = Part3
Weld139.C1 = CFrame.new(-3.03983688e-06, 0.82331419, -0.458539009, 1, 2.08732672e-07, 7.35781214e-08, -9.66247171e-08, 0.707106471, -0.707107365, -1.97673216e-07, 0.707107365, 0.707106471)
Weld139.Part0 = Part3
Weld139.Part1 = Part181
Weld139.part1 = Part181
Weld140.Name = "BTWeld"
Weld140.Parent = Part3
Weld140.C1 = CFrame.new(-3.39746475e-06, -1.05464268, -1.43672371, 1, 2.08732672e-07, -4.8930815e-10, -1.93249434e-07, 0.922201157, -0.386711091, -7.82310963e-08, 0.386711091, 0.922201216)
Weld140.Part0 = Part3
Weld140.Part1 = Part333
Weld140.part1 = Part333
Weld141.Name = "BTWeld"
Weld141.Parent = Part3
Weld141.C1 = CFrame.new(0.0437097549, -0.0312481523, 1.49426508, -1.02329068e-07, -0.707107306, -0.707106531, -1, -1.1047814e-07, 2.52499376e-07, -2.57976353e-07, 0.70710659, -0.707107306)
Weld141.Part0 = Part3
Weld141.Part1 = Part249
Weld141.part1 = Part249
Weld142.Name = "BTWeld"
Weld142.Parent = Part3
Weld142.C1 = CFrame.new(1.84774399e-06, 1.04499984, 4.84788132, -1, -2.32830644e-10, 1.16708179e-07, -1.19271135e-07, -1.01514161e-06, -1.00000024, -1.16415322e-10, -1.00000024, 1.01141632e-06)
Weld142.Part0 = Part3
Weld142.Part1 = Part205
Weld142.part1 = Part205
Weld143.Name = "BTWeld"
Weld143.Parent = Part3
Weld143.C1 = CFrame.new(-3.03983688e-06, 0.591758728, 0.577001572, 1, -1.18976459e-07, 2.07579433e-07, -1.19325705e-07, -1.00000024, 3.57627869e-07, 2.05687684e-07, -3.57627869e-07, -1.00000024)
Weld143.Part0 = Part3
Weld143.Part1 = Part385
Weld143.part1 = Part385
Weld144.Name = "BTWeld"
Weld144.Parent = Part3
Weld144.C1 = CFrame.new(-0.568752289, -0.0312482715, 1.24358273, -5.98374754e-08, -1.00000024, 0, -1, 5.93718141e-08, 3.27925591e-07, -3.30370312e-07, -1.86264515e-09, -1.00000024)
Weld144.Part0 = Part3
Weld144.Part1 = Part197
Weld144.part1 = Part197
Weld145.Name = "BTWeld"
Weld145.Parent = Part3
Weld145.C1 = CFrame.new(8.34465027e-07, 0.340940475, -0.537741661, -1, 2.08383426e-07, 3.34477591e-07, -1.24564394e-08, -0.866025329, 0.500000596, 3.95695679e-07, 0.500000596, 0.866025448)
Weld145.Part0 = Part3
Weld145.Part1 = Part357
Weld145.part1 = Part357
Weld146.Name = "BTWeld"
Weld146.Parent = Part3
Weld146.C1 = CFrame.new(-0.0784215927, -0.0312500596, 0.188100338, -2.43075192e-07, -0.866025627, -0.5, 1, -2.29571015e-07, -8.65911716e-08, -3.80096026e-08, -0.49999994, 0.866025686)
Weld146.Part0 = Part3
Weld146.Part1 = Part343
Weld146.part1 = Part343
Weld147.Name = "BTWeld"
Weld147.Parent = Part3
Weld147.C1 = CFrame.new(0.078420639, -0.0312501192, 0.188100815, 1.53668225e-07, 0.866025686, 0.5, -1, 1.49011612e-07, 4.73319233e-08, -3.19560058e-08, -0.49999994, 0.866025686)
Weld147.Part0 = Part3
Weld147.Part1 = Part353
Weld147.part1 = Part353
Weld148.Name = "BTWeld"
Weld148.Parent = Part3
Weld148.C1 = CFrame.new(-3.39746475e-06, -1.19873238, -1.4971447, 1, 2.08732672e-07, -4.8930815e-10, -1.93249434e-07, 0.922201157, -0.386711091, -7.82310963e-08, 0.386711091, 0.922201216)
Weld148.Part0 = Part3
Weld148.Part1 = Part313
Weld148.part1 = Part313
Weld149.Name = "BTWeld"
Weld149.Parent = Part3
Weld149.C1 = CFrame.new(-0.665288925, -0.0312472582, -0.400229454, 6.10016286e-08, 0.999914467, 0.0130897425, -1, 6.01867214e-08, 2.42216629e-08, 2.52284735e-08, -0.0130897434, 0.999914587)
Weld149.Part0 = Part3
Weld149.Part1 = Part211
Weld149.part1 = Part211
Weld150.Name = "BTWeld"
Weld150.Parent = Part3
Weld150.C1 = CFrame.new(1.78813934e-06, -0.22074604, -0.390618801, -1, 1.18976459e-07, 3.56074452e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.58400939e-07, -5.77419996e-08, 1.00000024)
Weld150.Part0 = Part3
Weld150.Part1 = Part311
Weld150.part1 = Part311
Weld151.Name = "BTWeld"
Weld151.Parent = Part3
Weld151.C1 = CFrame.new(-3.39746475e-06, -1.12668896, -1.46693516, 1, 2.08732672e-07, -4.8930815e-10, -1.93249434e-07, 0.922201157, -0.386711091, -7.82310963e-08, 0.386711091, 0.922201216)
Weld151.Part0 = Part3
Weld151.Part1 = Part319
Weld151.part1 = Part319
Weld152.Name = "BTWeld"
Weld152.Parent = Part3
Weld152.C1 = CFrame.new(-3.03983688e-06, 0.522769928, 0.783498287, 1, -1.18976459e-07, 2.07579433e-07, -1.19325705e-07, -1.00000024, 3.57627869e-07, 2.05687684e-07, -3.57627869e-07, -1.00000024)
Weld152.Part0 = Part3
Weld152.Part1 = Part189
Weld152.part1 = Part189
Weld153.Name = "BTWeld"
Weld153.Parent = Part3
Weld153.C1 = CFrame.new(0.854812145, -0.0312569141, 0.683163643, -7.71833584e-08, 0.707106531, -0.707107306, 1, 1.8987339e-07, 8.20728019e-08, 1.90921128e-07, -0.707107365, -0.707106531)
Weld153.Part0 = Part3
Weld153.Part1 = Part271
Weld153.part1 = Part271
Weld154.Name = "BTWeld"
Weld154.Parent = Part3
Weld154.C1 = CFrame.new(1.78813934e-06, -0.589484215, -0.222372532, -1, 2.08499841e-07, 2.3712164e-07, -2.08849087e-07, -1.00000024, 0, 2.39566361e-07, 1.86264515e-09, 1.00000024)
Weld154.Part0 = Part3
Weld154.Part1 = Part303
Weld154.part1 = Part303
Weld155.Name = "BTWeld"
Weld155.Parent = Part3
Weld155.C1 = CFrame.new(-2.44379044e-06, 1.74366188, -2.46923256, 1, -3.87313776e-07, -1.35698428e-07, -2.53145117e-07, -0.31730628, -0.948323369, 3.2375101e-07, 0.948323369, -0.31730631)
Weld155.Part0 = Part3
Weld155.Part1 = Part305
Weld155.part1 = Part305
Weld156.Name = "BTWeld"
Weld156.Parent = Part3
Weld156.C1 = CFrame.new(2.74181366e-06, 0.0869274139, -0.603420258, -1, 2.08499841e-07, 2.86032446e-07, 5.57629392e-08, -0.707106411, 0.707107425, 3.51225026e-07, 0.707107425, 0.707106411)
Weld156.Part0 = Part3
Weld156.Part1 = Part413
Weld156.part1 = Part413
Weld157.Name = "BTWeld"
Weld157.Parent = Part3
Weld157.C1 = CFrame.new(-1.25169754e-06, 2.73876762, 0.462646961, 1, -2.08499841e-07, 1.89578714e-07, -1.861481e-07, -0.993572116, -0.113202803, 2.0985317e-07, 0.113202795, -0.993572176)
Weld157.Part0 = Part3
Weld157.Part1 = Part267
Weld157.part1 = Part267
Weld158.Name = "BTWeld"
Weld158.Parent = Part3
Weld158.C1 = CFrame.new(8.94069672e-07, 0.443323135, -0.28379035, -1, 2.08383426e-07, 3.34477591e-07, -2.08732672e-07, -1.00000024, 1.78813934e-07, 3.36614903e-07, 1.80676579e-07, 1.00000024)
Weld158.Part0 = Part3
Weld158.Part1 = Part439
Weld158.part1 = Part439
Weld159.Name = "BTWeld"
Weld159.Parent = Part3
Weld159.C1 = CFrame.new(-2.98023224e-07, 2.46521568, 0.596743584, -1, -8.95233825e-08, 3.02316039e-08, -8.92905518e-08, 1.00000024, 5.96046448e-08, -3.29036993e-08, 5.77419996e-08, -1.00000024)
Weld159.Part0 = Part3
Weld159.Part1 = Part201
Weld159.part1 = Part201
Weld160.Name = "BTWeld"
Weld160.Parent = Part3
Weld160.C1 = CFrame.new(0.665288925, -0.0312529206, -0.400229454, -1.50408596e-07, -0.999914527, -0.0130897444, 1, -1.49477273e-07, -2.5913323e-08, 2.56950443e-08, -0.0130897444, 0.999914587)
Weld160.Part0 = Part3
Weld160.Part1 = Part279
Weld160.part1 = Part279
Weld161.Name = "BTWeld"
Weld161.Parent = Part3
Weld161.C1 = CFrame.new(-3.63588333e-06, 1.55414867, 1.9456358, 1, 8.95233825e-08, 2.22247763e-07, -4.30736691e-08, -0.843391299, 0.537300408, 2.34518666e-07, -0.537300348, -0.84339118)
Weld161.Part0 = Part3
Weld161.Part1 = Part335
Weld161.part1 = Part335
Weld162.Name = "BTWeld"
Weld162.Parent = Part3
Weld162.C1 = CFrame.new(8.34465027e-07, -3.73201656, 0.770674467, 1, 2.32830644e-10, -2.6903399e-07, -2.32830644e-10, -1.00000024, 8.7544322e-08, -2.71093086e-07, -9.12696123e-08, -1.00000024)
Weld162.Part0 = Part3
Weld162.Part1 = Part185
Weld162.part1 = Part185
Part163.Parent = Model0
Part163.CFrame = CFrame.new(-0.611257851, 3.46313882, -15.394145, 0.999985635, -0.00162807317, 0.00510706799, 0.00513700349, 0.0189462826, -0.999807417, 0.00153099932, 0.999819279, 0.0189543739)
Part163.Orientation = Vector3.new(88.8799973, 15.0799999, 15.1700001)
Part163.Position = Vector3.new(-0.611257851, 3.46313882, -15.394145)
Part163.Rotation = Vector3.new(88.909996, 0.289999992, 0.0899999961)
Part163.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part163.Velocity = Vector3.new(2.31788153e-08, 0.0024639722, 3.04594494e-07)
Part163.Size = Vector3.new(0.275000006, 0.84512496, 0.359375)
Part163.Anchored = true
Part163.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part163.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part163.BrickColor = BrickColor.new("Really black")
Part163.CanCollide = false
Part163.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part163.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part163.Material = Enum.Material.Metal
Part163.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part163.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part163.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part163.brickColor = BrickColor.new("Really black")
SpecialMesh164.Parent = Part163
SpecialMesh164.Scale = Vector3.new(0.349999994, 1, 0.5)
SpecialMesh164.MeshType = Enum.MeshType.Brick
Part165.Parent = Model0
Part165.CFrame = CFrame.new(-0.617485046, 3.2590127, -10.6418428, -0.999985635, -0.00414685067, -0.00339615461, -0.00513672922, 0.560423911, 0.828190207, -0.00153109396, 0.828195751, -0.560437143)
Part165.Orientation = Vector3.new(-55.9099998, -179.649994, -0.529999971)
Part165.Position = Vector3.new(-0.617485046, 3.2590127, -10.6418428)
Part165.Rotation = Vector3.new(-124.089996, -0.189999998, 179.759995)
Part165.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part165.Velocity = Vector3.new(5.55462663e-08, 0.00247387378, 7.29936687e-07)
Part165.Size = Vector3.new(0.275000006, 0.4375, 0.25)
Part165.Anchored = true
Part165.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part165.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part165.BrickColor = BrickColor.new("Really black")
Part165.CanCollide = false
Part165.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part165.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part165.Material = Enum.Material.Metal
Part165.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part165.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part165.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part165.brickColor = BrickColor.new("Really black")
SpecialMesh166.Parent = Part165
SpecialMesh166.Scale = Vector3.new(0.5, 1, 0.25)
SpecialMesh166.MeshType = Enum.MeshType.Brick
Part167.Parent = Model0
Part167.CFrame = CFrame.new(-0.610199153, 2.88768315, -14.1553068, 0.999985635, 0.00162795268, -0.00510686403, 0.0051367972, -0.0189460143, 0.999807417, 0.00153088395, -0.999819279, -0.0189541057)
Part167.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part167.Position = Vector3.new(-0.610199153, 2.88768315, -14.1553068)
Part167.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part167.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part167.Velocity = Vector3.new(1.14426342e-07, 0.00246655382, 1.50368453e-06)
Part167.Size = Vector3.new(0.275000006, 0.207000002, 0.303375006)
Part167.Anchored = true
Part167.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part167.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part167.BrickColor = BrickColor.new("Really black")
Part167.CanCollide = false
Part167.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part167.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part167.Material = Enum.Material.Glass
Part167.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part167.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part167.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part167.brickColor = BrickColor.new("Really black")
SpecialMesh168.Parent = Part167
SpecialMesh168.Scale = Vector3.new(0.524999976, 0.5, 0.5)
SpecialMesh168.MeshType = Enum.MeshType.Wedge
Part169.Parent = Model0
Part169.CFrame = CFrame.new(-0.613238811, 3.32843637, -13.6493177, -0.999985635, -0.00162807142, -0.00510653527, -0.00513647031, 0.0189459249, 0.999807417, -0.00153100933, 0.999819279, -0.0189540163)
Part169.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part169.Position = Vector3.new(-0.613238811, 3.32843637, -13.6493177)
Part169.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part169.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part169.Velocity = Vector3.new(4.45380195e-08, 0.00246760761, 5.85277007e-07)
Part169.Size = Vector3.new(0.275000006, 0.698124886, 0.534374952)
Part169.Anchored = true
Part169.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part169.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part169.BrickColor = BrickColor.new("Bright blue")
Part169.CanCollide = false
Part169.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part169.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part169.Material = Enum.Material.Neon
Part169.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part169.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part169.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part169.brickColor = BrickColor.new("Bright blue")
SpecialMesh170.Parent = Part169
SpecialMesh170.Scale = Vector3.new(0.452499986, 1, 1)
SpecialMesh170.MeshType = Enum.MeshType.Cylinder
Part171.Parent = Model0
Part171.CFrame = CFrame.new(-0.610366702, 3.28867483, -15.3908367, 0.999985635, -0.00162807317, 0.00510706799, 0.00513700349, 0.0189462826, -0.999807417, 0.00153099932, 0.999819279, 0.0189543739)
Part171.Orientation = Vector3.new(88.8799973, 15.0799999, 15.1700001)
Part171.Position = Vector3.new(-0.610366702, 3.28867483, -15.3908367)
Part171.Rotation = Vector3.new(88.909996, 0.289999992, 0.0899999961)
Part171.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part171.Velocity = Vector3.new(5.08428144e-08, 0.00246397941, 6.68129019e-07)
Part171.Size = Vector3.new(0.275000006, 0.84512496, 0.422374964)
Part171.Anchored = true
Part171.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part171.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part171.BrickColor = BrickColor.new("Really black")
Part171.CanCollide = false
Part171.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part171.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part171.Material = Enum.Material.Metal
Part171.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part171.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part171.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part171.brickColor = BrickColor.new("Really black")
SpecialMesh172.Parent = Part171
SpecialMesh172.Scale = Vector3.new(0.400000006, 1, 0.5)
SpecialMesh172.MeshType = Enum.MeshType.Brick
Part173.Parent = Model0
Part173.CFrame = CFrame.new(-0.610880256, 2.96906447, -13.9840736, -0.999985635, -0.00162807154, -0.00510650687, -0.00513644237, 0.0189459547, 0.999807417, -0.00153100991, 0.999819279, -0.0189540461)
Part173.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part173.Position = Vector3.new(-0.610880256, 2.96906447, -13.9840736)
Part173.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part173.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part173.Velocity = Vector3.new(1.01522062e-07, 0.00246691052, 1.33410845e-06)
Part173.Size = Vector3.new(0.275000006, 0.239124984, 0.205375016)
Part173.Anchored = true
Part173.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part173.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part173.BrickColor = BrickColor.new("Bright blue")
Part173.CanCollide = false
Part173.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part173.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part173.Material = Enum.Material.Neon
Part173.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part173.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part173.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part173.brickColor = BrickColor.new("Bright blue")
SpecialMesh174.Parent = Part173
SpecialMesh174.Scale = Vector3.new(0.550000012, 1, 1)
SpecialMesh174.MeshType = Enum.MeshType.Brick
Part175.Parent = Model0
Part175.CFrame = CFrame.new(-0.613238811, 3.32843637, -13.6493177, -0.999985635, -0.00162807142, -0.00510653527, -0.00513647031, 0.0189459249, 0.999807417, -0.00153100933, 0.999819279, -0.0189540163)
Part175.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part175.Position = Vector3.new(-0.613238811, 3.32843637, -13.6493177)
Part175.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part175.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part175.Velocity = Vector3.new(4.45380195e-08, 0.00246760761, 5.85277007e-07)
Part175.Size = Vector3.new(0.275000006, 0.698124886, 0.372374952)
Part175.Anchored = true
Part175.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part175.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part175.BrickColor = BrickColor.new("Really black")
Part175.CanCollide = false
Part175.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part175.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part175.Material = Enum.Material.Metal
Part175.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part175.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part175.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part175.brickColor = BrickColor.new("Really black")
SpecialMesh176.Parent = Part175
SpecialMesh176.Scale = Vector3.new(0.455000013, 1, 1)
SpecialMesh176.MeshType = Enum.MeshType.Cylinder
Part177.Parent = Model0
Part177.CFrame = CFrame.new(-0.616063476, 3.26214504, -11.5807333, -0.999985635, -0.00162807154, -0.00510656228, -0.00513649778, 0.0189459547, 0.999807417, -0.00153100886, 0.999819279, -0.0189540461)
Part177.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part177.Position = Vector3.new(-0.616063476, 3.26214504, -11.5807333)
Part177.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part177.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part177.Velocity = Vector3.new(5.50495756e-08, 0.00247191754, 7.23409755e-07)
Part177.Size = Vector3.new(0.275000006, 0.630125046, 0.280375004)
Part177.Anchored = true
Part177.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part177.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part177.BrickColor = BrickColor.new("Really black")
Part177.CanCollide = false
Part177.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part177.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part177.Material = Enum.Material.Metal
Part177.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part177.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part177.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part177.brickColor = BrickColor.new("Really black")
SpecialMesh178.Parent = Part177
SpecialMesh178.Scale = Vector3.new(0.400000006, 1.04999995, 0.5)
SpecialMesh178.MeshType = Enum.MeshType.Brick
Part179.Parent = Model0
Part179.CFrame = CFrame.new(-0.610621691, 3.13382888, -14.7050791, 0.999985635, -0.00476216245, 0.00246017892, 0.00513689732, 0.720368028, -0.693573177, 0.00153067347, 0.693575799, 0.720382154)
Part179.Orientation = Vector3.new(43.9099998, 0.199999988, 0.409999996)
Part179.Position = Vector3.new(-0.610621691, 3.13382888, -14.7050791)
Part179.Rotation = Vector3.new(43.9099998, 0.140000001, 0.269999981)
Part179.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part179.Velocity = Vector3.new(7.53960734e-08, 0.0024654083, 9.90785111e-07)
Part179.Size = Vector3.new(0.275000006, 0.221124932, 0.418375015)
Part179.Anchored = true
Part179.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part179.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part179.BrickColor = BrickColor.new("Really black")
Part179.CanCollide = false
Part179.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part179.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part179.Material = Enum.Material.Metal
Part179.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part179.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part179.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part179.brickColor = BrickColor.new("Really black")
SpecialMesh180.Parent = Part179
SpecialMesh180.Scale = Vector3.new(0.550000012, 1.04999995, 0.899999976)
SpecialMesh180.MeshType = Enum.MeshType.Brick
Part181.Parent = Model0
Part181.CFrame = CFrame.new(-0.61356318, 3.48533392, -13.9631662, 0.999985635, 0.0047621401, -0.00246015727, 0.00513686566, -0.720367908, 0.693573296, 0.00153067405, -0.693575978, -0.720381975)
Part181.Orientation = Vector3.new(-43.9099998, -179.800003, 179.589996)
Part181.Position = Vector3.new(-0.61356318, 3.48533392, -13.9631662)
Part181.Rotation = Vector3.new(-136.089996, -0.140000001, -0.269999981)
Part181.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part181.Velocity = Vector3.new(1.96594527e-08, 0.00246695359, 2.58346063e-07)
Part181.Size = Vector3.new(0.275000006, 0.413124949, 0.622375011)
Part181.Anchored = true
Part181.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part181.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part181.BrickColor = BrickColor.new("Really black")
Part181.CanCollide = false
Part181.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part181.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part181.Material = Enum.Material.Metal
Part181.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part181.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part181.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part181.brickColor = BrickColor.new("Really black")
SpecialMesh182.Parent = Part181
SpecialMesh182.Scale = Vector3.new(0.400000006, 1.04999995, 0.5)
SpecialMesh182.MeshType = Enum.MeshType.Brick
Part183.Parent = Model0
Part183.CFrame = CFrame.new(-0.610578179, 2.93933439, -14.0816517, 0.999985635, 0.00162795174, -0.00510674529, 0.005136678, -0.0189458355, 0.999807417, 0.00153088616, -0.999819279, -0.0189539269)
Part183.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part183.Position = Vector3.new(-0.610578179, 2.93933439, -14.0816517)
Part183.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part183.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part183.Velocity = Vector3.new(1.06236229e-07, 0.00246670726, 1.39605754e-06)
Part183.Size = Vector3.new(0.275000006, 0.252000004, 0.213375002)
Part183.Anchored = true
Part183.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part183.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part183.BrickColor = BrickColor.new("Really black")
Part183.CanCollide = false
Part183.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part183.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part183.Material = Enum.Material.Metal
Part183.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part183.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part183.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part183.brickColor = BrickColor.new("Really black")
SpecialMesh184.Parent = Part183
SpecialMesh184.Scale = Vector3.new(0.569999993, 0.125, 0.375)
SpecialMesh184.MeshType = Enum.MeshType.Wedge
Part185.Parent = Model0
Part185.CFrame = CFrame.new(-0.61852932, 3.41544771, -10.4871407, 0.999985635, -0.00162795314, 0.00510659395, 0.00513652712, 0.0189461038, -0.999807417, 0.00153088907, 0.999819279, 0.0189541951)
Part185.Orientation = Vector3.new(88.8799973, 15.0799999, 15.1700001)
Part185.Position = Vector3.new(-0.61852932, 3.41544771, -10.4871407)
Part185.Rotation = Vector3.new(88.909996, 0.289999992, 0.0899999961)
Part185.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part185.Velocity = Vector3.new(3.07410488e-08, 0.00247419602, 4.03969523e-07)
Part185.Size = Vector3.new(0.270000011, 0.21875, 0.234375)
Part185.Anchored = true
Part185.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part185.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part185.BrickColor = BrickColor.new("Really black")
Part185.CanCollide = false
Part185.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part185.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part185.Material = Enum.Material.Metal
Part185.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part185.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part185.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part185.brickColor = BrickColor.new("Really black")
SpecialMesh186.Parent = Part185
SpecialMesh186.Scale = Vector3.new(0.5, 0.5, 0.5)
SpecialMesh186.MeshType = Enum.MeshType.Wedge
Part187.Parent = Model0
Part187.CFrame = CFrame.new(-0.608188927, 3.09825993, -16.1759663, -0.999985635, 0.00519088237, -0.00133629935, -0.0051367199, -0.999273539, -0.0377651006, -0.0015313623, -0.0377576947, 0.999285877)
Part187.Orientation = Vector3.new(2.15999985, -0.0799999982, -179.709991)
Part187.Position = Vector3.new(-0.608188927, 3.09825993, -16.1759663)
Part187.Rotation = Vector3.new(2.15999985, -0.0799999982, -179.699997)
Part187.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part187.Velocity = Vector3.new(8.10360774e-08, 0.00246234378, 1.06490097e-06)
Part187.Size = Vector3.new(0.275000006, 0.235124931, 1.6693753)
Part187.Anchored = true
Part187.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part187.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part187.BrickColor = BrickColor.new("Really black")
Part187.CanCollide = false
Part187.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part187.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part187.Material = Enum.Material.Metal
Part187.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part187.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part187.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part187.brickColor = BrickColor.new("Really black")
SpecialMesh188.Parent = Part187
SpecialMesh188.Scale = Vector3.new(0.400000006, 1.04999995, 1)
SpecialMesh188.MeshType = Enum.MeshType.Brick
Part189.Parent = Model0
Part189.CFrame = CFrame.new(-0.611664593, 3.3476572, -14.7413998, 0.999985635, -0.00162807363, 0.00510707032, 0.00513700629, 0.018946372, -0.999807417, 0.0015309992, 0.999819279, 0.0189544633)
Part189.Orientation = Vector3.new(88.8799973, 15.0799999, 15.1700001)
Part189.Position = Vector3.new(-0.611664593, 3.3476572, -14.7413998)
Part189.Rotation = Vector3.new(88.909996, 0.289999992, 0.0899999961)
Part189.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part189.Velocity = Vector3.new(4.14902424e-08, 0.00246533239, 5.45226158e-07)
Part189.Size = Vector3.new(0.275000006, 0.480124891, 0.214375019)
Part189.Anchored = true
Part189.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part189.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part189.BrickColor = BrickColor.new("Bright blue")
Part189.CanCollide = false
Part189.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part189.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part189.Material = Enum.Material.Neon
Part189.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part189.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part189.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part189.brickColor = BrickColor.new("Bright blue")
SpecialMesh190.Parent = Part189
SpecialMesh190.Scale = Vector3.new(0.449999988, 1, 0.100000001)
SpecialMesh190.MeshType = Enum.MeshType.Brick
Part191.Parent = Model0
Part191.CFrame = CFrame.new(-0.637731671, 3.71308732, -19.354105, -0.0050775772, -0.999985635, -0.00171704381, 0.999324501, -0.00513670873, 0.0363931209, -0.0364014208, -0.00153109431, 0.999336243)
Part191.Orientation = Vector3.new(-2.08999991, -0.099999994, 90.2900009)
Part191.Position = Vector3.new(-0.637731671, 3.71308732, -19.354105)
Part191.Rotation = Vector3.new(-2.08999991, -0.099999994, 90.2900009)
Part191.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part191.Velocity = Vector3.new(-1.64544822e-08, 0.00245571672, -2.16228841e-07)
Part191.Size = Vector3.new(0.210000038, 0.200000003, 0.285374999)
Part191.Anchored = true
Part191.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part191.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part191.BrickColor = BrickColor.new("Royal purple")
Part191.CanCollide = false
Part191.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part191.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part191.Material = Enum.Material.Neon
Part191.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part191.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part191.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part191.brickColor = BrickColor.new("Royal purple")
SpecialMesh192.Parent = Part191
SpecialMesh192.Scale = Vector3.new(0.5, 0.300000012, 0.5)
SpecialMesh192.MeshType = Enum.MeshType.Wedge
Part193.Parent = Model0
Part193.CFrame = CFrame.new(-0.613232374, 3.39655375, -13.8819904, 0.999985635, 0.000250508543, -0.00535421353, 0.00513686566, 0.240468621, 0.97064352, 0.00153067405, -0.970657051, 0.240463868)
Part193.Orientation = Vector3.new(-76.0800018, -1.27999997, 1.22000003)
Part193.Position = Vector3.new(-0.613232374, 3.39655375, -13.8819904)
Part193.Rotation = Vector3.new(-76.0899963, -0.310000002, -0.00999999978)
Part193.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part193.Velocity = Vector3.new(3.37369386e-08, 0.00246712286, 4.43339275e-07)
Part193.Size = Vector3.new(0.275000006, 0.422124922, 0.412375003)
Part193.Anchored = true
Part193.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part193.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part193.BrickColor = BrickColor.new("Really black")
Part193.CanCollide = false
Part193.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part193.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part193.Material = Enum.Material.Metal
Part193.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part193.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part193.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part193.brickColor = BrickColor.new("Really black")
SpecialMesh194.Parent = Part193
SpecialMesh194.Scale = Vector3.new(0.5, 1.04999995, 0.5)
SpecialMesh194.MeshType = Enum.MeshType.Brick
Part195.Parent = Model0
Part195.CFrame = CFrame.new(-0.640585661, 2.53611565, -13.5419912, 0.00476224814, -0.999985635, -0.00245993445, -0.72036773, -0.00513678836, 0.693573475, -0.693576157, -0.00153091096, -0.720381796)
Part195.Orientation = Vector3.new(-43.9099998, -179.800003, -90.409996)
Part195.Position = Vector3.new(-0.640585661, 2.53611565, -13.5419912)
Part195.Rotation = Vector3.new(-136.089996, -0.140000001, 89.7299957)
Part195.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part195.Velocity = Vector3.new(1.70172896e-07, 0.00246782694, 2.23625375e-06)
Part195.Size = Vector3.new(0.421999991, 0.200000003, 0.280375004)
Part195.Anchored = true
Part195.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part195.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part195.BrickColor = BrickColor.new("Royal purple")
Part195.CanCollide = false
Part195.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part195.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part195.Material = Enum.Material.Neon
Part195.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part195.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part195.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part195.brickColor = BrickColor.new("Royal purple")
SpecialMesh196.Parent = Part195
SpecialMesh196.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh196.MeshType = Enum.MeshType.Wedge
Part197.Parent = Model0
Part197.CFrame = CFrame.new(-0.647041559, 3.82817221, -13.658843, -0.00162801228, -0.999985635, 0.00510653481, 0.0189460143, -0.00513646938, -0.999807417, 0.999819279, -0.00153094972, 0.0189541057)
Part197.Orientation = Vector3.new(88.8799973, 15.0799999, 105.169998)
Part197.Position = Vector3.new(-0.647041559, 3.82817221, -13.658843)
Part197.Rotation = Vector3.new(88.909996, 0.289999992, 90.0899963)
Part197.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part197.Velocity = Vector3.new(-3.47029321e-08, 0.00246758247, -4.56033831e-07)
Part197.Size = Vector3.new(0.643000007, 0.200000003, 0.280375004)
Part197.Anchored = true
Part197.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part197.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part197.BrickColor = BrickColor.new("Royal purple")
Part197.CanCollide = false
Part197.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part197.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part197.Material = Enum.Material.Neon
Part197.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part197.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part197.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part197.brickColor = BrickColor.new("Royal purple")
SpecialMesh198.Parent = Part197
SpecialMesh198.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh198.MeshType = Enum.MeshType.Wedge
Part199.Parent = Model0
Part199.CFrame = CFrame.new(-0.615469754, 3.2510047, -11.9310894, -0.999985635, -0.00162807154, -0.00510656228, -0.00513649778, 0.0189459547, 0.999807417, -0.00153100886, 0.999819279, -0.0189540461)
Part199.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part199.Position = Vector3.new(-0.615469754, 3.2510047, -11.9310894)
Part199.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part199.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part199.Velocity = Vector3.new(5.68160452e-08, 0.00247118762, 7.46623186e-07)
Part199.Size = Vector3.new(0.275000006, 0.261124998, 0.245374992)
Part199.Anchored = true
Part199.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part199.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part199.BrickColor = BrickColor.new("Bright blue")
Part199.CanCollide = false
Part199.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part199.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part199.Material = Enum.Material.Neon
Part199.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part199.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part199.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part199.brickColor = BrickColor.new("Bright blue")
SpecialMesh200.Parent = Part199
SpecialMesh200.Scale = Vector3.new(0.375, 1.04999995, 0.5)
SpecialMesh200.MeshType = Enum.MeshType.Brick
Part201.Parent = Model0
Part201.CFrame = CFrame.new(-0.615578175, 3.21754885, -11.7504148, -0.999985635, 0.00162786292, 0.00510683237, -0.00513676414, -0.0189459566, -0.999807417, -0.00153079513, -0.999819279, 0.0189540461)
Part201.Orientation = Vector3.new(88.8799973, 15.0799999, -164.830002)
Part201.Position = Vector3.new(-0.615578175, 3.21754885, -11.7504148)
Part201.Rotation = Vector3.new(88.909996, 0.289999992, -179.909988)
Part201.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part201.Velocity = Vector3.new(6.21209963e-08, 0.0024715641, 8.16335842e-07)
Part201.Size = Vector3.new(0.275000006, 0.214125022, 0.234375)
Part201.Anchored = true
Part201.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part201.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part201.BrickColor = BrickColor.new("Really black")
Part201.CanCollide = false
Part201.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part201.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part201.Material = Enum.Material.Metal
Part201.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part201.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part201.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part201.brickColor = BrickColor.new("Really black")
SpecialMesh202.Parent = Part201
SpecialMesh202.Scale = Vector3.new(0.5, 0.560000002, 0.400000006)
SpecialMesh202.MeshType = Enum.MeshType.Wedge
Part203.Parent = Model0
Part203.CFrame = CFrame.new(-0.613475382, 3.25657153, -13.2536583, -0.999985635, 0.00162801275, 0.00510680024, -0.00513673527, -0.0189461038, -0.999807417, -0.00153094472, -0.999819279, 0.0189541951)
Part203.Orientation = Vector3.new(88.8799973, 15.0799999, -164.830002)
Part203.Position = Vector3.new(-0.613475382, 3.25657153, -13.2536583)
Part203.Rotation = Vector3.new(88.909996, 0.289999992, -179.909988)
Part203.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part203.Velocity = Vector3.new(5.59333202e-08, 0.00246843207, 7.35023434e-07)
Part203.Size = Vector3.new(0.275000006, 0.204125047, 0.210375011)
Part203.Anchored = true
Part203.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part203.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part203.BrickColor = BrickColor.new("Really black")
Part203.CanCollide = false
Part203.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part203.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part203.Material = Enum.Material.Metal
Part203.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part203.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part203.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part203.brickColor = BrickColor.new("Really black")
SpecialMesh204.Parent = Part203
SpecialMesh204.Scale = Vector3.new(0.5, 0.5, 0.5)
SpecialMesh204.MeshType = Enum.MeshType.Wedge
Part205.Parent = Model0
Part205.CFrame = CFrame.new(-0.605959892, 3.52715993, -19.0706863, -0.999985635, 0.00510674436, -0.0016279578, -0.00513667939, -0.999807417, 0.0189470276, -0.00153088616, 0.018955119, 0.999819279)
Part205.Orientation = Vector3.new(-1.09000003, -0.0899999961, -179.709991)
Part205.Position = Vector3.new(-0.605959892, 3.52715993, -19.0706863)
Part205.Rotation = Vector3.new(-1.09000003, -0.0899999961, -179.709991)
Part205.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part205.Velocity = Vector3.new(1.30272237e-08, 0.0024563123, 1.71192255e-07)
Part205.Size = Vector3.new(0.275000006, 0.446125001, 0.496375084)
Part205.Anchored = true
Part205.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part205.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part205.BrickColor = BrickColor.new("Really black")
Part205.CanCollide = false
Part205.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part205.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part205.Material = Enum.Material.Metal
Part205.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part205.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part205.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part205.brickColor = BrickColor.new("Really black")
SpecialMesh206.Parent = Part205
SpecialMesh206.Scale = Vector3.new(0.400000006, 1, 0.899999976)
SpecialMesh206.MeshType = Enum.MeshType.Wedge
Part207.Parent = Model0
Part207.CFrame = CFrame.new(-0.617458701, 3.24875402, -10.62463, -0.999985635, -0.00162816094, -0.00510671316, -0.00513665052, 0.0189459547, 0.999807417, -0.00153109536, 0.999819279, -0.0189540461)
Part207.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part207.Position = Vector3.new(-0.617458701, 3.24875402, -10.62463)
Part207.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part207.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part207.Velocity = Vector3.new(5.71729402e-08, 0.00247390964, 7.51312939e-07)
Part207.Size = Vector3.new(0.25999999, 0.375, 0.21875)
Part207.Anchored = true
Part207.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part207.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part207.BrickColor = BrickColor.new("Really black")
Part207.CanCollide = false
Part207.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part207.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part207.Material = Enum.Material.Metal
Part207.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part207.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part207.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part207.brickColor = BrickColor.new("Really black")
SpecialMesh208.Parent = Part207
SpecialMesh208.Scale = Vector3.new(0.300000012, 1, 1)
SpecialMesh208.MeshType = Enum.MeshType.Wedge
Part209.Parent = Model0
Part209.CFrame = CFrame.new(-0.614153862, 3.21053505, -12.6548157, -0.999985635, -0.00162816129, -0.00510668149, -0.00513661886, 0.0189460143, 0.999807417, -0.00153109606, 0.999819279, -0.0189541057)
Part209.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part209.Position = Vector3.new(-0.614153862, 3.21053505, -12.6548157)
Part209.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part209.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part209.Velocity = Vector3.new(6.32331378e-08, 0.00246967981, 8.30950682e-07)
Part209.Size = Vector3.new(0.275000006, 0.35512504, 0.416375011)
Part209.Anchored = true
Part209.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part209.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part209.BrickColor = BrickColor.new("Really black")
Part209.CanCollide = false
Part209.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part209.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part209.Material = Enum.Material.Metal
Part209.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part209.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part209.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part209.brickColor = BrickColor.new("Really black")
SpecialMesh210.Parent = Part209
SpecialMesh210.Scale = Vector3.new(0.5, 0.560000002, 0.5)
SpecialMesh210.MeshType = Enum.MeshType.Wedge
Part211.Parent = Model0
Part211.CFrame = CFrame.new(-0.640777826, 2.97037435, -14.8715458, 0.00156102644, -0.999985635, -0.00512771169, -0.00585717242, -0.00513677299, 0.99996984, -0.999981701, -0.00153094484, -0.00586510729)
Part211.Orientation = Vector3.new(-89.5599976, -138.839996, -131.25)
Part211.Position = Vector3.new(-0.640777826, 2.97037435, -14.8715458)
Part211.Rotation = Vector3.new(-90.3399963, -0.289999992, 89.909996)
Part211.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part211.Velocity = Vector3.new(1.01314356e-07, 0.00246505649, 1.33137894e-06)
Part211.Size = Vector3.new(0.49000001, 0.200000003, 0.290374994)
Part211.Anchored = true
Part211.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part211.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part211.BrickColor = BrickColor.new("Royal purple")
Part211.CanCollide = false
Part211.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part211.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part211.Material = Enum.Material.Neon
Part211.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part211.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part211.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part211.brickColor = BrickColor.new("Royal purple")
SpecialMesh212.Parent = Part211
SpecialMesh212.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh212.MeshType = Enum.MeshType.Wedge
Part213.Parent = Model0
Part213.CFrame = CFrame.new(-0.609622896, 3.39657903, -16.2390652, 0.999985635, -0.00133592181, 0.00519115385, 0.00513700396, -0.0377659053, -0.999273479, 0.00153099932, 0.999285877, -0.0377584994)
Part213.Orientation = Vector3.new(87.8199997, 172.169998, 172.25)
Part213.Position = Vector3.new(-0.609622896, 3.39657903, -16.2390652)
Part213.Rotation = Vector3.new(92.159996, 0.299999982, 0.0799999982)
Part213.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part213.Velocity = Vector3.new(3.37329027e-08, 0.002462212, 4.43286638e-07)
Part213.Size = Vector3.new(0.275000006, 0.533124864, 0.214375019)
Part213.Anchored = true
Part213.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part213.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part213.BrickColor = BrickColor.new("Bright blue")
Part213.CanCollide = false
Part213.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part213.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part213.Material = Enum.Material.Neon
Part213.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part213.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part213.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part213.brickColor = BrickColor.new("Bright blue")
SpecialMesh214.Parent = Part213
SpecialMesh214.Scale = Vector3.new(0.449999988, 0.899999976, 0.100000001)
SpecialMesh214.MeshType = Enum.MeshType.Brick
Part215.Parent = Model0
Part215.CFrame = CFrame.new(-0.612417579, 3.49721146, -14.7513313, 0.999985635, -0.00219574547, 0.00488994364, 0.00513701141, 0.13200599, -0.991235793, 0.00153099908, 0.991246581, 0.132015377)
Part215.Orientation = Vector3.new(82.409996, 2.11999989, 2.23000002)
Part215.Position = Vector3.new(-0.612417579, 3.49721146, -14.7513313)
Part215.Rotation = Vector3.new(82.409996, 0.280000001, 0.129999995)
Part215.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part215.Velocity = Vector3.new(1.77760739e-08, 0.00246531144, 2.33596552e-07)
Part215.Size = Vector3.new(0.275000006, 0.488124937, 0.359375)
Part215.Anchored = true
Part215.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part215.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part215.BrickColor = BrickColor.new("Really black")
Part215.CanCollide = false
Part215.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part215.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part215.Material = Enum.Material.Metal
Part215.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part215.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part215.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part215.brickColor = BrickColor.new("Really black")
SpecialMesh216.Parent = Part215
SpecialMesh216.Scale = Vector3.new(0.400000006, 1, 0.5)
SpecialMesh216.MeshType = Enum.MeshType.Brick
Part217.Parent = Model0
Part217.CFrame = CFrame.new(-0.645515323, 3.66365719, -14.1031828, -0.0047622188, -0.999985635, 0.00246008043, 0.720367849, -0.00513686892, -0.693573356, 0.693576038, -0.00153078465, 0.720381975)
Part217.Orientation = Vector3.new(43.9099998, 0.199999988, 90.409996)
Part217.Position = Vector3.new(-0.645515323, 3.66365719, -14.1031828)
Part217.Rotation = Vector3.new(43.9099998, 0.140000001, 90.2699966)
Part217.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part217.Velocity = Vector3.new(-8.61649951e-09, 0.00246665697, -1.13230158e-07)
Part217.Size = Vector3.new(0.496000022, 0.200000003, 0.280375004)
Part217.Anchored = true
Part217.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part217.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part217.BrickColor = BrickColor.new("Royal purple")
Part217.CanCollide = false
Part217.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part217.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part217.Material = Enum.Material.Neon
Part217.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part217.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part217.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part217.brickColor = BrickColor.new("Royal purple")
SpecialMesh218.Parent = Part217
SpecialMesh218.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh218.MeshType = Enum.MeshType.Wedge
Part219.Parent = Model0
Part219.CFrame = CFrame.new(-0.611597419, 2.92886329, -13.380847, -0.999985635, -0.00162816129, -0.00510668149, -0.00513661886, 0.0189460143, 0.999807417, -0.00153109606, 0.999819279, -0.0189541057)
Part219.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part219.Position = Vector3.new(-0.611597419, 2.92886329, -13.380847)
Part219.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part219.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part219.Velocity = Vector3.new(1.07896597e-07, 0.00246816734, 1.41787655e-06)
Part219.Size = Vector3.new(0.275000006, 0.630125046, 0.280375004)
Part219.Anchored = true
Part219.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part219.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part219.BrickColor = BrickColor.new("Really black")
Part219.CanCollide = false
Part219.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part219.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part219.Material = Enum.Material.Metal
Part219.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part219.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part219.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part219.brickColor = BrickColor.new("Really black")
SpecialMesh220.Parent = Part219
SpecialMesh220.Scale = Vector3.new(0.395000011, 0.75, 0.25)
SpecialMesh220.MeshType = Enum.MeshType.Wedge
Part221.Parent = Model0
Part221.CFrame = CFrame.new(-0.609442294, 2.87052941, -14.5920582, -0.999985635, 0.00510674296, -0.00162775011, -0.00513667427, -0.999807417, 0.0189472083, -0.00153067766, 0.0189552978, 0.999819279)
Part221.Orientation = Vector3.new(-1.09000003, -0.0899999961, -179.709991)
Part221.Position = Vector3.new(-0.609442294, 2.87052941, -14.5920582)
Part221.Rotation = Vector3.new(-1.09000003, -0.0899999961, -179.709991)
Part221.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part221.Velocity = Vector3.new(1.17146328e-07, 0.00246564392, 1.53942813e-06)
Part221.Size = Vector3.new(0.275000006, 0.216999978, 0.295375019)
Part221.Anchored = true
Part221.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part221.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part221.BrickColor = BrickColor.new("Really black")
Part221.CanCollide = false
Part221.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part221.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part221.Material = Enum.Material.Glass
Part221.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part221.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part221.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part221.brickColor = BrickColor.new("Really black")
SpecialMesh222.Parent = Part221
SpecialMesh222.Scale = Vector3.new(0.5, 0.75, 0.25)
SpecialMesh222.MeshType = Enum.MeshType.Wedge
Part223.Parent = Model0
Part223.CFrame = CFrame.new(-0.609190822, 2.76472902, -14.4025202, -0.999985635, 0.00510674296, -0.00162775011, -0.00513667427, -0.999807417, 0.0189472083, -0.00153067766, 0.0189552978, 0.999819279)
Part223.Orientation = Vector3.new(-1.09000003, -0.0899999961, -179.709991)
Part223.Position = Vector3.new(-0.609190822, 2.76472902, -14.4025202)
Part223.Rotation = Vector3.new(-1.09000003, -0.0899999961, -179.709991)
Part223.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part223.Velocity = Vector3.new(1.3392264e-07, 0.0024660388, 1.7598868e-06)
Part223.Size = Vector3.new(0.275000006, 0.23299998, 0.295375019)
Part223.Anchored = true
Part223.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part223.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part223.BrickColor = BrickColor.new("Really black")
Part223.CanCollide = false
Part223.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part223.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part223.Material = Enum.Material.Glass
Part223.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part223.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part223.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part223.brickColor = BrickColor.new("Really black")
SpecialMesh224.Parent = Part223
SpecialMesh224.Scale = Vector3.new(0.5, 1, 0.25)
SpecialMesh224.MeshType = Enum.MeshType.Wedge
Part225.Parent = Model0
Part225.CFrame = CFrame.new(-0.610054374, 2.83367729, -14.0694036, 0.999985635, 0.00162807188, -0.00510671316, 0.00513664866, -0.0189460143, 0.999807417, 0.00153100595, -0.999819279, -0.0189541057)
Part225.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part225.Position = Vector3.new(-0.610054374, 2.83367729, -14.0694036)
Part225.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part225.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part225.Velocity = Vector3.new(1.22989817e-07, 0.00246673287, 1.61621767e-06)
Part225.Size = Vector3.new(0.275000006, 0.311124951, 0.267374992)
Part225.Anchored = true
Part225.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part225.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part225.BrickColor = BrickColor.new("Really black")
Part225.CanCollide = false
Part225.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part225.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part225.Material = Enum.Material.Metal
Part225.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part225.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part225.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part225.brickColor = BrickColor.new("Really black")
SpecialMesh226.Parent = Part225
SpecialMesh226.Scale = Vector3.new(0.495000005, 1, 1)
SpecialMesh226.MeshType = Enum.MeshType.Brick
Part227.Parent = Model0
Part227.CFrame = CFrame.new(-0.611247957, 3.01424932, -13.8955402, 0.999985635, -0.00162807154, 0.00510659395, 0.00513652945, 0.0189459547, -0.999807417, 0.00153100828, 0.999819279, 0.0189540461)
Part227.Orientation = Vector3.new(88.8799973, 15.0799999, 15.1700001)
Part227.Position = Vector3.new(-0.611247957, 3.01424932, -13.8955402)
Part227.Rotation = Vector3.new(88.909996, 0.289999992, 0.0899999961)
Part227.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part227.Velocity = Vector3.new(9.43572971e-08, 0.00246709492, 1.23995574e-06)
Part227.Size = Vector3.new(0.275000006, 0.228, 0.213375002)
Part227.Anchored = true
Part227.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part227.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part227.BrickColor = BrickColor.new("Really black")
Part227.CanCollide = false
Part227.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part227.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part227.Material = Enum.Material.Metal
Part227.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part227.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part227.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part227.brickColor = BrickColor.new("Really black")
SpecialMesh228.Parent = Part227
SpecialMesh228.Scale = Vector3.new(0.569999993, 0.125, 0.375)
SpecialMesh228.MeshType = Enum.MeshType.Wedge
Part229.Parent = Model0
Part229.CFrame = CFrame.new(-0.614671409, 3.24594569, -12.4355726, -0.999985635, -0.00162807154, -0.00510656228, -0.00513649778, 0.0189459547, 0.999807417, -0.00153100886, 0.999819279, -0.0189540461)
Part229.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part229.Position = Vector3.new(-0.614671409, 3.24594569, -12.4355726)
Part229.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part229.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part229.Velocity = Vector3.new(5.76182231e-08, 0.00247013662, 7.57164685e-07)
Part229.Size = Vector3.new(0.275000006, 0.745124936, 0.280375004)
Part229.Anchored = true
Part229.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part229.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part229.BrickColor = BrickColor.new("Really black")
Part229.CanCollide = false
Part229.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part229.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part229.Material = Enum.Material.Metal
Part229.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part229.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part229.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part229.brickColor = BrickColor.new("Really black")
SpecialMesh230.Parent = Part229
SpecialMesh230.Scale = Vector3.new(0.400000006, 1.04999995, 0.5)
SpecialMesh230.MeshType = Enum.MeshType.Brick
Part231.Parent = Model0
Part231.CFrame = CFrame.new(-0.610754132, 2.89412951, -13.8151274, -0.999985635, -0.00162807154, -0.00510650687, -0.00513644237, 0.0189459547, 0.999807417, -0.00153100991, 0.999819279, -0.0189540461)
Part231.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part231.Position = Vector3.new(-0.610754132, 2.89412951, -13.8151274)
Part231.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part231.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part231.Velocity = Vector3.new(1.1340417e-07, 0.00246726256, 1.49025209e-06)
Part231.Size = Vector3.new(0.275000006, 0.200000003, 0.303375006)
Part231.Anchored = true
Part231.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part231.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part231.BrickColor = BrickColor.new("Really black")
Part231.CanCollide = false
Part231.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part231.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part231.Material = Enum.Material.Glass
Part231.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part231.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part231.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part231.brickColor = BrickColor.new("Really black")
SpecialMesh232.Parent = Part231
SpecialMesh232.Scale = Vector3.new(0.524999976, 0.5, 0.5)
SpecialMesh232.MeshType = Enum.MeshType.Wedge
Part233.Parent = Model0
Part233.CFrame = CFrame.new(-0.614374042, 3.38457584, -13.09618, 0.999985635, -0.00162795233, 0.00510671316, 0.00513664633, 0.0189459547, -0.999807417, 0.00153088674, 0.999819279, 0.0189540461)
Part233.Orientation = Vector3.new(88.8799973, 15.0799999, 15.1700001)
Part233.Position = Vector3.new(-0.614374042, 3.38457584, -13.09618)
Part233.Rotation = Vector3.new(88.909996, 0.289999992, 0.0899999961)
Part233.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part233.Velocity = Vector3.new(3.56362335e-08, 0.00246876013, 4.68297941e-07)
Part233.Size = Vector3.new(0.275000006, 0.322125077, 0.363375008)
Part233.Anchored = true
Part233.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part233.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part233.BrickColor = BrickColor.new("Really black")
Part233.CanCollide = false
Part233.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part233.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part233.Material = Enum.Material.Metal
Part233.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part233.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part233.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part233.brickColor = BrickColor.new("Really black")
SpecialMesh234.Parent = Part233
SpecialMesh234.Scale = Vector3.new(0.5, 1, 1)
SpecialMesh234.MeshType = Enum.MeshType.Wedge
Part235.Parent = Model0
Part235.CFrame = CFrame.new(-0.612951875, 3.3556869, -13.9274721, 0.999985635, 0.00162774313, -0.00510693667, 0.00513686566, -0.0189458374, 0.999807417, 0.00153067405, -0.999819279, -0.0189539269)
Part235.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part235.Position = Vector3.new(-0.612951875, 3.3556869, -13.9274721)
Part235.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part235.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part235.Velocity = Vector3.new(4.02170173e-08, 0.0024670281, 5.28494468e-07)
Part235.Size = Vector3.new(0.275000006, 0.54112494, 0.367374986)
Part235.Anchored = true
Part235.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part235.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part235.BrickColor = BrickColor.new("Really black")
Part235.CanCollide = false
Part235.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part235.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part235.Material = Enum.Material.Metal
Part235.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part235.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part235.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part235.brickColor = BrickColor.new("Really black")
SpecialMesh236.Parent = Part235
SpecialMesh236.Scale = Vector3.new(0.5, 1.04999995, 0.600000024)
SpecialMesh236.MeshType = Enum.MeshType.Brick
Part237.Parent = Model0
Part237.CFrame = CFrame.new(-0.611452341, 3.03449631, -13.8299093, 0.999985635, 0.00162795268, -0.00510686403, 0.0051367972, -0.0189460143, 0.999807417, 0.00153088395, -0.999819279, -0.0189541057)
Part237.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part237.Position = Vector3.new(-0.611452341, 3.03449631, -13.8299093)
Part237.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part237.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part237.Velocity = Vector3.new(9.11468163e-08, 0.00246723159, 1.19776655e-06)
Part237.Size = Vector3.new(0.275000006, 0.207000002, 0.303375006)
Part237.Anchored = true
Part237.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part237.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part237.BrickColor = BrickColor.new("Really black")
Part237.CanCollide = false
Part237.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part237.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part237.Material = Enum.Material.Metal
Part237.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part237.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part237.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part237.brickColor = BrickColor.new("Really black")
SpecialMesh238.Parent = Part237
SpecialMesh238.Scale = Vector3.new(0.5, 0.5, 0.5)
SpecialMesh238.MeshType = Enum.MeshType.Wedge
Part239.Parent = Model0
Part239.CFrame = CFrame.new(-0.608695984, 3.30580091, -16.5400867, 0.999985635, -0.00133592135, 0.00519114826, 0.0051369979, -0.0377659909, -0.999273479, 0.00153099943, 0.999285758, -0.0377585851)
Part239.Orientation = Vector3.new(87.8199997, 172.169998, 172.25)
Part239.Position = Vector3.new(-0.608695984, 3.30580091, -16.5400867)
Part239.Rotation = Vector3.new(92.159996, 0.299999982, 0.0799999982)
Part239.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part239.Velocity = Vector3.new(4.81271911e-08, 0.00246158475, 6.32443061e-07)
Part239.Size = Vector3.new(0.275000006, 1.65712488, 0.422374964)
Part239.Anchored = true
Part239.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part239.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part239.BrickColor = BrickColor.new("Really black")
Part239.CanCollide = false
Part239.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part239.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part239.Material = Enum.Material.Metal
Part239.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part239.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part239.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part239.brickColor = BrickColor.new("Really black")
SpecialMesh240.Parent = Part239
SpecialMesh240.Scale = Vector3.new(0.400000006, 1, 0.5)
SpecialMesh240.MeshType = Enum.MeshType.Brick
Part241.Parent = Model0
Part241.CFrame = CFrame.new(-0.607766628, 3.58790874, -18.0936966, 0.999985635, -0.0010395617, 0.00525854016, 0.00513699278, -0.0943568796, -0.99552542, 0.00153108896, 0.995537996, -0.094350189)
Part241.Orientation = Vector3.new(84.5800018, 176.809998, 176.87999)
Part241.Position = Vector3.new(-0.607766628, 3.58790874, -18.0936966)
Part241.Rotation = Vector3.new(95.409996, 0.299999982, 0.0599999987)
Part241.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part241.Velocity = Vector3.new(3.39455752e-09, 0.00245834771, 4.46085551e-08)
Part241.Size = Vector3.new(0.275000006, 1.66212487, 0.359375)
Part241.Anchored = true
Part241.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part241.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part241.BrickColor = BrickColor.new("Really black")
Part241.CanCollide = false
Part241.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part241.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part241.Material = Enum.Material.Metal
Part241.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part241.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part241.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part241.brickColor = BrickColor.new("Really black")
SpecialMesh242.Parent = Part241
SpecialMesh242.Scale = Vector3.new(0.400000006, 1, 0.5)
SpecialMesh242.MeshType = Enum.MeshType.Brick
Part243.Parent = Model0
Part243.CFrame = CFrame.new(-0.618630528, 3.29811025, -11.1170893, -0.999985635, -0.00162795233, -0.0051068007, -0.00513673387, 0.0189459547, 0.999807417, -0.00153088511, 0.999819279, -0.0189540461)
Part243.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part243.Position = Vector3.new(-0.618630528, 3.29811025, -11.1170893)
Part243.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part243.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part243.Velocity = Vector3.new(4.93467311e-08, 0.00247288332, 6.48468244e-07)
Part243.Size = Vector3.new(0.25999999, 0.3125, 0.320125014)
Part243.Anchored = true
Part243.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part243.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part243.BrickColor = BrickColor.new("Really black")
Part243.CanCollide = false
Part243.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part243.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part243.Material = Enum.Material.Metal
Part243.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part243.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part243.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part243.brickColor = BrickColor.new("Really black")
SpecialMesh244.Parent = Part243
SpecialMesh244.Scale = Vector3.new(0.5, 1, 1)
SpecialMesh244.MeshType = Enum.MeshType.Wedge
Part245.Parent = Model0
Part245.CFrame = CFrame.new(-0.639055848, 2.33898354, -13.8797112, 0.0028942409, -0.999985635, -0.00451144017, -0.277069569, -0.00513673481, 0.960836232, -0.960845649, -0.00153090828, -0.277080446)
Part245.Orientation = Vector3.new(-73.909996, -179.069992, -91.0599976)
Part245.Position = Vector3.new(-0.639055848, 2.33898354, -13.8797112)
Part245.Rotation = Vector3.new(-106.089996, -0.25999999, 89.8299942)
Part245.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part245.Velocity = Vector3.new(2.01431277e-07, 0.00246712356, 2.64702226e-06)
Part245.Size = Vector3.new(0.453000009, 0.200000003, 0.280375004)
Part245.Anchored = true
Part245.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part245.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part245.BrickColor = BrickColor.new("Royal purple")
Part245.CanCollide = false
Part245.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part245.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part245.Material = Enum.Material.Neon
Part245.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part245.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part245.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part245.brickColor = BrickColor.new("Royal purple")
SpecialMesh246.Parent = Part245
SpecialMesh246.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh246.MeshType = Enum.MeshType.Wedge
Part247.Parent = Model0
Part247.CFrame = CFrame.new(-0.611137211, 3.24560308, -14.7434616, 0.999985635, -0.00162807363, 0.00510707032, 0.00513700629, 0.018946372, -0.999807417, 0.0015309992, 0.999819279, 0.0189544633)
Part247.Orientation = Vector3.new(88.8799973, 15.0799999, 15.1700001)
Part247.Position = Vector3.new(-0.611137211, 3.24560308, -14.7434616)
Part247.Rotation = Vector3.new(88.909996, 0.289999992, 0.0899999961)
Part247.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part247.Velocity = Vector3.new(5.76725228e-08, 0.0024653282, 7.57878638e-07)
Part247.Size = Vector3.new(0.275000006, 0.488124937, 0.418375015)
Part247.Anchored = true
Part247.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part247.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part247.BrickColor = BrickColor.new("Really black")
Part247.CanCollide = false
Part247.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part247.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part247.Material = Enum.Material.Metal
Part247.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part247.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part247.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part247.brickColor = BrickColor.new("Really black")
SpecialMesh248.Parent = Part247
SpecialMesh248.Scale = Vector3.new(0.400000006, 1, 0.899999976)
SpecialMesh248.MeshType = Enum.MeshType.Brick
Part249.Parent = Model0
Part249.CFrame = CFrame.new(-0.646988273, 3.68078995, -13.1990242, 0.00245985761, -0.999985635, 0.00476197852, -0.693573356, -0.00513654156, -0.720367849, 0.720381916, -0.00153077836, -0.693576097)
Part249.Orientation = Vector3.new(46.079998, 179.610001, -90.4199982)
Part249.Position = Vector3.new(-0.646988273, 3.68078995, -13.1990242)
Part249.Rotation = Vector3.new(133.910004, 0.269999981, 89.8600006)
Part249.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part249.Velocity = Vector3.new(-1.13331566e-08, 0.00246854057, -1.48930098e-07)
Part249.Size = Vector3.new(0.496000022, 0.200000003, 0.280375004)
Part249.Anchored = true
Part249.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part249.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part249.BrickColor = BrickColor.new("Royal purple")
Part249.CanCollide = false
Part249.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part249.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part249.Material = Enum.Material.Neon
Part249.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part249.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part249.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part249.brickColor = BrickColor.new("Royal purple")
SpecialMesh250.Parent = Part249
SpecialMesh250.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh250.MeshType = Enum.MeshType.Wedge
Part251.Parent = Model0
Part251.CFrame = CFrame.new(-0.616084397, 3.20240736, -11.3666525, -0.999985635, -0.000716604234, -0.00531162601, -0.00513642887, -0.154956639, 0.987908065, -0.00153101014, 0.987921119, 0.154950723)
Part251.Orientation = Vector3.new(-81.0800018, -1.95999992, -178.099991)
Part251.Position = Vector3.new(-0.616084397, 3.20240736, -11.3666525)
Part251.Rotation = Vector3.new(-81.0899963, -0.299999982, 179.959991)
Part251.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part251.Velocity = Vector3.new(6.45219203e-08, 0.00247236365, 8.47886554e-07)
Part251.Size = Vector3.new(0.275000006, 0.203125, 0.234375)
Part251.Anchored = true
Part251.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part251.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part251.BrickColor = BrickColor.new("Really black")
Part251.CanCollide = false
Part251.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part251.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part251.Material = Enum.Material.Metal
Part251.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part251.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part251.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part251.brickColor = BrickColor.new("Really black")
SpecialMesh252.Parent = Part251
SpecialMesh252.Scale = Vector3.new(0.5, 1.04999995, 0.400000006)
SpecialMesh252.MeshType = Enum.MeshType.Brick
Part253.Parent = Model0
Part253.CFrame = CFrame.new(-0.616027236, 3.22281599, -11.4724684, -0.999985635, -0.00162807154, -0.00510656228, -0.00513649778, 0.0189459547, 0.999807417, -0.00153100886, 0.999819279, -0.0189540461)
Part253.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part253.Position = Vector3.new(-0.616027236, 3.22281599, -11.4724684)
Part253.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part253.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part253.Velocity = Vector3.new(6.12858102e-08, 0.00247214315, 8.05360628e-07)
Part253.Size = Vector3.new(0.275000006, 0.415125012, 0.234375)
Part253.Anchored = true
Part253.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part253.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part253.BrickColor = BrickColor.new("Really black")
Part253.CanCollide = false
Part253.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part253.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part253.Material = Enum.Material.Metal
Part253.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part253.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part253.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part253.brickColor = BrickColor.new("Really black")
SpecialMesh254.Parent = Part253
SpecialMesh254.Scale = Vector3.new(0.5, 1.04999995, 0.400000006)
SpecialMesh254.MeshType = Enum.MeshType.Brick
Part255.Parent = Model0
Part255.CFrame = CFrame.new(-0.610752404, 3.28331137, -15.1213608, 0.999985635, -0.00347625092, 0.00408016983, 0.00513697462, 0.404109061, -0.914696634, 0.00153088057, 0.914704442, 0.404121131)
Part255.Orientation = Vector3.new(66.159996, 0.579999983, 0.729999959)
Part255.Position = Vector3.new(-0.610752404, 3.28331137, -15.1213608)
Part255.Rotation = Vector3.new(66.159996, 0.229999989, 0.199999988)
Part255.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part255.Velocity = Vector3.new(5.16932808e-08, 0.00246454077, 6.79305003e-07)
Part255.Size = Vector3.new(0.275000006, 0.330124885, 0.214375019)
Part255.Anchored = true
Part255.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part255.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part255.BrickColor = BrickColor.new("Bright blue")
Part255.CanCollide = false
Part255.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part255.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part255.Material = Enum.Material.Neon
Part255.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part255.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part255.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part255.brickColor = BrickColor.new("Bright blue")
SpecialMesh256.Parent = Part255
SpecialMesh256.Scale = Vector3.new(0.449999988, 1, 0.100000001)
SpecialMesh256.MeshType = Enum.MeshType.Brick
Part257.Parent = Model0
Part257.CFrame = CFrame.new(-0.63657546, 3.38894939, -19.0216789, -0.00237622252, -0.999985635, -0.00480452133, 0.680895686, -0.00513668498, 0.732362568, -0.732376754, -0.00153112097, 0.68089813)
Part257.Orientation = Vector3.new(-47.079998, -0.399999976, 90.4300003)
Part257.Position = Vector3.new(-0.63657546, 3.38894939, -19.0216789)
Part257.Rotation = Vector3.new(-47.0900002, -0.280000001, 90.1399994)
Part257.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part257.Velocity = Vector3.new(3.49426692e-08, 0.00245640939, 4.59184662e-07)
Part257.Size = Vector3.new(0.940000057, 0.200000003, 0.285374999)
Part257.Anchored = true
Part257.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part257.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part257.BrickColor = BrickColor.new("Royal purple")
Part257.CanCollide = false
Part257.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part257.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part257.Material = Enum.Material.Neon
Part257.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part257.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part257.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part257.brickColor = BrickColor.new("Royal purple")
SpecialMesh258.Parent = Part257
SpecialMesh258.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh258.MeshType = Enum.MeshType.Wedge
Part259.Parent = Model0
Part259.CFrame = CFrame.new(-0.584489346, 3.6811111, -13.1989288, -0.00245976867, 0.999985635, 0.00476201251, 0.693573415, 0.00513650384, -0.720367789, -0.720381916, 0.00153086672, -0.693576038)
Part259.Orientation = Vector3.new(46.079998, 179.610001, 89.5799942)
Part259.Position = Vector3.new(-0.584489346, 3.6811111, -13.1989288)
Part259.Rotation = Vector3.new(133.910004, 0.269999981, -90.1399994)
Part259.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part259.Velocity = Vector3.new(-1.13840777e-08, 0.00246855081, -1.49599259e-07)
Part259.Size = Vector3.new(0.496000022, 0.200000003, 0.280375004)
Part259.Anchored = true
Part259.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part259.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part259.BrickColor = BrickColor.new("Royal purple")
Part259.CanCollide = false
Part259.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part259.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part259.Material = Enum.Material.Neon
Part259.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part259.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part259.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part259.brickColor = BrickColor.new("Royal purple")
SpecialMesh260.Parent = Part259
SpecialMesh260.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh260.MeshType = Enum.MeshType.Wedge
Part261.Parent = Model0
Part261.CFrame = CFrame.new(-0.574076533, 3.38927007, -19.0215836, 0.00237613311, 0.999985635, -0.00480454601, -0.680895686, 0.00513664167, 0.732362568, 0.732376754, 0.00153120293, 0.68089813)
Part261.Orientation = Vector3.new(-47.079998, -0.399999976, -89.5699997)
Part261.Position = Vector3.new(-0.574076533, 3.38927007, -19.0215836)
Part261.Rotation = Vector3.new(-47.0900002, -0.280000001, -89.8600006)
Part261.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part261.Velocity = Vector3.new(3.48918228e-08, 0.00245641964, 4.58516467e-07)
Part261.Size = Vector3.new(0.940000057, 0.200000003, 0.285374999)
Part261.Anchored = true
Part261.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part261.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part261.BrickColor = BrickColor.new("Royal purple")
Part261.CanCollide = false
Part261.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part261.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part261.Material = Enum.Material.Neon
Part261.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part261.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part261.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part261.brickColor = BrickColor.new("Royal purple")
SpecialMesh262.Parent = Part261
SpecialMesh262.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh262.MeshType = Enum.MeshType.Wedge
Part263.Parent = Model0
Part263.CFrame = CFrame.new(-0.640052557, 2.92977762, -15.2103024, 0.00336818164, -0.999985635, -0.00416955911, -0.380026042, -0.00513675297, 0.924961627, -0.924969733, -0.00153089722, -0.380037904)
Part263.Orientation = Vector3.new(-67.659996, -179.369995, -90.7699966)
Part263.Position = Vector3.new(-0.640052557, 2.92977762, -15.2103024)
Part263.Rotation = Vector3.new(-112.339996, -0.239999995, 89.8099976)
Part263.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part263.Velocity = Vector3.new(1.07751589e-07, 0.00246435078, 1.41597127e-06)
Part263.Size = Vector3.new(0.288000047, 0.200000003, 0.27837503)
Part263.Anchored = true
Part263.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part263.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part263.BrickColor = BrickColor.new("Royal purple")
Part263.CanCollide = false
Part263.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part263.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part263.Material = Enum.Material.Neon
Part263.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part263.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part263.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part263.brickColor = BrickColor.new("Royal purple")
SpecialMesh264.Parent = Part263
SpecialMesh264.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh264.MeshType = Enum.MeshType.Wedge
Part265.Parent = Model0
Part265.CFrame = CFrame.new(-0.611472309, 3.03472614, -13.8177929, 0.999985635, -0.00162807154, 0.00510659395, 0.00513652945, 0.0189459547, -0.999807417, 0.00153100828, 0.999819279, 0.0189540461)
Part265.Orientation = Vector3.new(88.8799973, 15.0799999, 15.1700001)
Part265.Position = Vector3.new(-0.611472309, 3.03472614, -13.8177929)
Part265.Rotation = Vector3.new(88.909996, 0.289999992, 0.0899999961)
Part265.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part265.Velocity = Vector3.new(9.11103797e-08, 0.00246725697, 1.1972877e-06)
Part265.Size = Vector3.new(0.275000006, 0.200000003, 0.303375006)
Part265.Anchored = true
Part265.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part265.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part265.BrickColor = BrickColor.new("Really black")
Part265.CanCollide = false
Part265.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part265.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part265.Material = Enum.Material.Glass
Part265.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part265.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part265.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part265.brickColor = BrickColor.new("Really black")
SpecialMesh266.Parent = Part265
SpecialMesh266.Scale = Vector3.new(0.524999976, 0.5, 0.5)
SpecialMesh266.MeshType = Enum.MeshType.Wedge
Part267.Parent = Model0
Part267.CFrame = CFrame.new(-0.608101904, 3.29321218, -16.8867702, 0.999985635, -0.00103956275, 0.00525853597, 0.00513698952, -0.0943567529, -0.99552536, 0.00153108896, 0.995537996, -0.0943500549)
Part267.Orientation = Vector3.new(84.5800018, 176.809998, 176.87999)
Part267.Position = Vector3.new(-0.608101904, 3.29321218, -16.8867702)
Part267.Rotation = Vector3.new(95.409996, 0.299999982, 0.0599999987)
Part267.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part267.Velocity = Vector3.new(5.0123333e-08, 0.00246086251, 6.5867448e-07)
Part267.Size = Vector3.new(0.275000006, 0.454124868, 0.214375019)
Part267.Anchored = true
Part267.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part267.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part267.BrickColor = BrickColor.new("Bright blue")
Part267.CanCollide = false
Part267.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part267.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part267.Material = Enum.Material.Neon
Part267.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part267.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part267.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part267.brickColor = BrickColor.new("Bright blue")
SpecialMesh268.Parent = Part267
SpecialMesh268.Scale = Vector3.new(0.449999988, 0.899999976, 0.100000001)
SpecialMesh268.MeshType = Enum.MeshType.Brick
Part269.Parent = Model0
Part269.CFrame = CFrame.new(-0.609975338, 2.71316695, -13.7165575, -0.999985635, -0.00476232171, -0.00245974911, -0.00513671385, 0.720367908, 0.693573296, -0.0015310942, 0.693576038, -0.720381975)
Part269.Orientation = Vector3.new(-43.9099998, -179.800003, -0.409999996)
Part269.Position = Vector3.new(-0.609975338, 2.71316695, -13.7165575)
Part269.Rotation = Vector3.new(-136.089996, -0.140000001, 179.729996)
Part269.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part269.Velocity = Vector3.new(1.42098628e-07, 0.00246746815, 1.8673278e-06)
Part269.Size = Vector3.new(0.275000006, 0.403124899, 0.352375001)
Part269.Anchored = true
Part269.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part269.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part269.BrickColor = BrickColor.new("Really black")
Part269.CanCollide = false
Part269.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part269.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part269.Material = Enum.Material.Metal
Part269.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part269.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part269.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part269.brickColor = BrickColor.new("Really black")
SpecialMesh270.Parent = Part269
SpecialMesh270.Scale = Vector3.new(0.349999994, 1, 1)
SpecialMesh270.MeshType = Enum.MeshType.Brick
Part271.Parent = Model0
Part271.CFrame = CFrame.new(-0.583012402, 3.6639781, -14.1030874, 0.00476215919, 0.999985635, 0.00246015075, -0.720367849, 0.0051368745, -0.693573356, -0.693576038, 0.00153069268, 0.720381975)
Part271.Orientation = Vector3.new(43.9099998, 0.199999988, -89.5899963)
Part271.Position = Vector3.new(-0.583012402, 3.6639781, -14.1030874)
Part271.Rotation = Vector3.new(43.9099998, 0.140000001, -89.7299957)
Part271.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part271.Velocity = Vector3.new(-8.66738503e-09, 0.00246666698, -1.13898864e-07)
Part271.Size = Vector3.new(0.496000022, 0.200000003, 0.280375004)
Part271.Anchored = true
Part271.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part271.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part271.BrickColor = BrickColor.new("Royal purple")
Part271.CanCollide = false
Part271.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part271.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part271.Material = Enum.Material.Neon
Part271.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part271.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part271.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part271.brickColor = BrickColor.new("Royal purple")
SpecialMesh272.Parent = Part271
SpecialMesh272.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh272.MeshType = Enum.MeshType.Wedge
Part273.Parent = Model0
Part273.CFrame = CFrame.new(-0.573997319, 3.0173018, -17.825201, -0.00108546892, 0.999985635, -0.00524905883, -0.0856661052, 0.00513677904, 0.99631083, 0.996323526, 0.00153113017, 0.0856593028)
Part273.Orientation = Vector3.new(-85.0800018, -3.50999999, -86.5699997)
Part273.Position = Vector3.new(-0.573997319, 3.0173018, -17.825201)
Part273.Rotation = Vector3.new(-85.0899963, -0.299999982, -90.0599976)
Part273.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part273.Velocity = Vector3.new(9.38732327e-08, 0.00245891255, 1.23359519e-06)
Part273.Size = Vector3.new(1.78499997, 0.200000003, 0.301375002)
Part273.Anchored = true
Part273.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part273.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part273.BrickColor = BrickColor.new("Royal purple")
Part273.CanCollide = false
Part273.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part273.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part273.Material = Enum.Material.Neon
Part273.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part273.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part273.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part273.brickColor = BrickColor.new("Royal purple")
SpecialMesh274.Parent = Part273
SpecialMesh274.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh274.MeshType = Enum.MeshType.Wedge
Part275.Parent = Model0
Part275.CFrame = CFrame.new(-0.614639282, 3.4985106, -13.3051252, -0.999985635, 0.00162801275, 0.00510680024, -0.00513673527, -0.0189461038, -0.999807417, -0.00153094472, -0.999819279, 0.0189541951)
Part275.Orientation = Vector3.new(88.8799973, 15.0799999, -164.830002)
Part275.Position = Vector3.new(-0.614639282, 3.4985106, -13.3051252)
Part275.Rotation = Vector3.new(88.909996, 0.289999992, -179.909988)
Part275.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part275.Velocity = Vector3.new(1.75700912e-08, 0.00246832473, 2.30889498e-07)
Part275.Size = Vector3.new(0.275000006, 0.204125047, 0.207375005)
Part275.Anchored = true
Part275.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part275.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part275.BrickColor = BrickColor.new("Really black")
Part275.CanCollide = false
Part275.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part275.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part275.Material = Enum.Material.Metal
Part275.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part275.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part275.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part275.brickColor = BrickColor.new("Really black")
SpecialMesh276.Parent = Part275
SpecialMesh276.Scale = Vector3.new(0.5, 0.5, 0.5)
SpecialMesh276.MeshType = Enum.MeshType.Wedge
Part277.Parent = Model0
Part277.CFrame = CFrame.new(-0.609530032, 2.79620743, -14.2853489, 0.999985635, 0.00162795268, -0.00510686403, 0.0051367972, -0.0189460143, 0.999807417, 0.00153088395, -0.999819279, -0.0189541057)
Part277.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part277.Position = Vector3.new(-0.609530032, 2.79620743, -14.2853489)
Part277.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part277.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part277.Velocity = Vector3.new(1.28931248e-07, 0.00246628304, 1.6942945e-06)
Part277.Size = Vector3.new(0.275000006, 0.223999977, 0.375375003)
Part277.Anchored = true
Part277.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part277.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part277.BrickColor = BrickColor.new("Really black")
Part277.CanCollide = false
Part277.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part277.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part277.Material = Enum.Material.Glass
Part277.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part277.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part277.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part277.brickColor = BrickColor.new("Really black")
SpecialMesh278.Parent = Part277
SpecialMesh278.Scale = Vector3.new(0.5, 0.699999988, 0.5)
SpecialMesh278.MeshType = Enum.MeshType.Brick
Part279.Parent = Model0
Part279.CFrame = CFrame.new(-0.578278601, 2.9706955, -14.8714504, -0.00156111596, 0.999985635, -0.00512771122, 0.00585717056, 0.00513677299, 0.99996984, 0.999981761, 0.00153103413, -0.00586510636)
Part279.Orientation = Vector3.new(-89.5599976, -138.839996, 48.75)
Part279.Position = Vector3.new(-0.578278601, 2.9706955, -14.8714504)
Part279.Rotation = Vector3.new(-90.3399963, -0.289999992, -90.0899963)
Part279.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part279.Velocity = Vector3.new(1.01263424e-07, 0.00246506673, 1.33070978e-06)
Part279.Size = Vector3.new(0.49000001, 0.200000003, 0.290374994)
Part279.Anchored = true
Part279.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part279.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part279.BrickColor = BrickColor.new("Royal purple")
Part279.CanCollide = false
Part279.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part279.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part279.Material = Enum.Material.Neon
Part279.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part279.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part279.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part279.brickColor = BrickColor.new("Royal purple")
SpecialMesh280.Parent = Part279
SpecialMesh280.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh280.MeshType = Enum.MeshType.Wedge
Part281.Parent = Model0
Part281.CFrame = CFrame.new(-0.613238811, 3.32843637, -13.6493177, -0.999985635, -0.00162807142, -0.00510653527, -0.00513647031, 0.0189459249, 0.999807417, -0.00153100933, 0.999819279, -0.0189540163)
Part281.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part281.Position = Vector3.new(-0.613238811, 3.32843637, -13.6493177)
Part281.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part281.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part281.Velocity = Vector3.new(4.45380195e-08, 0.00246760761, 5.85277007e-07)
Part281.Size = Vector3.new(0.275000006, 0.698124886, 0.732374966)
Part281.Anchored = true
Part281.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part281.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part281.BrickColor = BrickColor.new("Really black")
Part281.CanCollide = false
Part281.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part281.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part281.Material = Enum.Material.Metal
Part281.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part281.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part281.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part281.brickColor = BrickColor.new("Really black")
SpecialMesh282.Parent = Part281
SpecialMesh282.Scale = Vector3.new(0.425000012, 1, 1)
SpecialMesh282.MeshType = Enum.MeshType.Cylinder
Part283.Parent = Model0
Part283.CFrame = CFrame.new(-0.614591718, 3.4972918, -13.3320847, -0.999985635, 0.00245974353, -0.0047620195, -0.00513649127, -0.693573475, 0.72036773, -0.00153088977, 0.720381856, 0.693576157)
Part283.Orientation = Vector3.new(-46.079998, -0.389999986, -179.580002)
Part283.Position = Vector3.new(-0.614591718, 3.4972918, -13.3320847)
Part283.Rotation = Vector3.new(-46.0900002, -0.269999981, -179.860001)
Part283.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part283.Velocity = Vector3.new(1.77633499e-08, 0.00246826862, 2.33429148e-07)
Part283.Size = Vector3.new(0.275000006, 0.413124949, 0.622375011)
Part283.Anchored = true
Part283.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part283.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part283.BrickColor = BrickColor.new("Really black")
Part283.CanCollide = false
Part283.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part283.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part283.Material = Enum.Material.Metal
Part283.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part283.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part283.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part283.brickColor = BrickColor.new("Really black")
SpecialMesh284.Parent = Part283
SpecialMesh284.Scale = Vector3.new(0.400000006, 1.04999995, 0.5)
SpecialMesh284.MeshType = Enum.MeshType.Brick
Part285.Parent = Model0
Part285.CFrame = CFrame.new(-0.615438342, 3.25487208, -11.9645395, -0.999985635, 0.00162786292, 0.00510683237, -0.00513676414, -0.0189459566, -0.999807417, -0.00153079513, -0.999819279, 0.0189540461)
Part285.Orientation = Vector3.new(88.8799973, 15.0799999, -164.830002)
Part285.Position = Vector3.new(-0.615438342, 3.25487208, -11.9645395)
Part285.Rotation = Vector3.new(88.909996, 0.289999992, -179.909988)
Part285.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part285.Velocity = Vector3.new(5.62028113e-08, 0.002471118, 7.38564609e-07)
Part285.Size = Vector3.new(0.275000006, 0.206125051, 0.280375004)
Part285.Anchored = true
Part285.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part285.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part285.BrickColor = BrickColor.new("Really black")
Part285.CanCollide = false
Part285.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part285.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part285.Material = Enum.Material.Metal
Part285.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part285.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part285.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part285.brickColor = BrickColor.new("Really black")
SpecialMesh286.Parent = Part285
SpecialMesh286.Scale = Vector3.new(0.400000006, 0.560000002, 0.5)
SpecialMesh286.MeshType = Enum.MeshType.Wedge
Part287.Parent = Model0
Part287.CFrame = CFrame.new(-0.613306701, 3.18584442, -13.1265478, -0.999985635, -0.00162807154, -0.00510656228, -0.00513649778, 0.0189459547, 0.999807417, -0.00153100886, 0.999819279, -0.0189540461)
Part287.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part287.Position = Vector3.new(-0.613306701, 3.18584442, -13.1265478)
Part287.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part287.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part287.Velocity = Vector3.new(6.71482141e-08, 0.00246869703, 8.82399092e-07)
Part287.Size = Vector3.new(0.275000006, 0.567124963, 0.311374992)
Part287.Anchored = true
Part287.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part287.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part287.BrickColor = BrickColor.new("Really black")
Part287.CanCollide = false
Part287.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part287.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part287.Material = Enum.Material.Metal
Part287.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part287.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part287.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part287.brickColor = BrickColor.new("Really black")
SpecialMesh288.Parent = Part287
SpecialMesh288.Scale = Vector3.new(0.400000006, 1.04999995, 0.5)
SpecialMesh288.MeshType = Enum.MeshType.Brick
Part289.Parent = Model0
Part289.CFrame = CFrame.new(-0.646988273, 3.68078995, -13.1990242, 0.00245985761, -0.999985635, 0.00476197852, -0.693573356, -0.00513654156, -0.720367849, 0.720381916, -0.00153077836, -0.693576097)
Part289.Orientation = Vector3.new(46.079998, 179.610001, -90.4199982)
Part289.Position = Vector3.new(-0.646988273, 3.68078995, -13.1990242)
Part289.Rotation = Vector3.new(133.910004, 0.269999981, 89.8600006)
Part289.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part289.Velocity = Vector3.new(-1.13331566e-08, 0.00246854057, -1.48930098e-07)
Part289.Size = Vector3.new(0.496000022, 0.200000003, 0.280375004)
Part289.Anchored = true
Part289.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part289.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part289.BrickColor = BrickColor.new("Royal purple")
Part289.CanCollide = false
Part289.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part289.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part289.Material = Enum.Material.Neon
Part289.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part289.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part289.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part289.brickColor = BrickColor.new("Royal purple")
SpecialMesh290.Parent = Part289
SpecialMesh290.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh290.MeshType = Enum.MeshType.Wedge
Part291.Parent = Model0
Part291.CFrame = CFrame.new(-0.611590862, 3.29178786, -14.6020966, 0.999985635, -0.00510681886, -0.00162807701, 0.00513675623, 0.999807417, 0.0189470276, 0.00153100397, -0.018955119, 0.999819279)
Part291.Orientation = Vector3.new(-1.09000003, -0.0899999961, 0.289999992)
Part291.Position = Vector3.new(-0.611590862, 3.29178786, -14.6020966)
Part291.Rotation = Vector3.new(-1.09000003, -0.0899999961, 0.289999992)
Part291.Color = Color3.new(0.972549, 0.972549, 0.972549)
Part291.Velocity = Vector3.new(5.03492039e-08, 0.00246562273, 6.61642332e-07)
Part291.Size = Vector3.new(0.275000006, 0.200124964, 0.287375033)
Part291.Anchored = true
Part291.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part291.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part291.BrickColor = BrickColor.new("Institutional white")
Part291.CanCollide = false
Part291.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part291.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part291.Material = Enum.Material.Metal
Part291.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part291.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part291.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part291.brickColor = BrickColor.new("Institutional white")
SpecialMesh292.Parent = Part291
SpecialMesh292.Scale = Vector3.new(0.560000002, 1, 0.899999976)
SpecialMesh292.MeshType = Enum.MeshType.Wedge
Part293.Parent = Model0
Part293.CFrame = CFrame.new(-0.636496425, 3.01698065, -17.8252964, 0.00108537939, -0.999985635, -0.00524905883, 0.0856661052, -0.00513678649, 0.99631083, -0.996323466, -0.00153104111, 0.0856593102)
Part293.Orientation = Vector3.new(-85.0800018, -3.50999999, 93.4300003)
Part293.Position = Vector3.new(-0.636496425, 3.01698065, -17.8252964)
Part293.Rotation = Vector3.new(-85.0899963, -0.299999982, 89.9399948)
Part293.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part293.Velocity = Vector3.new(9.39241573e-08, 0.00245890254, 1.23426435e-06)
Part293.Size = Vector3.new(1.78499997, 0.200000003, 0.301375002)
Part293.Anchored = true
Part293.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part293.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part293.BrickColor = BrickColor.new("Royal purple")
Part293.CanCollide = false
Part293.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part293.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part293.Material = Enum.Material.Neon
Part293.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part293.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part293.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part293.brickColor = BrickColor.new("Royal purple")
SpecialMesh294.Parent = Part293
SpecialMesh294.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh294.MeshType = Enum.MeshType.Wedge
Part295.Parent = Model0
Part295.CFrame = CFrame.new(-0.611132324, 3.1960454, -14.5803022, 0.999985635, 0.00162786234, -0.00510698371, 0.00513691502, -0.0189458374, 0.999807417, 0.00153079221, -0.999819279, -0.0189539269)
Part295.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part295.Position = Vector3.new(-0.611132324, 3.1960454, -14.5803022)
Part295.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part295.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part295.Velocity = Vector3.new(6.55306707e-08, 0.00246566813, 8.61143121e-07)
Part295.Size = Vector3.new(0.275000006, 0.277124941, 0.702375054)
Part295.Anchored = true
Part295.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part295.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part295.BrickColor = BrickColor.new("Really black")
Part295.CanCollide = false
Part295.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part295.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part295.Material = Enum.Material.Glass
Part295.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part295.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part295.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part295.brickColor = BrickColor.new("Really black")
SpecialMesh296.Parent = Part295
SpecialMesh296.Scale = Vector3.new(0.550000012, 0.5, 0.800000012)
SpecialMesh296.MeshType = Enum.MeshType.Brick
Part297.Parent = Model0
Part297.CFrame = CFrame.new(-0.610346913, 2.907269, -14.1244287, 0.999985635, 0.00162795268, -0.00510686403, 0.0051367972, -0.0189460143, 0.999807417, 0.00153088395, -0.999819279, -0.0189541057)
Part297.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part297.Position = Vector3.new(-0.610346913, 2.907269, -14.1244287)
Part297.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part297.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part297.Velocity = Vector3.new(1.11320702e-07, 0.00246661808, 1.462873e-06)
Part297.Size = Vector3.new(0.275000006, 0.207000002, 0.213375002)
Part297.Anchored = true
Part297.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part297.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part297.BrickColor = BrickColor.new("Bright blue")
Part297.CanCollide = false
Part297.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part297.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part297.Material = Enum.Material.Neon
Part297.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part297.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part297.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part297.brickColor = BrickColor.new("Bright blue")
SpecialMesh298.Parent = Part297
SpecialMesh298.Scale = Vector3.new(0.550000012, 0.25, 0.5)
SpecialMesh298.MeshType = Enum.MeshType.Wedge
Part299.Parent = Model0
Part299.CFrame = CFrame.new(-0.617512941, 3.42300797, -11.1735916, 0.999985635, -0.00206693518, 0.00494515104, 0.00513641397, 0.106012821, -0.994351625, 0.00153101049, 0.994362772, 0.106021926)
Part299.Orientation = Vector3.new(83.909996, 2.66999984, 2.76999998)
Part299.Position = Vector3.new(-0.617512941, 3.42300797, -11.1735916)
Part299.Rotation = Vector3.new(83.909996, 0.280000001, 0.119999997)
Part299.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part299.Velocity = Vector3.new(2.95422424e-08, 0.00247276574, 3.88216051e-07)
Part299.Size = Vector3.new(0.275000006, 0.223124996, 0.234375)
Part299.Anchored = true
Part299.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part299.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part299.BrickColor = BrickColor.new("Really black")
Part299.CanCollide = false
Part299.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part299.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part299.Material = Enum.Material.Metal
Part299.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part299.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part299.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part299.brickColor = BrickColor.new("Really black")
SpecialMesh300.Parent = Part299
SpecialMesh300.Scale = Vector3.new(0.5, 1, 0.400000006)
SpecialMesh300.MeshType = Enum.MeshType.Brick
Part301.Parent = Model0
Part301.CFrame = CFrame.new(-0.60622716, 3.20835805, -17.8265324, -0.999985635, 0.00525827007, -0.00103986717, -0.00513669662, -0.995525479, -0.0943559632, -0.00153136277, -0.0943492651, 0.995538116)
Part301.Orientation = Vector3.new(5.40999985, -0.0599999987, -179.699997)
Part301.Position = Vector3.new(-0.60622716, 3.20835805, -17.8265324)
Part301.Rotation = Vector3.new(5.40999985, -0.0599999987, -179.699997)
Part301.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part301.Velocity = Vector3.new(6.35782698e-08, 0.00245890464, 8.35486958e-07)
Part301.Size = Vector3.new(0.275000006, 0.235124931, 1.6693753)
Part301.Anchored = true
Part301.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part301.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part301.BrickColor = BrickColor.new("Really black")
Part301.CanCollide = false
Part301.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part301.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part301.Material = Enum.Material.Metal
Part301.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part301.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part301.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part301.brickColor = BrickColor.new("Really black")
SpecialMesh302.Parent = Part301
SpecialMesh302.Scale = Vector3.new(0.400000006, 1.04999995, 1)
SpecialMesh302.MeshType = Enum.MeshType.Brick
Part303.Parent = Model0
Part303.CFrame = CFrame.new(-0.610610962, 2.80771255, -13.6187115, -0.999985635, -0.00162816129, -0.00510662561, -0.00513656298, 0.0189460143, 0.999807417, -0.00153109711, 0.999819279, -0.0189541057)
Part303.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part303.Position = Vector3.new(-0.610610962, 2.80771255, -13.6187115)
Part303.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part303.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part303.Velocity = Vector3.new(1.27106944e-07, 0.00246767187, 1.67032101e-06)
Part303.Size = Vector3.new(0.275000006, 0.368124902, 0.378374994)
Part303.Anchored = true
Part303.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part303.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part303.BrickColor = BrickColor.new("Really black")
Part303.CanCollide = false
Part303.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part303.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part303.Material = Enum.Material.Glass
Part303.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part303.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part303.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part303.brickColor = BrickColor.new("Really black")
SpecialMesh304.Parent = Part303
SpecialMesh304.Scale = Vector3.new(0.400000006, 1, 1)
SpecialMesh304.MeshType = Enum.MeshType.Wedge
Part305.Parent = Model0
Part305.CFrame = CFrame.new(-0.608244181, 3.38925195, -17.114748, 0.999985635, 0.00432614516, 0.00316458894, 0.00513666775, -0.942128837, -0.335212082, 0.00153127394, 0.335223496, -0.942137599)
Part305.Orientation = Vector3.new(19.5900002, 179.809998, 179.690002)
Part305.Position = Vector3.new(-0.608244181, 3.38925195, -17.114748)
Part305.Rotation = Vector3.new(160.410004, 0.179999992, -0.25)
Part305.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part305.Velocity = Vector3.new(3.48947182e-08, 0.00246038754, 4.5855424e-07)
Part305.Size = Vector3.new(0.275000006, 0.35212487, 0.214375019)
Part305.Anchored = true
Part305.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part305.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part305.BrickColor = BrickColor.new("Bright blue")
Part305.CanCollide = false
Part305.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part305.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part305.Material = Enum.Material.Neon
Part305.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part305.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part305.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part305.brickColor = BrickColor.new("Bright blue")
SpecialMesh306.Parent = Part305
SpecialMesh306.Scale = Vector3.new(0.449999988, 0.5, 0.100000001)
SpecialMesh306.MeshType = Enum.MeshType.Brick
Part307.Parent = Model0
Part307.CFrame = CFrame.new(-0.610837221, 3.46367049, -15.6710596, 0.999985635, 0.00347598689, -0.00408008695, 0.00513679162, -0.404108554, 0.914696753, 0.00153067545, -0.914704561, -0.404120624)
Part307.Orientation = Vector3.new(-66.159996, -179.419998, 179.269989)
Part307.Position = Vector3.new(-0.610837221, 3.46367049, -15.6710596)
Part307.Rotation = Vector3.new(-113.839996, -0.229999989, -0.199999988)
Part307.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part307.Velocity = Vector3.new(2.30945076e-08, 0.00246339524, 3.03486615e-07)
Part307.Size = Vector3.new(0.200000003, 0.217000008, 0.200375021)
Part307.Anchored = true
Part307.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part307.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part307.BrickColor = BrickColor.new("Royal purple")
Part307.CanCollide = false
Part307.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part307.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part307.Material = Enum.Material.Neon
Part307.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part307.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part307.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part307.brickColor = BrickColor.new("Royal purple")
SpecialMesh308.Parent = Part307
SpecialMesh308.Scale = Vector3.new(0.560000002, 0.200000003, 0.600000024)
SpecialMesh308.MeshType = Enum.MeshType.Brick
Part309.Parent = Model0
Part309.CFrame = CFrame.new(-0.609296381, 2.72693467, -14.2067709, 0.999985635, -0.00162807154, 0.00510647474, 0.00513641024, 0.0189459547, -0.999807417, 0.00153101049, 0.999819279, 0.0189540461)
Part309.Orientation = Vector3.new(88.8799973, 15.0799999, 15.1700001)
Part309.Position = Vector3.new(-0.609296381, 2.72693467, -14.2067709)
Part309.Rotation = Vector3.new(88.909996, 0.289999992, 0.0899999961)
Part309.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part309.Velocity = Vector3.new(1.39915542e-07, 0.00246644672, 1.83863972e-06)
Part309.Size = Vector3.new(0.275000006, 0.315999985, 0.310375005)
Part309.Anchored = true
Part309.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part309.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part309.BrickColor = BrickColor.new("Really black")
Part309.CanCollide = false
Part309.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part309.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part309.Material = Enum.Material.Glass
Part309.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part309.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part309.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part309.brickColor = BrickColor.new("Really black")
SpecialMesh310.Parent = Part309
SpecialMesh310.Scale = Vector3.new(0.5, 1, 0.5)
SpecialMesh310.MeshType = Enum.MeshType.Wedge
Part311.Parent = Model0
Part311.CFrame = CFrame.new(-0.610869706, 2.96894002, -13.990572, -0.999985635, -0.00162807154, -0.00510650687, -0.00513644237, 0.0189459547, 0.999807417, -0.00153100991, 0.999819279, -0.0189540461)
Part311.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part311.Position = Vector3.new(-0.610869706, 2.96894002, -13.990572)
Part311.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part311.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part311.Velocity = Vector3.new(1.01541801e-07, 0.00246689701, 1.33436765e-06)
Part311.Size = Vector3.new(0.275000006, 0.214124978, 0.205375016)
Part311.Anchored = true
Part311.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part311.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part311.BrickColor = BrickColor.new("Really black")
Part311.CanCollide = false
Part311.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part311.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part311.Material = Enum.Material.Metal
Part311.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part311.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part311.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part311.brickColor = BrickColor.new("Really black")
SpecialMesh312.Parent = Part311
SpecialMesh312.Scale = Vector3.new(0.569999993, 0.75, 0.75)
SpecialMesh312.MeshType = Enum.MeshType.Brick
Part313.Parent = Model0
Part313.CFrame = CFrame.new(-0.610455632, 3.45922971, -15.9053869, 0.999985635, 0.00347598689, -0.00408008695, 0.00513679162, -0.404108554, 0.914696753, 0.00153067545, -0.914704561, -0.404120624)
Part313.Orientation = Vector3.new(-66.159996, -179.419998, 179.269989)
Part313.Position = Vector3.new(-0.610455632, 3.45922971, -15.9053869)
Part313.Rotation = Vector3.new(-113.839996, -0.229999989, -0.199999988)
Part313.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part313.Velocity = Vector3.new(2.37986608e-08, 0.00246290723, 3.12739985e-07)
Part313.Size = Vector3.new(0.200000003, 0.217000008, 0.200375021)
Part313.Anchored = true
Part313.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part313.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part313.BrickColor = BrickColor.new("Royal purple")
Part313.CanCollide = false
Part313.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part313.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part313.Material = Enum.Material.Neon
Part313.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part313.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part313.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part313.brickColor = BrickColor.new("Royal purple")
SpecialMesh314.Parent = Part313
SpecialMesh314.Scale = Vector3.new(0.560000002, 0.200000003, 0.600000024)
SpecialMesh314.MeshType = Enum.MeshType.Brick
Part315.Parent = Model0
Part315.CFrame = CFrame.new(-0.61787647, 3.39316416, -10.8383427, 0.999985635, -0.00162795314, 0.00510659395, 0.00513652712, 0.0189461038, -0.999807417, 0.00153088907, 0.999819279, 0.0189541951)
Part315.Orientation = Vector3.new(88.8799973, 15.0799999, 15.1700001)
Part315.Position = Vector3.new(-0.61787647, 3.39316416, -10.8383427)
Part315.Rotation = Vector3.new(88.909996, 0.289999992, 0.0899999961)
Part315.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part315.Velocity = Vector3.new(3.42744499e-08, 0.00247346424, 4.50402268e-07)
Part315.Size = Vector3.new(0.275000006, 0.578125, 0.234375)
Part315.Anchored = true
Part315.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part315.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part315.BrickColor = BrickColor.new("Really black")
Part315.CanCollide = false
Part315.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part315.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part315.Material = Enum.Material.Metal
Part315.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part315.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part315.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part315.brickColor = BrickColor.new("Really black")
SpecialMesh316.Parent = Part315
SpecialMesh316.Scale = Vector3.new(0.5, 1.04999995, 0.400000006)
SpecialMesh316.MeshType = Enum.MeshType.Brick
Part317.Parent = Model0
Part317.CFrame = CFrame.new(-0.613369107, 3.18659282, -13.087059, -0.999985635, -0.00162807154, -0.00510656228, -0.00513649778, 0.0189459547, 0.999807417, -0.00153100886, 0.999819279, -0.0189540461)
Part317.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part317.Position = Vector3.new(-0.613369107, 3.18659282, -13.087059)
Part317.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part317.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part317.Velocity = Vector3.new(6.70295464e-08, 0.00246877922, 8.8083965e-07)
Part317.Size = Vector3.new(0.275000006, 0.248124972, 0.311374992)
Part317.Anchored = true
Part317.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part317.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part317.BrickColor = BrickColor.new("Really black")
Part317.CanCollide = false
Part317.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part317.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part317.Material = Enum.Material.Metal
Part317.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part317.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part317.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part317.brickColor = BrickColor.new("Really black")
SpecialMesh318.Parent = Part317
SpecialMesh318.Scale = Vector3.new(0.400000006, 1.04999995, 0.5)
SpecialMesh318.MeshType = Enum.MeshType.Brick
Part319.Parent = Model0
Part319.CFrame = CFrame.new(-0.610582829, 3.460711, -15.82728, 0.999985635, 0.00347598689, -0.00408008695, 0.00513679162, -0.404108554, 0.914696753, 0.00153067545, -0.914704561, -0.404120624)
Part319.Orientation = Vector3.new(-66.159996, -179.419998, 179.269989)
Part319.Position = Vector3.new(-0.610582829, 3.460711, -15.82728)
Part319.Rotation = Vector3.new(-113.839996, -0.229999989, -0.199999988)
Part319.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part319.Velocity = Vector3.new(2.35637785e-08, 0.00246306974, 3.09653387e-07)
Part319.Size = Vector3.new(0.200000003, 0.217000008, 0.200375021)
Part319.Anchored = true
Part319.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part319.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part319.BrickColor = BrickColor.new("Royal purple")
Part319.CanCollide = false
Part319.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part319.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part319.Material = Enum.Material.Neon
Part319.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part319.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part319.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part319.brickColor = BrickColor.new("Royal purple")
SpecialMesh320.Parent = Part319
SpecialMesh320.Scale = Vector3.new(0.560000002, 0.200000003, 0.600000024)
SpecialMesh320.MeshType = Enum.MeshType.Brick
Part321.Parent = Model0
Part321.CFrame = CFrame.new(-0.611585259, 3.11314392, -14.0068893, 0.999985635, 0.00162774313, -0.00510693667, 0.00513686566, -0.0189458374, 0.999807417, 0.00153067405, -0.999819279, -0.0189539269)
Part321.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part321.Position = Vector3.new(-0.611585259, 3.11314392, -14.0068893)
Part321.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part321.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part321.Velocity = Vector3.new(7.86760097e-08, 0.00246686279, 1.03388675e-06)
Part321.Size = Vector3.new(0.275000006, 0.709124923, 0.47437498)
Part321.Anchored = true
Part321.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part321.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part321.BrickColor = BrickColor.new("Really black")
Part321.CanCollide = false
Part321.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part321.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part321.Material = Enum.Material.Metal
Part321.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part321.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part321.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part321.brickColor = BrickColor.new("Really black")
SpecialMesh322.Parent = Part321
SpecialMesh322.Scale = Vector3.new(0.5, 1.04999995, 0.800000012)
SpecialMesh322.MeshType = Enum.MeshType.Brick
Part323.Parent = Model0
Part323.CFrame = CFrame.new(-0.610941768, 3.01069665, -14.083005, -0.999985635, 0.00162795174, 0.00510683283, -0.00513676554, -0.0189458355, -0.999807417, -0.00153088453, -0.999819279, 0.0189539269)
Part323.Orientation = Vector3.new(88.8799973, 15.0799999, -164.830002)
Part323.Position = Vector3.new(-0.610941768, 3.01069665, -14.083005)
Part323.Rotation = Vector3.new(88.909996, 0.289999992, -179.909988)
Part323.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part323.Velocity = Vector3.new(9.49206296e-08, 0.00246670446, 1.24735845e-06)
Part323.Size = Vector3.new(0.275000006, 0.252000004, 0.213375002)
Part323.Anchored = true
Part323.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part323.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part323.BrickColor = BrickColor.new("Really black")
Part323.CanCollide = false
Part323.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part323.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part323.Material = Enum.Material.Metal
Part323.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part323.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part323.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part323.brickColor = BrickColor.new("Really black")
SpecialMesh324.Parent = Part323
SpecialMesh324.Scale = Vector3.new(0.569999993, 0.125, 0.375)
SpecialMesh324.MeshType = Enum.MeshType.Wedge
Part325.Parent = Model0
Part325.CFrame = CFrame.new(-0.61388576, 3.20741606, -12.8194075, -0.999985635, 0.00162786373, 0.00510683237, -0.00513676414, -0.0189461056, -0.999807417, -0.00153079513, -0.999819279, 0.0189541951)
Part325.Orientation = Vector3.new(88.8799973, 15.0799999, -164.830002)
Part325.Position = Vector3.new(-0.61388576, 3.20741606, -12.8194075)
Part325.Rotation = Vector3.new(88.909996, 0.289999992, -179.909988)
Part325.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part325.Velocity = Vector3.new(6.37276969e-08, 0.00246933685, 8.37449761e-07)
Part325.Size = Vector3.new(0.275000006, 0.244125068, 0.416375011)
Part325.Anchored = true
Part325.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part325.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part325.BrickColor = BrickColor.new("Really black")
Part325.CanCollide = false
Part325.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part325.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part325.Material = Enum.Material.Metal
Part325.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part325.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part325.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part325.brickColor = BrickColor.new("Really black")
SpecialMesh326.Parent = Part325
SpecialMesh326.Scale = Vector3.new(0.5, 0.560000002, 0.5)
SpecialMesh326.MeshType = Enum.MeshType.Wedge
Part327.Parent = Model0
Part327.CFrame = CFrame.new(-0.609650612, 3.31554532, -15.9490957, 0.999985635, 0.00326791825, 0.00424884167, 0.00513684331, -0.810688972, -0.585454702, 0.00153127068, 0.585468173, -0.810694098)
Part327.Orientation = Vector3.new(35.8400002, 179.699997, 179.639999)
Part327.Position = Vector3.new(-0.609650612, 3.31554532, -15.9490957)
Part327.Rotation = Vector3.new(144.160004, 0.239999995, -0.189999998)
Part327.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part327.Velocity = Vector3.new(4.65820733e-08, 0.00246281619, 6.12138422e-07)
Part327.Size = Vector3.new(0.275000006, 0.237124875, 0.214375019)
Part327.Anchored = true
Part327.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part327.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part327.BrickColor = BrickColor.new("Bright blue")
Part327.CanCollide = false
Part327.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part327.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part327.Material = Enum.Material.Neon
Part327.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part327.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part327.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part327.brickColor = BrickColor.new("Bright blue")
SpecialMesh328.Parent = Part327
SpecialMesh328.Scale = Vector3.new(0.449999988, 0.800000012, 0.100000001)
SpecialMesh328.MeshType = Enum.MeshType.Brick
Part329.Parent = Model0
Part329.CFrame = CFrame.new(-0.612260759, 3.04390216, -13.3335075, -0.999985635, -0.00162807154, -0.00510656228, -0.00513649778, 0.0189459547, 0.999807417, -0.00153100886, 0.999819279, -0.0189540461)
Part329.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part329.Position = Vector3.new(-0.612260759, 3.04390216, -13.3335075)
Part329.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part329.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part329.Velocity = Vector3.new(8.96553871e-08, 0.00246826583, 1.17816739e-06)
Part329.Size = Vector3.new(0.275000006, 0.200000003, 0.303375006)
Part329.Anchored = true
Part329.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part329.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part329.BrickColor = BrickColor.new("Really black")
Part329.CanCollide = false
Part329.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part329.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part329.Material = Enum.Material.Metal
Part329.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part329.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part329.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part329.brickColor = BrickColor.new("Really black")
SpecialMesh330.Parent = Part329
SpecialMesh330.Scale = Vector3.new(0.5, 0.5, 0.5)
SpecialMesh330.MeshType = Enum.MeshType.Wedge
Part331.Parent = Model0
Part331.CFrame = CFrame.new(-0.614394248, 3.36069822, -13.0015078, -0.999985635, 0.00245974353, -0.0047620195, -0.00513649127, -0.693573475, 0.72036773, -0.00153088977, 0.720381856, 0.693576157)
Part331.Orientation = Vector3.new(-46.079998, -0.389999986, -179.580002)
Part331.Position = Vector3.new(-0.614394248, 3.36069822, -13.0015078)
Part331.Rotation = Vector3.new(-46.0900002, -0.269999981, -179.860001)
Part331.Color = Color3.new(0.803922, 0.803922, 0.803922)
Part331.Velocity = Vector3.new(3.94224067e-08, 0.00246895733, 5.18052275e-07)
Part331.Size = Vector3.new(0.275000006, 0.216124982, 0.280375004)
Part331.Anchored = true
Part331.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part331.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part331.BrickColor = BrickColor.new("Mid gray")
Part331.CanCollide = false
Part331.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part331.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part331.Material = Enum.Material.Metal
Part331.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part331.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part331.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part331.brickColor = BrickColor.new("Mid gray")
SpecialMesh332.Parent = Part331
SpecialMesh332.Scale = Vector3.new(0.349999994, 1.04999995, 0.5)
SpecialMesh332.MeshType = Enum.MeshType.Brick
Part333.Parent = Model0
Part333.CFrame = CFrame.new(-0.610709965, 3.46219134, -15.7491703, 0.999985635, 0.00347598689, -0.00408008695, 0.00513679162, -0.404108554, 0.914696753, 0.00153067545, -0.914704561, -0.404120624)
Part333.Orientation = Vector3.new(-66.159996, -179.419998, 179.269989)
Part333.Position = Vector3.new(-0.610709965, 3.46219134, -15.7491703)
Part333.Rotation = Vector3.new(-113.839996, -0.229999989, -0.199999988)
Part333.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part333.Velocity = Vector3.new(2.33290489e-08, 0.00246323249, 3.06568751e-07)
Part333.Size = Vector3.new(0.200000003, 0.217000008, 0.200375021)
Part333.Anchored = true
Part333.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part333.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part333.BrickColor = BrickColor.new("Royal purple")
Part333.CanCollide = false
Part333.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part333.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part333.Material = Enum.Material.Neon
Part333.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part333.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part333.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part333.brickColor = BrickColor.new("Royal purple")
SpecialMesh334.Parent = Part333
SpecialMesh334.Scale = Vector3.new(0.560000002, 0.200000003, 0.600000024)
SpecialMesh334.MeshType = Enum.MeshType.Brick
Part335.Parent = Model0
Part335.CFrame = CFrame.new(-0.608794093, 3.33530617, -16.5748692, 0.999985635, -0.0041169636, 0.00343261915, 0.005137017, 0.553175688, -0.83304894, 0.00153079035, 0.833054662, 0.55318886)
Part335.Orientation = Vector3.new(56.4099998, 0.359999985, 0.529999971)
Part335.Position = Vector3.new(-0.608794093, 3.33530617, -16.5748692)
Part335.Rotation = Vector3.new(56.4099998, 0.199999988, 0.239999995)
Part335.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part335.Velocity = Vector3.new(4.34486722e-08, 0.00246151234, 5.709623e-07)
Part335.Size = Vector3.new(0.275000006, 0.265124857, 0.214375019)
Part335.Anchored = true
Part335.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part335.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part335.BrickColor = BrickColor.new("Bright blue")
Part335.CanCollide = false
Part335.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part335.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part335.Material = Enum.Material.Neon
Part335.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part335.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part335.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part335.brickColor = BrickColor.new("Bright blue")
SpecialMesh336.Parent = Part335
SpecialMesh336.Scale = Vector3.new(0.449999988, 0.899999976, 0.100000001)
SpecialMesh336.MeshType = Enum.MeshType.Brick
Part337.Parent = Model0
Part337.CFrame = CFrame.new(-0.61091727, 3.02827954, -14.1579723, -0.999985635, 0.00162795268, 0.00510695158, -0.00513688475, -0.0189460143, -0.999807417, -0.00153088232, -0.999819279, 0.0189541057)
Part337.Orientation = Vector3.new(88.8799973, 15.0799999, -164.830002)
Part337.Position = Vector3.new(-0.61091727, 3.02827954, -14.1579723)
Part337.Rotation = Vector3.new(88.909996, 0.289999992, -179.909988)
Part337.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part337.Velocity = Vector3.new(9.21325807e-08, 0.00246654823, 1.2107206e-06)
Part337.Size = Vector3.new(0.275000006, 0.207000002, 0.303375006)
Part337.Anchored = true
Part337.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part337.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part337.BrickColor = BrickColor.new("Really black")
Part337.CanCollide = false
Part337.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part337.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part337.Material = Enum.Material.Glass
Part337.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part337.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part337.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part337.brickColor = BrickColor.new("Really black")
SpecialMesh338.Parent = Part337
SpecialMesh338.Scale = Vector3.new(0.524999976, 0.5, 0.5)
SpecialMesh338.MeshType = Enum.MeshType.Wedge
Part339.Parent = Model0
Part339.CFrame = CFrame.new(-0.609729409, 3.2205193, -15.578517, 0.999985635, -0.00133592135, 0.00519115385, 0.00513700396, -0.0377659947, -0.999273479, 0.00153099932, 0.999285877, -0.0377585888)
Part339.Orientation = Vector3.new(87.8199997, 172.169998, 172.25)
Part339.Position = Vector3.new(-0.609729409, 3.2205193, -15.578517)
Part339.Rotation = Vector3.new(92.159996, 0.299999982, 0.0799999982)
Part339.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part339.Velocity = Vector3.new(6.1649942e-08, 0.00246358826, 8.10146275e-07)
Part339.Size = Vector3.new(0.275000006, 0.621124864, 0.214375019)
Part339.Anchored = true
Part339.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part339.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part339.BrickColor = BrickColor.new("Bright blue")
Part339.CanCollide = false
Part339.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part339.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part339.Material = Enum.Material.Neon
Part339.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part339.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part339.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part339.brickColor = BrickColor.new("Bright blue")
SpecialMesh340.Parent = Part339
SpecialMesh340.Scale = Vector3.new(0.449999988, 1, 0.100000001)
SpecialMesh340.MeshType = Enum.MeshType.Brick
Part341.Parent = Model0
Part341.CFrame = CFrame.new(-0.610086679, 3.15827918, -15.1365986, -0.999985635, 0.00409500999, -0.00345871458, -0.00513683027, -0.916451037, 0.400114089, -0.00153127091, 0.40012604, 0.916459024)
Part341.Orientation = Vector3.new(-23.5900002, -0.219999999, -179.679993)
Part341.Position = Vector3.new(-0.610086679, 3.15827918, -15.1365986)
Part341.Rotation = Vector3.new(-23.5900002, -0.199999988, -179.769989)
Part341.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part341.Velocity = Vector3.new(7.15190893e-08, 0.0024645091, 9.39837378e-07)
Part341.Size = Vector3.new(0.275000006, 0.221124932, 0.655375004)
Part341.Anchored = true
Part341.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part341.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part341.BrickColor = BrickColor.new("Really black")
Part341.CanCollide = false
Part341.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part341.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part341.Material = Enum.Material.Metal
Part341.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part341.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part341.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part341.brickColor = BrickColor.new("Really black")
SpecialMesh342.Parent = Part341
SpecialMesh342.Scale = Vector3.new(0.400000006, 1.04999995, 0.899999976)
SpecialMesh342.MeshType = Enum.MeshType.Brick
Part343.Parent = Model0
Part343.CFrame = CFrame.new(-0.576193094, 2.37180829, -14.2261257, 0.00114334025, 0.999985635, -0.00523668947, -0.483495861, 0.00513671385, 0.8753317, 0.875346005, 0.00153111527, 0.483494759)
Part343.Orientation = Vector3.new(-61.079998, -0.620000005, -89.3899994)
Part343.Position = Vector3.new(-0.576193094, 2.37180829, -14.2261257)
Part343.Rotation = Vector3.new(-61.0900002, -0.299999982, -89.9300003)
Part343.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part343.Velocity = Vector3.new(1.96226381e-07, 0.00246641156, 2.57862462e-06)
Part343.Size = Vector3.new(0.405000031, 0.200000003, 0.280375004)
Part343.Anchored = true
Part343.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part343.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part343.BrickColor = BrickColor.new("Royal purple")
Part343.CanCollide = false
Part343.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part343.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part343.Material = Enum.Material.Neon
Part343.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part343.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part343.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part343.brickColor = BrickColor.new("Royal purple")
SpecialMesh344.Parent = Part343
SpecialMesh344.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh344.MeshType = Enum.MeshType.Wedge
Part345.Parent = Model0
Part345.CFrame = CFrame.new(-0.606692195, 3.59138489, -18.8080196, 0.999985635, 0.00250130473, 0.00474093435, 0.00513696205, -0.699832857, -0.714288294, 0.00153120875, 0.714302421, -0.699835718)
Part345.Orientation = Vector3.new(45.579998, 179.610001, 179.580002)
Part345.Position = Vector3.new(-0.606692195, 3.59138489, -18.8080196)
Part345.Rotation = Vector3.new(134.410004, 0.269999981, -0.140000001)
Part345.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part345.Velocity = Vector3.new(2.843354e-09, 0.00245685945, 3.73652256e-08)
Part345.Size = Vector3.new(0.275000006, 0.47012496, 0.214375019)
Part345.Anchored = true
Part345.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part345.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part345.BrickColor = BrickColor.new("Bright blue")
Part345.CanCollide = false
Part345.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part345.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part345.Material = Enum.Material.Neon
Part345.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part345.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part345.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part345.brickColor = BrickColor.new("Bright blue")
SpecialMesh346.Parent = Part345
SpecialMesh346.Scale = Vector3.new(0.449999988, 0.699999988, 0.100000001)
SpecialMesh346.MeshType = Enum.MeshType.Brick
Part347.Parent = Model0
Part347.CFrame = CFrame.new(-0.612170458, 3.17509294, -13.8325748, -0.999985635, 0.00162795268, 0.00510695158, -0.00513688475, -0.0189460143, -0.999807417, -0.00153088232, -0.999819279, 0.0189541057)
Part347.Orientation = Vector3.new(88.8799973, 15.0799999, -164.830002)
Part347.Position = Vector3.new(-0.612170458, 3.17509294, -13.8325748)
Part347.Rotation = Vector3.new(88.909996, 0.289999992, -179.909988)
Part347.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part347.Velocity = Vector3.new(6.88530264e-08, 0.002467226, 9.04802221e-07)
Part347.Size = Vector3.new(0.275000006, 0.207000002, 0.303375006)
Part347.Anchored = true
Part347.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part347.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part347.BrickColor = BrickColor.new("Really black")
Part347.CanCollide = false
Part347.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part347.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part347.Material = Enum.Material.Metal
Part347.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part347.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part347.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part347.brickColor = BrickColor.new("Really black")
SpecialMesh348.Parent = Part347
SpecialMesh348.Scale = Vector3.new(0.5, 0.5, 0.5)
SpecialMesh348.MeshType = Enum.MeshType.Wedge
Part349.Parent = Model0
Part349.CFrame = CFrame.new(-0.608221889, 3.47114682, -17.4040871, 0.999985635, -0.00133592309, 0.00519115338, 0.00513700396, -0.037765637, -0.999273479, 0.00153099932, 0.999285877, -0.0377582312)
Part349.Orientation = Vector3.new(87.8199997, 172.169998, 172.25)
Part349.Position = Vector3.new(-0.608221889, 3.47114682, -17.4040871)
Part349.Rotation = Vector3.new(92.159996, 0.299999982, 0.0799999982)
Part349.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part349.Velocity = Vector3.new(2.19089991e-08, 0.0024597845, 2.87908023e-07)
Part349.Size = Vector3.new(0.275000006, 0.678124905, 0.214375019)
Part349.Anchored = true
Part349.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part349.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part349.BrickColor = BrickColor.new("Bright blue")
Part349.CanCollide = false
Part349.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part349.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part349.Material = Enum.Material.Neon
Part349.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part349.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part349.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part349.brickColor = BrickColor.new("Bright blue")
SpecialMesh350.Parent = Part349
SpecialMesh350.Scale = Vector3.new(0.449999988, 0.800000012, 0.100000001)
SpecialMesh350.MeshType = Enum.MeshType.Brick
Part351.Parent = Model0
Part351.CFrame = CFrame.new(-0.617746711, 3.42490911, -11.0273066, 0.999985635, -0.000716609415, 0.00531159993, 0.00513640279, -0.15495652, -0.987908006, 0.00153101061, 0.987921119, -0.154950604)
Part351.Orientation = Vector3.new(81.0800018, 178.039993, 178.099991)
Part351.Position = Vector3.new(-0.617746711, 3.42490911, -11.0273066)
Part351.Rotation = Vector3.new(98.909996, 0.299999982, 0.0399999991)
Part351.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part351.Velocity = Vector3.new(2.92407876e-08, 0.00247307052, 3.84254577e-07)
Part351.Size = Vector3.new(0.275000006, 0.203125, 0.234375)
Part351.Anchored = true
Part351.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part351.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part351.BrickColor = BrickColor.new("Really black")
Part351.CanCollide = false
Part351.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part351.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part351.Material = Enum.Material.Metal
Part351.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part351.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part351.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part351.brickColor = BrickColor.new("Really black")
SpecialMesh352.Parent = Part351
SpecialMesh352.Scale = Vector3.new(0.5, 0.502499998, 0.400000006)
SpecialMesh352.MeshType = Enum.MeshType.Brick
Part353.Parent = Model0
Part353.CFrame = CFrame.new(-0.638692379, 2.37148738, -14.226222, -0.00114342954, -0.999985635, -0.00523668341, 0.483495861, -0.00513675157, 0.8753317, -0.875346065, -0.00153103401, 0.483494759)
Part353.Orientation = Vector3.new(-61.079998, -0.620000005, 90.6100006)
Part353.Position = Vector3.new(-0.638692379, 2.37148738, -14.226222)
Part353.Rotation = Vector3.new(-61.0900002, -0.299999982, 90.0699997)
Part353.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part353.Velocity = Vector3.new(1.9627727e-07, 0.00246640155, 2.57929332e-06)
Part353.Size = Vector3.new(0.405000031, 0.200000003, 0.280375004)
Part353.Anchored = true
Part353.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part353.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part353.BrickColor = BrickColor.new("Royal purple")
Part353.CanCollide = false
Part353.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part353.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part353.Material = Enum.Material.Neon
Part353.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part353.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part353.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part353.brickColor = BrickColor.new("Royal purple")
SpecialMesh354.Parent = Part353
SpecialMesh354.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh354.MeshType = Enum.MeshType.Wedge
Part355.Parent = Model0
Part355.CFrame = CFrame.new(-0.576556623, 2.33930445, -13.8796148, -0.00289415126, 0.999985635, -0.00451143365, 0.277069539, 0.00513670407, 0.960836232, 0.96084559, 0.00153082411, -0.277080417)
Part355.Orientation = Vector3.new(-73.909996, -179.069992, 88.9399948)
Part355.Position = Vector3.new(-0.576556623, 2.33930445, -13.8796148)
Part355.Rotation = Vector3.new(-106.089996, -0.25999999, -90.1699982)
Part355.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part355.Velocity = Vector3.new(2.01380388e-07, 0.00246713357, 2.64635355e-06)
Part355.Size = Vector3.new(0.453000009, 0.200000003, 0.280375004)
Part355.Anchored = true
Part355.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part355.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part355.BrickColor = BrickColor.new("Royal purple")
Part355.CanCollide = false
Part355.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part355.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part355.Material = Enum.Material.Neon
Part355.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part355.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part355.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part355.brickColor = BrickColor.new("Royal purple")
SpecialMesh356.Parent = Part355
SpecialMesh356.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh356.MeshType = Enum.MeshType.Wedge
Part357.Parent = Model0
Part357.CFrame = CFrame.new(-0.609105706, 2.8586967, -14.7735023, -0.999985635, -0.0039632949, -0.00360830128, -0.00513646565, 0.516311884, 0.856385469, -0.00153109885, 0.856391609, -0.516324818)
Part357.Orientation = Vector3.new(-58.9099998, -179.599991, -0.569999993)
Part357.Position = Vector3.new(-0.609105706, 2.8586967, -14.7735023)
Part357.Rotation = Vector3.new(-121.089996, -0.209999993, 179.769989)
Part357.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part357.Velocity = Vector3.new(1.19022602e-07, 0.0024652658, 1.56408419e-06)
Part357.Size = Vector3.new(0.275000006, 0.277124912, 0.227375031)
Part357.Anchored = true
Part357.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part357.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part357.BrickColor = BrickColor.new("Really black")
Part357.CanCollide = false
Part357.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part357.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part357.Material = Enum.Material.Metal
Part357.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part357.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part357.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part357.brickColor = BrickColor.new("Really black")
SpecialMesh358.Parent = Part357
SpecialMesh358.Scale = Vector3.new(0.349999994, 0.300000012, 1)
SpecialMesh358.MeshType = Enum.MeshType.Brick
Part359.Parent = Model0
Part359.CFrame = CFrame.new(-0.614465594, 3.24354935, -12.5620441, -0.999985635, -0.00162807154, -0.00510656228, -0.00513649778, 0.0189459547, 0.999807417, -0.00153100886, 0.999819279, -0.0189540461)
Part359.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part359.Position = Vector3.new(-0.614465594, 3.24354935, -12.5620441)
Part359.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part359.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part359.Velocity = Vector3.new(5.79982e-08, 0.00246987306, 7.62158038e-07)
Part359.Size = Vector3.new(0.275000006, 0.998124957, 0.280375004)
Part359.Anchored = true
Part359.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part359.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part359.BrickColor = BrickColor.new("Really black")
Part359.CanCollide = false
Part359.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part359.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part359.Material = Enum.Material.Metal
Part359.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part359.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part359.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part359.brickColor = BrickColor.new("Really black")
SpecialMesh360.Parent = Part359
SpecialMesh360.Scale = Vector3.new(0.400000006, 1.04999995, 0.5)
SpecialMesh360.MeshType = Enum.MeshType.Brick
Part361.Parent = Model0
Part361.CFrame = CFrame.new(-0.611248136, 3.25645614, -14.7074032, -0.999985635, 0.00245982548, -0.00476256292, -0.00513693923, -0.693573654, 0.720367551, -0.00153120921, 0.720381677, 0.693576276)
Part361.Orientation = Vector3.new(-46.079998, -0.389999986, -179.580002)
Part361.Position = Vector3.new(-0.611248136, 3.25645614, -14.7074032)
Part361.Rotation = Vector3.new(-46.0900002, -0.269999981, -179.860001)
Part361.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part361.Velocity = Vector3.new(5.59516025e-08, 0.00246540317, 7.35263882e-07)
Part361.Size = Vector3.new(0.275000006, 0.221124932, 0.418375015)
Part361.Anchored = true
Part361.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part361.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part361.BrickColor = BrickColor.new("Really black")
Part361.CanCollide = false
Part361.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part361.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part361.Material = Enum.Material.Metal
Part361.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part361.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part361.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part361.brickColor = BrickColor.new("Really black")
SpecialMesh362.Parent = Part361
SpecialMesh362.Scale = Vector3.new(0.550000012, 1.04999995, 0.899999976)
SpecialMesh362.MeshType = Enum.MeshType.Brick
Part363.Parent = Model0
Part363.CFrame = CFrame.new(-0.611290276, 3.1978817, -14.4833202, 0.999985635, 0.00162786234, -0.00510698371, 0.00513691502, -0.0189458374, 0.999807417, 0.00153079221, -0.999819279, -0.0189539269)
Part363.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part363.Position = Vector3.new(-0.611290276, 3.1978817, -14.4833202)
Part363.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part363.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part363.Velocity = Vector3.new(6.52394974e-08, 0.00246587023, 8.57316763e-07)
Part363.Size = Vector3.new(0.275000006, 0.221124932, 0.448374987)
Part363.Anchored = true
Part363.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part363.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part363.BrickColor = BrickColor.new("Really black")
Part363.CanCollide = false
Part363.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part363.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part363.Material = Enum.Material.Metal
Part363.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part363.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part363.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part363.brickColor = BrickColor.new("Really black")
SpecialMesh364.Parent = Part363
SpecialMesh364.Scale = Vector3.new(0.550000012, 1.04999995, 0.800000012)
SpecialMesh364.MeshType = Enum.MeshType.Brick
Part365.Parent = Model0
Part365.CFrame = CFrame.new(-0.610800147, 2.91253304, -13.8467321, -0.999985635, -0.00162807154, -0.00510650687, -0.00513644237, 0.0189459547, 0.999807417, -0.00153100991, 0.999819279, -0.0189540461)
Part365.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part365.Position = Vector3.new(-0.610800147, 2.91253304, -13.8467321)
Part365.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part365.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part365.Velocity = Vector3.new(1.10486013e-07, 0.00246719667, 1.45190415e-06)
Part365.Size = Vector3.new(0.275000006, 0.200000003, 0.213375002)
Part365.Anchored = true
Part365.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part365.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part365.BrickColor = BrickColor.new("Bright blue")
Part365.CanCollide = false
Part365.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part365.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part365.Material = Enum.Material.Neon
Part365.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part365.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part365.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part365.brickColor = BrickColor.new("Bright blue")
SpecialMesh366.Parent = Part365
SpecialMesh366.Scale = Vector3.new(0.550000012, 0.25, 0.5)
SpecialMesh366.MeshType = Enum.MeshType.Wedge
Part367.Parent = Model0
Part367.CFrame = CFrame.new(-0.616349459, 3.1451273, -11.0012493, -0.999985635, -0.000250895391, -0.00535403285, -0.00513659744, -0.24046874, 0.970643461, -0.001531007, 0.970656931, 0.240463987)
Part367.Orientation = Vector3.new(-76.0800018, -1.27999997, -178.779999)
Part367.Position = Vector3.new(-0.616349459, 3.1451273, -11.0012493)
Part367.Rotation = Vector3.new(-76.0899963, -0.310000002, 179.98999)
Part367.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part367.Velocity = Vector3.new(7.3604582e-08, 0.002473125, 9.67242272e-07)
Part367.Size = Vector3.new(0.200000003, 0.449500024, 0.236624971)
Part367.Anchored = true
Part367.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part367.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part367.BrickColor = BrickColor.new("Bright blue")
Part367.CanCollide = false
Part367.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part367.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part367.Material = Enum.Material.Neon
Part367.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part367.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part367.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part367.brickColor = BrickColor.new("Bright blue")
SpecialMesh368.Parent = Part367
SpecialMesh368.Scale = Vector3.new(0.5, 1, 0.25)
SpecialMesh368.MeshType = Enum.MeshType.Brick
Part369.Parent = Model0
Part369.CFrame = CFrame.new(-0.612978816, 3.18449855, -13.3361721, 0.999985635, -0.00162807154, 0.00510664983, 0.00513658533, 0.0189459547, -0.999807417, 0.00153100723, 0.999819279, 0.0189540461)
Part369.Orientation = Vector3.new(88.8799973, 15.0799999, 15.1700001)
Part369.Position = Vector3.new(-0.612978816, 3.18449855, -13.3361721)
Part369.Rotation = Vector3.new(88.909996, 0.289999992, 0.0899999961)
Part369.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part369.Velocity = Vector3.new(6.73616256e-08, 0.00246826024, 8.85203519e-07)
Part369.Size = Vector3.new(0.275000006, 0.200000003, 0.303375006)
Part369.Anchored = true
Part369.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part369.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part369.BrickColor = BrickColor.new("Really black")
Part369.CanCollide = false
Part369.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part369.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part369.Material = Enum.Material.Metal
Part369.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part369.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part369.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part369.brickColor = BrickColor.new("Really black")
SpecialMesh370.Parent = Part369
SpecialMesh370.Scale = Vector3.new(0.5, 0.5, 0.5)
SpecialMesh370.MeshType = Enum.MeshType.Wedge
Part371.Parent = Model0
Part371.CFrame = CFrame.new(-0.611412168, 3.19930172, -14.4084625, 0.999985635, 0.00162786234, -0.00510698371, 0.00513691502, -0.0189458374, 0.999807417, 0.00153079221, -0.999819279, -0.0189539269)
Part371.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part371.Position = Vector3.new(-0.611412168, 3.19930172, -14.4084625)
Part371.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part371.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part371.Velocity = Vector3.new(6.50143335e-08, 0.00246602623, 8.54357836e-07)
Part371.Size = Vector3.new(0.275000006, 0.204124942, 0.464375019)
Part371.Anchored = true
Part371.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part371.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part371.BrickColor = BrickColor.new("Royal purple")
Part371.CanCollide = false
Part371.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part371.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part371.Material = Enum.Material.Neon
Part371.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part371.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part371.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part371.brickColor = BrickColor.new("Royal purple")
SpecialMesh372.Parent = Part371
SpecialMesh372.Scale = Vector3.new(0.524999976, 1.04999995, 0.800000012)
SpecialMesh372.MeshType = Enum.MeshType.Brick
Part373.Parent = Model0
Part373.CFrame = CFrame.new(-0.607544899, 3.43064713, -17.7122707, 0.999985635, -0.004783432, 0.00241859211, 0.00513692852, 0.726393282, -0.68726027, 0.00153061328, 0.687262774, 0.726407468)
Part373.Orientation = Vector3.new(43.4099998, 0.189999998, 0.409999996)
Part373.Position = Vector3.new(-0.607544899, 3.43064713, -17.7122707)
Part373.Rotation = Vector3.new(43.4099998, 0.140000001, 0.269999981)
Part373.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part373.Velocity = Vector3.new(2.83308559e-08, 0.00245914259, 3.72298132e-07)
Part373.Size = Vector3.new(0.275000006, 0.24712491, 0.214375019)
Part373.Anchored = true
Part373.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part373.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part373.BrickColor = BrickColor.new("Bright blue")
Part373.CanCollide = false
Part373.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part373.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part373.Material = Enum.Material.Neon
Part373.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part373.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part373.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part373.brickColor = BrickColor.new("Bright blue")
SpecialMesh374.Parent = Part373
SpecialMesh374.Scale = Vector3.new(0.449999988, 0.600000024, 0.100000001)
SpecialMesh374.MeshType = Enum.MeshType.Brick
Part375.Parent = Model0
Part375.CFrame = CFrame.new(-0.613238811, 3.32843637, -13.6493177, -0.999985635, -0.00162807142, -0.00510653527, -0.00513647031, 0.0189459249, 0.999807417, -0.00153100933, 0.999819279, -0.0189540163)
Part375.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part375.Position = Vector3.new(-0.613238811, 3.32843637, -13.6493177)
Part375.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part375.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part375.Velocity = Vector3.new(4.45380195e-08, 0.00246760761, 5.85277007e-07)
Part375.Size = Vector3.new(0.275000006, 0.698124886, 0.534374952)
Part375.Anchored = true
Part375.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part375.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part375.BrickColor = BrickColor.new("Bright blue")
Part375.CanCollide = false
Part375.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part375.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part375.Material = Enum.Material.Glass
Part375.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part375.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part375.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part375.brickColor = BrickColor.new("Bright blue")
SpecialMesh376.Parent = Part375
SpecialMesh376.Scale = Vector3.new(0.452499986, 1, 1)
SpecialMesh376.MeshType = Enum.MeshType.Cylinder
Part377.Parent = Model0
Part377.CFrame = CFrame.new(-0.618502736, 3.35398197, -11.388195, -0.999985635, 0.00162807188, 0.00510671316, -0.00513664866, -0.0189460143, -0.999807417, -0.00153100595, -0.999819279, 0.0189541057)
Part377.Orientation = Vector3.new(88.8799973, 15.0799999, -164.830002)
Part377.Position = Vector3.new(-0.618502736, 3.35398197, -11.388195)
Part377.Rotation = Vector3.new(88.909996, 0.289999992, -179.909988)
Part377.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part377.Velocity = Vector3.new(4.0487393e-08, 0.00247231848, 5.32047068e-07)
Part377.Size = Vector3.new(0.25999999, 0.225500003, 0.210125014)
Part377.Anchored = true
Part377.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part377.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part377.BrickColor = BrickColor.new("Really black")
Part377.CanCollide = false
Part377.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part377.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part377.Material = Enum.Material.Metal
Part377.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part377.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part377.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part377.brickColor = BrickColor.new("Really black")
SpecialMesh378.Parent = Part377
SpecialMesh378.Scale = Vector3.new(0.5, 1, 1)
SpecialMesh378.MeshType = Enum.MeshType.Wedge
Part379.Parent = Model0
Part379.CFrame = CFrame.new(-0.575232625, 3.71340823, -19.3540096, 0.00507748965, 0.999985635, -0.00171704218, -0.999324501, 0.00513662118, 0.0363931209, 0.0364014208, 0.00153109594, 0.999336243)
Part379.Orientation = Vector3.new(-2.08999991, -0.099999994, -89.7099991)
Part379.Position = Vector3.new(-0.575232625, 3.71340823, -19.3540096)
Part379.Rotation = Vector3.new(-2.08999991, -0.099999994, -89.7099991)
Part379.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part379.Velocity = Vector3.new(-1.65053677e-08, 0.00245572673, -2.16897547e-07)
Part379.Size = Vector3.new(0.210000038, 0.200000003, 0.285374999)
Part379.Anchored = true
Part379.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part379.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part379.BrickColor = BrickColor.new("Royal purple")
Part379.CanCollide = false
Part379.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part379.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part379.Material = Enum.Material.Neon
Part379.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part379.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part379.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part379.brickColor = BrickColor.new("Royal purple")
SpecialMesh380.Parent = Part379
SpecialMesh380.Scale = Vector3.new(0.5, 0.300000012, 0.5)
SpecialMesh380.MeshType = Enum.MeshType.Wedge
Part381.Parent = Model0
Part381.CFrame = CFrame.new(-0.609601736, 3.48017144, -16.5335026, 0.999985635, -0.00133592158, 0.00519114826, 0.0051369979, -0.0377659947, -0.999273479, 0.00153099943, 0.999285877, -0.0377585888)
Part381.Orientation = Vector3.new(87.8199997, 172.169998, 172.25)
Part381.Position = Vector3.new(-0.609601736, 3.48017144, -16.5335026)
Part381.Rotation = Vector3.new(92.159996, 0.299999982, 0.0799999982)
Part381.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part381.Velocity = Vector3.new(2.0478014e-08, 0.00246159849, 2.69103225e-07)
Part381.Size = Vector3.new(0.275000006, 1.65712488, 0.359375)
Part381.Anchored = true
Part381.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part381.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part381.BrickColor = BrickColor.new("Really black")
Part381.CanCollide = false
Part381.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part381.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part381.Material = Enum.Material.Metal
Part381.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part381.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part381.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part381.brickColor = BrickColor.new("Really black")
SpecialMesh382.Parent = Part381
SpecialMesh382.Scale = Vector3.new(0.400000006, 1, 0.5)
SpecialMesh382.MeshType = Enum.MeshType.Brick
Part383.Parent = Model0
Part383.CFrame = CFrame.new(-0.608603716, 2.57794237, -14.160059, -0.999985635, 0.00114323408, -0.00523646409, -0.00513646565, -0.483495802, 0.8753317, -0.00153109885, 0.875346065, 0.483494699)
Part383.Orientation = Vector3.new(-61.079998, -0.620000005, -179.389999)
Part383.Position = Vector3.new(-0.608603716, 2.57794237, -14.160059)
Part383.Rotation = Vector3.new(-61.0900002, -0.299999982, -179.929993)
Part383.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part383.Velocity = Vector3.new(1.63540591e-07, 0.00246654428, 2.14909824e-06)
Part383.Size = Vector3.new(0.275000006, 0.309124947, 0.343375027)
Part383.Anchored = true
Part383.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part383.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part383.BrickColor = BrickColor.new("Really black")
Part383.CanCollide = false
Part383.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part383.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part383.Material = Enum.Material.Metal
Part383.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part383.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part383.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part383.brickColor = BrickColor.new("Really black")
SpecialMesh384.Parent = Part383
SpecialMesh384.Scale = Vector3.new(0.349999994, 1, 1)
SpecialMesh384.MeshType = Enum.MeshType.Brick
Part385.Parent = Model0
Part385.CFrame = CFrame.new(-0.610497713, 3.13989329, -14.8064632, 0.999985635, -0.00162807363, 0.00510707032, 0.00513700629, 0.018946372, -0.999807417, 0.0015309992, 0.999819279, 0.0189544633)
Part385.Orientation = Vector3.new(88.8799973, 15.0799999, 15.1700001)
Part385.Position = Vector3.new(-0.610497713, 3.13989329, -14.8064632)
Part385.Rotation = Vector3.new(88.909996, 0.289999992, 0.0899999961)
Part385.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part385.Velocity = Vector3.new(7.44344675e-08, 0.00246519689, 9.78148478e-07)
Part385.Size = Vector3.new(0.275000006, 0.618124902, 0.209375009)
Part385.Anchored = true
Part385.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part385.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part385.BrickColor = BrickColor.new("Really black")
Part385.CanCollide = false
Part385.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part385.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part385.Material = Enum.Material.Metal
Part385.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part385.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part385.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part385.brickColor = BrickColor.new("Really black")
SpecialMesh386.Parent = Part385
SpecialMesh386.Scale = Vector3.new(0.400000006, 1, 0.899999976)
SpecialMesh386.MeshType = Enum.MeshType.Brick
Part387.Parent = Model0
Part387.CFrame = CFrame.new(-0.611324251, 3.01513863, -13.8486776, 0.999985635, -0.00162807154, 0.00510659395, 0.00513652945, 0.0189459547, -0.999807417, 0.00153100828, 0.999819279, 0.0189540461)
Part387.Orientation = Vector3.new(88.8799973, 15.0799999, 15.1700001)
Part387.Position = Vector3.new(-0.611324251, 3.01513863, -13.8486776)
Part387.Rotation = Vector3.new(88.909996, 0.289999992, 0.0899999961)
Part387.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part387.Velocity = Vector3.new(9.42162828e-08, 0.00246719248, 1.23810264e-06)
Part387.Size = Vector3.new(0.275000006, 0.200000003, 0.213375002)
Part387.Anchored = true
Part387.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part387.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part387.BrickColor = BrickColor.new("Bright blue")
Part387.CanCollide = false
Part387.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part387.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part387.Material = Enum.Material.Neon
Part387.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part387.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part387.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part387.brickColor = BrickColor.new("Bright blue")
SpecialMesh388.Parent = Part387
SpecialMesh388.Scale = Vector3.new(0.550000012, 0.25, 0.5)
SpecialMesh388.MeshType = Enum.MeshType.Wedge
Part389.Parent = Model0
Part389.CFrame = CFrame.new(-0.615387738, 3.25427985, -11.9957829, -0.999985635, -0.00162816129, -0.00510668149, -0.00513661886, 0.0189460143, 0.999807417, -0.00153109606, 0.999819279, -0.0189541057)
Part389.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part389.Position = Vector3.new(-0.615387738, 3.25427985, -11.9957829)
Part389.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part389.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part389.Velocity = Vector3.new(5.62967202e-08, 0.00247105281, 7.39798622e-07)
Part389.Size = Vector3.new(0.275000006, 0.206125051, 0.280375004)
Part389.Anchored = true
Part389.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part389.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part389.BrickColor = BrickColor.new("Really black")
Part389.CanCollide = false
Part389.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part389.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part389.Material = Enum.Material.Metal
Part389.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part389.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part389.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part389.brickColor = BrickColor.new("Really black")
SpecialMesh390.Parent = Part389
SpecialMesh390.Scale = Vector3.new(0.400000006, 0.560000002, 0.5)
SpecialMesh390.MeshType = Enum.MeshType.Wedge
Part391.Parent = Model0
Part391.CFrame = CFrame.new(-0.614540219, 3.2634635, -12.5800533, -0.999985635, -0.00162816129, -0.00510668149, -0.00513661886, 0.0189460143, 0.999807417, -0.00153109606, 0.999819279, -0.0189541057)
Part391.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part391.Position = Vector3.new(-0.614540219, 3.2634635, -12.5800533)
Part391.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part391.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part391.Velocity = Vector3.new(5.48404984e-08, 0.00246983557, 7.20662456e-07)
Part391.Size = Vector3.new(0.275000006, 0.405125052, 0.211375013)
Part391.Anchored = true
Part391.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part391.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part391.BrickColor = BrickColor.new("Really black")
Part391.CanCollide = false
Part391.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part391.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part391.Material = Enum.Material.Metal
Part391.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part391.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part391.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part391.brickColor = BrickColor.new("Really black")
SpecialMesh392.Parent = Part391
SpecialMesh392.Scale = Vector3.new(0.5, 0.560000002, 0.5)
SpecialMesh392.MeshType = Enum.MeshType.Wedge
Part393.Parent = Model0
Part393.CFrame = CFrame.new(-0.608892262, 2.75060058, -14.5502081, -0.999985635, 0.00114323408, -0.00523646409, -0.00513646565, -0.483495802, 0.8753317, -0.00153109885, 0.875346065, 0.483494699)
Part393.Orientation = Vector3.new(-61.079998, -0.620000005, -179.389999)
Part393.Position = Vector3.new(-0.608892262, 2.75060058, -14.5502081)
Part393.Rotation = Vector3.new(-61.0900002, -0.299999982, -179.929993)
Part393.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part393.Velocity = Vector3.new(1.36162924e-07, 0.00246573123, 1.78932657e-06)
Part393.Size = Vector3.new(0.275000006, 0.409124911, 0.268375039)
Part393.Anchored = true
Part393.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part393.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part393.BrickColor = BrickColor.new("Really black")
Part393.CanCollide = false
Part393.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part393.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part393.Material = Enum.Material.Metal
Part393.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part393.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part393.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part393.brickColor = BrickColor.new("Really black")
SpecialMesh394.Parent = Part393
SpecialMesh394.Scale = Vector3.new(0.349999994, 1, 1)
SpecialMesh394.MeshType = Enum.MeshType.Brick
Part395.Parent = Model0
Part395.CFrame = CFrame.new(-0.606766462, 3.43472743, -18.2343674, 0.999985635, -0.00103941432, 0.00525853038, 0.0051369979, -0.0943565816, -0.99552542, 0.00153093971, 0.995537996, -0.0943498909)
Part395.Orientation = Vector3.new(84.5800018, 176.809998, 176.87999)
Part395.Position = Vector3.new(-0.606766462, 3.43472743, -18.2343674)
Part395.Rotation = Vector3.new(95.409996, 0.299999982, 0.0599999987)
Part395.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part395.Velocity = Vector3.new(2.76838534e-08, 0.00245805481, 3.63795948e-07)
Part395.Size = Vector3.new(0.275000006, 1.04612494, 0.214375019)
Part395.Anchored = true
Part395.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part395.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part395.BrickColor = BrickColor.new("Bright blue")
Part395.CanCollide = false
Part395.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part395.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part395.Material = Enum.Material.Neon
Part395.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part395.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part395.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part395.brickColor = BrickColor.new("Bright blue")
SpecialMesh396.Parent = Part395
SpecialMesh396.Scale = Vector3.new(0.449999988, 0.899999976, 0.100000001)
SpecialMesh396.MeshType = Enum.MeshType.Brick
Part397.Parent = Model0
Part397.CFrame = CFrame.new(-0.638540506, 2.9091177, -16.128315, 0.00135860231, -0.999985635, -0.00518506905, 0.0334058255, -0.00513679488, 0.999428749, -0.999441087, -0.00153103739, 0.0333983675)
Part397.Orientation = Vector3.new(-88.0599976, -8.81999969, 98.7399979)
Part397.Position = Vector3.new(-0.638540506, 2.9091177, -16.128315)
Part397.Rotation = Vector3.new(-88.0899963, -0.299999982, 89.9199982)
Part397.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part397.Velocity = Vector3.new(1.11027532e-07, 0.00246243807, 1.45902084e-06)
Part397.Size = Vector3.new(1.625, 0.200000003, 0.296375006)
Part397.Anchored = true
Part397.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part397.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part397.BrickColor = BrickColor.new("Royal purple")
Part397.CanCollide = false
Part397.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part397.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part397.Material = Enum.Material.Neon
Part397.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part397.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part397.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part397.brickColor = BrickColor.new("Royal purple")
SpecialMesh398.Parent = Part397
SpecialMesh398.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh398.MeshType = Enum.MeshType.Wedge
Part399.Parent = Model0
Part399.CFrame = CFrame.new(-0.614644945, 3.60375571, -13.6545372, -0.999985635, -0.00162807142, -0.00510653527, -0.00513647031, 0.0189459249, 0.999807417, -0.00153100933, 0.999819279, -0.0189540163)
Part399.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part399.Position = Vector3.new(-0.614644945, 3.60375571, -13.6545372)
Part399.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part399.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part399.Velocity = Vector3.new(8.81826168e-10, 0.00246759667, 1.1587872e-08)
Part399.Size = Vector3.new(0.275000006, 0.51412493, 0.622375011)
Part399.Anchored = true
Part399.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part399.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part399.BrickColor = BrickColor.new("Really black")
Part399.CanCollide = false
Part399.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part399.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part399.Material = Enum.Material.Metal
Part399.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part399.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part399.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part399.brickColor = BrickColor.new("Really black")
SpecialMesh400.Parent = Part399
SpecialMesh400.Scale = Vector3.new(0.400000006, 1.04999995, 0.5)
SpecialMesh400.MeshType = Enum.MeshType.Brick
Part401.Parent = Model0
Part401.CFrame = CFrame.new(-0.577553451, 2.93009853, -15.210207, -0.00336827105, 0.999985635, -0.0041695768, 0.380026042, 0.00513680326, 0.924961627, 0.924969733, 0.00153097301, -0.380037904)
Part401.Orientation = Vector3.new(-67.659996, -179.369995, 89.2299957)
Part401.Position = Vector3.new(-0.577553451, 2.93009853, -15.210207)
Part401.Rotation = Vector3.new(-112.339996, -0.239999995, -90.1899948)
Part401.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part401.Velocity = Vector3.new(1.07700714e-07, 0.00246436079, 1.41530256e-06)
Part401.Size = Vector3.new(0.288000047, 0.200000003, 0.27837503)
Part401.Anchored = true
Part401.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part401.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part401.BrickColor = BrickColor.new("Royal purple")
Part401.CanCollide = false
Part401.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part401.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part401.Material = Enum.Material.Neon
Part401.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part401.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part401.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part401.brickColor = BrickColor.new("Royal purple")
SpecialMesh402.Parent = Part401
SpecialMesh402.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh402.MeshType = Enum.MeshType.Wedge
Part403.Parent = Model0
Part403.CFrame = CFrame.new(-0.610871017, 3.00987482, -14.1263742, -0.999985635, 0.00162795268, 0.00510695158, -0.00513688475, -0.0189460143, -0.999807417, -0.00153088232, -0.999819279, 0.0189541057)
Part403.Orientation = Vector3.new(88.8799973, 15.0799999, -164.830002)
Part403.Position = Vector3.new(-0.610871017, 3.00987482, -14.1263742)
Part403.Rotation = Vector3.new(88.909996, 0.289999992, -179.909988)
Part403.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part403.Velocity = Vector3.new(9.5050936e-08, 0.00246661413, 1.24907092e-06)
Part403.Size = Vector3.new(0.275000006, 0.207000002, 0.213375002)
Part403.Anchored = true
Part403.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part403.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part403.BrickColor = BrickColor.new("Bright blue")
Part403.CanCollide = false
Part403.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part403.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part403.Material = Enum.Material.Neon
Part403.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part403.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part403.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part403.brickColor = BrickColor.new("Bright blue")
SpecialMesh404.Parent = Part403
SpecialMesh404.Scale = Vector3.new(0.550000012, 0.25, 0.5)
SpecialMesh404.MeshType = Enum.MeshType.Wedge
Part405.Parent = Model0
Part405.CFrame = CFrame.new(-0.576041341, 2.90943861, -16.1282196, -0.00135869172, 0.999985635, -0.00518506905, -0.0334058292, 0.00513679255, 0.999428749, 0.999441028, 0.00153112656, 0.0333983749)
Part405.Orientation = Vector3.new(-88.0599976, -8.81999969, -81.2599945)
Part405.Position = Vector3.new(-0.576041341, 2.90943861, -16.1282196)
Part405.Rotation = Vector3.new(-88.0899963, -0.299999982, -90.0799942)
Part405.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part405.Velocity = Vector3.new(1.10976643e-07, 0.00246244832, 1.45835213e-06)
Part405.Size = Vector3.new(1.625, 0.200000003, 0.296375006)
Part405.Anchored = true
Part405.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part405.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part405.BrickColor = BrickColor.new("Royal purple")
Part405.CanCollide = false
Part405.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part405.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part405.Material = Enum.Material.Neon
Part405.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part405.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part405.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part405.brickColor = BrickColor.new("Royal purple")
SpecialMesh406.Parent = Part405
SpecialMesh406.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh406.MeshType = Enum.MeshType.Wedge
Part407.Parent = Model0
Part407.CFrame = CFrame.new(-0.61728102, 3.21630335, -10.6318092, -0.999985635, -0.00414685067, -0.00339615461, -0.00513672922, 0.560423911, 0.828190207, -0.00153109396, 0.828195751, -0.560437143)
Part407.Orientation = Vector3.new(-55.9099998, -179.649994, -0.529999971)
Part407.Position = Vector3.new(-0.61728102, 3.21630335, -10.6318092)
Part407.Rotation = Vector3.new(-124.089996, -0.189999998, 179.759995)
Part407.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part407.Velocity = Vector3.new(6.23185059e-08, 0.00247389474, 8.18931142e-07)
Part407.Size = Vector3.new(0.200000003, 0.46875, 0.220999971)
Part407.Anchored = true
Part407.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part407.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part407.BrickColor = BrickColor.new("Bright blue")
Part407.CanCollide = false
Part407.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part407.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part407.Material = Enum.Material.Neon
Part407.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part407.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part407.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part407.brickColor = BrickColor.new("Bright blue")
SpecialMesh408.Parent = Part407
SpecialMesh408.Scale = Vector3.new(0.5, 1, 0.25)
SpecialMesh408.MeshType = Enum.MeshType.Brick
Part409.Parent = Model0
Part409.CFrame = CFrame.new(-0.612716079, 3.04616904, -13.0423889, -0.999985635, -0.00162816129, -0.00510668149, -0.00513661886, 0.0189460143, 0.999807417, -0.00153109606, 0.999819279, -0.0189541057)
Part409.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part409.Position = Vector3.new(-0.612716079, 3.04616904, -13.0423889)
Part409.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part409.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part409.Velocity = Vector3.new(8.92959378e-08, 0.00246887235, 1.17344382e-06)
Part409.Size = Vector3.new(0.275000006, 0.35512504, 0.283374995)
Part409.Anchored = true
Part409.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part409.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part409.BrickColor = BrickColor.new("Really black")
Part409.CanCollide = false
Part409.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part409.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part409.Material = Enum.Material.Metal
Part409.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part409.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part409.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part409.brickColor = BrickColor.new("Really black")
SpecialMesh410.Parent = Part409
SpecialMesh410.Scale = Vector3.new(0.400000006, 0.560000002, 0.5)
SpecialMesh410.MeshType = Enum.MeshType.Wedge
Part411.Parent = Model0
Part411.CFrame = CFrame.new(-0.614045858, 3.38228369, -13.3029222, 0.999985635, 0.00162801193, -0.00510688825, 0.00513682282, -0.0189459547, 0.999807417, 0.00153094309, -0.999819279, -0.0189540461)
Part411.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part411.Position = Vector3.new(-0.614045858, 3.38228369, -13.3029222)
Part411.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part411.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part411.Velocity = Vector3.new(3.59996903e-08, 0.00246832939, 4.73074152e-07)
Part411.Size = Vector3.new(0.275000006, 0.204125047, 0.287375003)
Part411.Anchored = true
Part411.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part411.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part411.BrickColor = BrickColor.new("Really black")
Part411.CanCollide = false
Part411.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part411.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part411.Material = Enum.Material.Metal
Part411.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part411.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part411.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part411.brickColor = BrickColor.new("Really black")
SpecialMesh412.Parent = Part411
SpecialMesh412.Scale = Vector3.new(0.5, 0.5, 0.5)
SpecialMesh412.MeshType = Enum.MeshType.Wedge
Part413.Parent = Model0
Part413.CFrame = CFrame.new(-0.609584808, 2.93011069, -14.6988583, -0.999985635, -0.00476218108, -0.00245960802, -0.00513651408, 0.720367968, 0.693573236, -0.00153109804, 0.693575919, -0.720382035)
Part413.Orientation = Vector3.new(-43.9099998, -179.800003, -0.409999996)
Part413.Position = Vector3.new(-0.609584808, 2.93011069, -14.6988583)
Part413.Rotation = Vector3.new(-136.089996, -0.140000001, 179.729996)
Part413.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part413.Velocity = Vector3.new(1.07698781e-07, 0.00246542133, 1.41527721e-06)
Part413.Size = Vector3.new(0.275000006, 0.484124899, 0.227375031)
Part413.Anchored = true
Part413.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part413.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part413.BrickColor = BrickColor.new("Really black")
Part413.CanCollide = false
Part413.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part413.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part413.Material = Enum.Material.Metal
Part413.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part413.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part413.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part413.brickColor = BrickColor.new("Really black")
SpecialMesh414.Parent = Part413
SpecialMesh414.Scale = Vector3.new(0.349999994, 0.300000012, 1)
SpecialMesh414.MeshType = Enum.MeshType.Brick
Part415.Parent = Model0
Part415.CFrame = CFrame.new(-0.606956184, 3.40465999, -18.0096188, 0.999985635, -0.0010395617, 0.00525854016, 0.00513699278, -0.0943568796, -0.99552542, 0.00153108896, 0.995537996, -0.094350189)
Part415.Orientation = Vector3.new(84.5800018, 176.809998, 176.87999)
Part415.Position = Vector3.new(-0.606956184, 3.40465999, -18.0096188)
Part415.Rotation = Vector3.new(95.409996, 0.299999982, 0.0599999987)
Part415.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part415.Velocity = Vector3.new(3.24515206e-08, 0.00245852303, 4.26448139e-07)
Part415.Size = Vector3.new(0.275000006, 1.46012485, 0.422374964)
Part415.Anchored = true
Part415.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part415.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part415.BrickColor = BrickColor.new("Really black")
Part415.CanCollide = false
Part415.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part415.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part415.Material = Enum.Material.Metal
Part415.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part415.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part415.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part415.brickColor = BrickColor.new("Really black")
SpecialMesh416.Parent = Part415
SpecialMesh416.Scale = Vector3.new(0.400000006, 1, 0.5)
SpecialMesh416.MeshType = Enum.MeshType.Brick
Part417.Parent = Model0
Part417.CFrame = CFrame.new(-0.613238811, 3.32843637, -13.6493177, -0.999985635, -0.00162807142, -0.00510653527, -0.00513647031, 0.0189459249, 0.999807417, -0.00153100933, 0.999819279, -0.0189540163)
Part417.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part417.Position = Vector3.new(-0.613238811, 3.32843637, -13.6493177)
Part417.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part417.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part417.Velocity = Vector3.new(4.45380195e-08, 0.00246760761, 5.85277007e-07)
Part417.Size = Vector3.new(0.275000006, 0.320124894, 0.316374987)
Part417.Anchored = true
Part417.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part417.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part417.BrickColor = BrickColor.new("Royal purple")
Part417.CanCollide = false
Part417.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part417.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part417.Material = Enum.Material.Neon
Part417.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part417.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part417.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part417.brickColor = BrickColor.new("Royal purple")
SpecialMesh418.Parent = Part417
SpecialMesh418.Scale = Vector3.new(0.457500011, 1, 1)
SpecialMesh418.MeshType = Enum.MeshType.Cylinder
Part419.Parent = Model0
Part419.CFrame = CFrame.new(-0.616606832, 3.19626212, -11.004673, -0.999985635, -0.000250895391, -0.00535403285, -0.00513659744, -0.24046874, 0.970643461, -0.001531007, 0.970656931, 0.240463987)
Part419.Orientation = Vector3.new(-76.0800018, -1.27999997, -178.779999)
Part419.Position = Vector3.new(-0.616606832, 3.19626212, -11.004673)
Part419.Rotation = Vector3.new(-76.0899963, -0.310000002, 179.98999)
Part419.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part419.Velocity = Vector3.new(6.54963515e-08, 0.00247311778, 8.606915e-07)
Part419.Size = Vector3.new(0.275000006, 0.418250024, 0.25)
Part419.Anchored = true
Part419.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part419.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part419.BrickColor = BrickColor.new("Really black")
Part419.CanCollide = false
Part419.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part419.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part419.Material = Enum.Material.Metal
Part419.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part419.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part419.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part419.brickColor = BrickColor.new("Really black")
SpecialMesh420.Parent = Part419
SpecialMesh420.Scale = Vector3.new(0.5, 1, 0.25)
SpecialMesh420.MeshType = Enum.MeshType.Brick
Part421.Parent = Model0
Part421.CFrame = CFrame.new(-0.610599458, 3.09770298, -14.5984182, -0.999985635, 0.00510674436, -0.0016279578, -0.00513667939, -0.999807417, 0.0189470276, -0.00153088616, 0.018955119, 0.999819279)
Part421.Orientation = Vector3.new(-1.09000003, -0.0899999961, -179.709991)
Part421.Position = Vector3.new(-0.610599458, 3.09770298, -14.5984182)
Part421.Rotation = Vector3.new(-1.09000003, -0.0899999961, -179.709991)
Part421.Color = Color3.new(0.972549, 0.972549, 0.972549)
Part421.Velocity = Vector3.new(8.1124405e-08, 0.00246563042, 1.06606149e-06)
Part421.Size = Vector3.new(0.275000006, 0.200124964, 0.287375033)
Part421.Anchored = true
Part421.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part421.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part421.BrickColor = BrickColor.new("Institutional white")
Part421.CanCollide = false
Part421.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part421.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part421.Material = Enum.Material.Metal
Part421.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part421.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part421.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part421.brickColor = BrickColor.new("Institutional white")
SpecialMesh422.Parent = Part421
SpecialMesh422.Scale = Vector3.new(0.560000002, 1, 0.899999976)
SpecialMesh422.MeshType = Enum.MeshType.Wedge
Part423.Parent = Model0
Part423.CFrame = CFrame.new(-0.608857095, 2.56135106, -13.9388657, -0.999985635, -0.00289438874, -0.00451127253, -0.00513661513, 0.277069688, 0.960836291, -0.00153109606, 0.96084559, -0.277080595)
Part423.Orientation = Vector3.new(-73.909996, -179.069992, -1.05999994)
Part423.Position = Vector3.new(-0.608857095, 2.56135106, -13.9388657)
Part423.Rotation = Vector3.new(-106.089996, -0.25999999, 179.830002)
Part423.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part423.Velocity = Vector3.new(1.66171404e-07, 0.00246700505, 2.18366995e-06)
Part423.Size = Vector3.new(0.275000006, 0.409124941, 0.360375017)
Part423.Anchored = true
Part423.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part423.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part423.BrickColor = BrickColor.new("Really black")
Part423.CanCollide = false
Part423.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part423.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part423.Material = Enum.Material.Metal
Part423.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part423.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part423.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part423.brickColor = BrickColor.new("Really black")
SpecialMesh424.Parent = Part423
SpecialMesh424.Scale = Vector3.new(0.349999994, 1, 1)
SpecialMesh424.MeshType = Enum.MeshType.Brick
Part425.Parent = Model0
Part425.CFrame = CFrame.new(-0.610883415, 2.94288707, -13.8941879, -0.999985635, -0.00162807154, -0.00510650687, -0.00513644237, 0.0189459547, 0.999807417, -0.00153100991, 0.999819279, -0.0189540461)
Part425.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part425.Position = Vector3.new(-0.610883415, 2.94288707, -13.8941879)
Part425.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part425.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part425.Velocity = Vector3.new(1.05672896e-07, 0.00246709795, 1.38865482e-06)
Part425.Size = Vector3.new(0.275000006, 0.228, 0.213375002)
Part425.Anchored = true
Part425.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part425.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part425.BrickColor = BrickColor.new("Really black")
Part425.CanCollide = false
Part425.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part425.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part425.Material = Enum.Material.Metal
Part425.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part425.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part425.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part425.brickColor = BrickColor.new("Really black")
SpecialMesh426.Parent = Part425
SpecialMesh426.Scale = Vector3.new(0.569999993, 0.125, 0.375)
SpecialMesh426.MeshType = Enum.MeshType.Wedge
Part427.Parent = Model0
Part427.CFrame = CFrame.new(-0.612252593, 3.11727381, -13.584939, -0.999985635, -0.00162807154, -0.00510656228, -0.00513649778, 0.0189459547, 0.999807417, -0.00153100886, 0.999819279, -0.0189540461)
Part427.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part427.Position = Vector3.new(-0.612252593, 3.11727381, -13.584939)
Part427.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part427.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part427.Velocity = Vector3.new(7.80211593e-08, 0.00246774196, 1.02528122e-06)
Part427.Size = Vector3.new(0.275000006, 0.398124993, 0.303375006)
Part427.Anchored = true
Part427.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part427.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part427.BrickColor = BrickColor.new("Really black")
Part427.CanCollide = false
Part427.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part427.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part427.Material = Enum.Material.Metal
Part427.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part427.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part427.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part427.brickColor = BrickColor.new("Really black")
SpecialMesh428.Parent = Part427
SpecialMesh428.Scale = Vector3.new(0.5, 1, 1)
SpecialMesh428.MeshType = Enum.MeshType.Brick
Part429.Parent = Model0
Part429.CFrame = CFrame.new(-0.612551332, 3.35195827, -14.1766062, 0.999985635, 0.0047621401, -0.00246015727, 0.00513686566, -0.720367908, 0.693573296, 0.00153067405, -0.693575978, -0.720381975)
Part429.Orientation = Vector3.new(-43.9099998, -179.800003, 179.589996)
Part429.Position = Vector3.new(-0.612551332, 3.35195827, -14.1766062)
Part429.Rotation = Vector3.new(-136.089996, -0.140000001, -0.269999981)
Part429.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part429.Velocity = Vector3.new(4.08082492e-08, 0.00246650912, 5.36263883e-07)
Part429.Size = Vector3.new(0.275000006, 0.331124961, 0.412375003)
Part429.Anchored = true
Part429.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part429.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part429.BrickColor = BrickColor.new("Really black")
Part429.CanCollide = false
Part429.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part429.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part429.Material = Enum.Material.Metal
Part429.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part429.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part429.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part429.brickColor = BrickColor.new("Really black")
SpecialMesh430.Parent = Part429
SpecialMesh430.Scale = Vector3.new(0.5, 1.04999995, 0.5)
SpecialMesh430.MeshType = Enum.MeshType.Brick
Part431.Parent = Model0
Part431.CFrame = CFrame.new(-0.578086436, 2.53643656, -13.5418949, -0.00476215873, 0.999985635, -0.00245991186, 0.72036773, 0.00513670826, 0.693573475, 0.693576157, 0.00153086532, -0.720381796)
Part431.Orientation = Vector3.new(-43.9099998, -179.800003, 89.5899963)
Part431.Position = Vector3.new(-0.578086436, 2.53643656, -13.5418949)
Part431.Rotation = Vector3.new(-136.089996, -0.140000001, -90.2699966)
Part431.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part431.Velocity = Vector3.new(1.70122007e-07, 0.00246783718, 2.23558482e-06)
Part431.Size = Vector3.new(0.421999991, 0.200000003, 0.280375004)
Part431.Anchored = true
Part431.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part431.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part431.BrickColor = BrickColor.new("Royal purple")
Part431.CanCollide = false
Part431.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part431.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part431.Material = Enum.Material.Neon
Part431.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part431.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part431.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part431.brickColor = BrickColor.new("Royal purple")
SpecialMesh432.Parent = Part431
SpecialMesh432.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh432.MeshType = Enum.MeshType.Wedge
Part433.Parent = Model0
Part433.CFrame = CFrame.new(-0.647041559, 3.82817221, -13.658843, -0.00162801228, -0.999985635, 0.00510653481, 0.0189460143, -0.00513646938, -0.999807417, 0.999819279, -0.00153094972, 0.0189541057)
Part433.Orientation = Vector3.new(88.8799973, 15.0799999, 105.169998)
Part433.Position = Vector3.new(-0.647041559, 3.82817221, -13.658843)
Part433.Rotation = Vector3.new(88.909996, 0.289999992, 90.0899963)
Part433.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part433.Velocity = Vector3.new(-3.47029321e-08, 0.00246758247, -4.56033831e-07)
Part433.Size = Vector3.new(0.643000007, 0.200000003, 0.280375004)
Part433.Anchored = true
Part433.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part433.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part433.BrickColor = BrickColor.new("Royal purple")
Part433.CanCollide = false
Part433.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part433.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part433.Material = Enum.Material.Neon
Part433.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part433.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part433.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part433.brickColor = BrickColor.new("Royal purple")
SpecialMesh434.Parent = Part433
SpecialMesh434.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh434.MeshType = Enum.MeshType.Wedge
Part435.Parent = Model0
Part435.CFrame = CFrame.new(-0.610847712, 3.10699439, -14.4674244, 0.999985635, 0.00345827825, -0.00409521349, 0.00513684051, -0.400113374, 0.916451454, 0.00153079373, -0.916459262, -0.400125414)
Part435.Orientation = Vector3.new(-66.409996, -179.409988, 179.259995)
Part435.Position = Vector3.new(-0.610847712, 3.10699439, -14.4674244)
Part435.Rotation = Vector3.new(-113.589996, -0.229999989, -0.199999988)
Part435.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part435.Velocity = Vector3.new(7.96511017e-08, 0.00246590329, 1.04670062e-06)
Part435.Size = Vector3.new(0.275000006, 0.23712492, 0.375375003)
Part435.Anchored = true
Part435.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part435.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part435.BrickColor = BrickColor.new("Royal purple")
Part435.CanCollide = false
Part435.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part435.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part435.Material = Enum.Material.Neon
Part435.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part435.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part435.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part435.brickColor = BrickColor.new("Royal purple")
SpecialMesh436.Parent = Part435
SpecialMesh436.Scale = Vector3.new(0.524999976, 1.04999995, 0.800000012)
SpecialMesh436.MeshType = Enum.MeshType.Brick
Part437.Parent = Model0
Part437.CFrame = CFrame.new(-0.583012402, 3.6639781, -14.1030874, 0.00476215919, 0.999985635, 0.00246015075, -0.720367849, 0.0051368745, -0.693573356, -0.693576038, 0.00153069268, 0.720381975)
Part437.Orientation = Vector3.new(43.9099998, 0.199999988, -89.5899963)
Part437.Position = Vector3.new(-0.583012402, 3.6639781, -14.1030874)
Part437.Rotation = Vector3.new(43.9099998, 0.140000001, -89.7299957)
Part437.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part437.Velocity = Vector3.new(-8.66738503e-09, 0.00246666698, -1.13898864e-07)
Part437.Size = Vector3.new(0.496000022, 0.200000003, 0.280375004)
Part437.Anchored = true
Part437.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part437.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part437.BrickColor = BrickColor.new("Royal purple")
Part437.CanCollide = false
Part437.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part437.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part437.Material = Enum.Material.Neon
Part437.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part437.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part437.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part437.brickColor = BrickColor.new("Royal purple")
SpecialMesh438.Parent = Part437
SpecialMesh438.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh438.MeshType = Enum.MeshType.Wedge
Part439.Parent = Model0
Part439.CFrame = CFrame.new(-0.609243929, 2.84955072, -14.6524963, -0.999985635, -0.00162816211, -0.00510652829, -0.00513646565, 0.0189461932, 0.999807417, -0.00153109885, 0.999819279, -0.0189542845)
Part439.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part439.Position = Vector3.new(-0.609243929, 2.84955072, -14.6524963)
Part439.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part439.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part439.Velocity = Vector3.new(1.20472833e-07, 0.00246551796, 1.58314185e-06)
Part439.Size = Vector3.new(0.275000006, 0.287124902, 0.227375031)
Part439.Anchored = true
Part439.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part439.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part439.BrickColor = BrickColor.new("Really black")
Part439.CanCollide = false
Part439.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part439.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part439.Material = Enum.Material.Metal
Part439.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part439.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part439.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part439.brickColor = BrickColor.new("Really black")
SpecialMesh440.Parent = Part439
SpecialMesh440.Scale = Vector3.new(0.349999994, 1, 1)
SpecialMesh440.MeshType = Enum.MeshType.Brick
Part441.Parent = Model0
Part441.CFrame = CFrame.new(-0.610548377, 2.83942795, -13.765955, -0.999985635, -0.00162816129, -0.00510662561, -0.00513656298, 0.0189460143, 0.999807417, -0.00153109711, 0.999819279, -0.0189541057)
Part441.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part441.Position = Vector3.new(-0.610548377, 2.83942795, -13.765955)
Part441.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part441.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part441.Velocity = Vector3.new(1.22077964e-07, 0.002467365, 1.60423497e-06)
Part441.Size = Vector3.new(0.275000006, 0.304124922, 0.267374992)
Part441.Anchored = true
Part441.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part441.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part441.BrickColor = BrickColor.new("Really black")
Part441.CanCollide = false
Part441.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part441.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part441.Material = Enum.Material.Metal
Part441.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part441.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part441.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part441.brickColor = BrickColor.new("Really black")
SpecialMesh442.Parent = Part441
SpecialMesh442.Scale = Vector3.new(0.495000005, 1, 1)
SpecialMesh442.MeshType = Enum.MeshType.Wedge
Part443.Parent = Model0
Part443.CFrame = CFrame.new(-0.584542513, 3.82849336, -13.6587467, 0.00162807188, 0.999985635, 0.00510653481, -0.0189460143, 0.00513647031, -0.999807417, -0.999819279, 0.00153100933, 0.0189541057)
Part443.Orientation = Vector3.new(88.8799973, 15.0799999, -74.8300018)
Part443.Position = Vector3.new(-0.584542513, 3.82849336, -13.6587467)
Part443.Rotation = Vector3.new(88.909996, 0.289999992, -89.909996)
Part443.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part443.Velocity = Vector3.new(-3.47538496e-08, 0.00246759271, -4.56702992e-07)
Part443.Size = Vector3.new(0.643000007, 0.200000003, 0.280375004)
Part443.Anchored = true
Part443.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part443.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part443.BrickColor = BrickColor.new("Royal purple")
Part443.CanCollide = false
Part443.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part443.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part443.Material = Enum.Material.Neon
Part443.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part443.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part443.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part443.brickColor = BrickColor.new("Royal purple")
SpecialMesh444.Parent = Part443
SpecialMesh444.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh444.MeshType = Enum.MeshType.Wedge
Part445.Parent = Model0
Part445.CFrame = CFrame.new(-0.618139863, 3.39627433, -10.6743059, 0.999985635, -0.0024899696, 0.00474630948, 0.00513651408, 0.192273051, -0.981328189, 0.00153088931, 0.981338441, 0.192283079)
Part445.Orientation = Vector3.new(78.909996, 1.40999997, 1.52999997)
Part445.Position = Vector3.new(-0.618139863, 3.39627433, -10.6743059)
Part445.Rotation = Vector3.new(78.909996, 0.269999981, 0.140000001)
Part445.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part445.Velocity = Vector3.new(3.37812835e-08, 0.00247380603, 4.43921522e-07)
Part445.Size = Vector3.new(0.275000006, 0.28125, 0.234375)
Part445.Anchored = true
Part445.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part445.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part445.BrickColor = BrickColor.new("Really black")
Part445.CanCollide = false
Part445.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part445.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part445.Material = Enum.Material.Metal
Part445.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part445.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part445.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part445.brickColor = BrickColor.new("Really black")
SpecialMesh446.Parent = Part445
SpecialMesh446.Scale = Vector3.new(0.5, 1.04999995, 0.400000006)
SpecialMesh446.MeshType = Enum.MeshType.Brick
Part447.Parent = Model0
Part447.CFrame = CFrame.new(-0.612165928, 3.04279852, -13.3917465, -0.999985635, -0.00162807154, -0.00510656228, -0.00513649778, 0.0189459547, 0.999807417, -0.00153100886, 0.999819279, -0.0189540461)
Part447.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part447.Position = Vector3.new(-0.612165928, 3.04279852, -13.3917465)
Part447.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part447.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part447.Velocity = Vector3.new(8.98303796e-08, 0.00246814452, 1.18046705e-06)
Part447.Size = Vector3.new(0.275000006, 0.577124953, 0.303375006)
Part447.Anchored = true
Part447.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part447.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part447.BrickColor = BrickColor.new("Really black")
Part447.CanCollide = false
Part447.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part447.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part447.Material = Enum.Material.Metal
Part447.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part447.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part447.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part447.brickColor = BrickColor.new("Really black")
SpecialMesh448.Parent = Part447
SpecialMesh448.Scale = Vector3.new(0.400000006, 0.870000005, 0.5)
SpecialMesh448.MeshType = Enum.MeshType.Brick
Part449.Parent = Model0
Part449.CFrame = CFrame.new(-0.576728344, 2.5984447, -14.6364422, 0.00114334025, 0.999985635, -0.00523668947, -0.483495861, 0.00513671385, 0.8753317, 0.875346005, 0.00153111527, 0.483494759)
Part449.Orientation = Vector3.new(-61.079998, -0.620000005, -89.3899994)
Part449.Position = Vector3.new(-0.576728344, 2.5984447, -14.6364422)
Part449.Rotation = Vector3.new(-61.0900002, -0.299999982, -89.9300003)
Part449.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part449.Velocity = Vector3.new(1.6028963e-07, 0.00246555661, 2.10637722e-06)
Part449.Size = Vector3.new(0.423000038, 0.200000003, 0.280375004)
Part449.Anchored = true
Part449.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part449.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part449.BrickColor = BrickColor.new("Royal purple")
Part449.CanCollide = false
Part449.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part449.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part449.Material = Enum.Material.Neon
Part449.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part449.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part449.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part449.brickColor = BrickColor.new("Royal purple")
SpecialMesh450.Parent = Part449
SpecialMesh450.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh450.MeshType = Enum.MeshType.Wedge
Part451.Parent = Model0
Part451.CFrame = CFrame.new(-0.611472607, 3.24456573, -14.520874, -0.999985635, 0.000250921701, 0.00535428664, -0.00513683865, 0.240468413, -0.970643461, -0.00153109187, -0.970656991, -0.240463659)
Part451.Orientation = Vector3.new(76.0800018, 178.720001, -1.22000003)
Part451.Position = Vector3.new(-0.611472607, 3.24456573, -14.520874)
Part451.Rotation = Vector3.new(103.909996, 0.310000002, -179.98999)
Part451.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part451.Velocity = Vector3.new(5.78370134e-08, 0.002465792, 7.60040166e-07)
Part451.Size = Vector3.new(0.275000006, 0.221124932, 0.408374965)
Part451.Anchored = true
Part451.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part451.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part451.BrickColor = BrickColor.new("Really black")
Part451.CanCollide = false
Part451.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part451.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part451.Material = Enum.Material.Metal
Part451.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part451.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part451.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part451.brickColor = BrickColor.new("Really black")
SpecialMesh452.Parent = Part451
SpecialMesh452.Scale = Vector3.new(0.550000012, 1.04999995, 0.800000012)
SpecialMesh452.MeshType = Enum.MeshType.Brick
Part453.Parent = Model0
Part453.CFrame = CFrame.new(-0.610993803, 3.15083313, -14.5190973, 0.999985635, 0.00289416499, -0.00451159757, 0.00513686473, -0.2770693, 0.960836351, 0.00153079326, -0.960845709, -0.277080178)
Part453.Orientation = Vector3.new(-73.909996, -179.069992, 178.940002)
Part453.Position = Vector3.new(-0.610993803, 3.15083313, -14.5190973)
Part453.Rotation = Vector3.new(-106.089996, -0.25999999, -0.170000002)
Part453.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part453.Velocity = Vector3.new(7.26997911e-08, 0.00246579573, 9.55352903e-07)
Part453.Size = Vector3.new(0.275000006, 0.221124932, 0.408374965)
Part453.Anchored = true
Part453.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part453.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part453.BrickColor = BrickColor.new("Really black")
Part453.CanCollide = false
Part453.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part453.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part453.Material = Enum.Material.Metal
Part453.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part453.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part453.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part453.brickColor = BrickColor.new("Really black")
SpecialMesh454.Parent = Part453
SpecialMesh454.Scale = Vector3.new(0.550000012, 1.04999995, 0.800000012)
SpecialMesh454.MeshType = Enum.MeshType.Brick
Part455.Parent = Model0
Part455.CFrame = CFrame.new(-0.609657764, 2.72515392, -13.9643335, -0.999985635, -0.00162816129, -0.00510662561, -0.00513656298, 0.0189460143, 0.999807417, -0.00153109711, 0.999819279, -0.0189541057)
Part455.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part455.Position = Vector3.new(-0.609657764, 2.72515392, -13.9643335)
Part455.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part455.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part455.Velocity = Vector3.new(1.40197898e-07, 0.00246695196, 1.84235034e-06)
Part455.Size = Vector3.new(0.275000006, 0.330124915, 0.226374999)
Part455.Anchored = true
Part455.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part455.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part455.BrickColor = BrickColor.new("Really black")
Part455.CanCollide = false
Part455.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part455.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part455.Material = Enum.Material.Glass
Part455.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part455.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part455.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part455.brickColor = BrickColor.new("Really black")
SpecialMesh456.Parent = Part455
SpecialMesh456.Scale = Vector3.new(0.400000006, 1, 1)
SpecialMesh456.MeshType = Enum.MeshType.Brick
Part457.Parent = Model0
Part457.CFrame = CFrame.new(-0.577368915, 2.78939152, -14.8586674, 0.00361127499, 0.999985635, -0.00396134611, -0.85638535, 0.00513800606, 0.516312063, 0.516324997, 0.00152789324, 0.856391609)
Part457.Orientation = Vector3.new(-31.0900002, -0.269999981, -89.659996)
Part457.Position = Vector3.new(-0.577368915, 2.78939152, -14.8586674)
Part457.Rotation = Vector3.new(-31.0900002, -0.229999989, -89.7900009)
Part457.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part457.Velocity = Vector3.new(1.30012012e-07, 0.00246509351, 1.70849694e-06)
Part457.Size = Vector3.new(0.293000042, 0.200000003, 0.280375004)
Part457.Anchored = true
Part457.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part457.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part457.BrickColor = BrickColor.new("Royal purple")
Part457.CanCollide = false
Part457.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part457.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part457.Material = Enum.Material.Neon
Part457.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part457.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part457.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part457.brickColor = BrickColor.new("Royal purple")
SpecialMesh458.Parent = Part457
SpecialMesh458.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh458.MeshType = Enum.MeshType.Wedge
Part459.Parent = Model0
Part459.CFrame = CFrame.new(-0.611768007, 3.29040194, -14.4816895, -0.999985635, -0.00045009004, 0.00534120994, -0.00513681443, 0.36510545, -0.930952132, -0.00153109233, -0.930966198, -0.3651025)
Part459.Orientation = Vector3.new(68.5800018, 179.159988, -0.810000002)
Part459.Position = Vector3.new(-0.611768007, 3.29040194, -14.4816895)
Part459.Rotation = Vector3.new(111.409996, 0.310000002, 179.970001)
Part459.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part459.Velocity = Vector3.new(5.05689677e-08, 0.00246587349, 6.64530262e-07)
Part459.Size = Vector3.new(0.275000006, 0.238124937, 0.381375015)
Part459.Anchored = true
Part459.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part459.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part459.BrickColor = BrickColor.new("Royal purple")
Part459.CanCollide = false
Part459.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part459.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part459.Material = Enum.Material.Neon
Part459.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part459.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part459.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part459.brickColor = BrickColor.new("Royal purple")
SpecialMesh460.Parent = Part459
SpecialMesh460.Scale = Vector3.new(0.524999976, 1.04999995, 0.800000012)
SpecialMesh460.MeshType = Enum.MeshType.Brick
Part461.Parent = Model0
Part461.CFrame = CFrame.new(-0.605971158, 3.45052385, -18.8064079, -0.999985635, 0.00474059395, 0.00250087585, -0.00513641909, -0.714288056, -0.699833155, -0.00153127871, -0.699835896, 0.714302182)
Part461.Orientation = Vector3.new(44.4099998, 0.199999988, -179.589996)
Part461.Position = Vector3.new(-0.605971158, 3.45052385, -18.8064079)
Part461.Rotation = Vector3.new(44.4099998, 0.140000001, -179.729996)
Part461.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part461.Velocity = Vector3.new(2.51790748e-08, 0.00245686295, 3.30880596e-07)
Part461.Size = Vector3.new(0.275000006, 0.235124931, 0.586375237)
Part461.Anchored = true
Part461.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part461.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part461.BrickColor = BrickColor.new("Really black")
Part461.CanCollide = false
Part461.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part461.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part461.Material = Enum.Material.Metal
Part461.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part461.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part461.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part461.brickColor = BrickColor.new("Really black")
SpecialMesh462.Parent = Part461
SpecialMesh462.Scale = Vector3.new(0.400000006, 1.04999995, 1)
SpecialMesh462.MeshType = Enum.MeshType.Brick
Part463.Parent = Model0
Part463.CFrame = CFrame.new(-0.610880256, 2.96906447, -13.9840736, -0.999985635, -0.00162807154, -0.00510650687, -0.00513644237, 0.0189459547, 0.999807417, -0.00153100991, 0.999819279, -0.0189540461)
Part463.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part463.Position = Vector3.new(-0.610880256, 2.96906447, -13.9840736)
Part463.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part463.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part463.Velocity = Vector3.new(1.01522062e-07, 0.00246691052, 1.33410845e-06)
Part463.Size = Vector3.new(0.275000006, 0.239124984, 0.303375006)
Part463.Anchored = true
Part463.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part463.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part463.BrickColor = BrickColor.new("Really black")
Part463.CanCollide = false
Part463.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part463.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part463.Material = Enum.Material.Glass
Part463.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part463.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part463.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part463.brickColor = BrickColor.new("Really black")
SpecialMesh464.Parent = Part463
SpecialMesh464.Scale = Vector3.new(0.524999976, 1, 1)
SpecialMesh464.MeshType = Enum.MeshType.Brick
Part465.Parent = Model0
Part465.CFrame = CFrame.new(-0.63922745, 2.59812379, -14.6365376, -0.00114342954, -0.999985635, -0.00523668341, 0.483495861, -0.00513675157, 0.8753317, -0.875346065, -0.00153103401, 0.483494759)
Part465.Orientation = Vector3.new(-61.079998, -0.620000005, 90.6100006)
Part465.Position = Vector3.new(-0.63922745, 2.59812379, -14.6365376)
Part465.Rotation = Vector3.new(-61.0900002, -0.299999982, 90.0699997)
Part465.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part465.Velocity = Vector3.new(1.6034052e-07, 0.0024655466, 2.10704593e-06)
Part465.Size = Vector3.new(0.423000038, 0.200000003, 0.280375004)
Part465.Anchored = true
Part465.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part465.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part465.BrickColor = BrickColor.new("Royal purple")
Part465.CanCollide = false
Part465.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part465.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part465.Material = Enum.Material.Neon
Part465.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part465.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part465.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part465.brickColor = BrickColor.new("Royal purple")
SpecialMesh466.Parent = Part465
SpecialMesh466.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh466.MeshType = Enum.MeshType.Wedge
Part467.Parent = Model0
Part467.CFrame = CFrame.new(-0.63986814, 2.78907037, -14.8587627, -0.0036113495, -0.999985635, -0.00396139733, 0.85638535, -0.00513809687, 0.516312063, -0.516324997, -0.0015278986, 0.856391549)
Part467.Orientation = Vector3.new(-31.0900002, -0.269999981, 90.3399963)
Part467.Position = Vector3.new(-0.63986814, 2.78907037, -14.8587627)
Part467.Rotation = Vector3.new(-31.0900002, -0.229999989, 90.2099991)
Part467.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part467.Velocity = Vector3.new(1.30062929e-07, 0.00246508326, 1.70916621e-06)
Part467.Size = Vector3.new(0.293000042, 0.200000003, 0.280375004)
Part467.Anchored = true
Part467.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part467.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part467.BrickColor = BrickColor.new("Royal purple")
Part467.CanCollide = false
Part467.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part467.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part467.Material = Enum.Material.Neon
Part467.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part467.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part467.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part467.brickColor = BrickColor.new("Royal purple")
SpecialMesh468.Parent = Part467
SpecialMesh468.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh468.MeshType = Enum.MeshType.Wedge
Part469.Parent = Model0
Part469.CFrame = CFrame.new(-0.610184669, 2.95239902, -14.3818283, 0.999985635, 0.00162795268, -0.00510686403, 0.0051367972, -0.0189460143, 0.999807417, 0.00153088395, -0.999819279, -0.0189541057)
Part469.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part469.Position = Vector3.new(-0.610184669, 2.95239902, -14.3818283)
Part469.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part469.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part469.Velocity = Vector3.new(1.04164627e-07, 0.00246608187, 1.36883455e-06)
Part469.Size = Vector3.new(0.275000006, 0.410999984, 0.469375014)
Part469.Anchored = true
Part469.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part469.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part469.BrickColor = BrickColor.new("Really black")
Part469.CanCollide = false
Part469.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part469.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part469.Material = Enum.Material.Glass
Part469.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part469.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part469.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part469.brickColor = BrickColor.new("Really black")
SpecialMesh470.Parent = Part469
SpecialMesh470.Scale = Vector3.new(0.5, 0.850000024, 0.699999988)
SpecialMesh470.MeshType = Enum.MeshType.Brick
Part471.Parent = Model0
Part471.CFrame = CFrame.new(-0.613238811, 3.32843637, -13.6493177, -0.999985635, -0.00162807142, -0.00510653527, -0.00513647031, 0.0189459249, 0.999807417, -0.00153100933, 0.999819279, -0.0189540163)
Part471.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part471.Position = Vector3.new(-0.613238811, 3.32843637, -13.6493177)
Part471.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part471.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part471.Velocity = Vector3.new(4.45380195e-08, 0.00246760761, 5.85277007e-07)
Part471.Size = Vector3.new(0.275000006, 0.698124886, 0.638374984)
Part471.Anchored = true
Part471.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part471.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part471.BrickColor = BrickColor.new("Really black")
Part471.CanCollide = false
Part471.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part471.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part471.Material = Enum.Material.Glass
Part471.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part471.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part471.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part471.brickColor = BrickColor.new("Really black")
SpecialMesh472.Parent = Part471
SpecialMesh472.Scale = Vector3.new(0.449999988, 1, 1)
SpecialMesh472.MeshType = Enum.MeshType.Cylinder
Part473.Parent = Model0
Part473.CFrame = CFrame.new(-0.618369102, 3.23987865, -11.0925436, 0.999985635, 0.00162807235, -0.00510680024, 0.0051367362, -0.0189461038, 0.999807417, 0.00153100432, -0.999819279, -0.0189541951)
Part473.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part473.Position = Vector3.new(-0.618369102, 3.23987865, -11.0925436)
Part473.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part473.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part473.Velocity = Vector3.new(5.85802624e-08, 0.00247293455, 7.69806775e-07)
Part473.Size = Vector3.new(0.25999999, 0.578125, 0.21875)
Part473.Anchored = true
Part473.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part473.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part473.BrickColor = BrickColor.new("Really black")
Part473.CanCollide = false
Part473.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part473.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part473.Material = Enum.Material.Metal
Part473.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part473.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part473.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part473.brickColor = BrickColor.new("Really black")
SpecialMesh474.Parent = Part473
SpecialMesh474.Scale = Vector3.new(0.300000012, 1, 1)
SpecialMesh474.MeshType = Enum.MeshType.Wedge
Part475.Name = "TrueHandle"
Part475.Parent = Model0
Part475.CFrame = CFrame.new(-0.615642607, 3.34541011, -12.1349049, -0.999985635, -0.00162807154, -0.00510656228, -0.00513649778, 0.0189459547, 0.999807417, -0.00153100886, 0.999819279, -0.0189540461)
Part475.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part475.Position = Vector3.new(-0.615642607, 3.34541011, -12.1349049)
Part475.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part475.Color = Color3.new(0.803922, 0.803922, 0.803922)
Part475.Velocity = Vector3.new(4.18465866e-08, 0.00247076293, 5.49908464e-07)
Part475.Size = Vector3.new(0.275000006, 1.73512506, 0.280375004)
Part475.Anchored = true
Part475.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part475.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part475.BrickColor = BrickColor.new("Mid gray")
Part475.CanCollide = false
Part475.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part475.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part475.Material = Enum.Material.Metal
Part475.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part475.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part475.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part475.brickColor = BrickColor.new("Mid gray")
SpecialMesh476.Parent = Part475
SpecialMesh476.Scale = Vector3.new(0.349999994, 1.04999995, 0.5)
SpecialMesh476.MeshType = Enum.MeshType.Brick
for i,v in pairs(mas:GetChildren()) do
	v.Parent = workspace.Camera.CameraSubject.Parent
	pcall(function() v:MakeJoints() end)
end
mas:Destroy()
for i,v in pairs(cors) do
	spawn(function()
		pcall(v)
	end)
end
for i,v in pairs(Model0:GetChildren()) do
	if v:IsA("Part") then
                v.Locked = true
		v.Anchored = false
		v.Transparency = 1
                v.CanCollide = false
	end
end

-- -gh 4315489767
plr = game:GetService("Players").LocalPlayer
char = workspace.Camera.CameraSubject.Parent
hum = char.Humanoid
local cam = game.Workspace.CurrentCamera
t = char.Torso
h = char.Head
ra = char["Right Arm"]
la = char["Left Arm"]
rl = char["Right Leg"]
ll = char["Left Leg"]
tors = char.Torso
lleg = char["Left Leg"]
root = char.HumanoidRootPart
hed = char.Head
rleg = char["Right Leg"]
rarm = char["Right Arm"]
larm = char["Left Arm"]
it = Instance.new
vt = Vector3.new
bc = BrickColor.new
br = BrickColor.random
it = Instance.new
cf = CFrame.new
ceuler = CFrame.fromEulerAnglesXYZ

local muter = false
local ORGID = 1873219898
local ORVOL = 1.15
local ORPIT = 1.01
local kan = Instance.new("Sound",plr.PlayerGui)
kan.Volume = 1.15
kan.TimePosition = 0
kan.PlaybackSpeed = 1.01
kan.Pitch = 1.01
kan.SoundId = "rbxassetid://1873219898" --525289865,1873219898,381991270
kan.Name = "nepnepnep"
kan.Looped = true
kan:Play()

--------------------------- GUI STUFF
local basgui = it("GuiMain")
basgui.Parent = plr.PlayerGui
basgui.Name = "VISgui"
local fullscreenz = it("Frame")
fullscreenz.Parent = basgui
fullscreenz.BackgroundColor3 = Color3.new(255, 255, 255)
fullscreenz.BackgroundTransparency = 1
fullscreenz.BorderColor3 = Color3.new(17, 17, 17)
fullscreenz.Size = UDim2.new(1, 0, 1, 0)
fullscreenz.Position = UDim2.new(0, 0, 0, 0)
local imgl2 = Instance.new("ImageLabel",fullscreenz)
imgl2.BackgroundTransparency = 1
imgl2.BorderSizePixel = 0
imgl2.ImageTransparency = 0.5
imgl2.ImageColor3 = Color3.new(1,0,0)
imgl2.Position = UDim2.new(0.75,0,0.55,0)
imgl2.Size = UDim2.new(0,600,0,600)
imgl2.Image = "rbxassetid://320731120"
local techc = imgl2:Clone()
techc.Parent = fullscreenz
techc.ImageTransparency = 0.5
techc.Size = UDim2.new(0,700,0,700)
techc.Position = UDim2.new(0.75,-50,0.55,-50)
techc.ImageColor3 = Color3.new(0.5,0,1)
techc.Image = "rbxassetid://521073910"
local circl = imgl2:Clone()
circl.Parent = fullscreenz
circl.ImageTransparency = 0
circl.Size = UDim2.new(0,500,0,500)
circl.Position = UDim2.new(0.75,50,0.55,50)
circl.ImageColor3 = Color3.new(0,0.5,1)
circl.Image = "rbxassetid://997291547"
local circl2 = imgl2:Clone()
circl2.Parent = fullscreenz
circl2.ImageTransparency = 0
circl2.ImageColor3 = Color3.new(0.5,0,1)
circl2.Image = "rbxassetid://997291547"
local imgl2b = imgl2:Clone()
imgl2b.Parent = fullscreenz
imgl2b.ImageTransparency = 0
imgl2b.Size = UDim2.new(0,500,0,500)
imgl2b.Position = UDim2.new(0.75,50,0.55,50)
local ned = Instance.new("TextLabel",fullscreenz)
ned.ZIndex = 2
ned.Font = "SciFi"
ned.BackgroundTransparency = 1
ned.BorderSizePixel = 0.65
ned.Size = UDim2.new(0.4,0,0.2,0)
ned.Position = UDim2.new(0.6,0,0.8,0)
ned.TextColor3 = BrickColor.new("Royal purple").Color
ned.TextStrokeColor3 = BrickColor.new("Cyan").Color
ned.TextScaled = true
ned.TextStrokeTransparency = 0
ned.Text = "NEPTUNIAN V"
ned.TextSize = 24
ned.Rotation = 1
--ned.TextXAlignment = "Right"
ned.TextYAlignment = "Bottom"

function CameraShake(Times, Power)
coroutine.resume(coroutine.create(function()
FV = Instance.new("BoolValue", Character)
FV.Name = "CameraShake"
for ShakeNum=1,Times do
swait()
local ef=Power
  if ef>=1 then
   Humanoid.CameraOffset = Vector3.new(math.random(-ef,ef),math.random(-ef,ef),math.random(-ef,ef))
  else
   ef=Power*10
   Humanoid.CameraOffset = Vector3.new(math.random(-ef,ef)/10,math.random(-ef,ef)/10,math.random(-ef,ef)/10)
  end	
end
Humanoid.CameraOffset = Vector3.new(0,0,0)
FV:Destroy()
end))
end

CamShake=function(Part,Distan,Power,Times) 
local de=Part.Position
for i,v in pairs(workspace:children()) do
 if v:IsA("Model") and v:findFirstChild("Humanoid") then
for _,c in pairs(v:children()) do
if c.ClassName=="Part" and (c.Position - de).magnitude < Distan then
local Noob=v.Humanoid
if Noob~=nil then
if Noob:FindFirstChild("CamShake")==nil then-- and Noob == Character then
--[[local ss=script.CamShake:clone()
ss.Parent=Noob
ss.Power.Value=Power
ss.Times.Value=Times
ss.Disabled=false]]
CameraShake(Times, Power)
end
end
end
end
end
end
end

function chatfunc(text,color,typet,font,timeex)
local chat = coroutine.wrap(function()
if Character:FindFirstChild("TalkingBillBoard")~= nil then
Character:FindFirstChild("TalkingBillBoard"):destroy()
end
local naeeym2 = Instance.new("BillboardGui",Character)
naeeym2.Size = UDim2.new(0,100,0,40)
naeeym2.StudsOffset = Vector3.new(0,3,0)
naeeym2.Adornee = Character.Head
naeeym2.Name = "TalkingBillBoard"
local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.BorderSizePixel = 0
tecks2.Text = ""
tecks2.Font = font
tecks2.TextSize = 30
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = color
tecks2.TextStrokeColor3 = Color3.new(0,0,0)
tecks2.Size = UDim2.new(1,0,0.5,0)
local tecks3 = Instance.new("TextLabel",naeeym2)
tecks3.BackgroundTransparency = 1
tecks3.BorderSizePixel = 0
tecks3.Text = ""
tecks3.Font = font
tecks3.TextSize = 30
tecks3.TextStrokeTransparency = 0
if typet == "Inverted" then
tecks3.TextColor3 = Color3.new(0,0,0)
tecks3.TextStrokeColor3 = color
elseif typet == "Normal" then
tecks3.TextColor3 = color
tecks3.TextStrokeColor3 = Color3.new(0,0,0)
end
tecks3.Size = UDim2.new(1,0,0.5,0)
coroutine.resume(coroutine.create(function()
while true do
swait(1)
if chaosmode == true then
tecks2.TextColor3 = BrickColor.random().Color
tecks3.TextStrokeColor3 = BrickColor.random().Color
end
end
end))
for i = 0, 74*timeex do
swait()
tecks2.Text = text
tecks3.Text = text
end
local randomrot = math.random(1,2)
if randomrot == 1 then
for i = 1, 50 do
swait()
tecks2.Text = text
tecks3.Text = text
tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
tecks2.TextTransparency = tecks2.TextTransparency + .04
tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
tecks3.TextTransparency = tecks2.TextTransparency + .04
end
elseif randomrot == 2 then
	for i = 1, 50 do
swait()
tecks2.Text = text
tecks3.Text = text
tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
tecks2.TextTransparency = tecks2.TextTransparency + .04
tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
tecks3.TextTransparency = tecks2.TextTransparency + .04
end
end
naeeym2:Destroy()
end)
chat()
end

loadstring(game:HttpGet("https://pastebin.com/raw/ZcMcKmLs"))()
local Create = LoadLibrary("RbxUtility").Create

CFuncs = {	
	["Part"] = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part"){
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material,
			}
			RemoveOutlines(Part)
			return Part
		end;
	};
	
	["Mesh"] = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end;
	};
	
	["Mesh"] = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end;
	};
	
	["Weld"] = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld"){
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1,
			}
			return Weld
		end;
	};

	["Sound"] = {
		Create = function(id, par, vol, pit) 
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound"){
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 10)
			end))
		end;
	};

["LongSound"] = {
		Create = function(id, par, vol, pit) 
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound"){
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 30)
			end))
		end;
	};
	
	["ParticleEmitter"] = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter"){
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread,
			}
			return fp
		end;
	};

	CreateTemplate = {
	
	};
}



New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end
local m = Instance.new("Model",char)

function CreateParta(parent,transparency,reflectance,material,brickcolor)
local p = Instance.new("Part")
p.TopSurface = 0
p.BottomSurface = 0
p.Parent = parent
p.Size = Vector3.new(0.05,0.05,0.05)
p.Transparency = transparency
p.Reflectance = reflectance
p.CanCollide = false
p.Locked = true
p.BrickColor = brickcolor
p.Material = material
return p
end

function CreateMesh(parent,meshtype,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = meshtype
mesh.Scale = Vector3.new(x1*20,y1*20,z1*20)
return mesh
end

function CreateSpecialMesh(parent,meshid,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = "FileMesh"
mesh.MeshId = meshid
mesh.Scale = Vector3.new(x1,y1,z1)
return mesh
end


function CreateSpecialGlowMesh(parent,meshid,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = "FileMesh"
mesh.MeshId = meshid
mesh.TextureId = "http://www.roblox.com/asset/?id=269748808"
mesh.Scale = Vector3.new(x1,y1,z1)
mesh.VertexColor = Vector3.new(parent.BrickColor.r, parent.BrickColor.g, parent.BrickColor.b)
return mesh
end

function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
local weld = Instance.new("Weld")
weld.Parent = parent
weld.Part0 = part0
weld.Part1 = part1
weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
return weld
end




---- WEAPON OR STUFF
local rarmor = CreateParta(m,1,0,"SmoothPlastic",BrickColor.Random())
local weaponweld = CreateWeld(rarmor,tors,rarmor,-3,0,-0.5,math.rad(0),math.rad(0),math.rad(-40),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local MainWeldS = CreateWeld(Part475,rarmor,Part475,0,0,0,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local A0 = Instance.new("Attachment",rarmor)
A0.Position = Vector3.new(-2.5,0.25,0)
local A1 = Instance.new("Attachment",rarmor)
A1.Position = Vector3.new(-7.5,0.4,0)
tl1 = Instance.new('Trail',rarmor)
tl1.Attachment0 = A0
tl1.Attachment1 = A1
tl1.Texture = "http://www.roblox.com/asset/?id=1978704853"
tl1.LightEmission = 1
tl1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
tl1.Color = ColorSequence.new(BrickColor.new('Royal purple').Color)
tl1.Lifetime = 0.6
tl1.Enabled = false




--------------- WINGS
local mainpart = CreateParta(m,1,0,"SmoothPlastic",BrickColor.Random())
local mwingweld = CreateWeld(mainpart,tors,mainpart,0,-0.5,-0.75,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local wng1a = CreateParta(m,1,0,"Neon",BrickColor.new("Alder"))
CreateMesh(wng1a,"Wedge",0.1,4,4)
CreateWeld(wng1a,mainpart,wng1a,0,-2,-2.5,math.rad(0),math.rad(70),math.rad(5),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local wng2a = CreateParta(m,1,0,"Neon",BrickColor.new("Alder"))
CreateMesh(wng2a,"Wedge",0.1,4,4)
CreateWeld(wng2a,mainpart,wng2a,0,-2,-2.5,math.rad(0),math.rad(-70),math.rad(-5),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local wng1b = CreateParta(m,1,0,"Neon",BrickColor.new("Alder"))
CreateMesh(wng1b,"Wedge",0.1,1.5,3)
CreateWeld(wng1b,mainpart,wng1b,0,-1,-2.25,math.rad(180),math.rad(-110),math.rad(-5),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local wng2b = CreateParta(m,1,0,"Neon",BrickColor.new("Alder"))
CreateMesh(wng2b,"Wedge",0.1,1.5,3)
CreateWeld(wng2b,mainpart,wng2b,0,-1,-2.25,math.rad(180),math.rad(110),math.rad(5),0,0,0,math.rad(0),math.rad(0),math.rad(0))
------


function lerp(object, newCFrame, alpha)
  return object:lerp(newCFrame, alpha)
end

function RemoveOutlines(part)
  part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
  local Part = Create("Part")({
    Parent = Parent,
    Reflectance = Reflectance,
    Transparency = Transparency,
    CanCollide = false,
    Locked = true,
    BrickColor = BrickColor.new(tostring(BColor)),
    Name = Name,
    Size = Size,
    Material = Material
  })
  Part.CustomPhysicalProperties = PhysicalProperties.new(0.001, 0.001, 0.001, 0.001, 0.001)
  RemoveOutlines(Part)
  return Part
end
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
  local Msh = Create(Mesh)({
    Parent = Part,
    Offset = OffSet,
    Scale = Scale
  })
  if Mesh == "SpecialMesh" then
    Msh.MeshType = MeshType
    Msh.MeshId = MeshId
  end
  return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
  local Weld = Create("Weld")({
    Parent = Parent,
    Part0 = Part0,
    Part1 = Part1,
    C0 = C0,
    C1 = C1
  })
  return Weld
end

function Align(Part0, Part1, Position, Angle)
	if Part0:FindFirstChild("Attachment") then
		Part0:FindFirstChild("Attachment"):Remove()
	end
    local AlignPosition = Instance.new("AlignPosition",Part0)
    local AlignOrientation = Instance.new("AlignOrientation",Part0)
    
    local Attachment1 = Instance.new("Attachment", Part0)
    local Attachment2 = Instance.new("Attachment", Part1)

    AlignPosition.Attachment0 = Attachment1
    AlignPosition.Attachment1 = Attachment2
    
    AlignOrientation.Attachment0 = Attachment1
    AlignOrientation.Attachment1 = Attachment2
    
    Attachment2.Position = Position or Vector3.new(0,0,0)
    Attachment2.Orientation = Angle or Vector3.new(0,0,0)
    
    AlignOrientation.MaxTorque = math.huge
    AlignOrientation.MaxAngularVelocity = math.huge
    AlignOrientation.PrimaryAxisOnly = false 
    AlignOrientation.Responsiveness = 200
    AlignOrientation.RigidityEnabled = false
    AlignOrientation.ReactionTorqueEnabled = false
    AlignPosition.MaxForce = 3453845
    AlignPosition.MaxVelocity = math.huge
    AlignPosition.ReactionForceEnabled = false
    AlignPosition.Responsiveness = 200
    AlignPosition.ApplyAtCenterOfMass = true
    AlignPosition.RigidityEnabled = true
    game:GetService("RunService").Heartbeat:Connect(function()
        Part0.Velocity = Vector3.new(-39.99,0,0)
    end)
    if Part0.Parent:IsA("Accessory") then
    	Part0:BreakJoints()
    end
end

Align(game.Players.LocalPlayer.Character["MeshPartAccessory"].Handle, char.Model.TrueHandle, Vector3.new(0, -2.7, 0), Vector3.new(-0, 90, 45))

Player=game:GetService("Players").LocalPlayer
Character=workspace.Camera.CameraSubject.Parent
PlayerGui=Player.PlayerGui 
Backpack=Player.Backpack 
Torso=Character.Torso 
Head=Character.Head 
Humanoid=Character.Humanoid
m=Instance.new('Model',Character)
LeftArm=Character["Left Arm"] 
LeftLeg=Character["Left Leg"] 
RightArm=Character["Right Arm"] 
RightLeg=Character["Right Leg"] 
LS=Torso["Left Shoulder"] 
LH=Torso["Left Hip"] 
RS=Torso["Right Shoulder"] 
RH=Torso["Right Hip"] 
Face = Head.face
Neck=Torso.Neck
it=Instance.new
attacktype=1
vt=Vector3.new
cf=CFrame.new
euler=CFrame.fromEulerAnglesXYZ
angles=CFrame.Angles
cloaked=false
necko=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
necko2=cf(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
LHC0=cf(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
LHC1=cf(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
RHC0=cf(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
RHC1=cf(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
RootPart=Character.HumanoidRootPart
RootJoint=RootPart.RootJoint
RootCF=euler(-1.57,0,3.14)
attack = false 
attackdebounce = false 
deb=false
equipped=true
hand=false
MMouse=nil
combo=0
mana=0
trispeed=.2
attackmode='none'
local idle=0
local Anim="Idle"
local Effects={}
local gun=false
local shoot=false
local sine = 0
local change = 1
player=nil 

mouse=Player:GetMouse()
--save shoulders 
RSH, LSH=nil, nil 
--welds 
RW, LW=Instance.new("Weld"), Instance.new("Weld") 
RW.Name="Right Shoulder" LW.Name="Left Shoulder"
LH=Torso["Left Hip"]
RH=Torso["Right Hip"]
TorsoColor=Torso.BrickColor
function NoOutline(Part)
Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
end
player=Player 
ch=Character
RSH=ch.Torso["Right Shoulder"] 
LSH=ch.Torso["Left Shoulder"] 
-- 
RSH.Parent=nil 
LSH.Parent=nil 
-- 
RW.Name="Right Shoulder"
RW.Part0=ch.Torso 
RW.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5) 
RW.C1=cf(0, 0.5, 0) 
RW.Part1=ch["Right Arm"] 
RW.Parent=ch.Torso 
-- 
LW.Name="Left Shoulder"
LW.Part0=ch.Torso 
LW.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8) 
LW.C1=cf(0, 0.5, 0) 
LW.Part1=ch["Left Arm"] 
LW.Parent=ch.Torso 

local Stats=Instance.new("BoolValue")
Stats.Name="Stats"
Stats.Parent=Character
local Atk=Instance.new("NumberValue")
Atk.Name="Damage"
Atk.Parent=Stats
Atk.Value=1
local Def=Instance.new("NumberValue")
Def.Name="Defense"
Def.Parent=Stats
Def.Value=1
local Speed=Instance.new("NumberValue")
Speed.Name="Speed"
Speed.Parent=Stats
Speed.Value=1
local Mvmt=Instance.new("NumberValue")
Mvmt.Name="Movement"
Mvmt.Parent=Stats
Mvmt.Value=1

local donum=0
 

function part(formfactor,parent,reflectance,transparency,brickcolor,name,size)
local fp=it("Part")
fp.formFactor=formfactor 
fp.Parent=parent
fp.Reflectance=reflectance
fp.Transparency=transparency
fp.CanCollide=false 
fp.Locked=true
fp.BrickColor=brickcolor
fp.Name=name
fp.Size=size
fp.Position=Torso.Position 
NoOutline(fp)
fp.Material="SmoothPlastic"
fp:BreakJoints()
return fp 
end 
 
function mesh(Mesh,part,meshtype,meshid,offset,scale)
local mesh=it(Mesh) 
mesh.Parent=part
if Mesh=="SpecialMesh" then
mesh.MeshType=meshtype
if meshid~="nil" then
mesh.MeshId="http://www.roblox.com/asset/?id="..meshid
end
end
mesh.Offset=offset
mesh.Scale=scale
return mesh
end
 
function weld(parent,part0,part1,c0)
local weld=it("Weld") 
weld.Parent=parent
weld.Part0=part0 
weld.Part1=part1 
weld.C0=c0
return weld
end
 
local Color1=Torso.BrickColor

local bodvel=Instance.new("BodyVelocity")
local bg=Instance.new("BodyGyro")

function swait(num)
if num==0 or num==nil then
game:service'RunService'.Stepped:wait(0)
else
for i=0,num do
game:service'RunService'.Stepped:wait(0)
end
end
end
 
 
so = function(id,par,vol,pit) 
coroutine.resume(coroutine.create(function()
local sou = Instance.new("Sound",par or workspace)
sou.Volume=vol
sou.Pitch=pit or 1
sou.SoundId=id
swait() 
sou:play() 
game:GetService("Debris"):AddItem(sou,6)
end))
end
 
function clerp(a,b,t) 
local qa = {QuaternionFromCFrame(a)}
local qb = {QuaternionFromCFrame(b)} 
local ax, ay, az = a.x, a.y, a.z 
local bx, by, bz = b.x, b.y, b.z
local _t = 1-t
return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
end 
 
function QuaternionFromCFrame(cf) 
local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
local trace = m00 + m11 + m22 
if trace > 0 then 
local s = math.sqrt(1 + trace) 
local recip = 0.5/s 
return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
else 
local i = 0 
if m11 > m00 then
i = 1
end
if m22 > (i == 0 and m00 or m11) then 
i = 2 
end 
if i == 0 then 
local s = math.sqrt(m00-m11-m22+1) 
local recip = 0.5/s 
return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
elseif i == 1 then 
local s = math.sqrt(m11-m22-m00+1) 
local recip = 0.5/s 
return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
elseif i == 2 then 
local s = math.sqrt(m22-m00-m11+1) 
local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
end 
end 
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w) 
local xs, ys, zs = x + x, y + y, z + z 
local wx, wy, wz = w*xs, w*ys, w*zs 
local xx = x*xs 
local xy = x*ys 
local xz = x*zs 
local yy = y*ys 
local yz = y*zs 
local zz = z*zs 
return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
end
 
function QuaternionSlerp(a, b, t) 
local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
local startInterp, finishInterp; 
if cosTheta >= 0.0001 then 
if (1 - cosTheta) > 0.0001 then 
local theta = math.acos(cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((1-t)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta  
else 
startInterp = 1-t 
finishInterp = t 
end 
else 
if (1+cosTheta) > 0.0001 then 
local theta = math.acos(-cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((t-1)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta 
else 
startInterp = t-1 
finishInterp = t 
end 
end 
return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
end

local function CFrameFromTopBack(at, top, back)
local right = top:Cross(back)
return CFrame.new(at.x, at.y, at.z,
right.x, top.x, back.x,
right.y, top.y, back.y,
right.z, top.z, back.z)
end

function Triangle(a, b, c)
local edg1 = (c-a):Dot((b-a).unit)
local edg2 = (a-b):Dot((c-b).unit)
local edg3 = (b-c):Dot((a-c).unit)
if edg1 <= (b-a).magnitude and edg1 >= 0 then
a, b, c = a, b, c
elseif edg2 <= (c-b).magnitude and edg2 >= 0 then
a, b, c = b, c, a
elseif edg3 <= (a-c).magnitude and edg3 >= 0 then
a, b, c = c, a, b
else
assert(false, "unreachable")
end
 
local len1 = (c-a):Dot((b-a).unit)
local len2 = (b-a).magnitude - len1
local width = (a + (b-a).unit*len1 - c).magnitude
 
local maincf = CFrameFromTopBack(a, (b-a):Cross(c-b).unit, -(b-a).unit)
 
local list = {}
 
if len1 > 0.01 then
local w1 = Instance.new('WedgePart', m)
game:GetService("Debris"):AddItem(w1,5)
w1.Material = "SmoothPlastic"
w1.FormFactor = 'Custom'
w1.BrickColor = BrickColor.new("Really red")
w1.Transparency = 0
w1.Reflectance = 0
w1.Material = "SmoothPlastic"
w1.CanCollide = false
local l1 = Instance.new("PointLight",w1)
l1.Color = Color3.new(170,0,0)
NoOutline(w1)
local sz = Vector3.new(0.2, width, len1)
w1.Size = sz
local sp = Instance.new("SpecialMesh",w1)
sp.MeshType = "Wedge"
sp.Scale = Vector3.new(0,1,1) * sz/w1.Size
w1:BreakJoints()
w1.Anchored = true
w1.Parent = workspace
w1.Transparency = 0.7
table.insert(Effects,{w1,"Disappear",.01})
w1.CFrame = maincf*CFrame.Angles(math.pi,0,math.pi/2)*CFrame.new(0,width/2,len1/2)
table.insert(list,w1)
end
 
if len2 > 0.01 then
local w2 = Instance.new('WedgePart', m)
game:GetService("Debris"):AddItem(w2,5)
w2.Material = "SmoothPlastic"
w2.FormFactor = 'Custom'
w2.BrickColor = BrickColor.new("Really red")
w2.Transparency = 0
w2.Reflectance = 0
w2.Material = "SmoothPlastic"
w2.CanCollide = false
local l2 = Instance.new("PointLight",w2)
l2.Color = Color3.new(170,0,0)
NoOutline(w2)
local sz = Vector3.new(0.2, width, len2)
w2.Size = sz
local sp = Instance.new("SpecialMesh",w2)
sp.MeshType = "Wedge"
sp.Scale = Vector3.new(0,1,1) * sz/w2.Size
w2:BreakJoints()
w2.Anchored = true
w2.Parent = workspace
w2.Transparency = 0.7
table.insert(Effects,{w2,"Disappear",.01})
w2.CFrame = maincf*CFrame.Angles(math.pi,math.pi,-math.pi/2)*CFrame.new(0,width/2,-len1 - len2/2)
table.insert(list,w2)
end
return unpack(list)
end
 

function Damagefunc(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
  if hit.Parent == nil then
    return
  end
  local h = hit.Parent:FindFirstChildOfClass("Humanoid")
  for _, v in pairs(hit.Parent:children()) do
    if v:IsA("Humanoid") then
      h = v
h.MaxHealth = 100
    end
  end
  if h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("Torso") ~= nil or h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("UpperTorso") ~= nil then
    if hit.Parent:findFirstChild("DebounceHit") ~= nil and hit.Parent.DebounceHit.Value == true then
      return
    end
    local c = Create("ObjectValue")({
      Name = "creator",
      Value = game:service("Players").LocalPlayer,
      Parent = h
    })
    game:GetService("Debris"):AddItem(c, 0.5)
    if HitSound ~= nil and HitPitch ~= nil then
      CFuncs.Sound.Create(HitSound, hit, 1, HitPitch)
    end
    local Damage = math.random(minim, maxim)
    local blocked = false
    local block = hit.Parent:findFirstChild("Block")
    if block ~= nil and block.className == "IntValue" and block.Value > 0 then
      blocked = true
      block.Value = block.Value - 1
      print(block.Value)
    end
    if blocked == false then
      HitHealth = h.Health
h.MaxHealth = 100
      --h.Health = h.Health - Damage
      if HitHealth ~= h.Health and HitHealth ~= 0 and 0 >= h.Health and h.Parent.Name ~= "Hologram" then
        print("gained kill")
dmg(h.Parent)
      end
      ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 1.5, Part.BrickColor.Color)
    else
      --h.Health = h.Health - Damage / 2
      ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 1.5, Part.BrickColor.Color)
    end
    if Type == "Knockdown" then
      local hum = hit.Parent.Humanoid
      --hum.PlatformStand = true
      coroutine.resume(coroutine.create(function(HHumanoid)
        swait(1)
        HHumanoid.PlatformStand = false
      end), hum)
      local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
      local bodvol = Create("BodyVelocity")({
        velocity = angle * knockback,
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      local rl = Create("BodyAngularVelocity")({
        P = 3000,
        maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
        angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodvol, 0.5)
      game:GetService("Debris"):AddItem(rl, 0.5)
    elseif Type == "Normal" then
      local vp = Create("BodyVelocity")({
        P = 500,
        maxForce = Vector3.new(math.huge, 0, math.huge),
        velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05
      })
      if knockback > 0 then
        vp.Parent = hit.Parent.Torso
      end
      game:GetService("Debris"):AddItem(vp, 0.5)
    elseif Type == "Up" then
      local bodyVelocity = Create("BodyVelocity")({
        velocity = Vector3.new(0, 20, 0),
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodyVelocity, 0.5)
      local bodyVelocity = Create("BodyVelocity")({
        velocity = Vector3.new(0, 20, 0),
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodyVelocity, 1)
    elseif Type == "Leech" then
      local hum = hit.Parent.Humanoid
      if hum ~= nil then
        for i = 0, 2 do
          Effects.Sphere.Create(BrickColor.new("Bright red"), hit.Parent.Torso.CFrame * cn(0, 0, 0) * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 15, 1, 0, 5, 0, 0.02)
        end
        Humanoid.Health = Humanoid.Health + 10
      end
    elseif Type == "UpKnock" then
      local hum = hit.Parent.Humanoid
      hum.PlatformStand = true
      if hum ~= nil then
        hitr = true
      end
      coroutine.resume(coroutine.create(function(HHumanoid)
        swait(5)
        HHumanoid.PlatformStand = false
        hitr = false
      end), hum)
      local bodyVelocity = Create("BodyVelocity")({
        velocity = Vector3.new(0, 20, 0),
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodyVelocity, 0.5)
      local bodyVelocity = Create("BodyVelocity")({
        velocity = Vector3.new(0, 20, 0),
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodyVelocity, 1)
    elseif Type == "Snare" then
      local bp = Create("BodyPosition")({
        P = 2000,
        D = 100,
        maxForce = Vector3.new(math.huge, math.huge, math.huge),
        position = hit.Parent.Torso.Position,
        Parent = hit.Parent.Torso
      })
      game:GetService("Debris"):AddItem(bp, 1)
    elseif Type == "Slashnare" then
      Effects.Block.Create(BrickColor.new("Pastel Blue"), hit.Parent.Torso.CFrame * cn(0, 0, 0), 15*4, 15*4, 15*4, 3*4, 3*4, 3*4, 0.07)
      for i = 1, math.random(4, 5) do
        Effects.Sphere.Create(BrickColor.new("Teal"), hit.Parent.Torso.CFrame * cn(math.random(-5, 5), math.random(-5, 5), math.random(-5, 5)) * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 15, 1, 0, 5, 0, 0.02)
      end
      local bp = Create("BodyPosition")({
        P = 2000,
        D = 100,
        maxForce = Vector3.new(math.huge, math.huge, math.huge),
        position = hit.Parent.Torso.Position,
        Parent = hit.Parent.Torso
      })
      game:GetService("Debris"):AddItem(bp, 1)
    elseif Type == "Spike" then
      CreateBigIceSword(hit.Parent.Torso.CFrame)
      local bp = Create("BodyPosition")({
        P = 2000,
        D = 100,
        maxForce = Vector3.new(math.huge, math.huge, math.huge),
        position = hit.Parent.Torso.Position,
        Parent = hit.Parent.Torso
      })
      game:GetService("Debris"):AddItem(bp, 1)
    elseif Type == "Freeze" then
      local BodPos = Create("BodyPosition")({
        P = 50000,
        D = 1000,
        maxForce = Vector3.new(math.huge, math.huge, math.huge),
        position = hit.Parent.Torso.Position,
        Parent = hit.Parent.Torso
      })
      local BodGy = Create("BodyGyro")({
        maxTorque = Vector3.new(400000, 400000, 400000) * math.huge,
        P = 20000,
        Parent = hit.Parent.Torso,
        cframe = hit.Parent.Torso.CFrame
      })
      hit.Parent.Torso.Anchored = true
      coroutine.resume(coroutine.create(function(Part)
        swait(1.5)
        Part.Anchored = false
      end), hit.Parent.Torso)
      game:GetService("Debris"):AddItem(BodPos, 3)
      game:GetService("Debris"):AddItem(BodGy, 3)
    end
    local debounce = Create("BoolValue")({
      Name = "DebounceHit",
      Parent = hit.Parent,
      Value = true
    })
    game:GetService("Debris"):AddItem(debounce, Delay)
    c = Instance.new("ObjectValue")
    c.Name = "creator"
    c.Value = Player
    c.Parent = h
    game:GetService("Debris"):AddItem(c, 0.5)
  end
end
function ShowDamage(Pos, Text, Time, Color)
  local Rate = 0.1
  local Pos = Pos or Vector3.new(0, 0, 0)
  local Text = Text or ""
  local Time = Time or 2
  local Color = Color or Color3.new(1, 0, 1)
  local EffectPart = CreatePart(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
  EffectPart.Anchored = true
  local BillboardGui = Create("BillboardGui")({
    Size = UDim2.new(3, 0, 3, 0),
    Adornee = EffectPart,
    Parent = EffectPart
  })
  local TextLabel = Create("TextLabel")({
    BackgroundTransparency = 1,
    Size = UDim2.new(1, 0, 1, 0),
    Text = Text,
    TextColor3 = Color3.new(1,1,1),
    TextStrokeColor3 = Color3.new(0,0,0),
    TextStrokeTransparency = 0.25,
    TextScaled = true,
    Font = Enum.Font.Fantasy,
    TextSize = 24,
    Parent = BillboardGui
  })
  game.Debris:AddItem(EffectPart, Time + 0.1)
  EffectPart.Parent = game:GetService("Workspace")
  delay(0, function()
    local Frames = Time / Rate
    for Frame = 1, Frames do
      swait(Rate)
      local Percent = Frame / Frames
      TextLabel.Text = Text
      EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent*2, 0)
    end
    for Frame = 1, Frames do
      swait(Rate)
      local Percent = Frame / Frames
      TextLabel.Text = Text
    end
    for Frame = 1, Frames do
      swait(Rate)
      local Percent = Frame / Frames
      TextLabel.TextTransparency = Percent
      TextLabel.Text = Text
      TextLabel.TextStrokeTransparency = Percent
    end
    if EffectPart and EffectPart.Parent then
      EffectPart:Destroy()
    end
  end)
end
function MagniDamage(Part, magni, mindam, maxdam, knock, Type,Sound)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChildOfClass("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Torso")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= Player.Name then
          Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://" ..Sound, 1)
        end
      end
      local head = c:findFirstChild("UpperTorso")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= Player.Name then
          Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://" ..Sound, 1)
        end
      end
    end
  end
end


function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore) 
end 
----

function dmg(dude)

end

function sphere(bonuspeed,type,pos,scale,value,color)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = scale
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 1
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
end
rng:Destroy()
end))
end

function sphere2(bonuspeed,type,pos,scale,value,value2,value3,color,color3)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.Color = color3
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end))
end

function block(bonuspeed,type,pos,scale,value,value2,value3,color,color3)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.Color = color3
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Brick"
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.CFrame = rng.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end))
end

function sphereMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,color3,outerpos)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.Color = color3
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = vt(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end))
end

function waveEff(bonuspeed,type,typeoftrans,pos,scale,value,value2,color)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
if typeoftrans == "In" then
rng.Transparency = 1
end
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "FileMesh"
rngm.MeshId = "rbxassetid://20329976"
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
end
local randomrot = math.random(1,2)
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
end
if randomrot == 1 then
rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(5*bonuspeed/2),0)
elseif randomrot == 2 then
rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(-5*bonuspeed/2),0)
end
if typeoftrans == "Out" then
rng.Transparency = rng.Transparency + 0.01*bonuspeed
elseif typeoftrans == "In" then
rng.Transparency = rng.Transparency - 0.01*bonuspeed
end
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2*bonuspeed)
end
rng:Destroy()
end))
end

function slash(bonuspeed,rotspeed,rotatingop,typeofshape,type,typeoftrans,pos,scale,value,color)
local type = type
local rotenable = rotatingop
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
if typeoftrans == "In" then
rng.Transparency = 1
end
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "FileMesh"
if typeofshape == "Normal" then
rngm.MeshId = "rbxassetid://662586858"
elseif typeofshape == "Round" then
rngm.MeshId = "rbxassetid://662585058"
end
rngm.Scale = scale
local scaler2 = 1/10
if type == "Add" then
scaler2 = 1*value/10
elseif type == "Divide" then
scaler2 = 1/value/10
end
local randomrot = math.random(1,2)
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed/10
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed/10
end
if rotenable == true then
if randomrot == 1 then
rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(rotspeed*bonuspeed/2),0)
elseif randomrot == 2 then
rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(-rotspeed*bonuspeed/2),0)
end
end
if typeoftrans == "Out" then
rng.Transparency = rng.Transparency + 0.01*bonuspeed
elseif typeoftrans == "In" then
rng.Transparency = rng.Transparency - 0.01*bonuspeed
end
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed/10, 0, scaler2*bonuspeed/10)
end
rng:Destroy()
end))
end

function FindNearestTorso(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return (SinglePlayer.Torso.CFrame.p - Position).magnitude < Distance
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") then
			if v:findFirstChild("Torso") or v:findFirstChild("UpperTorso") then
				if v ~= Character then
					if (v.Head.Position - Position).magnitude <= Distance then
						table.insert(List, v)
					end 
				end 
			end 
		end 
	end
	return List
end


local dashing = false
local floatmode = false
local OWS = hum.WalkSpeed
local equipped = false

Humanoid.Animator.Parent = nil
------------------
function equip()
	attack = true
	equipped = true
	hum.WalkSpeed = 0
tl1.Enabled = true
for i = 0, 9 do
slash(math.random(10,50)/10,3,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-360,360)),math.rad(math.random(-10,10))),vt(0.05,0.01,0.05),math.random(25,50)/250,BrickColor.new("White"))
end
CFuncs["Sound"].Create("rbxassetid://1368637781", rarmor, 2.5, 1.25)
CFuncs["Sound"].Create("rbxassetid://200633077", rarmor, 1, 1)
CFuncs["Sound"].Create("rbxassetid://169380495", rarmor, 0.5, 1.1)
sphere2(5,"Add",root.CFrame,vt(5,5,5),0.25,0.25,0.25,BrickColor.new("Cyan"),BrickColor.new("Cyan").Color)
sphere2(6,"Add",root.CFrame,vt(5,5,5),0.25,0.25,0.25,BrickColor.new("Royal purple"),BrickColor.new("Royal purple").Color)
	for i = 0, 2, 0.1 do
		swait()
hum.CameraOffset = vt(math.random(-5,5)/50,math.random(-5,5)/50,math.random(-5,5)/50)
sphere2(5,"Add",rarmor.CFrame*CFrame.new(math.random(-8,-2),0,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.1,0.1,0.1),0,0.1,0,BrickColor.new("Cyan"),BrickColor.new("Cyan").Color)
waveEff(5,"Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(0,math.rad(math.random(-360,360)),0),vt(5,0.25,5),0.05,0.015,BrickColor.new("Cyan"))
waveEff(5,"Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(0,math.rad(math.random(-360,360)),0),vt(10,0.25,10),0.05,0.015,BrickColor.new("Royal purple"))
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(10),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(-10)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2),math.rad(0),math.rad(-20)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(-20),math.rad(-30),math.rad(130)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(-13),math.rad(10),math.rad(-10)),.3)
end
hum.CameraOffset = vt(0,0,0)
weaponweld.Part0 = rarm
for i = 0, 2, 0.1 do
		swait()
sphere2(5,"Add",rarmor.CFrame*CFrame.new(math.random(-8,-2),0,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.1,0.1,0.1),0,0.1,0,BrickColor.new("Cyan"),BrickColor.new("Cyan").Color)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-40),math.rad(0)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(5)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0.1,0.1,0)*angles(math.rad(0),math.rad(0),math.rad(40)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2),math.rad(0),math.rad(-40)),.3)
RW.C0=clerp(RW.C0,cf(1.25,0.5,-0.65)*angles(math.rad(100),math.rad(0),math.rad(-23)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(110),math.rad(0),math.rad(-85)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
end
local hitb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.Random())
hitb.Anchored = true
hitb.CFrame = root.CFrame + root.CFrame.lookVector*4
MagniDamage(hitb, 4, 40,73, 0, "Normal",153092213)
slash(5,5,true,"Round","Add","Out",hitb.CFrame*CFrame.Angles(0,math.rad(math.random(-360,360)),0),vt(0.05,0.01,0.05),0.01,BrickColor.new("White"))
CFuncs["Sound"].Create("rbxassetid://200633196", rarmor, 1, 1.05)
CFuncs["Sound"].Create("rbxassetid://200633108", rarmor, 1.5, 1.025)
CFuncs["Sound"].Create("rbxassetid://234365549", rarmor, 1, 1)
for i = 0, 2, 0.1 do
		swait()
sphere2(5,"Add",rarmor.CFrame*CFrame.new(math.random(-8,-2),0,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.1,0.1,0.1),0,0.1,0,BrickColor.new("Cyan"),BrickColor.new("Cyan").Color)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-20)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(50),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(-0.1,-0.25,0)*angles(math.rad(10),math.rad(0),math.rad(-50)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2),math.rad(0),math.rad(50)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(80),math.rad(0),math.rad(70)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(100),math.rad(0),math.rad(-50)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(0),math.rad(-40)),.3)
end
hitb:Destroy()
hum.WalkSpeed = 24
OWS = hum.WalkSpeed
	attack = false
end

function unequip()
	attack = true
	equipped = false
	hum.WalkSpeed = 0
hum.WalkSpeed = 16
OWS = hum.WalkSpeed
tl1.Enabled = false
CFuncs["Sound"].Create("rbxassetid://200633029", rarmor, 1, 1)
weaponweld.C1=clerp(weaponweld.C1,cf(-3,0,-0.5)*angles(math.rad(0),math.rad(0),math.rad(-40)),.5)
weaponweld.Part0 = tors
	attack = false
end

------------------
function attackone()
attack = true
hum.WalkSpeed = 4
for i = 0, 2, 0.1 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-40),math.rad(0)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(5)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0.1,0.1,0)*angles(math.rad(0),math.rad(0),math.rad(40)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2),math.rad(0),math.rad(-40)),.3)
RW.C0=clerp(RW.C0,cf(1.25,0.5,-0.65)*angles(math.rad(100),math.rad(0),math.rad(-23)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(110),math.rad(0),math.rad(-85)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
end
local hitb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.Random())
hitb.Anchored = true
hitb.CFrame = root.CFrame + root.CFrame.lookVector*4
MagniDamage(hitb, 4, 24,30, 0, "Normal",153092213)
CFuncs["Sound"].Create("rbxassetid://200633196", rarmor, 1, 1.05)
CFuncs["Sound"].Create("rbxassetid://200633108", rarmor, 1.5, 1.025)
CFuncs["Sound"].Create("rbxassetid://234365549", rarmor, 1, 1)
for i = 0, 1, 0.1 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-20)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(50),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(-0.1,-0.25,0)*angles(math.rad(10),math.rad(0),math.rad(-50)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2),math.rad(0),math.rad(50)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(80),math.rad(0),math.rad(70)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(100),math.rad(0),math.rad(-50)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(0),math.rad(-40)),.3)
end
hitb:Destroy()
attack = false
hum.WalkSpeed = 24
end
function attacktwo()
attack = true
hum.WalkSpeed = 4
for i = 0, 1, 0.1 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(20),math.rad(5)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(-0.1,0.1,0)*angles(math.rad(0),math.rad(0),math.rad(-40)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2),math.rad(0),math.rad(40)),.3)
RW.C0=clerp(RW.C0,cf(1.25,0.5,-0.65)*angles(math.rad(100),math.rad(0),math.rad(-23)),.3)
LW.C0=clerp(LW.C0,cf(-0.5,0.5,-0.25)*angles(math.rad(90),math.rad(0),math.rad(40)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(180),math.rad(0)),.3)
end
local hitb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.Random())
hitb.Anchored = true
hitb.CFrame = root.CFrame + root.CFrame.lookVector*4
MagniDamage(hitb, 4, 24,30, 0, "Normal",153092213)
CFuncs["Sound"].Create("rbxassetid://200633281", rarmor, 1, 1.05)
CFuncs["Sound"].Create("rbxassetid://161006195", rarmor, 1.5, 1.025)
for i = 0, 1, 0.1 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-30),math.rad(0)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(20)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0.2,-0.25,0)*angles(math.rad(10),math.rad(0),math.rad(90)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2),math.rad(0),math.rad(-90)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(80),math.rad(0),math.rad(20)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(100),math.rad(0),math.rad(-50)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(180),math.rad(70)),.3)
end
attack = false
hum.WalkSpeed = 24
end
function attackthree()
attack = true
hum.WalkSpeed = 4
for i = 0, 1, 0.1 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-30),math.rad(0)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(5)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(-0.1,0.1,0)*angles(math.rad(0),math.rad(0),math.rad(-60)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2),math.rad(0),math.rad(60)),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-30),math.rad(0),math.rad(53)),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(10),math.rad(0),math.rad(-10)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(90),math.rad(-20)),.3)
end
for x = 0, 2 do
CFuncs["Sound"].Create("rbxassetid://200633108", rarmor, 1, 1.05)
CFuncs["Sound"].Create("rbxassetid://234365573", rarmor, 1.5, 1.025)
local hitb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.Random())
hitb.Anchored = true
hitb.CFrame = root.CFrame + root.CFrame.lookVector*4
MagniDamage(hitb, 4, 12,15, 0, "Normal",153092213)
for i = 0, 1, 0.6 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-10)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(40),math.rad(20)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0.2,-0.25,0)*angles(math.rad(-2),math.rad(0),math.rad(80)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(-80)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(80)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(10),math.rad(0),math.rad(-20)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,0,0)*angles(math.rad(0),math.rad(30),math.rad(90)),.3)
end
for i = 0, 1, 0.6 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-10)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(40),math.rad(20)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0.2,-0.25,0)*angles(math.rad(-2),math.rad(0),math.rad(80)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(-80)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(80)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(10),math.rad(0),math.rad(-20)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(180)),.3)
end
for i = 0, 1, 0.6 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-10)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(40),math.rad(20)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0.2,-0.25,0)*angles(math.rad(-2),math.rad(0),math.rad(80)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(-80)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(80)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(10),math.rad(0),math.rad(-20)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,0,0)*angles(math.rad(0),math.rad(-30),math.rad(270)),.3)
end
for i = 0, 1, 0.6 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-10)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(40),math.rad(20)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0.2,-0.25,0)*angles(math.rad(-2),math.rad(0),math.rad(80)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(-80)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(80)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(10),math.rad(0),math.rad(-20)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
end
end
attack = false
hum.WalkSpeed = 24
end
------------------
function spinnyblade()
attack = true
hum.WalkSpeed = 1
hum.JumpPower = 0
CFuncs["Sound"].Create("rbxassetid://1368583274", root, 4.5, 1)
local bgui = Instance.new("BillboardGui",root)
bgui.Size = UDim2.new(25, 0, 25, 0)
local imgc = Instance.new("ImageLabel",bgui)
imgc.BackgroundTransparency = 1
imgc.ImageTransparency = 1
imgc.Size = UDim2.new(1,0,1,0)
imgc.Image = "rbxassetid://997291547"
imgc.ImageColor3 = Color3.new(0,0.5,1)
local imgc2 = imgc:Clone()
imgc2.Parent = bgui
imgc2.Position = UDim2.new(-0.5,0,-0.5,0)
imgc2.Size = UDim2.new(2,0,2,0)
imgc2.ImageColor3 = Color3.new(0.5,0,1)
for i = 0, 10, 0.1 do
		swait()
imgc.ImageTransparency = imgc.ImageTransparency - 0.01
imgc.Rotation = imgc.Rotation + 1
imgc2.ImageTransparency = imgc2.ImageTransparency - 0.01
imgc2.Rotation = imgc2.Rotation - 1
bgui.Size = bgui.Size - UDim2.new(0.25, 0, 0.25, 0)
slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-360,360)),math.rad(math.random(-10,10))),vt(0.1,0.01,0.1),math.random(25,50)/250,BrickColor.new("White"))
sphere2(5,"Add",rarmor.CFrame*CFrame.new(math.random(-8,-2),0,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.1,0.1,0.1),0,0.1,0,BrickColor.new("Cyan"),BrickColor.new("Cyan").Color)
hum.CameraOffset = vt(math.random(-10,10)/50,math.random(-10,10)/50,math.random(-10,10)/50)
sphereMK(5,math.random(4,25)/45,"Add",root.CFrame*CFrame.new(math.random(-15,15),-20,math.random(-15,15))*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),0.75,0.75,20,-0.0075,BrickColor.new("Royal purple"),BrickColor.new("Royal purple").Color,0)
sphereMK(5,math.random(1,15)/45,"Add",root.CFrame*CFrame.new(math.random(-15,15),-20,math.random(-15,15))*CFrame.Angles(math.rad(90 + math.random(-25,25)),math.rad(math.random(-25,25)),math.rad(math.random(-25,25))),0.75,0.75,20,-0.0075,BrickColor.new("Cyan"),BrickColor.new("Cyan").Color,0)
waveEff(5,"Add","In",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(0,math.rad(math.random(-360,360)),0),vt(15,0.25,15),-0.075,0.05,BrickColor.new("White"))
	RH.C0=clerp(RH.C0,cf(1,-0.5,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-40),math.rad(10)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(20)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0.1,0.2,-0.3)*angles(math.rad(10),math.rad(0),math.rad(50)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5),math.rad(0),math.rad(-50)),.3)
RW.C0=clerp(RW.C0,cf(1.25,0.5,-0.65)*angles(math.rad(100),math.rad(0),math.rad(-23)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(110),math.rad(0),math.rad(-85)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
end
imgc.ImageTransparency = 1
hum.CameraOffset = vt(0,0,0)
waveEff(2,"Add","Out",root.CFrame*CFrame.new(0,0,0)*CFrame.Angles(math.rad(90),math.rad(math.random(-360,360)),0),vt(6,10,6),0.5,0.8,BrickColor.new("White"))
waveEff(3,"Add","Out",root.CFrame*CFrame.new(0,0,0)*CFrame.Angles(math.rad(90),math.rad(math.random(-360,360)),0),vt(6,10,6),0.5,0.4,BrickColor.new("White"))
waveEff(4,"Add","Out",root.CFrame*CFrame.new(0,0,0)*CFrame.Angles(math.rad(90),math.rad(math.random(-360,360)),0),vt(6,10,6),0.5,0.2,BrickColor.new("White"))
waveEff(5,"Add","Out",root.CFrame*CFrame.new(0,0,0)*CFrame.Angles(math.rad(90),math.rad(math.random(-360,360)),0),vt(6,10,6),0.5,0.1,BrickColor.new("White"))
waveEff(6,"Add","Out",root.CFrame*CFrame.new(0,0,0)*CFrame.Angles(math.rad(90),math.rad(math.random(-360,360)),0),vt(6,10,6),0.5,0.05,BrickColor.new("White"))
for i = 0, 9 do
slash(math.random(10,25)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,0,math.random(-30,15))*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-360,360)),math.rad(math.random(-10,10))),vt(0.1,0.01,0.1),math.random(75,250)/250,BrickColor.new("White"))
end
CFuncs["Sound"].Create("rbxassetid://430315987", root, 1.5, 1)
CFuncs["Sound"].Create("rbxassetid://1295446488", root, 3, 1)
for x = 0, 14 do
CFuncs["Sound"].Create("rbxassetid://200633281", rarmor, 1, 1.05)
CFuncs["Sound"].Create("rbxassetid://161006195", rarmor, 1.5, 1.025)
MagniDamage(tors, 10, 60,85, 0, "Normal",153092213)
CFuncs["Sound"].Create("rbxassetid://200632992", rarmor, 1.25, 1)
slash(5,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,3,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.05,0.01,0.05),math.random(1,10)/100,BrickColor.new("White"))
for i = 0, 1, 0.6 do
		swait()
sphereMK(2,-1,"Add",root.CFrame*CFrame.new(math.random(-8,8),math.random(-8,8),math.random(-3,8))*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.5,0.5,math.random(5,25),-0.0075,BrickColor.new("Cyan"),BrickColor.new("Cyan").Color,0)
root.CFrame = root.CFrame + root.CFrame.lookVector*2
root.Velocity = vt(0,0,0)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,3)*angles(math.rad(0),math.rad(0),math.rad(90)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(-60)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(90)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-90)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,0,0)*angles(math.rad(90),math.rad(0),math.rad(-90)),.3)
end
slash(5,2.5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,3,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.05,0.01,0.05),math.random(1,10)/100,BrickColor.new("White"))
CFuncs["Sound"].Create("rbxassetid://200632992", rarmor, 1.25, 1)
MagniDamage(tors, 10, 60,85, 0, "Normal",153092213)
for i = 0, 1, 0.6 do
		swait()
sphereMK(2,-1,"Add",root.CFrame*CFrame.new(math.random(-8,8),math.random(-8,8),math.random(-3,8))*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.5,0.5,math.random(5,25),-0.0075,BrickColor.new("Royal purple"),BrickColor.new("Royal purple").Color,0)
root.CFrame = root.CFrame + root.CFrame.lookVector*3
root.Velocity = vt(0,0,0)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,3)*angles(math.rad(90),math.rad(0),math.rad(90)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(-60)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(90)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-90)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,0,0)*angles(math.rad(90),math.rad(0),math.rad(-90)),.3)
end
slash(5,2.5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,3,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.05,0.01,0.05),math.random(1,10)/100,BrickColor.new("White"))
CFuncs["Sound"].Create("rbxassetid://200632992", rarmor, 1.25, 1)
MagniDamage(tors, 10, 60,85, 0, "Normal",153092213)
for i = 0, 1, 0.6 do
		swait()
sphereMK(2,-1,"Add",root.CFrame*CFrame.new(math.random(-8,8),math.random(-8,8),math.random(-3,8))*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.5,0.5,math.random(5,25),-0.0075,BrickColor.new("Cyan"),BrickColor.new("Cyan").Color,0)
root.CFrame = root.CFrame + root.CFrame.lookVector*3
root.Velocity = vt(0,0,0)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,3)*angles(math.rad(180),math.rad(0),math.rad(90)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(-60)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(90)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-90)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,0,0)*angles(math.rad(90),math.rad(0),math.rad(-90)),.3)
end
slash(5,2.5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,3,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.05,0.01,0.05),math.random(1,10)/100,BrickColor.new("White"))
CFuncs["Sound"].Create("rbxassetid://200632992", rarmor, 1.25, 1)
MagniDamage(tors, 10, 60,85, 0, "Normal",153092213)
for i = 0, 1, 0.6 do
		swait()
sphereMK(2,-1,"Add",root.CFrame*CFrame.new(math.random(-8,8),math.random(-8,8),math.random(-3,8))*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.5,0.5,math.random(5,25),-0.0075,BrickColor.new("Royal purple"),BrickColor.new("Royal purple").Color,0)
root.CFrame = root.CFrame + root.CFrame.lookVector*3
root.Velocity = vt(0,0,0)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,3)*angles(math.rad(270),math.rad(0),math.rad(90)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(-60)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(90)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-90)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,0,0)*angles(math.rad(90),math.rad(0),math.rad(-90)),.3)
end
end
hum.WalkSpeed = 0
for i = 0, 5, 0.1 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-20)),.2)
LH.C0=clerp(LH.C0,cf(-1,-0.6,-0.5)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(20),math.rad(-12)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0.1,0.2,-0.35)*angles(math.rad(10),math.rad(0),math.rad(-40)),.2)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5),math.rad(0),math.rad(40)),.2)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0)*angles(math.rad(90),math.rad(0),math.rad(110)),.2)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0)*angles(math.rad(45),math.rad(0),math.rad(-20)),.2)
weaponweld.C1=clerp(weaponweld.C1,cf(2,0,0)*angles(math.rad(90),math.rad(0),math.rad(-90)),.2)
end
bgui:Destroy()
attack = false
hum.WalkSpeed = 24
hum.JumpPower = 50
end

function eightbitmegablade()
attack = true
hum.WalkSpeed = 0
hum.JumpPower = 0
CFuncs["Sound"].Create("rbxassetid://1368583274", larm, 4.5, 1.2)
local OverCut = false
cam.CameraSubject = Humanoid
cam.CameraType = "Scriptable"
coroutine.resume(coroutine.create(function()
while true do
swait()
if OverCut == false then
cam.CFrame = lerp(cam.CFrame, root.CFrame * cf(1, 1.5, -6) * ceuler(math.rad(10), math.rad(170), math.rad(-20)), 0.1)
else
break
end
end
end))
for i = 0, 10, 0.1 do
swait()
slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,50)/250,BrickColor.new("White"))
sphere2(5,"Add",larm.CFrame*CFrame.new(0,-1.5,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.1,-0.01,BrickColor.new("Cyan"),BrickColor.new("Cyan").Color)
slash(math.random(20,40)/10,5,true,"Round","Add","Out",larm.CFrame*CFrame.new(0,-1.5,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.025,0.001,0.025),-0.025,BrickColor.new("White"))
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-6),math.rad(0),math.rad(-6)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(30),math.rad(3)),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(-50)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-15),math.rad(5),math.rad(50)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(-13),math.rad(-40),math.rad(20)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(170),math.rad(10),math.rad(0)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(130),math.rad(0)),.3)
end
OverCut = true
local orb = Instance.new("Part", char)
orb.Anchored = true
orb.BrickColor = BrickColor.new("Toothpaste")
orb.CanCollide = false
orb.FormFactor = 3
orb.Name = "Ring"
orb.Material = "Neon"
orb.Size = Vector3.new(1, 1, 1)
orb.Transparency = 0.5
orb.TopSurface = 0
orb.BottomSurface = 0
local orbm = Instance.new("SpecialMesh", orb)
orbm.MeshType = "FileMesh"
orbm.MeshId = "rbxassetid://361629844"
orbm.Scale = vt(30,60,60)
orb.CFrame = root.CFrame*CFrame.new(0,50,0)
for i = 0, 24 do
slash(math.random(10,30)/10,5,true,"Round","Add","Out",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.1,0.001,0.1),math.random(50,400)/420,BrickColor.new("White"))
end
sphere2(2,"Add",orb.CFrame,vt(10,10,10),0.5,0.5,0.5,BrickColor.new("Cyan"),BrickColor.new("Cyan").Color)
sphere2(3,"Add",orb.CFrame,vt(10,10,10),0.75,0.75,0.75,BrickColor.new("Cyan"),BrickColor.new("Cyan").Color)
sphere2(4,"Add",orb.CFrame,vt(10,10,10),1,1,1,BrickColor.new("Cyan"),BrickColor.new("Cyan").Color)
CFuncs["Sound"].Create("rbxassetid://1368637781", orb, 7.5, 1)
local a = Instance.new("Part",workspace)
a.Name = "Direction"	
a.Anchored = true
a.Transparency = 1
a.CanCollide = false
local ray = Ray.new(
orb.CFrame.p,                           -- origin
(mouse.Hit.p - orb.CFrame.p).unit * 500 -- direction
) 
local ignore = orb
local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
a.BottomSurface = 10
a.TopSurface = 10
local distance = (orb.CFrame.p - position).magnitude
a.Size = Vector3.new(0.1, 0.1, 0.1)
a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, 0)
orb.CFrame = a.CFrame
for i = 0, 8, 0.1 do
swait()
sphere2(5,"Add",orb.CFrame*CFrame.new(math.random(-20,20),math.random(-20,20),math.random(-20,20)),vt(1,1,1),0.01,0.01,0.01,BrickColor.new("Royal purple"),BrickColor.new("Royal purple").Color)
ray = Ray.new(
orb.CFrame.p,                           -- origin
(mouse.Hit.p - orb.CFrame.p).unit * 500 -- direction
) 
hit, position, normal = workspace:FindPartOnRay(ray, ignore)
distance = (orb.CFrame.p - position).magnitude
a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, 0)
orb.CFrame = a.CFrame
slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,50)/250,BrickColor.new("White"))
cam.CFrame = lerp(cam.CFrame, root.CFrame * cf(20, 65, 55) * ceuler(math.rad(-20), math.rad(0), math.rad(10)), 0.2)
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-6),math.rad(0),math.rad(-6)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(40),math.rad(3)),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(-90)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5),math.rad(0),math.rad(90)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(-13),math.rad(-20),math.rad(20)),.3)
LW.C0=clerp(LW.C0,cf(-1.25,0.5,-0.5)*angles(math.rad(100),math.rad(0),math.rad(60)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(130),math.rad(0)),.3)
end
cam.CameraType = "Custom"
orb.Anchored = false
a:Destroy()
local bv = Instance.new("BodyVelocity")
bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
bv.velocity = orb.CFrame.lookVector*250
bv.Parent = orb
local hitted = false
CFuncs["Sound"].Create("rbxassetid://466493476", orb, 7.5, 0.7)
waveEff(2,"Add","Out",orb.CFrame*CFrame.Angles(math.rad(90),math.rad(math.random(-360,360)),0),vt(5,1,5),0.5,0.1,BrickColor.new("Cyan"))
waveEff(4,"Add","Out",orb.CFrame*CFrame.Angles(math.rad(90),math.rad(math.random(-360,360)),0),vt(5,1,5),0.5,0.05,BrickColor.new("Royal purple"))
coroutine.resume(coroutine.create(function()
while true do
swait(2)
if hitted == false and orb.Parent ~= nil then
slash(3,5,true,"Round","Add","Out",orb.CFrame*CFrame.Angles(math.rad(90),math.rad(math.random(-360,360)),0),vt(0.075,0.005,0.075),-0.05,BrickColor.new("White"))
elseif hitted == true and orb.Parent == nil then
break
end
end
end))
orb.Touched:connect(function(hit) 
if hitted == false and hit.Parent ~= char then
hitted = true
MagniDamage(orb, 30, 72,95, 0, "Normal",153092213)
CFuncs["Sound"].Create("rbxassetid://763717897", orb, 10, 1)
CFuncs["Sound"].Create("rbxassetid://1295446488", orb, 9, 0.75)
for i = 0, 24 do
slash(math.random(15,30)/10,5,true,"Round","Add","Out",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.001,0.01),math.random(125,250)/400,BrickColor.new("White"))
end
slash(1,5,true,"Round","Add","Out",orb.CFrame*CFrame.Angles(math.rad(90),math.rad(math.random(-360,360)),0),vt(0.01,0.015,0.01),1.5,BrickColor.new("White"))
slash(1,5,true,"Round","Add","Out",orb.CFrame*CFrame.Angles(math.rad(90),math.rad(math.random(-360,360)),0),vt(0.01,0.01,0.01),2,BrickColor.new("White"))
sphere2(1,"Add",orb.CFrame,vt(10,10,10),1,1,1,BrickColor.new("Cyan"),BrickColor.new("Cyan").Color)
sphere2(1.5,"Add",orb.CFrame,vt(10,10,10),1.1,1.1,1.1,BrickColor.new("Royal purple"),BrickColor.new("Royal purple").Color)
sphere2(2,"Add",orb.CFrame,vt(10,10,10),1.2,1.2,1.2,BrickColor.new("Royal purple"),BrickColor.new("Royal purple").Color)
orb.Anchored = true
orb.Transparency = 1
coroutine.resume(coroutine.create(function()
for i = 0, 4, 0.1 do
swait()
slash(math.random(10,50)/10,5,true,"Round","Add","Out",orb.CFrame*CFrame.Angles(math.rad(90 + math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.015,0.01),1.5,BrickColor.new("Royal purple"))
hum.CameraOffset = vt(math.random(-10,10)/25,math.random(-10,10)/25,math.random(-10,10)/25)
end
hum.CameraOffset = vt(0,0,0)
end))
wait(10)
orb:Destroy()
end
end)
game:GetService("Debris"):AddItem(orb, 10)
for i = 0, 2, 0.1 do
swait()
slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,50)/250,BrickColor.new("White"))
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-6),math.rad(0),math.rad(-6)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(30),math.rad(3)),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.4,0)*angles(math.rad(0),math.rad(0),math.rad(-70)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5),math.rad(0),math.rad(70)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(-13),math.rad(-40),math.rad(20)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-80)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(130),math.rad(0)),.3)
end
attack = false
hum.WalkSpeed = 24
hum.JumpPower = 50
end

function bladespinagain()
attack = true
hum.WalkSpeed = 4
hum.JumpPower = 0
CFuncs["Sound"].Create("rbxassetid://1368598393", rarmor, 2, 1)
CFuncs["Sound"].Create("rbxassetid://1368583274", rarmor, 2.5, 1)
for x = 0, 9 do
slash(5,5,true,"Round","Add","Out",rarmor.CFrame*CFrame.new(0,0,0)*CFrame.Angles(0,0,0),vt(0.05,0.01,0.05),0.05,BrickColor.new("White"))
CFuncs["Sound"].Create("rbxassetid://200633108", rarmor, 2, 1.05)
CFuncs["Sound"].Create("rbxassetid://234365573", rarmor, 2.5, 1.025)
for i = 0, 1, 0.6 do
		swait()
sphereMK(5,math.random(4,25)/45,"Add",root.CFrame*CFrame.new(math.random(-15,15),-20,math.random(-15,15))*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),0.75,0.75,20,-0.0075,BrickColor.new("Royal purple"),BrickColor.new("Royal purple").Color,0)
sphereMK(5,math.random(1,15)/45,"Add",root.CFrame*CFrame.new(math.random(-15,15),-20,math.random(-15,15))*CFrame.Angles(math.rad(90 + math.random(-25,25)),math.rad(math.random(-25,25)),math.rad(math.random(-25,25))),0.75,0.75,20,-0.0075,BrickColor.new("Cyan"),BrickColor.new("Cyan").Color,0)
slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,50)/250,BrickColor.new("White"))
sphere2(5,"Add",rarmor.CFrame*CFrame.new(math.random(-8,-2),0,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.1,0.1,0.1),0,0.1,0,BrickColor.new("Cyan"),BrickColor.new("Cyan").Color)
hum.CameraOffset = vt(math.random(-10,10)/100,math.random(-10,10)/100,math.random(-10,10)/100)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-10)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(30),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,0)*angles(math.rad(0),math.rad(0),math.rad(-60)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(60)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(80)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-60)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
end
slash(5,5,true,"Round","Add","Out",rarmor.CFrame*CFrame.new(0,0,0)*CFrame.Angles(0,0,0),vt(0.05,0.01,0.05),0.05,BrickColor.new("White"))
for i = 0, 1, 0.6 do
		swait()
sphereMK(5,math.random(4,25)/45,"Add",root.CFrame*CFrame.new(math.random(-15,15),-20,math.random(-15,15))*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),0.75,0.75,20,-0.0075,BrickColor.new("Royal purple"),BrickColor.new("Royal purple").Color,0)
sphereMK(5,math.random(1,15)/45,"Add",root.CFrame*CFrame.new(math.random(-15,15),-20,math.random(-15,15))*CFrame.Angles(math.rad(90 + math.random(-25,25)),math.rad(math.random(-25,25)),math.rad(math.random(-25,25))),0.75,0.75,20,-0.0075,BrickColor.new("Cyan"),BrickColor.new("Cyan").Color,0)
slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,50)/250,BrickColor.new("White"))
sphere2(5,"Add",rarmor.CFrame*CFrame.new(math.random(-8,-2),0,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.1,0.1,0.1),0,0.1,0,BrickColor.new("Cyan"),BrickColor.new("Cyan").Color)
hum.CameraOffset = vt(math.random(-10,10)/100,math.random(-10,10)/100,math.random(-10,10)/100)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-10)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(30),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,0)*angles(math.rad(0),math.rad(0),math.rad(-60)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(60)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(80)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-60)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(90),math.rad(0)),.3)
end
slash(5,5,true,"Round","Add","Out",rarmor.CFrame*CFrame.new(0,0,0)*CFrame.Angles(0,0,0),vt(0.05,0.01,0.05),0.05,BrickColor.new("White"))
for i = 0, 1, 0.6 do
		swait()
sphereMK(5,math.random(4,25)/45,"Add",root.CFrame*CFrame.new(math.random(-15,15),-20,math.random(-15,15))*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),0.75,0.75,20,-0.0075,BrickColor.new("Royal purple"),BrickColor.new("Royal purple").Color,0)
sphereMK(5,math.random(1,15)/45,"Add",root.CFrame*CFrame.new(math.random(-15,15),-20,math.random(-15,15))*CFrame.Angles(math.rad(90 + math.random(-25,25)),math.rad(math.random(-25,25)),math.rad(math.random(-25,25))),0.75,0.75,20,-0.0075,BrickColor.new("Cyan"),BrickColor.new("Cyan").Color,0)
slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,50)/250,BrickColor.new("White"))
sphere2(5,"Add",rarmor.CFrame*CFrame.new(math.random(-8,-2),0,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.1,0.1,0.1),0,0.1,0,BrickColor.new("Cyan"),BrickColor.new("Cyan").Color)
hum.CameraOffset = vt(math.random(-10,10)/100,math.random(-10,10)/100,math.random(-10,10)/100)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-10)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(30),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,0)*angles(math.rad(0),math.rad(0),math.rad(-60)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(60)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(80)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-60)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(180),math.rad(0)),.3)
end
slash(5,5,true,"Round","Add","Out",rarmor.CFrame*CFrame.new(0,0,0)*CFrame.Angles(0,0,0),vt(0.05,0.01,0.05),0.05,BrickColor.new("White"))
for i = 0, 1, 0.6 do
		swait()
sphereMK(5,math.random(4,25)/45,"Add",root.CFrame*CFrame.new(math.random(-15,15),-20,math.random(-15,15))*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),0.75,0.75,20,-0.0075,BrickColor.new("Royal purple"),BrickColor.new("Royal purple").Color,0)
sphereMK(5,math.random(1,15)/45,"Add",root.CFrame*CFrame.new(math.random(-15,15),-20,math.random(-15,15))*CFrame.Angles(math.rad(90 + math.random(-25,25)),math.rad(math.random(-25,25)),math.rad(math.random(-25,25))),0.75,0.75,20,-0.0075,BrickColor.new("Cyan"),BrickColor.new("Cyan").Color,0)
slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,50)/250,BrickColor.new("White"))
sphere2(5,"Add",rarmor.CFrame*CFrame.new(math.random(-8,-2),0,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.1,0.1,0.1),0,0.1,0,BrickColor.new("Cyan"),BrickColor.new("Cyan").Color)
hum.CameraOffset = vt(math.random(-10,10)/100,math.random(-10,10)/100,math.random(-10,10)/100)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-10)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(30),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,0)*angles(math.rad(0),math.rad(0),math.rad(-60)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(60)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(80)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-60)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(270),math.rad(0)),.3)
end
end
local hitb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.Random())
hitb.Anchored = true
hitb.CFrame = root.CFrame + root.CFrame.lookVector*8
hitb.CFrame = hitb.CFrame*CFrame.new(0,1,0)
MagniDamage(hitb, 8, 92,158, 0, "Normal",153092213)
sphere2(5,"Add",hitb.CFrame,vt(2.1,2.1,2),-0.02,-0.02,5,BrickColor.new("Royal purple"),BrickColor.new("Royal purple").Color)
sphere2(5,"Add",hitb.CFrame,vt(2,2,2),-0.02,-0.02,4,BrickColor.new("Cyan"),BrickColor.new("Cyan").Color)
for i = 0, 24 do
slash(math.random(20,100)/10,5,true,"Round","Add","Out",hitb.CFrame*CFrame.new(0,0,math.random(-60,60))*CFrame.Angles(math.rad(90),0,0),vt(0.01,0.01,0.01),math.random(10,100)/1000,BrickColor.new("White"))
end
CFuncs["Sound"].Create("rbxassetid://313205954", root, 4,1)
CFuncs["Sound"].Create("rbxassetid://1368637781", rarmor, 4,1)
CFuncs["Sound"].Create("rbxassetid://763718160", rarmor, 5, 1.1)
CFuncs["Sound"].Create("rbxassetid://782353443", rarmor, 6, 1)
--CFuncs["Sound"].Create("rbxassetid://1548538202", rarmor, 4,1)
for i = 0, 2, 0.1 do
		swait()
MagniDamage(hitb, 8, 92,158, 0, "Normal",153092213)
hum.CameraOffset = vt(math.random(-10,10)/25,math.random(-10,10)/25,math.random(-10,10)/25)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-20),math.rad(-10)),.9)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.9)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.5,0)*angles(math.rad(0),math.rad(0),math.rad(80)),.9)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(-80)),.9)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(70)),.9)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(10),math.rad(0),math.rad(-60)),.9)
weaponweld.C1=clerp(weaponweld.C1,cf(2,0,0)*angles(math.rad(90),math.rad(0),math.rad(-90)),.9)
end
hum.CameraOffset = vt(0,0,0)
hitb:Destroy()
attack = false
hum.WalkSpeed = 24
hum.JumpPower = 50
end

function superjump()
attack = true
hum.WalkSpeed = 0
hum.JumpPower = 0
wng1a.Transparency = wng1a.Transparency - 1
wng1b.Transparency = wng1b.Transparency - 1
wng2a.Transparency = wng2a.Transparency - 1
wng2b.Transparency = wng2b.Transparency - 1
sphere2(5,"Add",root.CFrame,vt(1,1,1),1.5,1.5,1.5,BrickColor.new("Royal purple"),BrickColor.new("Royal purple").Color)
sphere2(5,"Add",root.CFrame,vt(1,1,1),1,1,1,BrickColor.new("Cyan"),BrickColor.new("Cyan").Color)
CFuncs["Sound"].Create("rbxassetid://1368637781", root, 7.5, 1)
for i = 0, 2, 0.1 do
		swait()
hum.CameraOffset = vt(math.random(-10,10)/100,math.random(-10,10)/100,math.random(-10,10)/100)
root.Velocity = vt(0,0,0)
slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,250)/250,BrickColor.new("White"))
	RH.C0=clerp(RH.C0,cf(1,-0.45,-0.45)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(20)),.4)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(40)),.4)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.5,-1)*angles(math.rad(20),math.rad(0),math.rad(0)),.4)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(0)),.4)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(10),math.rad(0),math.rad(40)),.4)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(10),math.rad(0),math.rad(-40)),.4)
end
CFuncs["Sound"].Create("rbxassetid://477843807", root, 7, 1.05)
local lat1 = Instance.new("Attachment",larm)
lat1.Position = Vector3.new(1,-1,0.5)
local lat2 = Instance.new("Attachment",larm)
lat2.Position = Vector3.new(-1,-1,-0.5)
local rat1 = Instance.new("Attachment",rarm)
rat1.Position = Vector3.new(1,-1,-0.5)
local rat2 = Instance.new("Attachment",rarm)
rat2.Position = Vector3.new(-1,-1,0.5)
local tl1 = Instance.new('Trail',larm)
tl1.Attachment0 = lat1
tl1.Attachment1 = lat2
tl1.Texture = "http://www.roblox.com/asset/?id=1049219073"
tl1.LightEmission = 1
tl1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1),NumberSequenceKeypoint.new(0.05, 0),NumberSequenceKeypoint.new(1, 1)})
tl1.Color = ColorSequence.new(BrickColor.new('Royal purple').Color,BrickColor.new('Cyan').Color)
tl1.Lifetime = 5
local tl2 = tl1:Clone()
tl2.Attachment0 = rat1
tl2.Attachment1 = rat2
tl2.Parent = rarm
hum.JumpPower = 50
hum.Jump = true
swait()
hum.JumpPower = 0
root.Velocity = vt(0,250,0) + root.CFrame.lookVector*250
sphere2(5,"Add",root.CFrame*CFrame.Angles(math.rad(-45),0,0),vt(25,1,25),0.3,5,0.3,BrickColor.new("Royal purple"),BrickColor.new("Royal purple").Color)
sphere2(5,"Add",root.CFrame*CFrame.Angles(math.rad(-45),0,0),vt(25,1,25),0.2,4,0.2,BrickColor.new("Cyan"),BrickColor.new("Cyan").Color)
for i = 0, 49 do
waveEff(math.random(10,100)/10,"Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(0,math.rad(math.random(-360,360)),0),vt(15,0.25,15),math.random(25,250)/250,0.25,BrickColor.new("White"))
slash(math.random(10,100)/10,3,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-360,360)),math.rad(math.random(-10,10))),vt(0.01,0.01,0.01),math.random(50,500)/250,BrickColor.new("White"))
end
coroutine.resume(coroutine.create(function()
for i = 0, 2, 0.1 do
swait()
hum.CameraOffset = vt(math.random(-10,10)/50,math.random(-10,10)/50,math.random(-10,10)/50)
end
hum.CameraOffset = vt(0,0,0)
wait(3)
tl1.Enabled = false
tl2.Enabled = false
game:GetService("Debris"):AddItem(tl1, 5)
game:GetService("Debris"):AddItem(tl2, 5)
game:GetService("Debris"):AddItem(rat1, 5)
game:GetService("Debris"):AddItem(rat2, 5)
game:GetService("Debris"):AddItem(lat1, 5)
game:GetService("Debris"):AddItem(lat2, 5)
end))
CFuncs["Sound"].Create("rbxassetid://1295446488", root, 10, 1)
for i = 0, 3, 0.1 do
		swait()
RH.C0=clerp(RH.C0,cf(1,-0.45,-0.45)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-20)),.4)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(30)),.4)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.75,0)*angles(math.rad(40),math.rad(0),math.rad(0)),.4)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-20),math.rad(0),math.rad(0)),.4)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(-30),math.rad(0),math.rad(20)),.4)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(-30),math.rad(0),math.rad(-20)),.4)
end
coroutine.resume(coroutine.create(function()
for i = 0, 99 do
swait()
wng1a.Transparency = wng1a.Transparency + 0.01
wng1b.Transparency = wng1b.Transparency + 0.01
wng2a.Transparency = wng2a.Transparency + 0.01
wng2b.Transparency = wng2b.Transparency + 0.01
end
end))
attack = false
if equipped == false then
hum.WalkSpeed = 16
else
hum.WalkSpeed = 24
end
hum.JumpPower = 50
end
------------------


local attacktype = 1
mouse.Button1Down:connect(function()
if equipped == true then
  if attack == false and attacktype == 1 then
    attacktype = 2
    attackone()
  elseif attack == false and attacktype == 2 then
    attacktype = 3
    attacktwo()
  elseif attack == false and attacktype == 3 then
    attacktype = 1
    attackthree()
  --[[elseif attack == false and attacktype == 4 then
    attacktype = 1
    --attackfour()]]--
  end
end
end)
mouse.KeyDown:connect(function(k)
if k == "f" and attack == false and equipped == false then
	equip()
elseif k == "f" and attack == false and equipped == true then
   unequip()
end
if k == "r" and attack == false then
superjump()
end
if equipped == true then
if k == "z" and attack == false then
spinnyblade()
end
if k == "x" and attack == false then
eightbitmegablade()
end
if k == "c" and attack == false then
bladespinagain()
end
end
if k == "l" and muter == false then
muter = true
kan.Volume = 0
elseif k == "l" and muter == true then
muter = false
kan.Volume = 1.25
end
end)
plr.Chatted:connect(function(message)
if message:sub(1,3) == "id/" then
ORGID = message:sub(4)
kan.TimePosition = 0
kan:Play()
elseif message:sub(1,6) == "pitch/" then
ORPIT = message:sub(7)
elseif message:sub(1,4) == "vol/" then
ORVOL = message:sub(5)
elseif message:sub(1,7) == "skipto/" then
kan.TimePosition = message:sub(8)
end
end)

idleanim=.4
while true do
swait()
if muter == false then
kan.Volume = ORVOL
else
kan.Volume = 0
end
kan.PlaybackSpeed = ORPIT
kan.Pitch = ORPIT
kan.SoundId = "rbxassetid://" ..ORGID
kan.Looped = true
kan.Parent = plr.PlayerGui
kan:Resume()
techc.Rotation = techc.Rotation + 0.1
imgl2.Rotation = imgl2.Rotation - kan.PlaybackLoudness/50
imgl2.ImageColor3 = Color3.new(0.15 + kan.PlaybackLoudness/2500,0,0.6 + kan.PlaybackLoudness/1000)
imgl2b.Rotation = imgl2b.Rotation + kan.PlaybackLoudness/25
imgl2b.ImageColor3 = Color3.new(0,0.3 + kan.PlaybackLoudness/1500,0.6 + kan.PlaybackLoudness/1000)
ned.Rotation = 0 - 2 * math.cos(sine / 24)
ned.Position = UDim2.new(0.6,0 - 10 * math.cos(sine / 32),0.8,0 - 10 * math.cos(sine / 45))
  sine = sine + change
local torvel=(RootPart.Velocity*Vector3.new(1,0,1)).magnitude 
local velderp=RootPart.Velocity.y
hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
if equipped==true or equipped==false then
if attack==false then
idle=idle+1
else
idle=0
end
if idle>=500 then
if attack==false then
--Sheath()
end
end
if RootPart.Velocity.y > 1 and hitfloor==nil then 
Anim="Jump"
if attack==false then
RH.C0=clerp(RH.C0,cf(1,-0.35 - 0.05 * math.cos(sine / 25),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-20)),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(20)),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 25))*angles(math.rad(-tors.Velocity.Y/6),math.rad(0),math.rad(0)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.1)
RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-5),math.rad(0),math.rad(25)),.1)
LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-5),math.rad(0),math.rad(-25)),.1)
if equipped == false then
weaponweld.C1=clerp(weaponweld.C1,cf(-3,0,-0.5)*angles(math.rad(0),math.rad(0),math.rad(-40)),.3)
else
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(130),math.rad(0)),.3)
end
end
elseif RootPart.Velocity.y < -1 and hitfloor==nil then 
Anim="Fall"
if attack==false then
RH.C0=clerp(RH.C0,cf(1,-0.35 - 0.05 * math.cos(sine / 25),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-20)),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(20)),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 25))*angles(math.rad(-tors.Velocity.Y/6),math.rad(0),math.rad(0)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2.5),math.rad(0),math.rad(0)),.1)
RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-15),math.rad(0),math.rad(55)),.1)
LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-15),math.rad(0),math.rad(-55)),.1)
if equipped == false then
weaponweld.C1=clerp(weaponweld.C1,cf(-3,0,-0.5)*angles(math.rad(0),math.rad(0),math.rad(-40)),.3)
else
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(130),math.rad(0)),.3)
end
end
elseif torvel<1 and hitfloor~=nil then
Anim="Idle"
if attack==false then
if equipped == false then
RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 20)  - 0.02 * math.cos(sine / 40),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3 + 2 * math.cos(sine / 40)),math.rad(-15),math.rad(0 + 2 * math.cos(sine / 20))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 20) - 0.02 * math.cos(sine / 40),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 - 2 * math.cos(sine / 40)),math.rad(1),math.rad(0 - 2 * math.cos(sine / 20))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.02 * math.cos(sine / 40),0 - 0.02 * math.cos(sine / 40),-0.05 - 0.05 * math.cos(sine / 20))*angles(math.rad(0 + 2 * math.cos(sine / 20)),math.rad(0 + 2 * math.cos(sine / 40)),math.rad(30 + 3 * math.cos(sine / 40))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2),math.rad(0 - 7 * math.cos(sine / 40)),math.rad(-30 - 3 * math.cos(sine / 40))),.1)
RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.05 * math.cos(sine / 28),0.1)*angles(math.rad(-6 + 5 * math.cos(sine / 26)),math.rad(-10 - 6 * math.cos(sine / 24)),math.rad(13 - 5 * math.cos(sine / 34))),.1)
LW.C0=clerp(LW.C0,cf(-1.4,0.5 + 0.05 * math.cos(sine / 28),0.1)*angles(math.rad(-13 - 1 * math.cos(sine / 25)),math.rad(10 + 2 * math.cos(sine / 24)),math.rad(10 + 2 * math.cos(sine / 34))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(-3,0,-0.5)*angles(math.rad(0),math.rad(0),math.rad(-40)),.3)
else
RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 20)  - 0.02 * math.cos(sine / 40),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3 + 2 * math.cos(sine / 40)),math.rad(0 - 6 * math.cos(sine / 40)),math.rad(-6 + 2 * math.cos(sine / 20) - 6 * math.cos(sine / 40))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 20) - 0.02 * math.cos(sine / 40),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 - 2 * math.cos(sine / 40)),math.rad(10 - 6 * math.cos(sine / 40)),math.rad(3 - 2 * math.cos(sine / 20) - 3 * math.cos(sine / 40))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.02 * math.cos(sine / 40),0 - 0.06 * math.cos(sine / 40),-0.05 - 0.05 * math.cos(sine / 20))*angles(math.rad(0 + 2 * math.cos(sine / 20)),math.rad(0 + 2 * math.cos(sine / 40)),math.rad(-20 + 6 * math.cos(sine / 40))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(6),math.rad(0 - 2 * math.cos(sine / 42)),math.rad(20 - 6 * math.cos(sine / 40))),.1)
RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.05 * math.cos(sine / 28),0.1)*angles(math.rad(-13 + 3 * math.cos(sine / 26)),math.rad(-20 - 3 * math.cos(sine / 24)),math.rad(20 - 5 * math.cos(sine / 34))),.1)
LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.05 * math.cos(sine / 28),0.1)*angles(math.rad(-13 - 3 * math.cos(sine / 25)),math.rad(10 + 3 * math.cos(sine / 24)),math.rad(-10 + 5 * math.cos(sine / 34))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(130),math.rad(0)),.3)
end
end
elseif torvel>2 and torvel<42 and hitfloor~=nil then
Anim="Walk"
if attack==false then
if equipped == false then
RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 45 * math.cos(sine / 8))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 45 * math.cos(sine / 8))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.05,-0.05 + 0.05 * math.cos(sine / 4))*angles(math.rad(5 + 3 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - root.RotVelocity.Y - 10 * math.cos(sine / 8))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-5 - 5 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - hed.RotVelocity.Y*1.5 + 10 * math.cos(sine / 8))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0 + 0.25 * math.cos(sine / 8))*angles(math.rad(0 - 50 * math.cos(sine / 8)),math.rad(0),math.rad(5 - 10 * math.cos(sine / 4))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0 - 0.25 * math.cos(sine / 8))*angles(math.rad(0 + 50 * math.cos(sine / 8)),math.rad(0),math.rad(-5 + 10 * math.cos(sine / 4))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(-3,0,-0.5)*angles(math.rad(0),math.rad(0),math.rad(-40)),.3)
else
RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 60 * math.cos(sine / 8))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 60 * math.cos(sine / 8))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.05,0 + 0.15 * math.cos(sine / 4))*angles(math.rad(10 - 3 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(-10 - root.RotVelocity.Y - 5 * math.cos(sine / 8))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5 + 3 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5 + 3 * math.cos(sine / 57)),math.rad(10 - hed.RotVelocity.Y*1.5 + 5 * math.cos(sine / 8))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0 + 0.25 * math.cos(sine / 8))*angles(math.rad(-10),math.rad(0),math.rad(15 - 2 * math.cos(sine / 34))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0 - 0.25 * math.cos(sine / 8))*angles(math.rad(0 + 50 * math.cos(sine / 8)),math.rad(0),math.rad(-5 + 10 * math.cos(sine / 4))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(120 + 5 * math.cos(sine / 35)),math.rad(0)),.3)
end
end
elseif torvel>=42 and hitfloor~=nil then
Anim="Run"
if attack==false then
RH.C0=clerp(RH.C0,cf(1,-1 - 0.15 * math.cos(sine / 3),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0 + 85 * math.cos(sine / 6))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.15 * math.cos(sine / 3),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0 + 85 * math.cos(sine / 6))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.3,-0.05 + 0.15 * math.cos(sine / 3))*angles(math.rad(15 - 4 * math.cos(sine / 3)),math.rad(0 + root.RotVelocity.Y*1.5),math.rad(0 - root.RotVelocity.Y - 10 * math.cos(sine / 6))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-2.5 + 4 * math.cos(sine / 3)),math.rad(0 + root.RotVelocity.Y*1.5),math.rad(0 - hed.RotVelocity.Y*1.5 + 10 * math.cos(sine / 6))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0 + 0.5 * math.cos(sine / 6))*angles(math.rad(0 - 140 * math.cos(sine / 6)),math.rad(0),math.rad(5 - 20 * math.cos(sine / 3))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0 - 0.5 * math.cos(sine / 6))*angles(math.rad(0 + 140 * math.cos(sine / 6)),math.rad(0),math.rad(-5 + 20 * math.cos(sine / 3))),.1)
end
end
end
end
end)
	
Section1:CreateButton("Freestylin'", function()
	PlayR6Anim("4432024917", "5782963809")
end)

Section1:CreateButton("Spooky Month", function()
	PlayR6Anim("4049304710", "0")
end)

Section1:CreateButton("Electro Shuffle", function()
	PlayR6Anim("3619935462", "3014471292")
end)

Section1:CreateButton("Whip It", function()
	PlayR6Anim("5743854562", "266616327")
end)

Section1:CreateButton("Smug", function()
	PlayR6Anim("3450125501", "3761783315")
end)
--[[
Section1:CreateButton("Anthony Shuffle", function()
	PlayR6Anim("", "0")
end)]]

Section1:CreateButton("Anthony Shuffle", function()
			local playanother = false
local playing = false
local rtrnv;
local c;
local tbl3;
local v;
local anim;
local count;
local hhhh;
local asdf;
local s;
local animid;
local plr;
local char;
local cframe;
local torso;
local rs;
local ls;
local rh;
local lh;
local n;
local rj;
local rsc0;
local lsc0;
local rhc0;
local lhc0;
local rjc0;
local nc0;
local gc0;
local orsc0;
local olsc0;
local orhc0;
local olhc0;
local orjc0;
local onc0;
local count2;
local maxcount2;

local function getnext(tbl,number)
	c=100
	rtrnv=0
	for i,v in pairs(tbl) do
		if i>number and i-number<c then
			c=i-number
			rtrnv=i
		end
	end
	return(rtrnv)
end
local function wait2(tim)
	if tim<0.1 then
		game:GetService("RunService").Heartbeat:Wait()
	else
		for i=1,tim*40 do
			game:GetService("RunService").Heartbeat:Wait()
		end
	end
end
local function kftotbl(kf) -- Below this is literal pain..
	tbl3 = {}
	for i,v in pairs(kf:GetDescendants()) do
		if v:IsA("Pose") then
			tbl3[string.sub(v.Name,1,1)..string.sub(v.Name,#v.Name,#v.Name)] = v.CFrame
		end
	end
	return(tbl3)
end
        if playanother == true then
				playanother = false
			end
			playing = true
			if workspace.Camera.CameraSubject.Parent:FindFirstChild("Sound") then
				workspace.Camera.CameraSubject.Parent:FindFirstChild("Sound"):Remove()
		end
			s = Instance.new("Sound", workspace.Camera.CameraSubject.Parent)

				s.SoundId = "rbxassetid://5173160926"--5173160926

			s.Looped = true
			s.Playing = true
			wait(.1) -- Do not change because changing it will break.
			animid="rbxassetid://4837748730"
			plr = game.Players.LocalPlayer
			char = workspace.Camera.CameraSubject.Parent
			cframe = char.HumanoidRootPart.CFrame
			torso = char.Torso
			-----------------------------------------------------------
			rs = torso["Right Shoulder"] -- Just took this from another script(Faster).
			ls = torso["Left Shoulder"]
			rh = torso["Right Hip"]
			lh = torso["Left Hip"]
			n = torso["Neck"]
			rj = char.HumanoidRootPart["RootJoint"]
			rsc0 = rs.C0
			lsc0 = ls.C0
			rhc0 = rh.C0
			lhc0 = lh.C0
			rjc0 = rj.C0
			nc0 = n.C0
			gc0 = CFrame.new()
			orsc0 = rs.C0
			olsc0 = ls.C0
			orhc0 = rh.C0
			olhc0 = lh.C0
			orjc0 = rj.C0
			onc0 = n.C0
			count2 = 100
			maxcount2=100
			-----------------------------------------------------------
			game:GetService("RunService").Heartbeat:Connect(function() -- Speed.
				if playanother == true then
					return nil
				else
					count2 = count2+1
					if count2<=maxcount2 then
						rs.Transform=rs.Transform:Lerp(rsc0,count2/maxcount2)
						ls.Transform=ls.Transform:Lerp(lsc0,count2/maxcount2)
						rh.Transform=rh.Transform:Lerp(rhc0,count2/maxcount2)
						lh.Transform=lh.Transform:Lerp(lhc0,count2/maxcount2)
						n.Transform=n.Transform:Lerp(nc0,count2/maxcount2)
						rj.Transform=rj.Transform:Lerp(rjc0,count2/maxcount2)
					end
				end
			end)
			-----------------------------------------------------------
			animid=game:GetObjects(animid)[1]
			anim={}
			for i,v in pairs(animid:GetChildren()) do
				if v:IsA("Keyframe") then
					anim[v.Time]=kftotbl(v)
				end
			end

			count = 0
			char=workspace.Camera.CameraSubject.Parent
			hhhh=char.Humanoid.Animator
			hhhh.Parent = nil
			for _,v in pairs(char.Humanoid:GetPlayingAnimationTracks()) do
				v:Stop()
			end

			plr.CharacterRemoving:Connect(function()
				if playing == true then
					playing = false
				end
			end)

			while wait() do
				if playanother == true then
					break
				else
					for i,oasjdadlasdkadkldjkl in pairs(anim) do
						asdf=getnext(anim,count)
						v=anim[asdf]
						if v["Lg"] then
							lhc0 = v["Lg"]
						end
						if v["Rg"] then
							rhc0 = v["Rg"]
						end
						if v["Lm"] then
							lsc0 = v["Lm"]
						end
						if v["Rm"] then
							rsc0 = v["Rm"]
						end
						if v["To"] then
							rjc0 = v["To"]
						end
						if v["Hd"] then
							nc0 = v["Hd"]
						end
						count2=0
						maxcount2=asdf-count
						count=asdf
						wait(asdf-count)
						count2=maxcount2
						if v["Lg"] then
							char.Torso["Left Hip"].Transform = v["Lg"]
						end
						if v["Rg"] then
							char.Torso["Right Hip"].Transform = v["Rg"]
						end
						if v["Lm"] then
							char.Torso["Left Shoulder"].Transform = v["Lm"]
						end
						if v["Rm"] then
							char.Torso["Right Shoulder"].Transform = v["Rm"]
						end
						if v["To"] then
							char.HumanoidRootPart["RootJoint"].Transform = v["To"]
						end
						if v["Hd"] then
							char.Torso["Neck"].Transform = v["Hd"]
						end
					end
				end
			end
		--end)
end)

Section3:CreateButton("R15 Reanimate", function()
function Align(Part0, Part1, Position, Angle)
    local AlignPosition = Instance.new("AlignPosition",Part0)
    local AlignOrientation = Instance.new("AlignOrientation",Part0)
    
    local Attachment1 = Instance.new("Attachment", Part0)
    local Attachment2 = Instance.new("Attachment", Part1)

    AlignPosition.Attachment0 = Attachment1
    AlignPosition.Attachment1 = Attachment2
    
    AlignOrientation.Attachment0 = Attachment1
    AlignOrientation.Attachment1 = Attachment2
    
    Attachment2.Position = Position or Vector3.new(0,0,0)
    Attachment2.Orientation = Angle or Vector3.new(0,0,0)
    
    AlignOrientation.MaxTorque = math.huge
    --AlignOrientation.MaxAngularVelocity = math.huge
    --AlignOrientation.PrimaryAxisOnly = false 
    AlignOrientation.Responsiveness = 200
    AlignOrientation.RigidityEnabled = false
    AlignOrientation.ReactionTorqueEnabled = false
   AlignPosition.MaxForce = 2626668
    AlignPosition.MaxVelocity = math.huge
    AlignPosition.ReactionForceEnabled = false
    AlignPosition.Responsiveness = 200
    AlignPosition.ApplyAtCenterOfMass = true
    AlignPosition.RigidityEnabled = false
    local BodyForce = Instance.new("BodyForce", Part0)
    game:GetService("RunService").Heartbeat:Connect(function()
        Part0.Velocity = Vector3.new(0,-50,0)
        BodyForce.Force = Vector3.new(800,800,800)
    end)
end

local Players = game:GetService("Players")
local Player = Players.LocalPlayer
Player.Character.Archivable = true
local Character = Player.Character
local fakerig = Character:Clone()
fakerig.Head.face.Transparency = 1
fakerig.Name = "ROWARER15Reanimation"
fakerig.Parent = Character
Character.Animate:Remove()
Character.Humanoid:ClearAllChildren()

--[[Rigging]]

Character.RightUpperArm["RightShoulder"]:Destroy()
Character.RightLowerArm["RightElbow"]:Destroy()
Character.RightHand["RightWrist"]:Destroy()

Character.LeftUpperArm["LeftShoulder"]:Destroy()
Character.LeftLowerArm["LeftElbow"]:Destroy()
Character.LeftHand["LeftWrist"]:Destroy()

Character.LeftUpperLeg["LeftHip"]:Destroy()
Character.LeftLowerLeg["LeftKnee"]:Destroy()
Character.LeftFoot["LeftAnkle"]:Destroy()

Character.RightUpperLeg["RightHip"]:Destroy()
Character.RightLowerLeg["RightKnee"]:Destroy()
Character.RightFoot["RightAnkle"]:Destroy()

Character.UpperTorso.Waist:Remove()
Character.LowerTorso.Root:Remove()

--[[Fake Rig Mods]]

for i,v in pairs(fakerig:GetDescendants()) do
    if v:IsA("BasePart") or v:IsA("Part") then
        v.Transparency = 1
        v.CanCollide = false
    end
end

--[[Alignment]]

Align(Character.RightUpperArm, fakerig.RightUpperArm)
Align(Character.RightLowerArm, fakerig.RightLowerArm)
Align(Character.RightHand, fakerig.RightHand)
Align(Character.LeftUpperArm, fakerig.LeftUpperArm)
Align(Character.LeftLowerArm, fakerig.LeftLowerArm)
Align(Character.LeftHand, fakerig.LeftHand)


Align(Character.RightUpperLeg, fakerig.RightUpperLeg)
Align(Character.RightLowerLeg, fakerig.RightLowerLeg)
Align(Character.RightFoot, fakerig.RightFoot)
Align(Character.LeftUpperLeg, fakerig.LeftUpperLeg)
Align(Character.LeftLowerLeg, fakerig.LeftLowerLeg)
Align(Character.LeftFoot, fakerig.LeftFoot)

Align(Character.UpperTorso, fakerig.UpperTorso, Vector3.new(0, 0.45, 0))
Align(Character.LowerTorso, fakerig.LowerTorso)

--[[Wrap it up]]

local movecharacter = game:GetService("RunService").Stepped:Connect(function()
    fakerig:FindFirstChildOfClass("Humanoid"):Move(Character.Humanoid.MoveDirection)
end)

local jump = game:GetService("RunService").Stepped:Connect(function()
    if Character:FindFirstChildOfClass("Humanoid").Jump == true then
        fakerig:FindFirstChildOfClass("Humanoid").Jump = true
    end
end)



local stepped = game:GetService("RunService").Stepped:Connect(function()
    for i,v in pairs(Character:GetDescendants()) do
        if v:IsA("BasePart") or v:IsA("Part") then
            v.CanCollide = false
        end
    end
end)
local hrpmove

if _G.Fling == true then
local plrs = game:GetService("Players")
local plr = plrs.LocalPlayer
local char = plr.Character
local hrp = char.HumanoidRootPart

hrp.Name = "HumanoidRootPart"
hrp.Transparency = 0.5
hrp.Anchored = false
local bp = Instance.new("BodyPosition", hrp)
bp.Position = hrp.Position
bp.D = 9999999
bp.P = 999999999999999
bp.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
local flinger = Instance.new("BodyAngularVelocity",hrp)
flinger.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
flinger.P = 1000000000000000000000000000
flinger.AngularVelocity = Vector3.new(10000,10000,10000)

spawn(function()
	while game:GetService("RunService").Heartbeat:Wait() do
		bp.Position = game:GetService("Players").LocalPlayer.Character["fakerig"].HumanoidRootPart.Position
	end
end)
else
hrpmove = game:GetService("RunService").Stepped:Connect(function()
	Character.HumanoidRootPart.CFrame = fakerig.HumanoidRootPart.CFrame
end)
end

Character.Humanoid.Died:Connect(function()
     movecharacter:Disconnect()
     jump:Disconnect()
     if _G.Fling ~= true then
     	
     hrpmove:Disconnect()
 end
    Character:BreakJoints()
    Character:FindFirstChildOfClass("Humanoid"):Remove()
        for i,v in pairs(Character:GetDescendants()) do
        if v:IsA("BasePart") or v:IsA("Part") then
            v.Anchored = true
        end
    end
    fakerig:Remove()
	wait(game.Players.RespawnTime + 0.5)
		     stepped:Disconnect()
	
end)

workspace.Camera.CameraSubject = fakerig.Humanoid
end)

Section3:CreateButton("R6 TO R15", function()
game.StarterGui:SetCore("SendNotification",  {
 Title = "ro-ware v2";
 Text = "for r15 hat rig enable in settings";
 Icon = game.Players:GetUserThumbnailAsync(game.Players.LocalPlayer.UserId, "HeadShot", Enum.ThumbnailSize.Size100x100);
 Duration = 10;
})
if _G.BotReanim ~= true then
function Align(Part0, Part1, Position, Angle)
    local AlignPosition = Instance.new("AlignPosition",Part0)
    local AlignOrientation = Instance.new("AlignOrientation",Part0)
    
    local Attachment1 = Instance.new("Attachment", Part0)
    local Attachment2 = Instance.new("Attachment", Part1)

    AlignPosition.Attachment0 = Attachment1
    AlignPosition.Attachment1 = Attachment2
    
    AlignOrientation.Attachment0 = Attachment1
    AlignOrientation.Attachment1 = Attachment2
	

    
    Attachment2.Position = Position or Vector3.new(0,0,0)
    Attachment2.Orientation = Angle or Vector3.new(0,0,0)
    
    AlignOrientation.MaxTorque = math.huge
    AlignOrientation.MaxAngularVelocity = math.huge
    AlignOrientation.PrimaryAxisOnly = false 
    AlignOrientation.Responsiveness = 200
    AlignOrientation.RigidityEnabled = false
    AlignOrientation.ReactionTorqueEnabled = false
   AlignPosition.MaxForce = 2626668
    AlignPosition.MaxVelocity = math.huge
    AlignPosition.ReactionForceEnabled = false
    AlignPosition.Responsiveness = 200
    AlignPosition.ApplyAtCenterOfMass = true
    AlignPosition.RigidityEnabled = false
    

                local BodyForce = Instance.new("BodyForce", Part0)
    
    game:GetService("RunService").Heartbeat:Connect(function()
    	if Part0.Name ~= "Torso" then
        Part0.Velocity = Vector3.new(0,-30,0)
		end
		if Part0.Name == "Torso" and _G.Fling == true then
			Part0.Velocity = Vector3.new(1039,460,80)
			Part0.CFrame = Part1.CFrame
			else
			Part0.Velocity = Vector3.new(0,-30,0)
		end
        BodyForce.Force = Vector3.new(10000,10000,10000)
    end)
end

local Players = game:GetService("Players")
local Player = Players.LocalPlayer
Player.Character.Archivable = true
local Character = Player.Character
local fakerig = game:GetObjects("rbxassetid://6065416220")[1] --Character:Clone()

fakerig.Name = "fakerig"
fakerig.Head.face.Transparency = 1
fakerig.Parent = Character
Character.Animate:Remove()
Character.Humanoid:ClearAllChildren()
fakerig:MoveTo(game.Players.LocalPlayer.Character.HumanoidRootPart.Position)
fakerig.UpperTorso.Anchored = false
fakerig.LowerTorso.Anchored = false
fakerig.HumanoidRootPart.Anchored = false

--[[Rigging]]

Character.Torso["Right Shoulder"]:Remove()
Character.Torso["Left Shoulder"]:Remove()
Character.Torso["Right Hip"]:Remove()
Character.Torso["Left Hip"]:Remove()

--[[Fake Rig Mods]]

for i,v in pairs(fakerig:GetDescendants()) do
    if v:IsA("BasePart") or v:IsA("Part") then
        v.Transparency = 1
        v.CanCollide = false
    end
    if v:IsA("Decal") then
        v.Transparency = 1
        --v.CanCollide = false
    end
end

--[[Alignment]]

Align(Character["Right Arm"],fakerig["RightLowerArm"], Vector3.new(0, 0.15, 0), Vector3.new(0,0,0))
Align(Character["Right Leg"],fakerig["RightLowerLeg"], Vector3.new(0, 0.15, 0), Vector3.new(0,0,0))
Align(Character["Left Arm"],fakerig["LeftLowerArm"], Vector3.new(0, 0.15, 0), Vector3.new(0,0,0))
Align(Character["Left Leg"],fakerig["LeftLowerLeg"], Vector3.new(0, 0.15, 0), Vector3.new(0,0,0))
Align(Character.Torso, fakerig.UpperTorso,Vector3.new(0, 0.3, 0))

--[[Wrap it up]]
Character.HumanoidRootPart:Remove()

local movecharacter = game:GetService("RunService").Stepped:Connect(function()
    fakerig:FindFirstChildOfClass("Humanoid"):Move(Character.Humanoid.MoveDirection)
end)

local jump = game:GetService("RunService").Stepped:Connect(function()
    if Character.Humanoid.Jump == true then
        fakerig:FindFirstChildOfClass("Humanoid").Jump = true
    end
end)

local stepped = game:GetService("RunService").Stepped:Connect(function()
    for i,v in pairs(Character:GetDescendants()) do
        if v:IsA("BasePart") or v:IsA("Part") then
            v.CanCollide = false
        end
    end
end)

Character.Humanoid.Died:Connect(function()
	     stepped:Disconnect()
     movecharacter:Disconnect()
     jump:Disconnect()
    Character:BreakJoints()
    Character.Humanoid:Remove()
        for i,v in pairs(Character:GetDescendants()) do
        if v:IsA("BasePart") or v:IsA("Part") then
            v.Anchored = true
        end
    end
    fakerig:Remove()

end)

workspace.Camera.CameraSubject = fakerig.Humanoid

function RUNANIMATESCRIPT(FOLDER)
	function   waitForChild(parent, childName)
		local child = parent:findFirstChild(childName)
		if child then return child end
		while true do
			child = parent.ChildAdded:wait()
			if child.Name==childName then return child end
		end
	end

	local Figure = FOLDER.Parent
	local Humanoid = waitForChild(Figure, "Humanoid")
	local pose = "Standing"

	local currentAnim = ""
	local currentAnimInstance = nil
	local currentAnimTrack = nil
	local currentAnimKeyframeHandler = nil
	local currentAnimSpeed = 1.0
	local animTable = {}
	local animNames = { 
		idle = 	{	
			{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
			{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
			{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
		},
		walk = 	{ 	
			{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
		}, 
		run = 	{
			{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
		}, 
		swim = 	{
			{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
		}, 
		swimidle = 	{
			{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
		}, 
		jump = 	{
			{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
		}, 
		fall = 	{
			{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
		}, 
		climb = {
			{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
		}, 
		sit = 	{
			{ id = "http://www.roblox.com/asset/?id=507768133", weight = 10 } 
		},	
		toolnone = {
			{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
		},
		toolslash = {
			{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			--				{ id = "slash.xml", weight = 10 } 
		},
		toollunge = {
			{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
		},
		wave = {
			{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
		},
		point = {
			{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
		},
		dance = {
			{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
			{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
			{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
		},
		dance2 = {
			{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
			{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
			{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
		},
		dance3 = {
			{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
			{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
			{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
		},
		laugh = {
			{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
		},
		cheer = {
			{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
		},
	}

	-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
	local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

	math.randomseed(tick())

	function configureAnimationSet(name, fileList)
		if (animTable[name] ~= nil) then
			for _, connection in pairs(animTable[name].connections) do
				connection:disconnect()
			end
		end
		animTable[name] = {}
		animTable[name].count = 0
		animTable[name].totalWeight = 0	
		animTable[name].connections = {}

		-- check for config values
		local config = script:FindFirstChild(name)
		if (config ~= nil) then
			--		print("Loading anims " .. name)
			table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
			table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
			local idx = 1
			for _, childPart in pairs(config:GetChildren()) do
				if (childPart:IsA("Animation")) then
					table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
					animTable[name][idx] = {}
					animTable[name][idx].anim = childPart
					local weightObject = childPart:FindFirstChild("Weight")
					if (weightObject == nil) then
						animTable[name][idx].weight = 1
					else
						animTable[name][idx].weight = weightObject.Value
					end
					animTable[name].count = animTable[name].count + 1
					animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
					--				print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
					idx = idx + 1
				end
			end
		end

		-- fallback to defaults
		if (animTable[name].count <= 0) then
			for idx, anim in pairs(fileList) do
				animTable[name][idx] = {}
				animTable[name][idx].anim = Instance.new("Animation")
				animTable[name][idx].anim.Name = name
				animTable[name][idx].anim.AnimationId = anim.id
				animTable[name][idx].weight = anim.weight
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
				--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
			end
		end
	end

	-- Setup animation objects
	function scriptChildModified(child)
		local fileList = animNames[child.Name]
		if (fileList ~= nil) then
			configureAnimationSet(child.Name, fileList)
		end	
	end

	script.ChildAdded:connect(scriptChildModified)
	script.ChildRemoved:connect(scriptChildModified)


	for name, fileList in pairs(animNames) do 
		configureAnimationSet(name, fileList)
	end	

	-- ANIMATION

	-- declarations
	local toolAnim = "None"
	local toolAnimTime = 0

	local jumpAnimTime = 0
	local jumpAnimDuration = 0.31

	local toolTransitionTime = 0.1
	local fallTransitionTime = 0.2

	-- functions

	function stopAllAnimations()
		local oldAnim = currentAnim

		-- return to idle if finishing an emote
		if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
			oldAnim = "idle"
		end

		currentAnim = ""
		currentAnimInstance = nil
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end

		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop()
			currentAnimTrack:Destroy()
			currentAnimTrack = nil
		end
		return oldAnim
	end

	function setAnimationSpeed(speed)
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end

	function keyFrameReachedFunc(frameName)
		if (frameName == "End") then
			--		print("Keyframe : ".. frameName)

			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end

			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end

	-- Preload animations
	function playAnimation(animName, transitionTime, humanoid) 

		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end

		--	print(animName .. " " .. idx .. " [" .. origRoll .. "]")

		local anim = animTable[animName][idx].anim

		-- switch animation		
		if (anim ~= currentAnimInstance) then

			if (currentAnimTrack ~= nil) then
				currentAnimTrack:Stop(transitionTime)
				currentAnimTrack:Destroy()
			end

			currentAnimSpeed = 1.0

			-- load it to the humanoid; get AnimationTrack
			currentAnimTrack = humanoid:LoadAnimation(anim)

			-- play the animation
			currentAnimTrack:Play(transitionTime)
			currentAnim = animName
			currentAnimInstance = anim

			-- set up keyframe name triggers
			if (currentAnimKeyframeHandler ~= nil) then
				currentAnimKeyframeHandler:disconnect()
			end
			currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)

		end

	end

	-------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------

	local toolAnimName = ""
	local toolAnimTrack = nil
	local toolAnimInstance = nil
	local currentToolAnimKeyframeHandler = nil

	function toolKeyFrameReachedFunc(frameName)
		if (frameName == "End") then
			--		print("Keyframe : ".. frameName)	
			playToolAnimation(toolAnimName, 0.0, Humanoid)
		end
	end


	function playToolAnimation(animName, transitionTime, humanoid)	 

		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
		--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then

			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end

			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)

			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
	end

	function stopToolAnimations()
		local oldAnim = toolAnimName

		if (currentToolAnimKeyframeHandler ~= nil) then
			currentToolAnimKeyframeHandler:disconnect()
		end

		toolAnimName = ""
		toolAnimInstance = nil
		if (toolAnimTrack ~= nil) then
			toolAnimTrack:Stop()
			toolAnimTrack:Destroy()
			toolAnimTrack = nil
		end


		return oldAnim
	end

	-------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------


	function onRunning(speed)
		if speed > 0.01 then
			local scale = 15.0
			playAnimation("walk", 0.1, Humanoid)
			setAnimationSpeed(speed / scale)
			pose = "Running"
		else
			playAnimation("idle", 0.1, Humanoid)
			pose = "Standing"
		end
	end

	function onDied()
		pose = "Dead"
	end

	function onJumping()
		playAnimation("jump", 0.1, Humanoid)
		jumpAnimTime = jumpAnimDuration
		pose = "Jumping"
	end

	function onClimbing(speed)
		local scale = 5.0
		playAnimation("climb", 0.1, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Climbing"
	end

	function onGettingUp()
		pose = "GettingUp"
	end

	function onFreeFall()
		if (jumpAnimTime <= 0) then
			playAnimation("fall", fallTransitionTime, Humanoid)
		end
		pose = "FreeFall"
	end

	function onFallingDown()
		pose = "FallingDown"
	end

	function onSeated()
		pose = "Seated"
	end

	function onPlatformStanding()
		pose = "PlatformStanding"
	end

	function onSwimming(speed)
		if speed > 1.00 then
			local scale = 10.0
			playAnimation("swim", 0.4, Humanoid)
			setAnimationSpeed(speed / scale)
			pose = "Swimming"
		else
			playAnimation("swimidle", 0.4, Humanoid)
			pose = "Standing"
		end
	end

	function getTool()	
		for _, kid in ipairs(Figure:GetChildren()) do
			if kid.className == "Tool" then return kid end
		end
		return nil
	end

	function getToolAnim(tool)
		for _, c in ipairs(tool:GetChildren()) do
			if c.Name == "toolanim" and c.className == "StringValue" then
				return c
			end
		end
		return nil
	end

	function animateTool()

		if (toolAnim == "None") then
			playToolAnimation("toolnone", toolTransitionTime, Humanoid)
			return
		end

		if (toolAnim == "Slash") then
			playToolAnimation("toolslash", 0, Humanoid)
			return
		end

		if (toolAnim == "Lunge") then
			playToolAnimation("toollunge", 0, Humanoid)
			return
		end
	end

	function moveSit()
		RightShoulder.MaxVelocity = 0.15
		LeftShoulder.MaxVelocity = 0.15
		RightShoulder:SetDesiredAngle(3.14 /2)
		LeftShoulder:SetDesiredAngle(-3.14 /2)
		RightHip:SetDesiredAngle(3.14 /2)
		LeftHip:SetDesiredAngle(-3.14 /2)
	end

	local lastTick = 0

	function move(time)
		local amplitude = 1
		local frequency = 1
		local deltaTime = time - lastTick
		lastTick = time

		local climbFudge = 0
		local setAngles = false

		if (jumpAnimTime > 0) then
			jumpAnimTime = jumpAnimTime - deltaTime
		end

		if (pose == "FreeFall" and jumpAnimTime <= 0) then
			playAnimation("fall", fallTransitionTime, Humanoid)
		elseif (pose == "Seated") then
			playAnimation("sit", 0.5, Humanoid)
			return
		elseif (pose == "Running") then
			playAnimation("walk", 0.1, Humanoid)
		elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
			stopAllAnimations()
			amplitude = 0.1
			frequency = 1
			setAngles = true
		end

		-- Tool Animation handling
		local tool = getTool()
		if tool then

			animStringValueObject = getToolAnim(tool)

			if animStringValueObject then
				toolAnim = animStringValueObject.Value
				-- message recieved, delete StringValue
				animStringValueObject.Parent = nil
				toolAnimTime = time + .3
			end

			if time > toolAnimTime then
				toolAnimTime = 0
				toolAnim = "None"
			end

			animateTool()		
		else
			stopToolAnimations()
			toolAnim = "None"
			toolAnimInstance = nil
			toolAnimTime = 0
		end
	end

	-- connect events
	Humanoid.Died:connect(onDied)
	Humanoid.Running:connect(onRunning)
	Humanoid.Jumping:connect(onJumping)
	Humanoid.Climbing:connect(onClimbing)
	Humanoid.GettingUp:connect(onGettingUp)
	Humanoid.FreeFalling:connect(onFreeFall)
	Humanoid.FallingDown:connect(onFallingDown)
	Humanoid.Seated:connect(onSeated)
	Humanoid.PlatformStanding:connect(onPlatformStanding)
	Humanoid.Swimming:connect(onSwimming)

	-- setup emote chat hook


	-- main program

	local runService = game:service("RunService");

	-- print("bottom")

	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"

	while Figure.Parent~=nil do
		local _, time = wait(0.1)
		move(time)
	end
end
RUNANIMATESCRIPT(fakerig.Animate)
else
function Align(Part0, Part1, Position, Angle)
    local AlignPosition = Instance.new("AlignPosition",Part0)
    local AlignOrientation = Instance.new("AlignOrientation",Part0)
    
    local Attachment1 = Instance.new("Attachment", Part0)
    local Attachment2 = Instance.new("Attachment", Part1)

    AlignPosition.Attachment0 = Attachment1
    AlignPosition.Attachment1 = Attachment2
    
    AlignOrientation.Attachment0 = Attachment1
    AlignOrientation.Attachment1 = Attachment2
	

    
    Attachment2.Position = Position or Vector3.new(0,0,0)
    Attachment2.Orientation = Angle or Vector3.new(0,0,0)
    
    AlignOrientation.MaxTorque = math.huge
    AlignOrientation.MaxAngularVelocity = math.huge
    AlignOrientation.PrimaryAxisOnly = false 
    AlignOrientation.Responsiveness = 200
    AlignOrientation.RigidityEnabled = false
    AlignOrientation.ReactionTorqueEnabled = false
   AlignPosition.MaxForce = 2626668
    AlignPosition.MaxVelocity = math.huge
    AlignPosition.ReactionForceEnabled = false
    AlignPosition.Responsiveness = 200
    AlignPosition.ApplyAtCenterOfMass = true
    AlignPosition.RigidityEnabled = false
    

                local BodyForce = Instance.new("BodyForce", Part0)
    
    game:GetService("RunService").Heartbeat:Connect(function()
    	if Part0.Name ~= "Torso" then
        Part0.Velocity = Vector3.new(0,-30,0)
		end
		if Part0.Name == "Torso" and _G.Fling == true then
			Part0.Velocity = Vector3.new(1039,460,80)
			Part0.CFrame = Part1.CFrame
			else
			Part0.Velocity = Vector3.new(0,-30,0)
		end
        BodyForce.Force = Vector3.new(10000,10000,10000)
    end)
end
local hatrig = {}
local Players = game:GetService("Players")
local Player = Players.LocalPlayer
Player.Character.Archivable = true
local Character = Player.Character
local fakerig = game:GetObjects("rbxassetid://6065416220")[1] --Character:Clone()

fakerig.Name = "fakerig"
fakerig.Head.face.Transparency = 1
fakerig.Parent = Character
Character.Animate:Remove()
Character.Humanoid:ClearAllChildren()
fakerig:MoveTo(game.Players.LocalPlayer.Character.HumanoidRootPart.Position)
fakerig.UpperTorso.Anchored = false
fakerig.LowerTorso.Anchored = false
fakerig.HumanoidRootPart.Anchored = false

--[[Rigging]]

Character.Torso["Right Shoulder"]:Remove()
Character.Torso["Left Shoulder"]:Remove()
Character.Torso["Right Hip"]:Remove()
Character.Torso["Left Hip"]:Remove()

--[[Fake Rig Mods]]

for i,v in pairs(fakerig:GetDescendants()) do
    if v:IsA("BasePart") or v:IsA("Part") then
        v.Transparency = 1
        v.CanCollide = false
    end
    if v:IsA("Decal") then
        v.Transparency = 1
        --v.CanCollide = false
    end
end

for i,v in pairs(Character:GetChildren()) do
    if v:IsA("Accessory") and v.Name == "InternationalFedora" or v.Name == "MeshPartAccessory" or v.Name == "International Fedora" and v.Handle.Size == Vector3.new(1,1,1) then
		table.insert(hatrig,v)
		v.Name = "funynhat"
		v.Handle:BreakJoints()
		if v.Handle:FindFirstChild("SpecialMesh") then
			v.Handle:FindFirstChild("SpecialMesh"):Remove()
		end
		if v.Handle:FindFirstChild("Mesh") then
			v.Handle:FindFirstChild("Mesh"):Remove()
		end
		--v.Handle:FindFirstChildOfClass("Mesh"):Remove()
    end
end

--[[Alignment]]
Align(hatrig[1].Handle,fakerig["RightUpperArm"], Vector3.new(0, 0, 0), Vector3.new(0,0,0))
Align(hatrig[2].Handle,fakerig["RightLowerArm"], Vector3.new(0, -0.3, 0), Vector3.new(0,0,0))
Align(hatrig[3].Handle,fakerig["LeftUpperArm"], Vector3.new(0, -0, 0), Vector3.new(0,0,0))
Align(hatrig[4].Handle,fakerig["LeftLowerArm"], Vector3.new(0, -0.3, 0), Vector3.new(0,0,0))

Align(hatrig[5].Handle,fakerig["RightUpperLeg"], Vector3.new(0, -0.15, 0), Vector3.new(0,0,0))
Align(hatrig[6].Handle,fakerig["RightLowerLeg"], Vector3.new(0, -0.15, 0), Vector3.new(0,0,0))
Align(hatrig[7].Handle,fakerig["LeftUpperLeg"], Vector3.new(0, -0.15, 0), Vector3.new(0,0,0))
Align(hatrig[8].Handle,fakerig["LeftLowerLeg"], Vector3.new(0, -0.15, 0), Vector3.new(0,0,0))

Align(Character.Torso, fakerig.UpperTorso, Vector3.new(0,0.25,0))

--[[Wrap it up]]
Character.HumanoidRootPart:Remove()

local movecharacter = game:GetService("RunService").Stepped:Connect(function()
    fakerig:FindFirstChildOfClass("Humanoid"):Move(Character.Humanoid.MoveDirection)
end)

local jump = game:GetService("RunService").Stepped:Connect(function()
    if Character.Humanoid.Jump == true then
        fakerig:FindFirstChildOfClass("Humanoid").Jump = true
    end
end)

local stepped = game:GetService("RunService").Stepped:Connect(function()
    for i,v in pairs(Character:GetDescendants()) do
        if v:IsA("BasePart") or v:IsA("Part") then
            v.CanCollide = false
        end
    end
end)

Character.Humanoid.Died:Connect(function()
	     stepped:Disconnect()
     movecharacter:Disconnect()
     jump:Disconnect()
    Character:BreakJoints()
    Character.Humanoid:Remove()
        for i,v in pairs(Character:GetDescendants()) do
        if v:IsA("BasePart") or v:IsA("Part") then
            v.Anchored = true
        end
    end
    fakerig:Remove()

end)

workspace.Camera.CameraSubject = fakerig.Humanoid

function RUNANIMATESCRIPT(FOLDER)
	function   waitForChild(parent, childName)
		local child = parent:findFirstChild(childName)
		if child then return child end
		while true do
			child = parent.ChildAdded:wait()
			if child.Name==childName then return child end
		end
	end

	local Figure = FOLDER.Parent
	local Humanoid = waitForChild(Figure, "Humanoid")
	local pose = "Standing"

	local currentAnim = ""
	local currentAnimInstance = nil
	local currentAnimTrack = nil
	local currentAnimKeyframeHandler = nil
	local currentAnimSpeed = 1.0
	local animTable = {}
	local animNames = { 
		idle = 	{	
			{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
			{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
			{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
		},
		walk = 	{ 	
			{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
		}, 
		run = 	{
			{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
		}, 
		swim = 	{
			{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
		}, 
		swimidle = 	{
			{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
		}, 
		jump = 	{
			{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
		}, 
		fall = 	{
			{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
		}, 
		climb = {
			{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
		}, 
		sit = 	{
			{ id = "http://www.roblox.com/asset/?id=507768133", weight = 10 } 
		},	
		toolnone = {
			{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
		},
		toolslash = {
			{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			--				{ id = "slash.xml", weight = 10 } 
		},
		toollunge = {
			{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
		},
		wave = {
			{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
		},
		point = {
			{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
		},
		dance = {
			{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
			{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
			{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
		},
		dance2 = {
			{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
			{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
			{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
		},
		dance3 = {
			{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
			{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
			{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
		},
		laugh = {
			{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
		},
		cheer = {
			{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
		},
	}

	-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
	local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

	math.randomseed(tick())

	function configureAnimationSet(name, fileList)
		if (animTable[name] ~= nil) then
			for _, connection in pairs(animTable[name].connections) do
				connection:disconnect()
			end
		end
		animTable[name] = {}
		animTable[name].count = 0
		animTable[name].totalWeight = 0	
		animTable[name].connections = {}

		-- check for config values
		local config = script:FindFirstChild(name)
		if (config ~= nil) then
			--		print("Loading anims " .. name)
			table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
			table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
			local idx = 1
			for _, childPart in pairs(config:GetChildren()) do
				if (childPart:IsA("Animation")) then
					table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
					animTable[name][idx] = {}
					animTable[name][idx].anim = childPart
					local weightObject = childPart:FindFirstChild("Weight")
					if (weightObject == nil) then
						animTable[name][idx].weight = 1
					else
						animTable[name][idx].weight = weightObject.Value
					end
					animTable[name].count = animTable[name].count + 1
					animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
					--				print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
					idx = idx + 1
				end
			end
		end

		-- fallback to defaults
		if (animTable[name].count <= 0) then
			for idx, anim in pairs(fileList) do
				animTable[name][idx] = {}
				animTable[name][idx].anim = Instance.new("Animation")
				animTable[name][idx].anim.Name = name
				animTable[name][idx].anim.AnimationId = anim.id
				animTable[name][idx].weight = anim.weight
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
				--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
			end
		end
	end

	-- Setup animation objects
	function scriptChildModified(child)
		local fileList = animNames[child.Name]
		if (fileList ~= nil) then
			configureAnimationSet(child.Name, fileList)
		end	
	end

	script.ChildAdded:connect(scriptChildModified)
	script.ChildRemoved:connect(scriptChildModified)


	for name, fileList in pairs(animNames) do 
		configureAnimationSet(name, fileList)
	end	

	-- ANIMATION

	-- declarations
	local toolAnim = "None"
	local toolAnimTime = 0

	local jumpAnimTime = 0
	local jumpAnimDuration = 0.31

	local toolTransitionTime = 0.1
	local fallTransitionTime = 0.2

	-- functions

	function stopAllAnimations()
		local oldAnim = currentAnim

		-- return to idle if finishing an emote
		if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
			oldAnim = "idle"
		end

		currentAnim = ""
		currentAnimInstance = nil
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end

		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop()
			currentAnimTrack:Destroy()
			currentAnimTrack = nil
		end
		return oldAnim
	end

	function setAnimationSpeed(speed)
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end

	function keyFrameReachedFunc(frameName)
		if (frameName == "End") then
			--		print("Keyframe : ".. frameName)

			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end

			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end

	-- Preload animations
	function playAnimation(animName, transitionTime, humanoid) 

		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end

		--	print(animName .. " " .. idx .. " [" .. origRoll .. "]")

		local anim = animTable[animName][idx].anim

		-- switch animation		
		if (anim ~= currentAnimInstance) then

			if (currentAnimTrack ~= nil) then
				currentAnimTrack:Stop(transitionTime)
				currentAnimTrack:Destroy()
			end

			currentAnimSpeed = 1.0

			-- load it to the humanoid; get AnimationTrack
			currentAnimTrack = humanoid:LoadAnimation(anim)

			-- play the animation
			currentAnimTrack:Play(transitionTime)
			currentAnim = animName
			currentAnimInstance = anim

			-- set up keyframe name triggers
			if (currentAnimKeyframeHandler ~= nil) then
				currentAnimKeyframeHandler:disconnect()
			end
			currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)

		end

	end

	-------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------

	local toolAnimName = ""
	local toolAnimTrack = nil
	local toolAnimInstance = nil
	local currentToolAnimKeyframeHandler = nil

	function toolKeyFrameReachedFunc(frameName)
		if (frameName == "End") then
			--		print("Keyframe : ".. frameName)	
			playToolAnimation(toolAnimName, 0.0, Humanoid)
		end
	end


	function playToolAnimation(animName, transitionTime, humanoid)	 

		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
		--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then

			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end

			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)

			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
	end

	function stopToolAnimations()
		local oldAnim = toolAnimName

		if (currentToolAnimKeyframeHandler ~= nil) then
			currentToolAnimKeyframeHandler:disconnect()
		end

		toolAnimName = ""
		toolAnimInstance = nil
		if (toolAnimTrack ~= nil) then
			toolAnimTrack:Stop()
			toolAnimTrack:Destroy()
			toolAnimTrack = nil
		end


		return oldAnim
	end

	-------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------


	function onRunning(speed)
		if speed > 0.01 then
			local scale = 15.0
			playAnimation("walk", 0.1, Humanoid)
			setAnimationSpeed(speed / scale)
			pose = "Running"
		else
			playAnimation("idle", 0.1, Humanoid)
			pose = "Standing"
		end
	end

	function onDied()
		pose = "Dead"
	end

	function onJumping()
		playAnimation("jump", 0.1, Humanoid)
		jumpAnimTime = jumpAnimDuration
		pose = "Jumping"
	end

	function onClimbing(speed)
		local scale = 5.0
		playAnimation("climb", 0.1, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Climbing"
	end

	function onGettingUp()
		pose = "GettingUp"
	end

	function onFreeFall()
		if (jumpAnimTime <= 0) then
			playAnimation("fall", fallTransitionTime, Humanoid)
		end
		pose = "FreeFall"
	end

	function onFallingDown()
		pose = "FallingDown"
	end

	function onSeated()
		pose = "Seated"
	end

	function onPlatformStanding()
		pose = "PlatformStanding"
	end

	function onSwimming(speed)
		if speed > 1.00 then
			local scale = 10.0
			playAnimation("swim", 0.4, Humanoid)
			setAnimationSpeed(speed / scale)
			pose = "Swimming"
		else
			playAnimation("swimidle", 0.4, Humanoid)
			pose = "Standing"
		end
	end

	function getTool()	
		for _, kid in ipairs(Figure:GetChildren()) do
			if kid.className == "Tool" then return kid end
		end
		return nil
	end

	function getToolAnim(tool)
		for _, c in ipairs(tool:GetChildren()) do
			if c.Name == "toolanim" and c.className == "StringValue" then
				return c
			end
		end
		return nil
	end

	function animateTool()

		if (toolAnim == "None") then
			playToolAnimation("toolnone", toolTransitionTime, Humanoid)
			return
		end

		if (toolAnim == "Slash") then
			playToolAnimation("toolslash", 0, Humanoid)
			return
		end

		if (toolAnim == "Lunge") then
			playToolAnimation("toollunge", 0, Humanoid)
			return
		end
	end

	function moveSit()
		RightShoulder.MaxVelocity = 0.15
		LeftShoulder.MaxVelocity = 0.15
		RightShoulder:SetDesiredAngle(3.14 /2)
		LeftShoulder:SetDesiredAngle(-3.14 /2)
		RightHip:SetDesiredAngle(3.14 /2)
		LeftHip:SetDesiredAngle(-3.14 /2)
	end

	local lastTick = 0

	function move(time)
		local amplitude = 1
		local frequency = 1
		local deltaTime = time - lastTick
		lastTick = time

		local climbFudge = 0
		local setAngles = false

		if (jumpAnimTime > 0) then
			jumpAnimTime = jumpAnimTime - deltaTime
		end

		if (pose == "FreeFall" and jumpAnimTime <= 0) then
			playAnimation("fall", fallTransitionTime, Humanoid)
		elseif (pose == "Seated") then
			playAnimation("sit", 0.5, Humanoid)
			return
		elseif (pose == "Running") then
			playAnimation("walk", 0.1, Humanoid)
		elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
			stopAllAnimations()
			amplitude = 0.1
			frequency = 1
			setAngles = true
		end

		-- Tool Animation handling
		local tool = getTool()
		if tool then

			animStringValueObject = getToolAnim(tool)

			if animStringValueObject then
				toolAnim = animStringValueObject.Value
				-- message recieved, delete StringValue
				animStringValueObject.Parent = nil
				toolAnimTime = time + .3
			end

			if time > toolAnimTime then
				toolAnimTime = 0
				toolAnim = "None"
			end

			animateTool()		
		else
			stopToolAnimations()
			toolAnim = "None"
			toolAnimInstance = nil
			toolAnimTime = 0
		end
	end

	-- connect events
	Humanoid.Died:connect(onDied)
	Humanoid.Running:connect(onRunning)
	Humanoid.Jumping:connect(onJumping)
	Humanoid.Climbing:connect(onClimbing)
	Humanoid.GettingUp:connect(onGettingUp)
	Humanoid.FreeFalling:connect(onFreeFall)
	Humanoid.FallingDown:connect(onFallingDown)
	Humanoid.Seated:connect(onSeated)
	Humanoid.PlatformStanding:connect(onPlatformStanding)
	Humanoid.Swimming:connect(onSwimming)

	-- setup emote chat hook


	-- main program

	local runService = game:service("RunService");

	-- print("bottom")

	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"

	while Figure.Parent~=nil do
		local _, time = wait(0.1)
		move(time)
	end
end
RUNANIMATESCRIPT(fakerig.Animate)
end
end)

Section3:CreateButton("Goopie", function()
local playanother = false
local playing = false
local rtrnv;
local c;
local tbl3;
local v;
local anim;
local count;
local hhhh;
local asdf;
local s;
local animid;
local plr;
local char;
local cframe;
local torso;
local rs;
local ls;
local rh;
local lh;
local n;
local rj;
local rsc0;
local lsc0;
local rhc0;
local lhc0;
local rjc0;
local nc0;
local gc0;
local orsc0;
local olsc0;
local orhc0;
local olhc0;
local orjc0;
local onc0;
local count2;
local maxcount2;

local function getnext(tbl,number)
	c=100
	rtrnv=0
	for i,v in pairs(tbl) do
		if i>number and i-number<c then
			c=i-number
			rtrnv=i
		end
	end
	return(rtrnv)
end
local function wait2(tim)
	if tim<0.1 then
		game:GetService("RunService").Heartbeat:Wait()
	else
		for i=1,tim*40 do
			game:GetService("RunService").Heartbeat:Wait()
		end
	end
end
local function kftotbl(kf) -- Below this is literal pain..
	tbl3 = {}
	for i,v in pairs(kf:GetDescendants()) do
		if v:IsA("Pose") then
			tbl3[v.Name] = v.CFrame
		end
	end
	return(tbl3)
end

        if playing == true then
			s:Destroy()
			playing = false
			playanother = true
		end
		wait()
		spawn(function()
			if playanother == true then
				playanother = false
			end
			playing = true
			s = Instance.new("Sound", workspace.Camera.CameraSubject.Parent.UpperTorso)

				s.SoundId = "rbxassetid://5173160926"

			s.Looped = true
			s.Playing = true
			wait(.1) -- Do not change because changing it will break.
			animid="rbxassetid://5777763852"
			plr = game.Players.LocalPlayer
			char = workspace.Camera.CameraSubject.Parent
			cframe = char.HumanoidRootPart.CFrame
			utorso = workspace.Camera.CameraSubject.Parent.UpperTorso
			ltorso = workspace.Camera.CameraSubject.Parent.LowerTorso
			-----------------------------------------------------------
			rus = char["RightUpperArm"]["RightShoulder"]
			lus = char["LeftUpperArm"]["LeftShoulder"]
			rls = char["RightLowerArm"]["RightElbow"]
			lls = char["LeftLowerArm"]["LeftElbow"]
			rw = char["RightHand"]["RightWrist"]
			lw = char["LeftHand"]["LeftWrist"]
			ruh = char["RightUpperLeg"]["RightHip"]
			luh = char["LeftUpperLeg"]["LeftHip"]
			rlh = char["RightLowerLeg"]["RightKnee"]
			llh = char["LeftLowerLeg"]["LeftKnee"]
			rf = char["RightFoot"]["RightAnkle"]
			lf = char["LeftFoot"]["LeftAnkle"]
			n = char.Head["Neck"]
            ut = char.UpperTorso.Waist
            lt = char.LowerTorso.Root
			rusc0 = rus.C0
			lusc0 = lus.C0
			rlsc0 = rls.C0
			llsc0 = lls.C0
			rwc0 = rw.C0
			lwc0 = lw.C0
			ruhc0 = ruh.C0
			luhc0 = luh.C0
			rlhc0 = rlh.C0
			llhc0 = llh.C0
			rfc0 = rf.C0
			lfc0 = lf.C0
			nc0 = n.C0
            utc0 = ut.C0
            ltc0 = lt.c0
			gc0 = CFrame.new()
			orrusc0 = rus.C0
			orlusc0 = lus.C0
			orrlsc0 = rls.C0
			orllsc0 = lls.C0
			orrwc0 = rw.C0
			orlwc0 = lw.C0
			orruhc0 = ruh.C0
			orluhc0 = luh.C0
			orrlhc0 = rlh.C0
			orllhc0 = llh.C0
			orrfc0 = rf.C0
			orlfc0 = lf.C0
			ornc0 = n.C0
            orutc0 = ut.C0
            orltc0 = lt.c0
			count2 = 100
			maxcount2=100
			-----------------------------------------------------------
			game:GetService("RunService").Heartbeat:Connect(function() -- Speed.
				if playanother == true then
					return nil
				else
					count2 = count2+1
					if count2<=maxcount2 then
						rus.Transform=rus.Transform:Lerp(rusc0,count2/maxcount2)
						lus.Transform=lus.Transform:Lerp(lusc0,count2/maxcount2)
						rls.Transform=rls.Transform:Lerp(rlsc0,count2/maxcount2)
						lls.Transform=lls.Transform:Lerp(llsc0,count2/maxcount2)
						rw.Transform=rw.Transform:Lerp(rwc0,count2/maxcount2)
						lw.Transform=lw.Transform:Lerp(lwc0,count2/maxcount2)
						ruh.Transform=ruh.Transform:Lerp(ruhc0,count2/maxcount2)
						luh.Transform=luh.Transform:Lerp(luhc0,count2/maxcount2)
						rlh.Transform=rlh.Transform:Lerp(rlhc0,count2/maxcount2)
						llh.Transform=llh.Transform:Lerp(llhc0,count2/maxcount2)
						rf.Transform=rf.Transform:Lerp(rfc0,count2/maxcount2)
						lf.Transform=lf.Transform:Lerp(lfc0,count2/maxcount2)
						n.Transform=n.Transform:Lerp(nc0,count2/maxcount2)
						ut.Transform=ut.Transform:Lerp(utc0,count2/maxcount2)
						lt.Transform=lt.Transform:Lerp(ltc0,count2/maxcount2)
					end
				end
			end)
			-----------------------------------------------------------
			animid=game:GetObjects(animid)[1]
			anim={}
			for i,v in pairs(animid:GetChildren()) do
				if v:IsA("Keyframe") then
					anim[v.Time]=kftotbl(v)
				end
			end

			count = 0
			char=workspace.Camera.CameraSubject.Parent
			hhhh=workspace.Camera.CameraSubject.Parent.Humanoid.Animator
			hhhh.Parent = nil
			for _,v in pairs(char.Humanoid:GetPlayingAnimationTracks()) do
				v:Stop()
			end
			
			hhhh:Destroy()
			char.Animate:Destroy()

			plr.CharacterRemoving:Connect(function()
				if playing == true then
					playing = false
				end
			end)

			while wait() do
				if playanother == true then
					break
				else
					for i,oasjdadlasdkadkldjkl in pairs(anim) do
						asdf=getnext(anim,count)
						v=anim[asdf]
						if v["LeftUpperArm"] then
							lusc0 = v["LeftUpperArm"]
						end
						if v["RightUpperArm"] then
							rusc0 = v["RightUpperArm"]
						end
						if v["LeftLowerArm"] then
							llsc0 = v["LeftLowerArm"]
						end
						if v["RightUpperArm"] then
							rlsc0 = v["RightLowerArm"]
						end
						if v["LeftHand"] then
							lwc0 = v["LeftHand"]
						end
						if v["RightHand"] then
							rwc0 = v["RightHand"]
						end
						if v["LeftUpperALeg"] then
							luhc0 = v["LeftUpperLeg"]
						end
						if v["RightUpperLeg"] then
							ruhc0 = v["RightUpperLeg"]
						end
						if v["LeftLowerLeg"] then
							llhc0 = v["LeftLowerLeg"]
						end
						if v["RightUpperLeg"] then
							rlhc0 = v["RightLowerLeg"]
						end
						if v["LeftFoot"] then
							lfc0 = v["LeftFoot"]
						end
						if v["RightFoot"] then
							rfc0 = v["RightFoot"]
						end
						if v["UpperTorso"] then
							utc0 = v["UpperTorso"]
						end
						if v["LowerTorso"] then
							ltc0 = v["LowerTorso"]
						end
						if v["Head"] then
							nc0 = v["Head"]
						end
						count2=0
						maxcount2=asdf-count
						count=asdf
						wait(asdf-count)
						count2=maxcount2
						if v["LeftUpperArm"] then
							char["LeftUpperArm"]["LeftShoulder"].Transform = v["LeftUpperArm"]
						end
						if v["RightUpperArm"] then
							char["RightUpperArm"]["RightShoulder"].Transform = v["RightUpperArm"]
						end
						if v["LeftLowerArm"] then
							char["LeftLowerArm"]["LeftElbow"].Transform = v["LeftLowerArm"]
						end
						if v["RightUpperArm"] then
							char["RightLowerArm"]["RightElbow"].Transform = v["RightLowerArm"]
						end
						if v["LeftHand"] then
							char["LeftHand"]["LeftWrist"].Transform = v["LeftHand"]
						end
						if v["RightHand"] then
							char["RightHand"]["RightWrist"].Transform = v["RightHand"]
						end
--
						if v["LeftUpperLeg"] then
							char["LeftUpperLeg"]["LeftHip"].Transform = v["LeftUpperLeg"]
						end
						if v["RightUpperLeg"] then
							char["RightUpperLeg"]["RightHip"].Transform = v["RightUpperLeg"]
						end
						if v["LeftLowerLeg"] then
							char["LeftLowerLeg"]["LeftKnee"].Transform = v["LeftLowerLeg"]
						end
						if v["RightUpperLeg"] then
							char["RightLowerLeg"]["RightKnee"].Transform = v["RightLowerLeg"]
						end
						if v["LeftFoot"] then
							char["LeftFoot"]["LeftAnkle"].Transform = v["LeftFoot"]
						end
						if v["RightFoot"] then
							char["RightFoot"]["RightAnkle"].Transform = v["RightFoot"]
						end
						if v["UpperTorso"] then
							char.UpperTorso["Waist"].Transform = v["UpperTorso"]
						end
						if v["LowerTorso"] then
							char.LowerTorso["Root"].Transform = v["LowerTorso"]
						end
						if v["Head"] then
							char.Head["Neck"].Transform = v["Head"]
						end
					end
				end
			end
		end)
	--end

end)

Section3:CreateButton("Quagmire", function()	
	
local playanother = false
local playing = false
local rtrnv;
local c;
local tbl3;
local v;
local anim;
local count;
local hhhh;
local asdf;
local s;
local animid;
local plr;
local char;
local cframe;
local torso;
local rs;
local ls;
local rh;
local lh;
local n;
local rj;
local rsc0;
local lsc0;
local rhc0;
local lhc0;
local rjc0;
local nc0;
local gc0;
local orsc0;
local olsc0;
local orhc0;
local olhc0;
local orjc0;
local onc0;
local count2;
local maxcount2;

local function getnext(tbl,number)
	c=100
	rtrnv=0
	for i,v in pairs(tbl) do
		if i>number and i-number<c then
			c=i-number
			rtrnv=i
		end
	end
	return(rtrnv)
end
local function wait2(tim)
	if tim<0.1 then
		game:GetService("RunService").Heartbeat:Wait()
	else
		for i=1,tim*40 do
			game:GetService("RunService").Heartbeat:Wait()
		end
	end
end
local function kftotbl(kf) -- Below this is literal pain..
	tbl3 = {}
	for i,v in pairs(kf:GetDescendants()) do
		if v:IsA("Pose") then
			tbl3[v.Name] = v.CFrame
		end
	end
	return(tbl3)
end

        if playing == true then
			s:Destroy()
			playing = false
			playanother = true
		end
		wait()
		spawn(function()
			if playanother == true then
				playanother = false
			end
			playing = true
			s = Instance.new("Sound", workspace.Camera.CameraSubject.Parent.UpperTorso)

				s.SoundId = "rbxassetid://5453573397"

			s.Looped = true
			s.Playing = true
			wait(.1) -- Do not change because changing it will break.
			animid="rbxassetid://6014674446"
			plr = game.Players.LocalPlayer
			char = workspace.Camera.CameraSubject.Parent
			cframe = char.HumanoidRootPart.CFrame
			utorso = workspace.Camera.CameraSubject.Parent.UpperTorso
			ltorso = workspace.Camera.CameraSubject.Parent.LowerTorso
			-----------------------------------------------------------
			rus = char["RightUpperArm"]["RightShoulder"]
			lus = char["LeftUpperArm"]["LeftShoulder"]
			rls = char["RightLowerArm"]["RightElbow"]
			lls = char["LeftLowerArm"]["LeftElbow"]
			rw = char["RightHand"]["RightWrist"]
			lw = char["LeftHand"]["LeftWrist"]
			ruh = char["RightUpperLeg"]["RightHip"]
			luh = char["LeftUpperLeg"]["LeftHip"]
			rlh = char["RightLowerLeg"]["RightKnee"]
			llh = char["LeftLowerLeg"]["LeftKnee"]
			rf = char["RightFoot"]["RightAnkle"]
			lf = char["LeftFoot"]["LeftAnkle"]
			n = char.Head["Neck"]
            ut = char.UpperTorso.Waist
            lt = char.LowerTorso.Root
			rusc0 = rus.C0
			lusc0 = lus.C0
			rlsc0 = rls.C0
			llsc0 = lls.C0
			rwc0 = rw.C0
			lwc0 = lw.C0
			ruhc0 = ruh.C0
			luhc0 = luh.C0
			rlhc0 = rlh.C0
			llhc0 = llh.C0
			rfc0 = rf.C0
			lfc0 = lf.C0
			nc0 = n.C0
            utc0 = ut.C0
            ltc0 = lt.c0
			gc0 = CFrame.new()
			orrusc0 = rus.C0
			orlusc0 = lus.C0
			orrlsc0 = rls.C0
			orllsc0 = lls.C0
			orrwc0 = rw.C0
			orlwc0 = lw.C0
			orruhc0 = ruh.C0
			orluhc0 = luh.C0
			orrlhc0 = rlh.C0
			orllhc0 = llh.C0
			orrfc0 = rf.C0
			orlfc0 = lf.C0
			ornc0 = n.C0
            orutc0 = ut.C0
            orltc0 = lt.c0
			count2 = 100
			maxcount2=100
			-----------------------------------------------------------
			game:GetService("RunService").Heartbeat:Connect(function() -- Speed.
				if playanother == true then
					return nil
				else
					count2 = count2+1
					if count2<=maxcount2 then
						rus.Transform=rus.Transform:Lerp(rusc0,count2/maxcount2)
						lus.Transform=lus.Transform:Lerp(lusc0,count2/maxcount2)
						rls.Transform=rls.Transform:Lerp(rlsc0,count2/maxcount2)
						lls.Transform=lls.Transform:Lerp(llsc0,count2/maxcount2)
						rw.Transform=rw.Transform:Lerp(rwc0,count2/maxcount2)
						lw.Transform=lw.Transform:Lerp(lwc0,count2/maxcount2)
						ruh.Transform=ruh.Transform:Lerp(ruhc0,count2/maxcount2)
						luh.Transform=luh.Transform:Lerp(luhc0,count2/maxcount2)
						rlh.Transform=rlh.Transform:Lerp(rlhc0,count2/maxcount2)
						llh.Transform=llh.Transform:Lerp(llhc0,count2/maxcount2)
						rf.Transform=rf.Transform:Lerp(rfc0,count2/maxcount2)
						lf.Transform=lf.Transform:Lerp(lfc0,count2/maxcount2)
						n.Transform=n.Transform:Lerp(nc0,count2/maxcount2)
						ut.Transform=ut.Transform:Lerp(utc0,count2/maxcount2)
						lt.Transform=lt.Transform:Lerp(ltc0,count2/maxcount2)
					end
				end
			end)
			-----------------------------------------------------------
			animid=game:GetObjects(animid)[1]
			anim={}
			for i,v in pairs(animid:GetChildren()) do
				if v:IsA("Keyframe") then
					anim[v.Time]=kftotbl(v)
				end
			end

			count = 0
			char=workspace.Camera.CameraSubject.Parent
			hhhh=workspace.Camera.CameraSubject.Parent.Humanoid.Animator
			hhhh.Parent = nil
			for _,v in pairs(char.Humanoid:GetPlayingAnimationTracks()) do
				v:Stop()
			end
			
			hhhh:Destroy()
			char.Animate:Destroy()

			plr.CharacterRemoving:Connect(function()
				if playing == true then
					playing = false
				end
			end)

			while wait() do
				if playanother == true then
					break
				else
					for i,oasjdadlasdkadkldjkl in pairs(anim) do
						asdf=getnext(anim,count)
						v=anim[asdf]
						if v["LeftUpperArm"] then
							lusc0 = v["LeftUpperArm"]
						end
						if v["RightUpperArm"] then
							rusc0 = v["RightUpperArm"]
						end
						if v["LeftLowerArm"] then
							llsc0 = v["LeftLowerArm"]
						end
						if v["RightUpperArm"] then
							rlsc0 = v["RightLowerArm"]
						end
						if v["LeftHand"] then
							lwc0 = v["LeftHand"]
						end
						if v["RightHand"] then
							rwc0 = v["RightHand"]
						end
						if v["LeftUpperALeg"] then
							luhc0 = v["LeftUpperLeg"]
						end
						if v["RightUpperLeg"] then
							ruhc0 = v["RightUpperLeg"]
						end
						if v["LeftLowerLeg"] then
							llhc0 = v["LeftLowerLeg"]
						end
						if v["RightUpperLeg"] then
							rlhc0 = v["RightLowerLeg"]
						end
						if v["LeftFoot"] then
							lfc0 = v["LeftFoot"]
						end
						if v["RightFoot"] then
							rfc0 = v["RightFoot"]
						end
						if v["UpperTorso"] then
							utc0 = v["UpperTorso"]
						end
						if v["LowerTorso"] then
							ltc0 = v["LowerTorso"]
						end
						if v["Head"] then
							nc0 = v["Head"]
						end
						count2=0
						maxcount2=asdf-count
						count=asdf
						wait(asdf-count)
						count2=maxcount2
						if v["LeftUpperArm"] then
							char["LeftUpperArm"]["LeftShoulder"].Transform = v["LeftUpperArm"]
						end
						if v["RightUpperArm"] then
							char["RightUpperArm"]["RightShoulder"].Transform = v["RightUpperArm"]
						end
						if v["LeftLowerArm"] then
							char["LeftLowerArm"]["LeftElbow"].Transform = v["LeftLowerArm"]
						end
						if v["RightUpperArm"] then
							char["RightLowerArm"]["RightElbow"].Transform = v["RightLowerArm"]
						end
						if v["LeftHand"] then
							char["LeftHand"]["LeftWrist"].Transform = v["LeftHand"]
						end
						if v["RightHand"] then
							char["RightHand"]["RightWrist"].Transform = v["RightHand"]
						end
--
						if v["LeftUpperLeg"] then
							char["LeftUpperLeg"]["LeftHip"].Transform = v["LeftUpperLeg"]
						end
						if v["RightUpperLeg"] then
							char["RightUpperLeg"]["RightHip"].Transform = v["RightUpperLeg"]
						end
						if v["LeftLowerLeg"] then
							char["LeftLowerLeg"]["LeftKnee"].Transform = v["LeftLowerLeg"]
						end
						if v["RightUpperLeg"] then
							char["RightLowerLeg"]["RightKnee"].Transform = v["RightLowerLeg"]
						end
						if v["LeftFoot"] then
							char["LeftFoot"]["LeftAnkle"].Transform = v["LeftFoot"]
						end
						if v["RightFoot"] then
							char["RightFoot"]["RightAnkle"].Transform = v["RightFoot"]
						end
						if v["UpperTorso"] then
							char.UpperTorso["Waist"].Transform = v["UpperTorso"]
						end
						if v["LowerTorso"] then
							char.LowerTorso["Root"].Transform = v["LowerTorso"]
						end
						if v["Head"] then
							char.Head["Neck"].Transform = v["Head"]
						end
					end
				end
			end
		end)
	--end

end)

Section3:CreateButton("True Heart", function()
local playanother = false
local playing = false
local rtrnv;
local c;
local tbl3;
local v;
local anim;
local count;
local hhhh;
local asdf;
local s;
local animid;
local plr;
local char;
local cframe;
local torso;
local rs;
local ls;
local rh;
local lh;
local n;
local rj;
local rsc0;
local lsc0;
local rhc0;
local lhc0;
local rjc0;
local nc0;
local gc0;
local orsc0;
local olsc0;
local orhc0;
local olhc0;
local orjc0;
local onc0;
local count2;
local maxcount2;

local function getnext(tbl,number)
	c=100
	rtrnv=0
	for i,v in pairs(tbl) do
		if i>number and i-number<c then
			c=i-number
			rtrnv=i
		end
	end
	return(rtrnv)
end
local function wait2(tim)
	if tim<0.1 then
		game:GetService("RunService").Heartbeat:Wait()
	else
		for i=1,tim*40 do
			game:GetService("RunService").Heartbeat:Wait()
		end
	end
end
local function kftotbl(kf) -- Below this is literal pain..
	tbl3 = {}
	for i,v in pairs(kf:GetDescendants()) do
		if v:IsA("Pose") then
			tbl3[v.Name] = v.CFrame
		end
	end
	return(tbl3)
end

        if playing == true then
			s:Destroy()
			playing = false
			playanother = true
		end
		wait()
		spawn(function()
			if playanother == true then
				playanother = false
			end
			playing = true
			s = Instance.new("Sound", workspace.Camera.CameraSubject.Parent.UpperTorso)

				s.SoundId = "rbxassetid://2035901496"

			s.Looped = true
			s.Playing = true
			wait(.1) -- Do not change because changing it will break.
			animid="rbxassetid://6351091281"
			plr = game.Players.LocalPlayer
			char = workspace.Camera.CameraSubject.Parent
			cframe = char.HumanoidRootPart.CFrame
			utorso = workspace.Camera.CameraSubject.Parent.UpperTorso
			ltorso = workspace.Camera.CameraSubject.Parent.LowerTorso
			-----------------------------------------------------------
			rus = char["RightUpperArm"]["RightShoulder"]
			lus = char["LeftUpperArm"]["LeftShoulder"]
			rls = char["RightLowerArm"]["RightElbow"]
			lls = char["LeftLowerArm"]["LeftElbow"]
			rw = char["RightHand"]["RightWrist"]
			lw = char["LeftHand"]["LeftWrist"]
			ruh = char["RightUpperLeg"]["RightHip"]
			luh = char["LeftUpperLeg"]["LeftHip"]
			rlh = char["RightLowerLeg"]["RightKnee"]
			llh = char["LeftLowerLeg"]["LeftKnee"]
			rf = char["RightFoot"]["RightAnkle"]
			lf = char["LeftFoot"]["LeftAnkle"]
			n = char.Head["Neck"]
            ut = char.UpperTorso.Waist
            lt = char.LowerTorso.Root
			rusc0 = rus.C0
			lusc0 = lus.C0
			rlsc0 = rls.C0
			llsc0 = lls.C0
			rwc0 = rw.C0
			lwc0 = lw.C0
			ruhc0 = ruh.C0
			luhc0 = luh.C0
			rlhc0 = rlh.C0
			llhc0 = llh.C0
			rfc0 = rf.C0
			lfc0 = lf.C0
			nc0 = n.C0
            utc0 = ut.C0
            ltc0 = lt.c0
			gc0 = CFrame.new()
			orrusc0 = rus.C0
			orlusc0 = lus.C0
			orrlsc0 = rls.C0
			orllsc0 = lls.C0
			orrwc0 = rw.C0
			orlwc0 = lw.C0
			orruhc0 = ruh.C0
			orluhc0 = luh.C0
			orrlhc0 = rlh.C0
			orllhc0 = llh.C0
			orrfc0 = rf.C0
			orlfc0 = lf.C0
			ornc0 = n.C0
            orutc0 = ut.C0
            orltc0 = lt.c0
			count2 = 100
			maxcount2=100
			-----------------------------------------------------------
			game:GetService("RunService").Heartbeat:Connect(function() -- Speed.
				if playanother == true then
					return nil
				else
					count2 = count2+1
					if count2<=maxcount2 then
						rus.Transform=rus.Transform:Lerp(rusc0,count2/maxcount2)
						lus.Transform=lus.Transform:Lerp(lusc0,count2/maxcount2)
						rls.Transform=rls.Transform:Lerp(rlsc0,count2/maxcount2)
						lls.Transform=lls.Transform:Lerp(llsc0,count2/maxcount2)
						rw.Transform=rw.Transform:Lerp(rwc0,count2/maxcount2)
						lw.Transform=lw.Transform:Lerp(lwc0,count2/maxcount2)
						ruh.Transform=ruh.Transform:Lerp(ruhc0,count2/maxcount2)
						luh.Transform=luh.Transform:Lerp(luhc0,count2/maxcount2)
						rlh.Transform=rlh.Transform:Lerp(rlhc0,count2/maxcount2)
						llh.Transform=llh.Transform:Lerp(llhc0,count2/maxcount2)
						rf.Transform=rf.Transform:Lerp(rfc0,count2/maxcount2)
						lf.Transform=lf.Transform:Lerp(lfc0,count2/maxcount2)
						n.Transform=n.Transform:Lerp(nc0,count2/maxcount2)
						ut.Transform=ut.Transform:Lerp(utc0,count2/maxcount2)
						lt.Transform=lt.Transform:Lerp(ltc0,count2/maxcount2)
					end
				end
			end)
			-----------------------------------------------------------
			animid=game:GetObjects(animid)[1]
			anim={}
			for i,v in pairs(animid:GetChildren()) do
				if v:IsA("Keyframe") then
					anim[v.Time]=kftotbl(v)
				end
			end

			count = 0
			char=workspace.Camera.CameraSubject.Parent
			hhhh=workspace.Camera.CameraSubject.Parent.Humanoid.Animator
			hhhh.Parent = nil
			for _,v in pairs(char.Humanoid:GetPlayingAnimationTracks()) do
				v:Stop()
			end
			
			hhhh:Destroy()
			char.Animate:Destroy()

			plr.CharacterRemoving:Connect(function()
				if playing == true then
					playing = false
				end
			end)

			while wait() do
				if playanother == true then
					break
				else
					for i,oasjdadlasdkadkldjkl in pairs(anim) do
						asdf=getnext(anim,count)
						v=anim[asdf]
						if v["LeftUpperArm"] then
							lusc0 = v["LeftUpperArm"]
						end
						if v["RightUpperArm"] then
							rusc0 = v["RightUpperArm"]
						end
						if v["LeftLowerArm"] then
							llsc0 = v["LeftLowerArm"]
						end
						if v["RightUpperArm"] then
							rlsc0 = v["RightLowerArm"]
						end
						if v["LeftHand"] then
							lwc0 = v["LeftHand"]
						end
						if v["RightHand"] then
							rwc0 = v["RightHand"]
						end
						if v["LeftUpperALeg"] then
							luhc0 = v["LeftUpperLeg"]
						end
						if v["RightUpperLeg"] then
							ruhc0 = v["RightUpperLeg"]
						end
						if v["LeftLowerLeg"] then
							llhc0 = v["LeftLowerLeg"]
						end
						if v["RightUpperLeg"] then
							rlhc0 = v["RightLowerLeg"]
						end
						if v["LeftFoot"] then
							lfc0 = v["LeftFoot"]
						end
						if v["RightFoot"] then
							rfc0 = v["RightFoot"]
						end
						if v["UpperTorso"] then
							utc0 = v["UpperTorso"]
						end
						if v["LowerTorso"] then
							ltc0 = v["LowerTorso"]
						end
						if v["Head"] then
							nc0 = v["Head"]
						end
						count2=0
						maxcount2=asdf-count
						count=asdf
						wait(asdf-count)
						count2=maxcount2
						if v["LeftUpperArm"] then
							char["LeftUpperArm"]["LeftShoulder"].Transform = v["LeftUpperArm"]
						end
						if v["RightUpperArm"] then
							char["RightUpperArm"]["RightShoulder"].Transform = v["RightUpperArm"]
						end
						if v["LeftLowerArm"] then
							char["LeftLowerArm"]["LeftElbow"].Transform = v["LeftLowerArm"]
						end
						if v["RightUpperArm"] then
							char["RightLowerArm"]["RightElbow"].Transform = v["RightLowerArm"]
						end
						if v["LeftHand"] then
							char["LeftHand"]["LeftWrist"].Transform = v["LeftHand"]
						end
						if v["RightHand"] then
							char["RightHand"]["RightWrist"].Transform = v["RightHand"]
						end
--
						if v["LeftUpperLeg"] then
							char["LeftUpperLeg"]["LeftHip"].Transform = v["LeftUpperLeg"]
						end
						if v["RightUpperLeg"] then
							char["RightUpperLeg"]["RightHip"].Transform = v["RightUpperLeg"]
						end
						if v["LeftLowerLeg"] then
							char["LeftLowerLeg"]["LeftKnee"].Transform = v["LeftLowerLeg"]
						end
						if v["RightUpperLeg"] then
							char["RightLowerLeg"]["RightKnee"].Transform = v["RightLowerLeg"]
						end
						if v["LeftFoot"] then
							char["LeftFoot"]["LeftAnkle"].Transform = v["LeftFoot"]
						end
						if v["RightFoot"] then
							char["RightFoot"]["RightAnkle"].Transform = v["RightFoot"]
						end
						if v["UpperTorso"] then
							char.UpperTorso["Waist"].Transform = v["UpperTorso"]
						end
						if v["LowerTorso"] then
							char.LowerTorso["Root"].Transform = v["LowerTorso"]
						end
						if v["Head"] then
							char.Head["Neck"].Transform = v["Head"]
						end
					end
				end
			end
		end)
	--end

end)

Section3:CreateButton("Laffy Taffy", function()
local playanother = false
local playing = false
local rtrnv;
local c;
local tbl3;
local v;
local anim;
local count;
local hhhh;
local asdf;
local s;
local animid;
local plr;
local char;
local cframe;
local torso;
local rs;
local ls;
local rh;
local lh;
local n;
local rj;
local rsc0;
local lsc0;
local rhc0;
local lhc0;
local rjc0;
local nc0;
local gc0;
local orsc0;
local olsc0;
local orhc0;
local olhc0;
local orjc0;
local onc0;
local count2;
local maxcount2;

local function getnext(tbl,number)
	c=100
	rtrnv=0
	for i,v in pairs(tbl) do
		if i>number and i-number<c then
			c=i-number
			rtrnv=i
		end
	end
	return(rtrnv)
end
local function wait2(tim)
	if tim<0.1 then
		game:GetService("RunService").Heartbeat:Wait()
	else
		for i=1,tim*40 do
			game:GetService("RunService").Heartbeat:Wait()
		end
	end
end
local function kftotbl(kf) -- Below this is literal pain..
	tbl3 = {}
	for i,v in pairs(kf:GetDescendants()) do
		if v:IsA("Pose") then
			tbl3[v.Name] = v.CFrame
		end
	end
	return(tbl3)
end

        if playing == true then
			s:Destroy()
			playing = false
			playanother = true
		end
		wait()
		spawn(function()
			if playanother == true then
				playanother = false
			end
			playing = true
			s = Instance.new("Sound", workspace.Camera.CameraSubject.Parent.UpperTorso)

				s.SoundId = "rbxassetid://5428942395"

			s.Looped = true
			s.Playing = true
			wait(.1) -- Do not change because changing it will break.
			animid="rbxassetid://5809148322"
			plr = game.Players.LocalPlayer
			char = workspace.Camera.CameraSubject.Parent
			cframe = char.HumanoidRootPart.CFrame
			utorso = workspace.Camera.CameraSubject.Parent.UpperTorso
			ltorso = workspace.Camera.CameraSubject.Parent.LowerTorso
			-----------------------------------------------------------
			rus = char["RightUpperArm"]["RightShoulder"]
			lus = char["LeftUpperArm"]["LeftShoulder"]
			rls = char["RightLowerArm"]["RightElbow"]
			lls = char["LeftLowerArm"]["LeftElbow"]
			rw = char["RightHand"]["RightWrist"]
			lw = char["LeftHand"]["LeftWrist"]
			ruh = char["RightUpperLeg"]["RightHip"]
			luh = char["LeftUpperLeg"]["LeftHip"]
			rlh = char["RightLowerLeg"]["RightKnee"]
			llh = char["LeftLowerLeg"]["LeftKnee"]
			rf = char["RightFoot"]["RightAnkle"]
			lf = char["LeftFoot"]["LeftAnkle"]
			n = char.Head["Neck"]
            ut = char.UpperTorso.Waist
            lt = char.LowerTorso.Root
			rusc0 = rus.C0
			lusc0 = lus.C0
			rlsc0 = rls.C0
			llsc0 = lls.C0
			rwc0 = rw.C0
			lwc0 = lw.C0
			ruhc0 = ruh.C0
			luhc0 = luh.C0
			rlhc0 = rlh.C0
			llhc0 = llh.C0
			rfc0 = rf.C0
			lfc0 = lf.C0
			nc0 = n.C0
            utc0 = ut.C0
            ltc0 = lt.c0
			gc0 = CFrame.new()
			orrusc0 = rus.C0
			orlusc0 = lus.C0
			orrlsc0 = rls.C0
			orllsc0 = lls.C0
			orrwc0 = rw.C0
			orlwc0 = lw.C0
			orruhc0 = ruh.C0
			orluhc0 = luh.C0
			orrlhc0 = rlh.C0
			orllhc0 = llh.C0
			orrfc0 = rf.C0
			orlfc0 = lf.C0
			ornc0 = n.C0
            orutc0 = ut.C0
            orltc0 = lt.c0
			count2 = 100
			maxcount2=100
			-----------------------------------------------------------
			game:GetService("RunService").Heartbeat:Connect(function() -- Speed.
				if playanother == true then
					return nil
				else
					count2 = count2+1
					if count2<=maxcount2 then
						rus.Transform=rus.Transform:Lerp(rusc0,count2/maxcount2)
						lus.Transform=lus.Transform:Lerp(lusc0,count2/maxcount2)
						rls.Transform=rls.Transform:Lerp(rlsc0,count2/maxcount2)
						lls.Transform=lls.Transform:Lerp(llsc0,count2/maxcount2)
						rw.Transform=rw.Transform:Lerp(rwc0,count2/maxcount2)
						lw.Transform=lw.Transform:Lerp(lwc0,count2/maxcount2)
						ruh.Transform=ruh.Transform:Lerp(ruhc0,count2/maxcount2)
						luh.Transform=luh.Transform:Lerp(luhc0,count2/maxcount2)
						rlh.Transform=rlh.Transform:Lerp(rlhc0,count2/maxcount2)
						llh.Transform=llh.Transform:Lerp(llhc0,count2/maxcount2)
						rf.Transform=rf.Transform:Lerp(rfc0,count2/maxcount2)
						lf.Transform=lf.Transform:Lerp(lfc0,count2/maxcount2)
						n.Transform=n.Transform:Lerp(nc0,count2/maxcount2)
						ut.Transform=ut.Transform:Lerp(utc0,count2/maxcount2)
						lt.Transform=lt.Transform:Lerp(ltc0,count2/maxcount2)
					end
				end
			end)
			-----------------------------------------------------------
			animid=game:GetObjects(animid)[1]
			anim={}
			for i,v in pairs(animid:GetChildren()) do
				if v:IsA("Keyframe") then
					anim[v.Time]=kftotbl(v)
				end
			end

			count = 0
			char=workspace.Camera.CameraSubject.Parent
			hhhh=workspace.Camera.CameraSubject.Parent.Humanoid.Animator
			hhhh.Parent = nil
			for _,v in pairs(char.Humanoid:GetPlayingAnimationTracks()) do
				v:Stop()
			end
			
			hhhh:Destroy()
			char.Animate:Destroy()

			plr.CharacterRemoving:Connect(function()
				if playing == true then
					playing = false
				end
			end)

			while wait() do
				if playanother == true then
					break
				else
					for i,oasjdadlasdkadkldjkl in pairs(anim) do
						asdf=getnext(anim,count)
						v=anim[asdf]
						if v["LeftUpperArm"] then
							lusc0 = v["LeftUpperArm"]
						end
						if v["RightUpperArm"] then
							rusc0 = v["RightUpperArm"]
						end
						if v["LeftLowerArm"] then
							llsc0 = v["LeftLowerArm"]
						end
						if v["RightUpperArm"] then
							rlsc0 = v["RightLowerArm"]
						end
						if v["LeftHand"] then
							lwc0 = v["LeftHand"]
						end
						if v["RightHand"] then
							rwc0 = v["RightHand"]
						end
						if v["LeftUpperALeg"] then
							luhc0 = v["LeftUpperLeg"]
						end
						if v["RightUpperLeg"] then
							ruhc0 = v["RightUpperLeg"]
						end
						if v["LeftLowerLeg"] then
							llhc0 = v["LeftLowerLeg"]
						end
						if v["RightUpperLeg"] then
							rlhc0 = v["RightLowerLeg"]
						end
						if v["LeftFoot"] then
							lfc0 = v["LeftFoot"]
						end
						if v["RightFoot"] then
							rfc0 = v["RightFoot"]
						end
						if v["UpperTorso"] then
							utc0 = v["UpperTorso"]
						end
						if v["LowerTorso"] then
							ltc0 = v["LowerTorso"]
						end
						if v["Head"] then
							nc0 = v["Head"]
						end
						count2=0
						maxcount2=asdf-count
						count=asdf
						wait(asdf-count)
						count2=maxcount2
						if v["LeftUpperArm"] then
							char["LeftUpperArm"]["LeftShoulder"].Transform = v["LeftUpperArm"]
						end
						if v["RightUpperArm"] then
							char["RightUpperArm"]["RightShoulder"].Transform = v["RightUpperArm"]
						end
						if v["LeftLowerArm"] then
							char["LeftLowerArm"]["LeftElbow"].Transform = v["LeftLowerArm"]
						end
						if v["RightUpperArm"] then
							char["RightLowerArm"]["RightElbow"].Transform = v["RightLowerArm"]
						end
						if v["LeftHand"] then
							char["LeftHand"]["LeftWrist"].Transform = v["LeftHand"]
						end
						if v["RightHand"] then
							char["RightHand"]["RightWrist"].Transform = v["RightHand"]
						end
--
						if v["LeftUpperLeg"] then
							char["LeftUpperLeg"]["LeftHip"].Transform = v["LeftUpperLeg"]
						end
						if v["RightUpperLeg"] then
							char["RightUpperLeg"]["RightHip"].Transform = v["RightUpperLeg"]
						end
						if v["LeftLowerLeg"] then
							char["LeftLowerLeg"]["LeftKnee"].Transform = v["LeftLowerLeg"]
						end
						if v["RightUpperLeg"] then
							char["RightLowerLeg"]["RightKnee"].Transform = v["RightLowerLeg"]
						end
						if v["LeftFoot"] then
							char["LeftFoot"]["LeftAnkle"].Transform = v["LeftFoot"]
						end
						if v["RightFoot"] then
							char["RightFoot"]["RightAnkle"].Transform = v["RightFoot"]
						end
						if v["UpperTorso"] then
							char.UpperTorso["Waist"].Transform = v["UpperTorso"]
						end
						if v["LowerTorso"] then
							char.LowerTorso["Root"].Transform = v["LowerTorso"]
						end
						if v["Head"] then
							char.Head["Neck"].Transform = v["Head"]
						end
					end
				end
			end
		end)
	--end

end)

Section3:CreateButton("Electro Shuffle", function()
local playanother = false
local playing = false
local rtrnv;
local c;
local tbl3;
local v;
local anim;
local count;
local hhhh;
local asdf;
local s;
local animid;
local plr;
local char;
local cframe;
local torso;
local rs;
local ls;
local rh;
local lh;
local n;
local rj;
local rsc0;
local lsc0;
local rhc0;
local lhc0;
local rjc0;
local nc0;
local gc0;
local orsc0;
local olsc0;
local orhc0;
local olhc0;
local orjc0;
local onc0;
local count2;
local maxcount2;

local function getnext(tbl,number)
	c=100
	rtrnv=0
	for i,v in pairs(tbl) do
		if i>number and i-number<c then
			c=i-number
			rtrnv=i
		end
	end
	return(rtrnv)
end
local function wait2(tim)
	if tim<0.1 then
		game:GetService("RunService").Heartbeat:Wait()
	else
		for i=1,tim*40 do
			game:GetService("RunService").Heartbeat:Wait()
		end
	end
end
local function kftotbl(kf) -- Below this is literal pain..
	tbl3 = {}
	for i,v in pairs(kf:GetDescendants()) do
		if v:IsA("Pose") then
			tbl3[v.Name] = v.CFrame
		end
	end
	return(tbl3)
end

        if playing == true then
			s:Destroy()
			playing = false
			playanother = true
		end
		wait()
		spawn(function()
			if playanother == true then
				playanother = false
			end
			playing = true
			s = Instance.new("Sound", workspace.Camera.CameraSubject.Parent.UpperTorso)

				s.SoundId = "rbxassetid://3014471292"

			s.Looped = true
			s.Playing = true
			wait(.1) -- Do not change because changing it will break.
			animid="rbxassetid://5784794292"
			plr = game.Players.LocalPlayer
			char = workspace.Camera.CameraSubject.Parent
			cframe = char.HumanoidRootPart.CFrame
			utorso = workspace.Camera.CameraSubject.Parent.UpperTorso
			ltorso = workspace.Camera.CameraSubject.Parent.LowerTorso
			-----------------------------------------------------------
			rus = char["RightUpperArm"]["RightShoulder"]
			lus = char["LeftUpperArm"]["LeftShoulder"]
			rls = char["RightLowerArm"]["RightElbow"]
			lls = char["LeftLowerArm"]["LeftElbow"]
			rw = char["RightHand"]["RightWrist"]
			lw = char["LeftHand"]["LeftWrist"]
			ruh = char["RightUpperLeg"]["RightHip"]
			luh = char["LeftUpperLeg"]["LeftHip"]
			rlh = char["RightLowerLeg"]["RightKnee"]
			llh = char["LeftLowerLeg"]["LeftKnee"]
			rf = char["RightFoot"]["RightAnkle"]
			lf = char["LeftFoot"]["LeftAnkle"]
			n = char.Head["Neck"]
            ut = char.UpperTorso.Waist
            lt = char.LowerTorso.Root
			rusc0 = rus.C0
			lusc0 = lus.C0
			rlsc0 = rls.C0
			llsc0 = lls.C0
			rwc0 = rw.C0
			lwc0 = lw.C0
			ruhc0 = ruh.C0
			luhc0 = luh.C0
			rlhc0 = rlh.C0
			llhc0 = llh.C0
			rfc0 = rf.C0
			lfc0 = lf.C0
			nc0 = n.C0
            utc0 = ut.C0
            ltc0 = lt.c0
			gc0 = CFrame.new()
			orrusc0 = rus.C0
			orlusc0 = lus.C0
			orrlsc0 = rls.C0
			orllsc0 = lls.C0
			orrwc0 = rw.C0
			orlwc0 = lw.C0
			orruhc0 = ruh.C0
			orluhc0 = luh.C0
			orrlhc0 = rlh.C0
			orllhc0 = llh.C0
			orrfc0 = rf.C0
			orlfc0 = lf.C0
			ornc0 = n.C0
            orutc0 = ut.C0
            orltc0 = lt.c0
			count2 = 100
			maxcount2=100
			-----------------------------------------------------------
			game:GetService("RunService").Heartbeat:Connect(function() -- Speed.
				if playanother == true then
					return nil
				else
					count2 = count2+1
					if count2<=maxcount2 then
						rus.Transform=rus.Transform:Lerp(rusc0,count2/maxcount2)
						lus.Transform=lus.Transform:Lerp(lusc0,count2/maxcount2)
						rls.Transform=rls.Transform:Lerp(rlsc0,count2/maxcount2)
						lls.Transform=lls.Transform:Lerp(llsc0,count2/maxcount2)
						rw.Transform=rw.Transform:Lerp(rwc0,count2/maxcount2)
						lw.Transform=lw.Transform:Lerp(lwc0,count2/maxcount2)
						ruh.Transform=ruh.Transform:Lerp(ruhc0,count2/maxcount2)
						luh.Transform=luh.Transform:Lerp(luhc0,count2/maxcount2)
						rlh.Transform=rlh.Transform:Lerp(rlhc0,count2/maxcount2)
						llh.Transform=llh.Transform:Lerp(llhc0,count2/maxcount2)
						rf.Transform=rf.Transform:Lerp(rfc0,count2/maxcount2)
						lf.Transform=lf.Transform:Lerp(lfc0,count2/maxcount2)
						n.Transform=n.Transform:Lerp(nc0,count2/maxcount2)
						ut.Transform=ut.Transform:Lerp(utc0,count2/maxcount2)
						lt.Transform=lt.Transform:Lerp(ltc0,count2/maxcount2)
					end
				end
			end)
			-----------------------------------------------------------
			animid=game:GetObjects(animid)[1]
			anim={}
			for i,v in pairs(animid:GetChildren()) do
				if v:IsA("Keyframe") then
					anim[v.Time]=kftotbl(v)
				end
			end

			count = 0
			char=workspace.Camera.CameraSubject.Parent
			hhhh=workspace.Camera.CameraSubject.Parent.Humanoid.Animator
			hhhh.Parent = nil
			for _,v in pairs(char.Humanoid:GetPlayingAnimationTracks()) do
				v:Stop()
			end
			
			hhhh:Destroy()
			char.Animate:Destroy()

			plr.CharacterRemoving:Connect(function()
				if playing == true then
					playing = false
				end
			end)

			while wait() do
				if playanother == true then
					break
				else
					for i,oasjdadlasdkadkldjkl in pairs(anim) do
						asdf=getnext(anim,count)
						v=anim[asdf]
						if v["LeftUpperArm"] then
							lusc0 = v["LeftUpperArm"]
						end
						if v["RightUpperArm"] then
							rusc0 = v["RightUpperArm"]
						end
						if v["LeftLowerArm"] then
							llsc0 = v["LeftLowerArm"]
						end
						if v["RightUpperArm"] then
							rlsc0 = v["RightLowerArm"]
						end
						if v["LeftHand"] then
							lwc0 = v["LeftHand"]
						end
						if v["RightHand"] then
							rwc0 = v["RightHand"]
						end
						if v["LeftUpperALeg"] then
							luhc0 = v["LeftUpperLeg"]
						end
						if v["RightUpperLeg"] then
							ruhc0 = v["RightUpperLeg"]
						end
						if v["LeftLowerLeg"] then
							llhc0 = v["LeftLowerLeg"]
						end
						if v["RightUpperLeg"] then
							rlhc0 = v["RightLowerLeg"]
						end
						if v["LeftFoot"] then
							lfc0 = v["LeftFoot"]
						end
						if v["RightFoot"] then
							rfc0 = v["RightFoot"]
						end
						if v["UpperTorso"] then
							utc0 = v["UpperTorso"]
						end
						if v["LowerTorso"] then
							ltc0 = v["LowerTorso"]
						end
						if v["Head"] then
							nc0 = v["Head"]
						end
						count2=0
						maxcount2=asdf-count
						count=asdf
						wait(asdf-count)
						count2=maxcount2
						if v["LeftUpperArm"] then
							char["LeftUpperArm"]["LeftShoulder"].Transform = v["LeftUpperArm"]
						end
						if v["RightUpperArm"] then
							char["RightUpperArm"]["RightShoulder"].Transform = v["RightUpperArm"]
						end
						if v["LeftLowerArm"] then
							char["LeftLowerArm"]["LeftElbow"].Transform = v["LeftLowerArm"]
						end
						if v["RightUpperArm"] then
							char["RightLowerArm"]["RightElbow"].Transform = v["RightLowerArm"]
						end
						if v["LeftHand"] then
							char["LeftHand"]["LeftWrist"].Transform = v["LeftHand"]
						end
						if v["RightHand"] then
							char["RightHand"]["RightWrist"].Transform = v["RightHand"]
						end
--
						if v["LeftUpperLeg"] then
							char["LeftUpperLeg"]["LeftHip"].Transform = v["LeftUpperLeg"]
						end
						if v["RightUpperLeg"] then
							char["RightUpperLeg"]["RightHip"].Transform = v["RightUpperLeg"]
						end
						if v["LeftLowerLeg"] then
							char["LeftLowerLeg"]["LeftKnee"].Transform = v["LeftLowerLeg"]
						end
						if v["RightUpperLeg"] then
							char["RightLowerLeg"]["RightKnee"].Transform = v["RightLowerLeg"]
						end
						if v["LeftFoot"] then
							char["LeftFoot"]["LeftAnkle"].Transform = v["LeftFoot"]
						end
						if v["RightFoot"] then
							char["RightFoot"]["RightAnkle"].Transform = v["RightFoot"]
						end
						if v["UpperTorso"] then
							char.UpperTorso["Waist"].Transform = v["UpperTorso"]
						end
						if v["LowerTorso"] then
							char.LowerTorso["Root"].Transform = v["LowerTorso"]
						end
						if v["Head"] then
							char.Head["Neck"].Transform = v["Head"]
						end
					end
				end
			end
		end)
	--end

end)



Section3:CreateButton("Anthony Shuffle", function()
local playanother = false
local playing = false
local rtrnv;
local c;
local tbl3;
local v;
local anim;
local count;
local hhhh;
local asdf;
local s;
local animid;
local plr;
local char;
local cframe;
local torso;
local rs;
local ls;
local rh;
local lh;
local n;
local rj;
local rsc0;
local lsc0;
local rhc0;
local lhc0;
local rjc0;
local nc0;
local gc0;
local orsc0;
local olsc0;
local orhc0;
local olhc0;
local orjc0;
local onc0;
local count2;
local maxcount2;

local function getnext(tbl,number)
	c=100
	rtrnv=0
	for i,v in pairs(tbl) do
		if i>number and i-number<c then
			c=i-number
			rtrnv=i
		end
	end
	return(rtrnv)
end
local function wait2(tim)
	if tim<0.1 then
		game:GetService("RunService").Heartbeat:Wait()
	else
		for i=1,tim*40 do
			game:GetService("RunService").Heartbeat:Wait()
		end
	end
end
local function kftotbl(kf) -- Below this is literal pain..
	tbl3 = {}
	for i,v in pairs(kf:GetDescendants()) do
		if v:IsA("Pose") then
			tbl3[v.Name] = v.CFrame
		end
	end
	return(tbl3)
end

        if playing == true then
			s:Destroy()
			playing = false
			playanother = true
		end
		wait()
		spawn(function()
			if playanother == true then
				playanother = false
			end
			playing = true
			s = Instance.new("Sound", workspace.Camera.CameraSubject.Parent.UpperTorso)

				s.SoundId = "rbxassetid://4747544134"

			s.Looped = true
			s.Playing = true
			wait(.1) -- Do not change because changing it will break.
			animid="rbxassetid://5942430032"
			plr = game.Players.LocalPlayer
			char = workspace.Camera.CameraSubject.Parent
			cframe = char.HumanoidRootPart.CFrame
			utorso = workspace.Camera.CameraSubject.Parent.UpperTorso
			ltorso = workspace.Camera.CameraSubject.Parent.LowerTorso
			-----------------------------------------------------------
			rus = char["RightUpperArm"]["RightShoulder"]
			lus = char["LeftUpperArm"]["LeftShoulder"]
			rls = char["RightLowerArm"]["RightElbow"]
			lls = char["LeftLowerArm"]["LeftElbow"]
			rw = char["RightHand"]["RightWrist"]
			lw = char["LeftHand"]["LeftWrist"]
			ruh = char["RightUpperLeg"]["RightHip"]
			luh = char["LeftUpperLeg"]["LeftHip"]
			rlh = char["RightLowerLeg"]["RightKnee"]
			llh = char["LeftLowerLeg"]["LeftKnee"]
			rf = char["RightFoot"]["RightAnkle"]
			lf = char["LeftFoot"]["LeftAnkle"]
			n = char.Head["Neck"]
            ut = char.UpperTorso.Waist
            lt = char.LowerTorso.Root
			rusc0 = rus.C0
			lusc0 = lus.C0
			rlsc0 = rls.C0
			llsc0 = lls.C0
			rwc0 = rw.C0
			lwc0 = lw.C0
			ruhc0 = ruh.C0
			luhc0 = luh.C0
			rlhc0 = rlh.C0
			llhc0 = llh.C0
			rfc0 = rf.C0
			lfc0 = lf.C0
			nc0 = n.C0
            utc0 = ut.C0
            ltc0 = lt.c0
			gc0 = CFrame.new()
			orrusc0 = rus.C0
			orlusc0 = lus.C0
			orrlsc0 = rls.C0
			orllsc0 = lls.C0
			orrwc0 = rw.C0
			orlwc0 = lw.C0
			orruhc0 = ruh.C0
			orluhc0 = luh.C0
			orrlhc0 = rlh.C0
			orllhc0 = llh.C0
			orrfc0 = rf.C0
			orlfc0 = lf.C0
			ornc0 = n.C0
            orutc0 = ut.C0
            orltc0 = lt.c0
			count2 = 100
			maxcount2=100
			-----------------------------------------------------------
			game:GetService("RunService").Heartbeat:Connect(function() -- Speed.
				if playanother == true then
					return nil
				else
					count2 = count2+1
					if count2<=maxcount2 then
						rus.Transform=rus.Transform:Lerp(rusc0,count2/maxcount2)
						lus.Transform=lus.Transform:Lerp(lusc0,count2/maxcount2)
						rls.Transform=rls.Transform:Lerp(rlsc0,count2/maxcount2)
						lls.Transform=lls.Transform:Lerp(llsc0,count2/maxcount2)
						rw.Transform=rw.Transform:Lerp(rwc0,count2/maxcount2)
						lw.Transform=lw.Transform:Lerp(lwc0,count2/maxcount2)
						ruh.Transform=ruh.Transform:Lerp(ruhc0,count2/maxcount2)
						luh.Transform=luh.Transform:Lerp(luhc0,count2/maxcount2)
						rlh.Transform=rlh.Transform:Lerp(rlhc0,count2/maxcount2)
						llh.Transform=llh.Transform:Lerp(llhc0,count2/maxcount2)
						rf.Transform=rf.Transform:Lerp(rfc0,count2/maxcount2)
						lf.Transform=lf.Transform:Lerp(lfc0,count2/maxcount2)
						n.Transform=n.Transform:Lerp(nc0,count2/maxcount2)
						ut.Transform=ut.Transform:Lerp(utc0,count2/maxcount2)
						lt.Transform=lt.Transform:Lerp(ltc0,count2/maxcount2)
					end
				end
			end)
			-----------------------------------------------------------
			animid=game:GetObjects(animid)[1]
			anim={}
			for i,v in pairs(animid:GetChildren()) do
				if v:IsA("Keyframe") then
					anim[v.Time]=kftotbl(v)
				end
			end

			count = 0
			char=workspace.Camera.CameraSubject.Parent
			hhhh=workspace.Camera.CameraSubject.Parent.Humanoid.Animator
			hhhh.Parent = nil
			for _,v in pairs(char.Humanoid:GetPlayingAnimationTracks()) do
				v:Stop()
			end
			
			hhhh:Destroy()
			char.Animate:Destroy()

			plr.CharacterRemoving:Connect(function()
				if playing == true then
					playing = false
				end
			end)

			while wait() do
				if playanother == true then
					break
				else
					for i,oasjdadlasdkadkldjkl in pairs(anim) do
						asdf=getnext(anim,count)
						v=anim[asdf]
						if v["LeftUpperArm"] then
							lusc0 = v["LeftUpperArm"]
						end
						if v["RightUpperArm"] then
							rusc0 = v["RightUpperArm"]
						end
						if v["LeftLowerArm"] then
							llsc0 = v["LeftLowerArm"]
						end
						if v["RightUpperArm"] then
							rlsc0 = v["RightLowerArm"]
						end
						if v["LeftHand"] then
							lwc0 = v["LeftHand"]
						end
						if v["RightHand"] then
							rwc0 = v["RightHand"]
						end
						if v["LeftUpperALeg"] then
							luhc0 = v["LeftUpperLeg"]
						end
						if v["RightUpperLeg"] then
							ruhc0 = v["RightUpperLeg"]
						end
						if v["LeftLowerLeg"] then
							llhc0 = v["LeftLowerLeg"]
						end
						if v["RightUpperLeg"] then
							rlhc0 = v["RightLowerLeg"]
						end
						if v["LeftFoot"] then
							lfc0 = v["LeftFoot"]
						end
						if v["RightFoot"] then
							rfc0 = v["RightFoot"]
						end
						if v["UpperTorso"] then
							utc0 = v["UpperTorso"]
						end
						if v["LowerTorso"] then
							ltc0 = v["LowerTorso"]
						end
						if v["Head"] then
							nc0 = v["Head"]
						end
						count2=0
						maxcount2=asdf-count
						count=asdf
						wait(asdf-count)
						count2=maxcount2
						if v["LeftUpperArm"] then
							char["LeftUpperArm"]["LeftShoulder"].Transform = v["LeftUpperArm"]
						end
						if v["RightUpperArm"] then
							char["RightUpperArm"]["RightShoulder"].Transform = v["RightUpperArm"]
						end
						if v["LeftLowerArm"] then
							char["LeftLowerArm"]["LeftElbow"].Transform = v["LeftLowerArm"]
						end
						if v["RightUpperArm"] then
							char["RightLowerArm"]["RightElbow"].Transform = v["RightLowerArm"]
						end
						if v["LeftHand"] then
							char["LeftHand"]["LeftWrist"].Transform = v["LeftHand"]
						end
						if v["RightHand"] then
							char["RightHand"]["RightWrist"].Transform = v["RightHand"]
						end
--
						if v["LeftUpperLeg"] then
							char["LeftUpperLeg"]["LeftHip"].Transform = v["LeftUpperLeg"]
						end
						if v["RightUpperLeg"] then
							char["RightUpperLeg"]["RightHip"].Transform = v["RightUpperLeg"]
						end
						if v["LeftLowerLeg"] then
							char["LeftLowerLeg"]["LeftKnee"].Transform = v["LeftLowerLeg"]
						end
						if v["RightUpperLeg"] then
							char["RightLowerLeg"]["RightKnee"].Transform = v["RightLowerLeg"]
						end
						if v["LeftFoot"] then
							char["LeftFoot"]["LeftAnkle"].Transform = v["LeftFoot"]
						end
						if v["RightFoot"] then
							char["RightFoot"]["RightAnkle"].Transform = v["RightFoot"]
						end
						if v["UpperTorso"] then
							char.UpperTorso["Waist"].Transform = v["UpperTorso"]
						end
						if v["LowerTorso"] then
							char.LowerTorso["Root"].Transform = v["LowerTorso"]
						end
						if v["Head"] then
							char.Head["Neck"].Transform = v["Head"]
						end
					end
				end
			end
		end)
	--end

end)

Section3:CreateButton("Carson Dance", function()
local playanother = false
local playing = false
local rtrnv;
local c;
local tbl3;
local v;
local anim;
local count;
local hhhh;
local asdf;
local s;
local animid;
local plr;
local char;
local cframe;
local torso;
local rs;
local ls;
local rh;
local lh;
local n;
local rj;
local rsc0;
local lsc0;
local rhc0;
local lhc0;
local rjc0;
local nc0;
local gc0;
local orsc0;
local olsc0;
local orhc0;
local olhc0;
local orjc0;
local onc0;
local count2;
local maxcount2;

local function getnext(tbl,number)
	c=100
	rtrnv=0
	for i,v in pairs(tbl) do
		if i>number and i-number<c then
			c=i-number
			rtrnv=i
		end
	end
	return(rtrnv)
end
local function wait2(tim)
	if tim<0.1 then
		game:GetService("RunService").Heartbeat:Wait()
	else
		for i=1,tim*40 do
			game:GetService("RunService").Heartbeat:Wait()
		end
	end
end
local function kftotbl(kf) -- Below this is literal pain..
	tbl3 = {}
	for i,v in pairs(kf:GetDescendants()) do
		if v:IsA("Pose") then
			tbl3[v.Name] = v.CFrame
		end
	end
	return(tbl3)
end

        if playing == true then
			s:Destroy()
			playing = false
			playanother = true
		end
		wait()
		spawn(function()
			if playanother == true then
				playanother = false
			end
			playing = true
			s = Instance.new("Sound", workspace.Camera.CameraSubject.Parent.UpperTorso)

				s.SoundId = "rbxassetid://5504793351"

			s.Looped = true
			s.Playing = true
			wait(.1) -- Do not change because changing it will break.
			animid="rbxassetid://5054154480"
			plr = game.Players.LocalPlayer
			char = workspace.Camera.CameraSubject.Parent
			cframe = char.HumanoidRootPart.CFrame
			utorso = workspace.Camera.CameraSubject.Parent.UpperTorso
			ltorso = workspace.Camera.CameraSubject.Parent.LowerTorso
			-----------------------------------------------------------
			rus = char["RightUpperArm"]["RightShoulder"]
			lus = char["LeftUpperArm"]["LeftShoulder"]
			rls = char["RightLowerArm"]["RightElbow"]
			lls = char["LeftLowerArm"]["LeftElbow"]
			rw = char["RightHand"]["RightWrist"]
			lw = char["LeftHand"]["LeftWrist"]
			ruh = char["RightUpperLeg"]["RightHip"]
			luh = char["LeftUpperLeg"]["LeftHip"]
			rlh = char["RightLowerLeg"]["RightKnee"]
			llh = char["LeftLowerLeg"]["LeftKnee"]
			rf = char["RightFoot"]["RightAnkle"]
			lf = char["LeftFoot"]["LeftAnkle"]
			n = char.Head["Neck"]
            ut = char.UpperTorso.Waist
            lt = char.LowerTorso.Root
			rusc0 = rus.C0
			lusc0 = lus.C0
			rlsc0 = rls.C0
			llsc0 = lls.C0
			rwc0 = rw.C0
			lwc0 = lw.C0
			ruhc0 = ruh.C0
			luhc0 = luh.C0
			rlhc0 = rlh.C0
			llhc0 = llh.C0
			rfc0 = rf.C0
			lfc0 = lf.C0
			nc0 = n.C0
            utc0 = ut.C0
            ltc0 = lt.c0
			gc0 = CFrame.new()
			orrusc0 = rus.C0
			orlusc0 = lus.C0
			orrlsc0 = rls.C0
			orllsc0 = lls.C0
			orrwc0 = rw.C0
			orlwc0 = lw.C0
			orruhc0 = ruh.C0
			orluhc0 = luh.C0
			orrlhc0 = rlh.C0
			orllhc0 = llh.C0
			orrfc0 = rf.C0
			orlfc0 = lf.C0
			ornc0 = n.C0
            orutc0 = ut.C0
            orltc0 = lt.c0
			count2 = 100
			maxcount2=100
			-----------------------------------------------------------
			game:GetService("RunService").Heartbeat:Connect(function() -- Speed.
				if playanother == true then
					return nil
				else
					count2 = count2+1
					if count2<=maxcount2 then
						rus.Transform=rus.Transform:Lerp(rusc0,count2/maxcount2)
						lus.Transform=lus.Transform:Lerp(lusc0,count2/maxcount2)
						rls.Transform=rls.Transform:Lerp(rlsc0,count2/maxcount2)
						lls.Transform=lls.Transform:Lerp(llsc0,count2/maxcount2)
						rw.Transform=rw.Transform:Lerp(rwc0,count2/maxcount2)
						lw.Transform=lw.Transform:Lerp(lwc0,count2/maxcount2)
						ruh.Transform=ruh.Transform:Lerp(ruhc0,count2/maxcount2)
						luh.Transform=luh.Transform:Lerp(luhc0,count2/maxcount2)
						rlh.Transform=rlh.Transform:Lerp(rlhc0,count2/maxcount2)
						llh.Transform=llh.Transform:Lerp(llhc0,count2/maxcount2)
						rf.Transform=rf.Transform:Lerp(rfc0,count2/maxcount2)
						lf.Transform=lf.Transform:Lerp(lfc0,count2/maxcount2)
						n.Transform=n.Transform:Lerp(nc0,count2/maxcount2)
						ut.Transform=ut.Transform:Lerp(utc0,count2/maxcount2)
						lt.Transform=lt.Transform:Lerp(ltc0,count2/maxcount2)
					end
				end
			end)
			-----------------------------------------------------------
			animid=game:GetObjects(animid)[1]
			anim={}
			for i,v in pairs(animid:GetChildren()) do
				if v:IsA("Keyframe") then
					anim[v.Time]=kftotbl(v)
				end
			end

			count = 0
			char=workspace.Camera.CameraSubject.Parent
			hhhh=workspace.Camera.CameraSubject.Parent.Humanoid.Animator
			hhhh.Parent = nil
			for _,v in pairs(char.Humanoid:GetPlayingAnimationTracks()) do
				v:Stop()
			end
			
			hhhh:Destroy()
			char.Animate:Destroy()

			plr.CharacterRemoving:Connect(function()
				if playing == true then
					playing = false
				end
			end)

			while wait() do
				if playanother == true then
					break
				else
					for i,oasjdadlasdkadkldjkl in pairs(anim) do
						asdf=getnext(anim,count)
						v=anim[asdf]
						if v["LeftUpperArm"] then
							lusc0 = v["LeftUpperArm"]
						end
						if v["RightUpperArm"] then
							rusc0 = v["RightUpperArm"]
						end
						if v["LeftLowerArm"] then
							llsc0 = v["LeftLowerArm"]
						end
						if v["RightUpperArm"] then
							rlsc0 = v["RightLowerArm"]
						end
						if v["LeftHand"] then
							lwc0 = v["LeftHand"]
						end
						if v["RightHand"] then
							rwc0 = v["RightHand"]
						end
						if v["LeftUpperALeg"] then
							luhc0 = v["LeftUpperLeg"]
						end
						if v["RightUpperLeg"] then
							ruhc0 = v["RightUpperLeg"]
						end
						if v["LeftLowerLeg"] then
							llhc0 = v["LeftLowerLeg"]
						end
						if v["RightUpperLeg"] then
							rlhc0 = v["RightLowerLeg"]
						end
						if v["LeftFoot"] then
							lfc0 = v["LeftFoot"]
						end
						if v["RightFoot"] then
							rfc0 = v["RightFoot"]
						end
						if v["UpperTorso"] then
							utc0 = v["UpperTorso"]
						end
						if v["LowerTorso"] then
							ltc0 = v["LowerTorso"]
						end
						if v["Head"] then
							nc0 = v["Head"]
						end
						count2=0
						maxcount2=asdf-count
						count=asdf
						wait(asdf-count)
						count2=maxcount2
						if v["LeftUpperArm"] then
							char["LeftUpperArm"]["LeftShoulder"].Transform = v["LeftUpperArm"]
						end
						if v["RightUpperArm"] then
							char["RightUpperArm"]["RightShoulder"].Transform = v["RightUpperArm"]
						end
						if v["LeftLowerArm"] then
							char["LeftLowerArm"]["LeftElbow"].Transform = v["LeftLowerArm"]
						end
						if v["RightUpperArm"] then
							char["RightLowerArm"]["RightElbow"].Transform = v["RightLowerArm"]
						end
						if v["LeftHand"] then
							char["LeftHand"]["LeftWrist"].Transform = v["LeftHand"]
						end
						if v["RightHand"] then
							char["RightHand"]["RightWrist"].Transform = v["RightHand"]
						end
--
						if v["LeftUpperLeg"] then
							char["LeftUpperLeg"]["LeftHip"].Transform = v["LeftUpperLeg"]
						end
						if v["RightUpperLeg"] then
							char["RightUpperLeg"]["RightHip"].Transform = v["RightUpperLeg"]
						end
						if v["LeftLowerLeg"] then
							char["LeftLowerLeg"]["LeftKnee"].Transform = v["LeftLowerLeg"]
						end
						if v["RightUpperLeg"] then
							char["RightLowerLeg"]["RightKnee"].Transform = v["RightLowerLeg"]
						end
						if v["LeftFoot"] then
							char["LeftFoot"]["LeftAnkle"].Transform = v["LeftFoot"]
						end
						if v["RightFoot"] then
							char["RightFoot"]["RightAnkle"].Transform = v["RightFoot"]
						end
						if v["UpperTorso"] then
							char.UpperTorso["Waist"].Transform = v["UpperTorso"]
						end
						if v["LowerTorso"] then
							char.LowerTorso["Root"].Transform = v["LowerTorso"]
						end
						if v["Head"] then
							char.Head["Neck"].Transform = v["Head"]
						end
					end
				end
			end
		end)
	--end

end)

Section3:CreateButton("Cruisin'", function()
local playanother = false
local playing = false
local rtrnv;
local c;
local tbl3;
local v;
local anim;
local count;
local hhhh;
local asdf;
local s;
local animid;
local plr;
local char;
local cframe;
local torso;
local rs;
local ls;
local rh;
local lh;
local n;
local rj;
local rsc0;
local lsc0;
local rhc0;
local lhc0;
local rjc0;
local nc0;
local gc0;
local orsc0;
local olsc0;
local orhc0;
local olhc0;
local orjc0;
local onc0;
local count2;
local maxcount2;

local function getnext(tbl,number)
	c=100
	rtrnv=0
	for i,v in pairs(tbl) do
		if i>number and i-number<c then
			c=i-number
			rtrnv=i
		end
	end
	return(rtrnv)
end
local function wait2(tim)
	if tim<0.1 then
		game:GetService("RunService").Heartbeat:Wait()
	else
		for i=1,tim*40 do
			game:GetService("RunService").Heartbeat:Wait()
		end
	end
end
local function kftotbl(kf) -- Below this is literal pain..
	tbl3 = {}
	for i,v in pairs(kf:GetDescendants()) do
		if v:IsA("Pose") then
			tbl3[v.Name] = v.CFrame
		end
	end
	return(tbl3)
end

        if playing == true then
			s:Destroy()
			playing = false
			playanother = true
		end
		wait()
		spawn(function()
			if playanother == true then
				playanother = false
			end
			playing = true
			s = Instance.new("Sound", workspace.Camera.CameraSubject.Parent.UpperTorso)

				s.SoundId = "rbxassetid://313905409"

			s.Looped = true
			s.Playing = true
			wait(.1) -- Do not change because changing it will break.
			animid="rbxassetid://6013273602"
			plr = game.Players.LocalPlayer
			char = workspace.Camera.CameraSubject.Parent
			cframe = char.HumanoidRootPart.CFrame
			utorso = workspace.Camera.CameraSubject.Parent.UpperTorso
			ltorso = workspace.Camera.CameraSubject.Parent.LowerTorso
			-----------------------------------------------------------
			rus = char["RightUpperArm"]["RightShoulder"]
			lus = char["LeftUpperArm"]["LeftShoulder"]
			rls = char["RightLowerArm"]["RightElbow"]
			lls = char["LeftLowerArm"]["LeftElbow"]
			rw = char["RightHand"]["RightWrist"]
			lw = char["LeftHand"]["LeftWrist"]
			ruh = char["RightUpperLeg"]["RightHip"]
			luh = char["LeftUpperLeg"]["LeftHip"]
			rlh = char["RightLowerLeg"]["RightKnee"]
			llh = char["LeftLowerLeg"]["LeftKnee"]
			rf = char["RightFoot"]["RightAnkle"]
			lf = char["LeftFoot"]["LeftAnkle"]
			n = char.Head["Neck"]
            ut = char.UpperTorso.Waist
            lt = char.LowerTorso.Root
			rusc0 = rus.C0
			lusc0 = lus.C0
			rlsc0 = rls.C0
			llsc0 = lls.C0
			rwc0 = rw.C0
			lwc0 = lw.C0
			ruhc0 = ruh.C0
			luhc0 = luh.C0
			rlhc0 = rlh.C0
			llhc0 = llh.C0
			rfc0 = rf.C0
			lfc0 = lf.C0
			nc0 = n.C0
            utc0 = ut.C0
            ltc0 = lt.c0
			gc0 = CFrame.new()
			orrusc0 = rus.C0
			orlusc0 = lus.C0
			orrlsc0 = rls.C0
			orllsc0 = lls.C0
			orrwc0 = rw.C0
			orlwc0 = lw.C0
			orruhc0 = ruh.C0
			orluhc0 = luh.C0
			orrlhc0 = rlh.C0
			orllhc0 = llh.C0
			orrfc0 = rf.C0
			orlfc0 = lf.C0
			ornc0 = n.C0
            orutc0 = ut.C0
            orltc0 = lt.c0
			count2 = 100
			maxcount2=100
			-----------------------------------------------------------
			game:GetService("RunService").Heartbeat:Connect(function() -- Speed.
				if playanother == true then
					return nil
				else
					count2 = count2+1
					if count2<=maxcount2 then
						rus.Transform=rus.Transform:Lerp(rusc0,count2/maxcount2)
						lus.Transform=lus.Transform:Lerp(lusc0,count2/maxcount2)
						rls.Transform=rls.Transform:Lerp(rlsc0,count2/maxcount2)
						lls.Transform=lls.Transform:Lerp(llsc0,count2/maxcount2)
						rw.Transform=rw.Transform:Lerp(rwc0,count2/maxcount2)
						lw.Transform=lw.Transform:Lerp(lwc0,count2/maxcount2)
						ruh.Transform=ruh.Transform:Lerp(ruhc0,count2/maxcount2)
						luh.Transform=luh.Transform:Lerp(luhc0,count2/maxcount2)
						rlh.Transform=rlh.Transform:Lerp(rlhc0,count2/maxcount2)
						llh.Transform=llh.Transform:Lerp(llhc0,count2/maxcount2)
						rf.Transform=rf.Transform:Lerp(rfc0,count2/maxcount2)
						lf.Transform=lf.Transform:Lerp(lfc0,count2/maxcount2)
						n.Transform=n.Transform:Lerp(nc0,count2/maxcount2)
						ut.Transform=ut.Transform:Lerp(utc0,count2/maxcount2)
						lt.Transform=lt.Transform:Lerp(ltc0,count2/maxcount2)
					end
				end
			end)
			-----------------------------------------------------------
			animid=game:GetObjects(animid)[1]
			anim={}
			for i,v in pairs(animid:GetChildren()) do
				if v:IsA("Keyframe") then
					anim[v.Time]=kftotbl(v)
				end
			end

			count = 0
			char=workspace.Camera.CameraSubject.Parent
			hhhh=workspace.Camera.CameraSubject.Parent.Humanoid.Animator
			hhhh.Parent = nil
			for _,v in pairs(char.Humanoid:GetPlayingAnimationTracks()) do
				v:Stop()
			end
			
			hhhh:Destroy()
			char.Animate:Destroy()

			plr.CharacterRemoving:Connect(function()
				if playing == true then
					playing = false
				end
			end)

			while wait() do
				if playanother == true then
					break
				else
					for i,oasjdadlasdkadkldjkl in pairs(anim) do
						asdf=getnext(anim,count)
						v=anim[asdf]
						if v["LeftUpperArm"] then
							lusc0 = v["LeftUpperArm"]
						end
						if v["RightUpperArm"] then
							rusc0 = v["RightUpperArm"]
						end
						if v["LeftLowerArm"] then
							llsc0 = v["LeftLowerArm"]
						end
						if v["RightUpperArm"] then
							rlsc0 = v["RightLowerArm"]
						end
						if v["LeftHand"] then
							lwc0 = v["LeftHand"]
						end
						if v["RightHand"] then
							rwc0 = v["RightHand"]
						end
						if v["LeftUpperALeg"] then
							luhc0 = v["LeftUpperLeg"]
						end
						if v["RightUpperLeg"] then
							ruhc0 = v["RightUpperLeg"]
						end
						if v["LeftLowerLeg"] then
							llhc0 = v["LeftLowerLeg"]
						end
						if v["RightUpperLeg"] then
							rlhc0 = v["RightLowerLeg"]
						end
						if v["LeftFoot"] then
							lfc0 = v["LeftFoot"]
						end
						if v["RightFoot"] then
							rfc0 = v["RightFoot"]
						end
						if v["UpperTorso"] then
							utc0 = v["UpperTorso"]
						end
						if v["LowerTorso"] then
							ltc0 = v["LowerTorso"]
						end
						if v["Head"] then
							nc0 = v["Head"]
						end
						count2=0
						maxcount2=asdf-count
						count=asdf
						wait(asdf-count)
						count2=maxcount2
						if v["LeftUpperArm"] then
							char["LeftUpperArm"]["LeftShoulder"].Transform = v["LeftUpperArm"]
						end
						if v["RightUpperArm"] then
							char["RightUpperArm"]["RightShoulder"].Transform = v["RightUpperArm"]
						end
						if v["LeftLowerArm"] then
							char["LeftLowerArm"]["LeftElbow"].Transform = v["LeftLowerArm"]
						end
						if v["RightUpperArm"] then
							char["RightLowerArm"]["RightElbow"].Transform = v["RightLowerArm"]
						end
						if v["LeftHand"] then
							char["LeftHand"]["LeftWrist"].Transform = v["LeftHand"]
						end
						if v["RightHand"] then
							char["RightHand"]["RightWrist"].Transform = v["RightHand"]
						end
--
						if v["LeftUpperLeg"] then
							char["LeftUpperLeg"]["LeftHip"].Transform = v["LeftUpperLeg"]
						end
						if v["RightUpperLeg"] then
							char["RightUpperLeg"]["RightHip"].Transform = v["RightUpperLeg"]
						end
						if v["LeftLowerLeg"] then
							char["LeftLowerLeg"]["LeftKnee"].Transform = v["LeftLowerLeg"]
						end
						if v["RightUpperLeg"] then
							char["RightLowerLeg"]["RightKnee"].Transform = v["RightLowerLeg"]
						end
						if v["LeftFoot"] then
							char["LeftFoot"]["LeftAnkle"].Transform = v["LeftFoot"]
						end
						if v["RightFoot"] then
							char["RightFoot"]["RightAnkle"].Transform = v["RightFoot"]
						end
						if v["UpperTorso"] then
							char.UpperTorso["Waist"].Transform = v["UpperTorso"]
						end
						if v["LowerTorso"] then
							char.LowerTorso["Root"].Transform = v["LowerTorso"]
						end
						if v["Head"] then
							char.Head["Neck"].Transform = v["Head"]
						end
					end
				end
			end
		end)
	--end

end)

Section3:CreateButton("Renegade", function()
local playanother = false
local playing = false
local rtrnv;
local c;
local tbl3;
local v;
local anim;
local count;
local hhhh;
local asdf;
local s;
local animid;
local plr;
local char;
local cframe;
local torso;
local rs;
local ls;
local rh;
local lh;
local n;
local rj;
local rsc0;
local lsc0;
local rhc0;
local lhc0;
local rjc0;
local nc0;
local gc0;
local orsc0;
local olsc0;
local orhc0;
local olhc0;
local orjc0;
local onc0;
local count2;
local maxcount2;

local function getnext(tbl,number)
	c=100
	rtrnv=0
	for i,v in pairs(tbl) do
		if i>number and i-number<c then
			c=i-number
			rtrnv=i
		end
	end
	return(rtrnv)
end
local function wait2(tim)
	if tim<0.1 then
		game:GetService("RunService").Heartbeat:Wait()
	else
		for i=1,tim*40 do
			game:GetService("RunService").Heartbeat:Wait()
		end
	end
end
local function kftotbl(kf) -- Below this is literal pain..
	tbl3 = {}
	for i,v in pairs(kf:GetDescendants()) do
		if v:IsA("Pose") then
			tbl3[v.Name] = v.CFrame
		end
	end
	return(tbl3)
end

        if playing == true then
			s:Destroy()
			playing = false
			playanother = true
		end
		wait()
		spawn(function()
			if playanother == true then
				playanother = false
			end
			playing = true
			s = Instance.new("Sound", workspace.Camera.CameraSubject.Parent.UpperTorso)

				s.SoundId = "rbxassetid://5569274163"

			s.Looped = true
			s.Playing = true
			wait(.1) -- Do not change because changing it will break.
			animid="rbxassetid://6045705572"
			plr = game.Players.LocalPlayer
			char = workspace.Camera.CameraSubject.Parent
			cframe = char.HumanoidRootPart.CFrame
			utorso = workspace.Camera.CameraSubject.Parent.UpperTorso
			ltorso = workspace.Camera.CameraSubject.Parent.LowerTorso
			-----------------------------------------------------------
			rus = char["RightUpperArm"]["RightShoulder"]
			lus = char["LeftUpperArm"]["LeftShoulder"]
			rls = char["RightLowerArm"]["RightElbow"]
			lls = char["LeftLowerArm"]["LeftElbow"]
			rw = char["RightHand"]["RightWrist"]
			lw = char["LeftHand"]["LeftWrist"]
			ruh = char["RightUpperLeg"]["RightHip"]
			luh = char["LeftUpperLeg"]["LeftHip"]
			rlh = char["RightLowerLeg"]["RightKnee"]
			llh = char["LeftLowerLeg"]["LeftKnee"]
			rf = char["RightFoot"]["RightAnkle"]
			lf = char["LeftFoot"]["LeftAnkle"]
			n = char.Head["Neck"]
            ut = char.UpperTorso.Waist
            lt = char.LowerTorso.Root
			rusc0 = rus.C0
			lusc0 = lus.C0
			rlsc0 = rls.C0
			llsc0 = lls.C0
			rwc0 = rw.C0
			lwc0 = lw.C0
			ruhc0 = ruh.C0
			luhc0 = luh.C0
			rlhc0 = rlh.C0
			llhc0 = llh.C0
			rfc0 = rf.C0
			lfc0 = lf.C0
			nc0 = n.C0
            utc0 = ut.C0
            ltc0 = lt.c0
			gc0 = CFrame.new()
			orrusc0 = rus.C0
			orlusc0 = lus.C0
			orrlsc0 = rls.C0
			orllsc0 = lls.C0
			orrwc0 = rw.C0
			orlwc0 = lw.C0
			orruhc0 = ruh.C0
			orluhc0 = luh.C0
			orrlhc0 = rlh.C0
			orllhc0 = llh.C0
			orrfc0 = rf.C0
			orlfc0 = lf.C0
			ornc0 = n.C0
            orutc0 = ut.C0
            orltc0 = lt.c0
			count2 = 100
			maxcount2=100
			-----------------------------------------------------------
			game:GetService("RunService").Heartbeat:Connect(function() -- Speed.
				if playanother == true then
					return nil
				else
					count2 = count2+1
					if count2<=maxcount2 then
						rus.Transform=rus.Transform:Lerp(rusc0,count2/maxcount2)
						lus.Transform=lus.Transform:Lerp(lusc0,count2/maxcount2)
						rls.Transform=rls.Transform:Lerp(rlsc0,count2/maxcount2)
						lls.Transform=lls.Transform:Lerp(llsc0,count2/maxcount2)
						rw.Transform=rw.Transform:Lerp(rwc0,count2/maxcount2)
						lw.Transform=lw.Transform:Lerp(lwc0,count2/maxcount2)
						ruh.Transform=ruh.Transform:Lerp(ruhc0,count2/maxcount2)
						luh.Transform=luh.Transform:Lerp(luhc0,count2/maxcount2)
						rlh.Transform=rlh.Transform:Lerp(rlhc0,count2/maxcount2)
						llh.Transform=llh.Transform:Lerp(llhc0,count2/maxcount2)
						rf.Transform=rf.Transform:Lerp(rfc0,count2/maxcount2)
						lf.Transform=lf.Transform:Lerp(lfc0,count2/maxcount2)
						n.Transform=n.Transform:Lerp(nc0,count2/maxcount2)
						ut.Transform=ut.Transform:Lerp(utc0,count2/maxcount2)
						lt.Transform=lt.Transform:Lerp(ltc0,count2/maxcount2)
					end
				end
			end)
			-----------------------------------------------------------
			animid=game:GetObjects(animid)[1]
			anim={}
			for i,v in pairs(animid:GetChildren()) do
				if v:IsA("Keyframe") then
					anim[v.Time]=kftotbl(v)
				end
			end

			count = 0
			char=workspace.Camera.CameraSubject.Parent
			hhhh=workspace.Camera.CameraSubject.Parent.Humanoid.Animator
			hhhh.Parent = nil
			for _,v in pairs(char.Humanoid:GetPlayingAnimationTracks()) do
				v:Stop()
			end
			
			hhhh:Destroy()
			char.Animate:Destroy()

			plr.CharacterRemoving:Connect(function()
				if playing == true then
					playing = false
				end
			end)

			while wait() do
				if playanother == true then
					break
				else
					for i,oasjdadlasdkadkldjkl in pairs(anim) do
						asdf=getnext(anim,count)
						v=anim[asdf]
						if v["LeftUpperArm"] then
							lusc0 = v["LeftUpperArm"]
						end
						if v["RightUpperArm"] then
							rusc0 = v["RightUpperArm"]
						end
						if v["LeftLowerArm"] then
							llsc0 = v["LeftLowerArm"]
						end
						if v["RightUpperArm"] then
							rlsc0 = v["RightLowerArm"]
						end
						if v["LeftHand"] then
							lwc0 = v["LeftHand"]
						end
						if v["RightHand"] then
							rwc0 = v["RightHand"]
						end
						if v["LeftUpperALeg"] then
							luhc0 = v["LeftUpperLeg"]
						end
						if v["RightUpperLeg"] then
							ruhc0 = v["RightUpperLeg"]
						end
						if v["LeftLowerLeg"] then
							llhc0 = v["LeftLowerLeg"]
						end
						if v["RightUpperLeg"] then
							rlhc0 = v["RightLowerLeg"]
						end
						if v["LeftFoot"] then
							lfc0 = v["LeftFoot"]
						end
						if v["RightFoot"] then
							rfc0 = v["RightFoot"]
						end
						if v["UpperTorso"] then
							utc0 = v["UpperTorso"]
						end
						if v["LowerTorso"] then
							ltc0 = v["LowerTorso"]
						end
						if v["Head"] then
							nc0 = v["Head"]
						end
						count2=0
						maxcount2=asdf-count
						count=asdf
						wait(asdf-count)
						count2=maxcount2
						if v["LeftUpperArm"] then
							char["LeftUpperArm"]["LeftShoulder"].Transform = v["LeftUpperArm"]
						end
						if v["RightUpperArm"] then
							char["RightUpperArm"]["RightShoulder"].Transform = v["RightUpperArm"]
						end
						if v["LeftLowerArm"] then
							char["LeftLowerArm"]["LeftElbow"].Transform = v["LeftLowerArm"]
						end
						if v["RightUpperArm"] then
							char["RightLowerArm"]["RightElbow"].Transform = v["RightLowerArm"]
						end
						if v["LeftHand"] then
							char["LeftHand"]["LeftWrist"].Transform = v["LeftHand"]
						end
						if v["RightHand"] then
							char["RightHand"]["RightWrist"].Transform = v["RightHand"]
						end
--
						if v["LeftUpperLeg"] then
							char["LeftUpperLeg"]["LeftHip"].Transform = v["LeftUpperLeg"]
						end
						if v["RightUpperLeg"] then
							char["RightUpperLeg"]["RightHip"].Transform = v["RightUpperLeg"]
						end
						if v["LeftLowerLeg"] then
							char["LeftLowerLeg"]["LeftKnee"].Transform = v["LeftLowerLeg"]
						end
						if v["RightUpperLeg"] then
							char["RightLowerLeg"]["RightKnee"].Transform = v["RightLowerLeg"]
						end
						if v["LeftFoot"] then
							char["LeftFoot"]["LeftAnkle"].Transform = v["LeftFoot"]
						end
						if v["RightFoot"] then
							char["RightFoot"]["RightAnkle"].Transform = v["RightFoot"]
						end
						if v["UpperTorso"] then
							char.UpperTorso["Waist"].Transform = v["UpperTorso"]
						end
						if v["LowerTorso"] then
							char.LowerTorso["Root"].Transform = v["LowerTorso"]
						end
						if v["Head"] then
							char.Head["Neck"].Transform = v["Head"]
						end
					end
				end
			end
		end)
	--end

end)

Section3:CreateButton("Toosie Slide", function()
PlayR15Anim("6232035742","6231484150", 0.89)
end)

Section3:CreateButton("Thriller", function()
PlayR15Anim("5771596614","4175271206")
end)

Section3:CreateButton("Cut em off", function()
PlayR15Anim("5864998647","5865077210", 0.7)
end)
--[[
Section3:CreateButton("Toosie Slide", function()
PlayR15Anim("6232035742","6231484150")
end)

Section3:CreateButton("Toosie Slide", function()
PlayR15Anim("6232035742","6231484150")
end)

Section3:CreateButton("Toosie Slide", function()
PlayR15Anim("6232035742","6231484150")
end)
Section3:CreateButton("Toosie Slide", function()
PlayR15Anim("6232035742","6231484150")
end)

Section3:CreateButton("Toosie Slide", function()
PlayR15Anim("6232035742","6231484150")
end)
Section3:CreateButton("Toosie Slide", function()
PlayR15Anim("6232035742","6231484150")
end)

Section3:CreateButton("Toosie Slide", function()
PlayR15Anim("6232035742","6231484150")
end)]]
----------- Settings -----------

local flingbutton = SettingsMenu2:CreateButton("Enable/Disable Fling", function()
	
	_G.Fling = not _G.Fling
	print(_G.Fling)
end)
flingbutton:AddToolTip("Enables/Disables Fling mode for the reanimation!")
--Togglewhateverthenumberis:SetState(false)
SettingsMenu:CreateLabel("Credits: \nBrackets: Making the UI Library\nTypical Username: Creating RO-WARE\nBedra: Giving me ideas\n and keeping me motivated! luv u mane <3\nAnd all the owners of the scripts we have.\nOh and you for chosing RO-WARE!")

local Colorpicker = SettingsMenu:CreateColorpicker("UI Color", function(Color)
Window:ChangeColor(Color)
end)
Colorpicker:UpdateColor(Config.Color)
Colorpicker:AddToolTip("Change UI color")
--[[ keep this in mind typical
Section3:CreateButton("Button 1", function()
PlayR15Anim("","")
end)
--]]
